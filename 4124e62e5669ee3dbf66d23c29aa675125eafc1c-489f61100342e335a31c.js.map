{"version":3,"file":"4124e62e5669ee3dbf66d23c29aa675125eafc1c-489f61100342e335a31c.js","mappings":"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,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,IAC1lCC,eAA+B,SAAO,SAAmBC,EAAQC,EAAQC,EAAUP,EAAIQ,EAASC,EAAIC,GAClG,IAAIC,EAAKF,EAAGvK,OAAS,EACrB,OAAQsK,GACN,KAAK,EACHI,KAAKC,EAAIJ,EAAGE,EAAK,GACjB,MACF,KAAK,EACL,KAAK,GACL,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,GACZ,MACF,KAAK,GACL,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GAAK,IAAMF,EAAGE,GAC/B,MACF,KAAK,GACL,KAAK,GA8NL,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GAAKF,EAAGE,GACzB,MA7NF,KAAK,GACL,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GAAK,IAAMF,EAAGE,GAAM,IACrC,MACF,KAAK,GACHX,EAAGc,YAAYL,EAAGE,IAClB,MACF,KAAK,GACHF,EAAGE,EAAK,GAAGI,MAAQf,EAAGgB,aAAaP,EAAGE,IACtCX,EAAGc,YAAYL,EAAGE,EAAK,IACvB,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,GAAIM,OAChBjB,EAAGkB,YAAYN,KAAKC,GACpB,MACF,KAAK,GACL,KAAK,GACHD,KAAKC,EAAIJ,EAAGE,GAAIM,OAChBjB,EAAGmB,kBAAkBP,KAAKC,GAC1B,MACF,KAAK,GACHb,EAAGoB,sBAAsBX,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAC7C,MACF,KAAK,GACHX,EAAGoB,sBAAsBX,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAC7C,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,GACZX,EAAGqB,aAAaZ,EAAGE,IACnB,MACF,KAAK,GAgCL,KAAK,GACL,KAAK,GAqJL,KAAK,GACHC,KAAKC,EAAI,CAACJ,EAAGE,IACb,MArLF,KAAK,GACHC,KAAKC,EAAI,CAACJ,EAAGE,EAAK,IAClB,MACF,KAAK,GACHF,EAAGE,GAAIW,QAAQb,EAAGE,EAAK,IACvBC,KAAKC,EAAIJ,EAAGE,GACZ,MACF,KAAK,GACHX,EAAGuB,YAAYd,EAAGE,EAAK,GAAIF,EAAGE,IAC9B,MACF,KAAK,GACHX,EAAGwB,WAAWf,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAClC,MACF,KAAK,GACHX,EAAGuB,YAAYd,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IACnCX,EAAGwB,WAAWf,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAClC,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,GACZX,EAAGyB,SAAShB,EAAGE,IACf,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGyB,SAAShB,EAAGE,EAAK,IACpBX,EAAG0B,cAAcjB,EAAGE,EAAK,GAAIF,EAAGE,IAChC,MACF,KAAK,GACHX,EAAG2B,cAAclB,EAAGE,GAAKF,EAAGE,EAAK,IACjC,MAKF,KAAK,GACHF,EAAGE,GAAInJ,KAAKiJ,EAAGE,EAAK,IACpBC,KAAKC,EAAIJ,EAAGE,GACZ,MACF,KAAK,GAKL,KAAK,GAEL,KAAK,GACH,MANF,KAAK,GACHX,EAAG4B,UAAUnB,EAAGE,EAAK,GAAIX,EAAGgB,aAAaP,EAAGE,KAC5C,MAKF,KAAK,GACHC,KAAKC,EAAI,CAAE,IAAOJ,EAAGE,EAAK,GAAI,IAAOF,EAAGE,GAAKkB,SAAUpB,EAAGE,EAAK,GAAImB,eAAgB,OAAQC,eAAgB,QAC3G,MACF,KAAK,GACHnB,KAAKC,EAAI,CAAEmB,IAAKvB,EAAGE,EAAK,GAAIsB,IAAKxB,EAAGE,GAAKkB,SAAUpB,EAAGE,EAAK,GAAImB,eAAgBrB,EAAGE,EAAK,GAAIoB,eAAgB,QAC3G,MACF,KAAK,GACHnB,KAAKC,EAAI,CAAEmB,IAAKvB,EAAGE,EAAK,GAAIsB,IAAKxB,EAAGE,GAAKkB,SAAUpB,EAAGE,EAAK,GAAImB,eAAgB,OAAQC,eAAgBtB,EAAGE,EAAK,IAC/G,MACF,KAAK,GACHC,KAAKC,EAAI,CAAEmB,IAAKvB,EAAGE,EAAK,GAAIsB,IAAKxB,EAAGE,GAAKkB,SAAUpB,EAAGE,EAAK,GAAImB,eAAgBrB,EAAGE,EAAK,GAAIoB,eAAgBtB,EAAGE,EAAK,IACnH,MACF,KAAK,GACHX,EAAGkC,QAAQzB,EAAGE,GAAKF,EAAGE,EAAK,IAC3B,MACF,KAAK,GACHX,EAAGkC,QAAQzB,EAAGE,IACd,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGmC,YAAY1B,EAAGE,EAAK,GAAIF,EAAGE,IAC9B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GAAGvM,OAAO,CAACqM,EAAGE,KAC/B,MACF,KAAK,GACHX,EAAGoC,aAAa,MAChB,MACF,KAAK,GACHpC,EAAGoC,aAAa,MAChB,MACF,KAAK,GACHpC,EAAGoC,aAAa,MAChB,MACF,KAAK,GACHpC,EAAGoC,aAAa,MAChB,MACF,KAAK,GACHxB,KAAKC,EAAI,CAAEwB,MAAO5B,EAAGE,EAAK,GAAI2B,MAAO7B,EAAGE,GAAK4B,SAAU9B,EAAGE,EAAK,IAC/D,MACF,KAAK,GACHC,KAAKC,EAAI,CAAEwB,MAAO,OAAQC,MAAO7B,EAAGE,GAAK4B,SAAU9B,EAAGE,EAAK,IAC3D,MACF,KAAK,GACHC,KAAKC,EAAI,CAAEwB,MAAO5B,EAAGE,EAAK,GAAI2B,MAAO,OAAQC,SAAU9B,EAAGE,IAC1D,MACF,KAAK,GACHC,KAAKC,EAAI,CAAEwB,MAAO,OAAQC,MAAO,OAAQC,SAAU9B,EAAGE,IACtD,MACF,KAAK,GACHC,KAAKC,EAAIb,EAAGwC,aAAaC,YACzB,MACF,KAAK,GACH7B,KAAKC,EAAIb,EAAGwC,aAAaE,UACzB,MACF,KAAK,GACH9B,KAAKC,EAAIb,EAAGwC,aAAaG,YACzB,MACF,KAAK,GACH/B,KAAKC,EAAIb,EAAGwC,aAAaI,WACzB,MACF,KAAK,GACHhC,KAAKC,EAAIb,EAAGwC,aAAaK,SACzB,MACF,KAAK,GACHjC,KAAKC,EAAIb,EAAGuC,SAASO,KACrB,MACF,KAAK,GACHlC,KAAKC,EAAIb,EAAGuC,SAASQ,YACrB,MACF,KAAK,GACL,KAAK,GACHnC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGgD,cAAcvC,EAAGE,EAAK,GAAIF,EAAGE,IAChC,MACF,KAAK,GACL,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGgD,cAAcvC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IACrCX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,IAC7B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,IAC1B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,IACtC,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAC/BX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,IAC7B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,IACtCX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAClC,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGgD,cAAcvC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,IAC5C,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGgD,cAAcvC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IACjDX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,IAC7B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,IAC1B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,IACtC,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAC/BX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,IAC7B,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGkD,QAAQzC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,GAAIF,EAAGE,IACtCX,EAAGiD,WAAWxC,EAAGE,EAAK,GAAIF,EAAGE,EAAK,IAClC,MACF,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,EAAK,GACjBX,EAAGmD,YAAY1C,EAAGE,EAAK,GAAIF,EAAGE,IAC9B,MACF,KAAK,GACHX,EAAGuB,YAAYd,EAAGE,EAAK,GAAIF,EAAGE,IAC9B,MAIF,KAAK,GACHF,EAAGE,EAAK,GAAGnJ,KAAKiJ,EAAGE,IACnBC,KAAKC,EAAIJ,EAAGE,EAAK,GAMvB,GAAG,aACHyC,MAAO,CAAC,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI/G,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,EAAG,CAAC,IAAM,CAAE,EAAG,CAAC,EAAG,IAAM,CAAE,EAAG,CAAC,EAAG,IAAM,CAAE,EAAG,CAAC,EAAG,IAAM7B,EAAE8B,EAAK,CAAC,EAAG,GAAI,CAAE,EAAG,CAAC,EAAG,MAAQ,CAAE,EAAG,CAAC,EAAG,KAAO9B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQ/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,IAAQ,CAAE,GAAI,CAAC,EAAG,KAAOtC,EAAEuC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,MAAQvC,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAIf,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIZ,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIb,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIb,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIb,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAIW,EAAK,GAAI,IAAM,CAAE,GAAI,GAAI,GAAI,CAAC,EAAG,KAAOxC,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAEyC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,IAAK,GAAIzB,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,IAAQ7B,EAAEyC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,GAAI,GAAI,GAAI,GAAIzB,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIZ,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAE0C,EAAK,CAAC,EAAG,MAAO1C,EAAE0C,EAAK,CAAC,EAAG,MAAO1C,EAAE0C,EAAK,CAAC,EAAG,MAAO1C,EAAE0C,EAAK,CAAC,EAAG,MAAO1C,EAAE,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,CAAC,EAAG,MAAOA,EAAE8B,EAAK,CAAC,EAAG,GAAI,CAAE,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAIzB,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,IAAQ,CAAE,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIxB,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIf,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIG,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAOtC,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAIM,EAAK,GAAIC,GAAOtC,EAAE2C,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,GAAI,GAAIX,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,IAAQpC,EAAE4C,EAAK,CAAC,EAAG,KAAM5C,EAAE4C,EAAK,CAAC,EAAG,KAAM5C,EAAE4C,EAAK,CAAC,EAAG,KAAM5C,EAAE4C,EAAK,CAAC,EAAG,KAAM5C,EAAE4C,EAAK,CAAC,EAAG,KAAM5C,EAAE6C,EAAK,CAAC,EAAG,KAAM7C,EAAE6C,EAAK,CAAC,EAAG,KAAM,CAAE,EAAG,CAAC,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIpC,GAAO,CAAE,GAAI,GAAI,GAAIO,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,GAAO,CAAE,GAAI,GAAI,GAAIkB,GAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAIC,EAAK,GAAI,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,IAAK,GAAI,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAO,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAIf,EAAK,GAAI,KAAOxC,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,MAAO,CAAE,GAAIgB,EAAK,GAAI,IAAK,GAAIC,EAAK,GAAI,CAAC,EAAG,KAAM,GAAIC,EAAK,GAAI,IAAK,GAAI,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAOvD,EAAEwD,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAIxC,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAEyC,EAAK,CAAC,EAAG,KAAMzC,EAAEyC,EAAK,CAAC,EAAG,KAAMzC,EAAEyC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,IAAK,GAAI,GAAI,GAAI,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,GAAI,GAAIzB,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,GAAO5B,EAAEyD,GAAK,CAAC,EAAG,IAAK,CAAE,GAAI,IAAK,GAAI,CAAC,EAAG,OAASzD,EAAE8B,EAAK,CAAC,EAAG,IAAK,CAAE,EAAG,CAAC,EAAG,MAAQ9B,EAAE0D,GAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI1C,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO,CAAE,GAAI,CAAC,EAAG,KAAM,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAIb,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAE2C,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,IAAK,GAAIX,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,IAAQpC,EAAE2C,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAIlC,GAAO,CAAE,EAAG,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,KAAOT,EAAEuC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,OAAS,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,CAAC,EAAG,IAAK,GAAI,IAAK,GAAIO,GAAO,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI9B,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,OAAS/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,OAAS/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,OAAS,CAAE,GAAI,CAAC,EAAG,MAAQ/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI4B,KAAQ3D,EAAE4D,GAAK,CAAC,EAAG,IAAK,CAAE,GAAI,IAAK,GAAIb,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,IAAQvD,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAE6D,GAAK,CAAC,EAAG,MAAO7D,EAAE6D,GAAK,CAAC,EAAG,MAAO7D,EAAE6D,GAAK,CAAC,EAAG,MAAO7D,EAAE6D,GAAK,CAAC,EAAG,MAAO7D,EAAE6D,GAAK,CAAC,EAAG,MAAO7D,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI4B,KAAQ,CAAE,GAAI,CAAC,EAAG,MAAQ3D,EAAEyC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,IAAK,GAAI,GAAI,GAAIzB,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,GAAO,CAAE,GAAI,CAAC,EAAG,KAAO5B,EAAEyD,GAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,EAAG,CAAC,EAAG,IAAMzD,EAAE0D,GAAK,CAAC,EAAG,KAAM1D,EAAE0D,GAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI1C,EAAK,GAAIU,EAAK,GAAIC,EAAK,IAAKC,EAAK,IAAKC,GAAO7B,EAAE2C,EAAK,CAAC,EAAG,KAAM3C,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,GAAI,GAAI,IAAK,GAAI,CAAC,EAAG,IAAK,GAAI,GAAI,GAAItB,GAAO,CAAE,GAAI,IAAK,GAAIqC,GAAO9C,EAAEuC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAOvC,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,OAAS/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,OAAS/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,KAAM,GAAI,CAAC,EAAG,OAAS,CAAE,GAAIgB,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,IAAK,GAAI,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAOvD,EAAE6D,GAAK,CAAC,EAAG,KAAM7D,EAAEwD,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,MAAQxD,EAAE0D,GAAK,CAAC,EAAG,KAAM1D,EAAE+B,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,MAAQ/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,KAAM/B,EAAE+B,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,OAAS/B,EAAE4D,GAAK,CAAC,EAAG,IAAK,CAAE,GAAI,IAAK,GAAIb,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,IAAQvD,EAAEyD,GAAK,CAAC,EAAG,IAAKzD,EAAEuC,EAAK,CAAC,EAAG,KAAMvC,EAAE+B,EAAK,CAAC,EAAG,MAC9gMsF,eAAgB,CAAE,EAAG,CAAC,EAAG,GAAI,EAAG,CAAC,EAAG,GAAI,EAAG,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,IAAK,IAAK,CAAC,EAAG,IAAK,IAAK,CAAC,EAAG,GAAI,IAAK,CAAC,EAAG,IAAK,IAAK,CAAC,EAAG,IAAK,IAAK,CAAC,EAAG,KAChIC,YAA4B,SAAO,SAAoBC,EAAKC,GAC1D,IAAIA,EAAKC,YAEF,CACL,IAAIC,EAAQ,IAAIlK,MAAM+J,GAEtB,MADAG,EAAMF,KAAOA,EACPE,CACR,CALE9C,KAAKb,MAAMwD,EAMf,GAAG,cACHI,OAAuB,SAAO,SAAeC,GAC3C,IAAIC,EAAOjD,KAAMkD,EAAQ,CAAC,GAAIC,EAAS,GAAIC,EAAS,CAAC,MAAOC,EAAS,GAAIb,EAAQxC,KAAKwC,MAAO/C,EAAS,GAAIE,EAAW,EAAGD,EAAS,EAAG4D,EAAa,EAC7IC,EAAOF,EAAOG,MAAMC,KAAKC,UAAW,GACpCC,EAASpK,OAAOqK,OAAO5D,KAAK6D,OAC5BC,EAAc,CAAE1E,GAAI,CAAC,GACzB,IAAK,IAAI/D,KAAK2E,KAAKZ,GACb7F,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKZ,GAAI/D,KAChDyI,EAAY1E,GAAG/D,GAAK2E,KAAKZ,GAAG/D,IAGhCsI,EAAOM,SAASjB,EAAOc,EAAY1E,IACnC0E,EAAY1E,GAAGyE,MAAQF,EACvBG,EAAY1E,GAAGjE,OAAS6E,UACI,IAAjB2D,EAAOO,SAChBP,EAAOO,OAAS,CAAC,GAEnB,IAAIC,EAAQR,EAAOO,OACnBb,EAAOzM,KAAKuN,GACZ,IAAIC,EAAST,EAAOzI,SAAWyI,EAAOzI,QAAQkJ,OAY9C,SAASC,IACP,IAAIC,EASJ,MAPqB,iBADrBA,EAAQnB,EAAOoB,OAASZ,EAAOU,OA/BqI,KAiC9JC,aAAiBE,QAEnBF,GADAnB,EAASmB,GACMC,OAEjBD,EAAQrB,EAAK5D,SAASiF,IAAUA,GAE3BA,CACT,CAtByC,mBAA9BR,EAAY1E,GAAGsD,WACxB1C,KAAK0C,WAAaoB,EAAY1E,GAAGsD,WAEjC1C,KAAK0C,WAAanJ,OAAOkL,eAAezE,MAAM0C,YAOhD,SALA,SAAkBgC,GAChBxB,EAAM5N,OAAS4N,EAAM5N,OAAS,EAAIoP,EAClCtB,EAAO9N,OAAS8N,EAAO9N,OAASoP,EAChCrB,EAAO/N,OAAS+N,EAAO/N,OAASoP,CAClC,GACiB,aAajB,QAAOL,EAAK,OAEZ,IADA,IAAIM,EAAQC,EAAgBC,EAAOnM,EAAWoM,EAAeC,EAAGC,EAAKC,EAAUC,EAA9BC,EAAQ,CAAC,IAC7C,CAUX,GATAN,EAAQ3B,EAAMA,EAAM5N,OAAS,GACzB0K,KAAKyC,eAAeoC,GACtBnM,EAASsH,KAAKyC,eAAeoC,IAEzBF,UACFA,EAASN,KAEX3L,EAAS8J,EAAMqC,IAAUrC,EAAMqC,GAAOF,SAElB,IAAXjM,IAA2BA,EAAOpD,SAAWoD,EAAO,GAAI,CACjE,IAAI0M,EAAS,GAEb,IAAKL,KADLG,EAAW,GACD1C,EAAMqC,GACV7E,KAAKV,WAAWyF,IAAMA,EAzD6H,GA0DrJG,EAAStO,KAAK,IAAMoJ,KAAKV,WAAWyF,GAAK,KAI3CK,EADEzB,EAAO0B,aACA,wBAA0B1F,EAAW,GAAK,MAAQgE,EAAO0B,eAAiB,eAAiBH,EAASxL,KAAK,MAAQ,WAAasG,KAAKV,WAAWqF,IAAWA,GAAU,IAEnK,wBAA0BhF,EAAW,GAAK,iBAhE6G,GAgE1FgF,EAAgB,eAAiB,KAAO3E,KAAKV,WAAWqF,IAAWA,GAAU,KAErJ3E,KAAK0C,WAAW0C,EAAQ,CACtBE,KAAM3B,EAAO4B,MACbjB,MAAOtE,KAAKV,WAAWqF,IAAWA,EAClCa,KAAM7B,EAAOhE,SACb8F,IAAKtB,EACLe,YAEJ,CACA,GAAIxM,EAAO,aAAc8L,OAAS9L,EAAOpD,OAAS,EAChD,MAAM,IAAIsD,MAAM,oDAAsDiM,EAAQ,YAAcF,GAE9F,OAAQjM,EAAO,IACb,KAAK,EACHwK,EAAMtM,KAAK+N,GACXvB,EAAOxM,KAAK+M,EAAOlE,QACnB4D,EAAOzM,KAAK+M,EAAOO,QACnBhB,EAAMtM,KAAK8B,EAAO,IAClBiM,EAAS,KACJC,GASHD,EAASC,EACTA,EAAiB,OATjBlF,EAASiE,EAAOjE,OAChBD,EAASkE,EAAOlE,OAChBE,EAAWgE,EAAOhE,SAClBwE,EAAQR,EAAOO,OACXZ,EAAa,GACfA,KAMJ,MACF,KAAK,EAwBH,GAvBA0B,EAAMhF,KAAKT,aAAa7G,EAAO,IAAI,GACnCyM,EAAMlF,EAAImD,EAAOA,EAAO9N,OAAS0P,GACjCG,EAAMrF,GAAK,CACT4F,WAAYrC,EAAOA,EAAO/N,QAAU0P,GAAO,IAAIU,WAC/CC,UAAWtC,EAAOA,EAAO/N,OAAS,GAAGqQ,UACrCC,aAAcvC,EAAOA,EAAO/N,QAAU0P,GAAO,IAAIY,aACjDC,YAAaxC,EAAOA,EAAO/N,OAAS,GAAGuQ,aAErCzB,IACFe,EAAMrF,GAAG3F,MAAQ,CACfkJ,EAAOA,EAAO/N,QAAU0P,GAAO,IAAI7K,MAAM,GACzCkJ,EAAOA,EAAO/N,OAAS,GAAG6E,MAAM,UAYnB,KATjB2K,EAAI9E,KAAKR,cAAcsG,MAAMX,EAAO,CAClC1F,EACAC,EACAC,EACAmE,EAAY1E,GACZ1G,EAAO,GACP0K,EACAC,GACA7P,OAAO+P,KAEP,OAAOuB,EAELE,IACF9B,EAAQA,EAAMM,MAAM,GAAI,EAAIwB,EAAM,GAClC5B,EAASA,EAAOI,MAAM,GAAI,EAAIwB,GAC9B3B,EAASA,EAAOG,MAAM,GAAI,EAAIwB,IAEhC9B,EAAMtM,KAAKoJ,KAAKT,aAAa7G,EAAO,IAAI,IACxC0K,EAAOxM,KAAKuO,EAAMlF,GAClBoD,EAAOzM,KAAKuO,EAAMrF,IAClBmF,EAAWzC,EAAMU,EAAMA,EAAM5N,OAAS,IAAI4N,EAAMA,EAAM5N,OAAS,IAC/D4N,EAAMtM,KAAKqO,GACX,MACF,KAAK,EACH,OAAO,EAEb,CACA,OAAO,CACT,GAAG,UAEDpB,GAAwB,WA8kB1B,MA7kBa,CACXkC,IAAK,EACLrD,YAA4B,SAAO,SAAoBC,EAAKC,GAC1D,IAAI5C,KAAKZ,GAAGjE,OAGV,MAAM,IAAIvC,MAAM+J,GAFhB3C,KAAKZ,GAAGjE,OAAOuH,WAAWC,EAAKC,EAInC,GAAG,cAEHqB,UAA0B,SAAO,SAASjB,EAAO5D,GAiB/C,OAhBAY,KAAKZ,GAAKA,GAAMY,KAAKZ,IAAM,CAAC,EAC5BY,KAAKgG,OAAShD,EACdhD,KAAKiG,MAAQjG,KAAKkG,WAAalG,KAAKtJ,MAAO,EAC3CsJ,KAAKL,SAAWK,KAAKN,OAAS,EAC9BM,KAAKP,OAASO,KAAKmG,QAAUnG,KAAKuF,MAAQ,GAC1CvF,KAAKoG,eAAiB,CAAC,WACvBpG,KAAKkE,OAAS,CACZwB,WAAY,EACZE,aAAc,EACdD,UAAW,EACXE,YAAa,GAEX7F,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC,EAAG,IAE1B6F,KAAKqG,OAAS,EACPrG,IACT,GAAG,YAEHgD,OAAuB,SAAO,WAC5B,IAAIsD,EAAKtG,KAAKgG,OAAO,GAiBrB,OAhBAhG,KAAKP,QAAU6G,EACftG,KAAKN,SACLM,KAAKqG,SACLrG,KAAKuF,OAASe,EACdtG,KAAKmG,SAAWG,EACJA,EAAGf,MAAM,oBAEnBvF,KAAKL,WACLK,KAAKkE,OAAOyB,aAEZ3F,KAAKkE,OAAO2B,cAEV7F,KAAK9E,QAAQkJ,QACfpE,KAAKkE,OAAO/J,MAAM,KAEpB6F,KAAKgG,OAAShG,KAAKgG,OAAOxC,MAAM,GACzB8C,CACT,GAAG,SAEHC,OAAuB,SAAO,SAASD,GACrC,IAAItB,EAAMsB,EAAGhR,OACTkR,EAAQF,EAAGG,MAAM,iBACrBzG,KAAKgG,OAASM,EAAKtG,KAAKgG,OACxBhG,KAAKP,OAASO,KAAKP,OAAOiH,OAAO,EAAG1G,KAAKP,OAAOnK,OAAS0P,GACzDhF,KAAKqG,QAAUrB,EACf,IAAI2B,EAAW3G,KAAKuF,MAAMkB,MAAM,iBAChCzG,KAAKuF,MAAQvF,KAAKuF,MAAMmB,OAAO,EAAG1G,KAAKuF,MAAMjQ,OAAS,GACtD0K,KAAKmG,QAAUnG,KAAKmG,QAAQO,OAAO,EAAG1G,KAAKmG,QAAQ7Q,OAAS,GACxDkR,EAAMlR,OAAS,IACjB0K,KAAKL,UAAY6G,EAAMlR,OAAS,GAElC,IAAIwP,EAAI9E,KAAKkE,OAAO/J,MAWpB,OAVA6F,KAAKkE,OAAS,CACZwB,WAAY1F,KAAKkE,OAAOwB,WACxBC,UAAW3F,KAAKL,SAAW,EAC3BiG,aAAc5F,KAAKkE,OAAO0B,aAC1BC,YAAaW,GAASA,EAAMlR,SAAWqR,EAASrR,OAAS0K,KAAKkE,OAAO0B,aAAe,GAAKe,EAASA,EAASrR,OAASkR,EAAMlR,QAAQA,OAASkR,EAAM,GAAGlR,OAAS0K,KAAKkE,OAAO0B,aAAeZ,GAEtLhF,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC2K,EAAE,GAAIA,EAAE,GAAK9E,KAAKN,OAASsF,IAElDhF,KAAKN,OAASM,KAAKP,OAAOnK,OACnB0K,IACT,GAAG,SAEH4G,MAAsB,SAAO,WAE3B,OADA5G,KAAKiG,OAAQ,EACNjG,IACT,GAAG,QAEH6G,QAAwB,SAAO,WAC7B,OAAI7G,KAAK9E,QAAQ4L,iBACf9G,KAAKkG,YAAa,EAQblG,MANEA,KAAK0C,WAAW,0BAA4B1C,KAAKL,SAAW,GAAK,mIAAqIK,KAAKqF,eAAgB,CAChOC,KAAM,GACNhB,MAAO,KACPkB,KAAMxF,KAAKL,UAIjB,GAAG,UAEHoH,MAAsB,SAAO,SAASrC,GACpC1E,KAAKuG,MAAMvG,KAAKuF,MAAM/B,MAAMkB,GAC9B,GAAG,QAEHsC,WAA2B,SAAO,WAChC,IAAIC,EAAOjH,KAAKmG,QAAQO,OAAO,EAAG1G,KAAKmG,QAAQ7Q,OAAS0K,KAAKuF,MAAMjQ,QACnE,OAAQ2R,EAAK3R,OAAS,GAAK,MAAQ,IAAM2R,EAAKP,QAAQ,IAAIQ,QAAQ,MAAO,GAC3E,GAAG,aAEHC,eAA+B,SAAO,WACpC,IAAI1Q,EAAOuJ,KAAKuF,MAIhB,OAHI9O,EAAKnB,OAAS,KAChBmB,GAAQuJ,KAAKgG,OAAOU,OAAO,EAAG,GAAKjQ,EAAKnB,UAElCmB,EAAKiQ,OAAO,EAAG,KAAOjQ,EAAKnB,OAAS,GAAK,MAAQ,KAAK4R,QAAQ,MAAO,GAC/E,GAAG,iBAEH7B,cAA8B,SAAO,WACnC,IAAI+B,EAAMpH,KAAKgH,YACXK,EAAI,IAAI7C,MAAM4C,EAAI9R,OAAS,GAAGoE,KAAK,KACvC,OAAO0N,EAAMpH,KAAKmH,gBAAkB,KAAOE,EAAI,GACjD,GAAG,gBAEHC,YAA4B,SAAO,SAAS/B,EAAOgC,GACjD,IAAIjD,EAAOkC,EAAOgB,EAmDlB,GAlDIxH,KAAK9E,QAAQ4L,kBACfU,EAAS,CACP7H,SAAUK,KAAKL,SACfuE,OAAQ,CACNwB,WAAY1F,KAAKkE,OAAOwB,WACxBC,UAAW3F,KAAK2F,UAChBC,aAAc5F,KAAKkE,OAAO0B,aAC1BC,YAAa7F,KAAKkE,OAAO2B,aAE3BpG,OAAQO,KAAKP,OACb8F,MAAOvF,KAAKuF,MACZkC,QAASzH,KAAKyH,QACdtB,QAASnG,KAAKmG,QACdzG,OAAQM,KAAKN,OACb2G,OAAQrG,KAAKqG,OACbJ,MAAOjG,KAAKiG,MACZD,OAAQhG,KAAKgG,OACb5G,GAAIY,KAAKZ,GACTgH,eAAgBpG,KAAKoG,eAAe5C,MAAM,GAC1C9M,KAAMsJ,KAAKtJ,MAETsJ,KAAK9E,QAAQkJ,SACfoD,EAAOtD,OAAO/J,MAAQ6F,KAAKkE,OAAO/J,MAAMqJ,MAAM,MAGlDgD,EAAQjB,EAAM,GAAGA,MAAM,sBAErBvF,KAAKL,UAAY6G,EAAMlR,QAEzB0K,KAAKkE,OAAS,CACZwB,WAAY1F,KAAKkE,OAAOyB,UACxBA,UAAW3F,KAAKL,SAAW,EAC3BiG,aAAc5F,KAAKkE,OAAO2B,YAC1BA,YAAaW,EAAQA,EAAMA,EAAMlR,OAAS,GAAGA,OAASkR,EAAMA,EAAMlR,OAAS,GAAGiQ,MAAM,UAAU,GAAGjQ,OAAS0K,KAAKkE,OAAO2B,YAAcN,EAAM,GAAGjQ,QAE/I0K,KAAKP,QAAU8F,EAAM,GACrBvF,KAAKuF,OAASA,EAAM,GACpBvF,KAAKyH,QAAUlC,EACfvF,KAAKN,OAASM,KAAKP,OAAOnK,OACtB0K,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC6F,KAAKqG,OAAQrG,KAAKqG,QAAUrG,KAAKN,SAExDM,KAAKiG,OAAQ,EACbjG,KAAKkG,YAAa,EAClBlG,KAAKgG,OAAShG,KAAKgG,OAAOxC,MAAM+B,EAAM,GAAGjQ,QACzC0K,KAAKmG,SAAWZ,EAAM,GACtBjB,EAAQtE,KAAKR,cAAciE,KAAKzD,KAAMA,KAAKZ,GAAIY,KAAMuH,EAAcvH,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,IAChH0K,KAAKtJ,MAAQsJ,KAAKgG,SACpBhG,KAAKtJ,MAAO,GAEV4N,EACF,OAAOA,EACF,GAAItE,KAAKkG,WAAY,CAC1B,IAAK,IAAI7K,KAAKmM,EACZxH,KAAK3E,GAAKmM,EAAOnM,GAEnB,OAAO,CACT,CACA,OAAO,CACT,GAAG,cAEH5E,MAAsB,SAAO,WAC3B,GAAIuJ,KAAKtJ,KACP,OAAOsJ,KAAK+F,IAKd,IAAIzB,EAAOiB,EAAOmC,EAAWtS,EAHxB4K,KAAKgG,SACRhG,KAAKtJ,MAAO,GAGTsJ,KAAKiG,QACRjG,KAAKP,OAAS,GACdO,KAAKuF,MAAQ,IAGf,IADA,IAAIrS,EAAQ8M,KAAK2H,gBACRzO,EAAI,EAAGA,EAAIhG,EAAMoC,OAAQ4D,IAEhC,IADAwO,EAAY1H,KAAKgG,OAAOT,MAAMvF,KAAK9M,MAAMA,EAAMgG,SAC5BqM,GAASmC,EAAU,GAAGpS,OAASiQ,EAAM,GAAGjQ,QAAS,CAGlE,GAFAiQ,EAAQmC,EACRtS,EAAQ8D,EACJ8G,KAAK9E,QAAQ4L,gBAAiB,CAEhC,IAAc,KADdxC,EAAQtE,KAAKsH,WAAWI,EAAWxU,EAAMgG,KAEvC,OAAOoL,EACF,GAAItE,KAAKkG,WAAY,CAC1BX,GAAQ,EACR,QACF,CACE,OAAO,CAEX,CAAO,IAAKvF,KAAK9E,QAAQ0M,KACvB,KAEJ,CAEF,OAAIrC,GAEY,KADdjB,EAAQtE,KAAKsH,WAAW/B,EAAOrS,EAAMkC,MAE5BkP,EAIS,KAAhBtE,KAAKgG,OACAhG,KAAK+F,IAEL/F,KAAK0C,WAAW,0BAA4B1C,KAAKL,SAAW,GAAK,yBAA2BK,KAAKqF,eAAgB,CACtHC,KAAM,GACNhB,MAAO,KACPkB,KAAMxF,KAAKL,UAGjB,GAAG,QAEH0E,KAAqB,SAAO,WAC1B,IAAIS,EAAI9E,KAAKvJ,OACb,OAAIqO,GAGK9E,KAAKqE,KAEhB,GAAG,OAEHwD,OAAuB,SAAO,SAAeC,GAC3C9H,KAAKoG,eAAexP,KAAKkR,EAC3B,GAAG,SAEHC,UAA0B,SAAO,WAE/B,OADQ/H,KAAKoG,eAAe9Q,OAAS,EAC7B,EACC0K,KAAKoG,eAAe7B,MAEpBvE,KAAKoG,eAAe,EAE/B,GAAG,YAEHuB,eAA+B,SAAO,WACpC,OAAI3H,KAAKoG,eAAe9Q,QAAU0K,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,GAC1E0K,KAAKgI,WAAWhI,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,IAAIpC,MAErE8M,KAAKgI,WAAoB,QAAE9U,KAEtC,GAAG,iBAEH+U,UAA0B,SAAO,SAAkBvD,GAEjD,OADAA,EAAI1E,KAAKoG,eAAe9Q,OAAS,EAAIE,KAAK0S,IAAIxD,GAAK,KAC1C,EACA1E,KAAKoG,eAAe1B,GAEpB,SAEX,GAAG,YAEHyD,WAA2B,SAAO,SAAmBL,GACnD9H,KAAK6H,MAAMC,EACb,GAAG,aAEHM,gBAAgC,SAAO,WACrC,OAAOpI,KAAKoG,eAAe9Q,MAC7B,GAAG,kBACH4F,QAAS,CAAC,EACVsE,eAA+B,SAAO,SAAmBJ,EAAIiJ,EAAKC,EAA2BC,GAE3F,OAAQD,GACN,KAAK,EACH,OAAO,GAET,KAAK,EACH,OAAO,GAET,KAAK,EACH,OAAO,GAET,KAAK,EACH,OAAO,GAET,KAAK,EAEL,KAAK,EA8BL,KAAK,GAqDL,KAAK,GAgBL,KAAK,GAaL,KAAK,GAwBL,KAAK,GACH,MAvIF,KAAK,EAEH,OADAtI,KAAK6H,MAAM,aACJ,GAET,KAAK,EAEH,OADA7H,KAAK+H,WACE,kBAET,KAAK,EAEH,OADA/H,KAAK6H,MAAM,aACJ,GAET,KAAK,EAEH,OADA7H,KAAK+H,WACE,kBAET,KAAK,GACH/H,KAAK6H,MAAM,uBACX,MACF,KAAK,GAuBL,KAAK,GAUL,KAAK,GAML,KAAK,GA4GL,KAAK,GASL,KAAK,GACH7H,KAAK+H,WACL,MA3JF,KAAK,GACH,MAAO,4BAET,KAAK,GAqEL,KAAK,GACH,OAAO,EAjET,KAAK,GAGL,KAAK,GACH,OAAO,EAET,KAAK,GA+DL,KAAK,GA6BL,KAAK,GACH,MAAO,aA1FT,KAAK,GACH/H,KAAK6H,MAAM,iBACX,MAIF,KAAK,GACH7H,KAAK+H,WACL/H,KAAK6H,MAAM,iBACX,MACF,KAAK,GACH,OAAO,GAKT,KAAK,GACH,OAAO,GAKT,KAAK,GACH,MAAO,MAET,KAAK,GACH7H,KAAK6H,MAAM,UACX,MACF,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GAEH,OADA7H,KAAK6H,MAAM,aACJ,GAET,KAAK,GA6BL,KAAK,GAEH,OADA7H,KAAK+H,WACE,EAzBT,KAAK,GAEH,OADA/H,KAAK6H,MAAM,kBACJ,GAET,KAAK,GAkCL,KAAK,GAEH,OADA7H,KAAK+H,WACE,GAhCT,KAAK,GAkCL,KAAK,GACH,MAAO,gBAxBT,KAAK,GAEH,OADA/H,KAAK6H,MAAM,SACJ,GAQT,KAAK,GAGH,OAFA7H,KAAK+H,WACL/H,KAAK+H,WACE,GAET,KAAK,GAEH,OADA/H,KAAK6H,MAAM,cACJ,GAYT,KAAK,GACH,MAAO,iBAIT,KAAK,GACH,MAAO,SAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAKT,KAAK,GACH,MAAO,cAET,KAAK,GACH7H,KAAK6H,MAAM,WACX,MAIF,KAAK,GACH,MAAO,aAET,KAAK,GACH7H,KAAK6H,MAAM,YACX,MACF,KAAK,GAGL,KAAK,GAGL,KAAK,GAGL,KAAK,GACH,OAAO,GAET,KAAK,GAGL,KAAK,GACH,OAAO,GAET,KAAK,GAGL,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,MAAO,OAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GAGL,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GAGL,KAAK,GACH,MAAO,SAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,MAAO,cAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,IAET,KAAK,GAGL,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,EAGb,GAAG,aACH3U,MAAO,CAAC,8BAA+B,8BAA+B,8BAA+B,8BAA+B,gCAAiC,wBAAyB,uBAAwB,uBAAwB,uBAAwB,uBAAwB,wBAAyB,YAAa,cAAe,mBAAoB,WAAY,yBAA0B,sBAAuB,cAAe,iBAAkB,iBAAkB,UAAW,aAAc,UAAW,aAAc,WAAY,aAAc,WAAY,eAAgB,kBAAmB,mBAAoB,mBAAoB,WAAY,WAAY,WAAY,SAAU,mBAAoB,WAAY,cAAe,eAAgB,mBAAoB,WAAY,WAAY,WAAY,WAAY,SAAU,cAAe,WAAY,YAAa,gBAAiB,kBAAmB,kBAAmB,cAAe,eAAgB,kBAAmB,cAAe,UAAW,UAAW,cAAe,WAAY,aAAc,SAAU,WAAY,aAAc,WAAY,eAAgB,gBAAiB,iBAAkB,cAAe,cAAe,cAAe,YAAa,YAAa,aAAc,cAAe,eAAgB,UAAW,YAAa,oBAAqB,YAAa,SAAU,UAAW,UAAW,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,WAAY,UAAW,UAAW,2BAA4B,cAAe,qxIAAsxI,UAAW,UAAW,UACpwL8U,WAAY,CAAE,iBAAkB,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,aAAc,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,MAAS,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,oBAAuB,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,cAAiB,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,cAAiB,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,KAAQ,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,OAAU,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,QAAW,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,SAAY,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,OAAU,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,QAAW,CAAE,MAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,IAG31G,CA/kB4B,GAilB5B,SAASQ,KACPxI,KAAKZ,GAAK,CAAC,CACb,CAIA,OAPAF,GAAQ2E,MAAQA,IAIhB,QAAO2E,GAAQ,UACfA,GAAOzE,UAAY7E,GACnBA,GAAQsJ,OAASA,GACV,IAAIA,EACb,CAj/Ba,GAk/BbrN,EAAOA,OAASA,EAChB,IAAIsN,EAAuBtN,EAMvBuN,EAAmB,CAAC,IAAK,IAAK,IAAK,IAAK,IACxCC,EAAc,cAEd,QAAO3I,KAAM,cACf,CACA,WAAA4I,CAAY5F,EAAO6F,GACjB7I,KAAK6I,WAAaA,EAClB7I,KAAK8I,WAAa,GAClB9I,KAAK+I,WAAa,GAClB/I,KAAKsF,KAAO,GACZ,MAAM0D,GAAiB,QAAahG,GAAO,WAC3ChD,KAAKiJ,YAAYD,EACnB,CACA,iBAAAE,GACE,IAAIC,EAAcnJ,KAAK8I,YAAa,QAAkB9I,KAAKoJ,IACnC,WAApBpJ,KAAK6I,aACPM,GAAe,KAAI,QAAkBnJ,KAAKqJ,WAAWhJ,WACjDL,KAAKzH,aACP4Q,GAAe,OAAQ,QAAkBnJ,KAAKzH,cAGlD4Q,EAAcA,EAAY9I,OAE1B,MAAO,CACL8I,cACAG,SAHetJ,KAAKuJ,kBAKxB,CACA,WAAAN,CAAYjG,GACV,IAAIwG,EAAsB,GAC1B,GAAwB,WAApBxJ,KAAK6I,WAAyB,CAChC,MACMtD,EADc,4CACMkE,KAAKzG,GAC/B,GAAIuC,EAAO,CACT,MAAMmE,EAAqBnE,EAAM,GAAKA,EAAM,GAAGlF,OAAS,GAQxD,GAPIqI,EAAiB1N,SAAS0O,KAC5B1J,KAAK8I,WAAaY,GAEpB1J,KAAKoJ,GAAK7D,EAAM,GAChBvF,KAAKqJ,WAAa9D,EAAM,GAAKA,EAAM,GAAGlF,OAAS,GAC/CmJ,EAAsBjE,EAAM,GAAKA,EAAM,GAAGlF,OAAS,GACnDL,KAAKzH,WAAagN,EAAM,GAAKA,EAAM,GAAGlF,OAAS,GACnB,KAAxBmJ,EAA4B,CAC9B,MAAMG,EAAW3J,KAAKzH,WAAWuC,UAAUkF,KAAKzH,WAAWjD,OAAS,GAChE,OAAOmU,KAAKE,KACdH,EAAsBG,EACtB3J,KAAKzH,WAAayH,KAAKzH,WAAWuC,UAAU,EAAGkF,KAAKzH,WAAWjD,OAAS,GAE5E,CACF,CACF,KAAO,CACL,MAAMA,EAAS0N,EAAM1N,OACfsU,EAAY5G,EAAMlI,UAAU,EAAG,GAC/B6O,EAAW3G,EAAMlI,UAAUxF,EAAS,GACtCoT,EAAiB1N,SAAS4O,KAC5B5J,KAAK8I,WAAac,GAEhB,OAAOH,KAAKE,KACdH,EAAsBG,GAExB3J,KAAKoJ,GAAKpG,EAAMlI,UACM,KAApBkF,KAAK8I,WAAoB,EAAI,EACL,KAAxBU,EAA6BlU,EAASA,EAAS,EAEnD,CACA0K,KAAK+I,WAAaS,EAClBxJ,KAAKoJ,GAAKpJ,KAAKoJ,GAAGS,WAAW,KAAO,IAAM7J,KAAKoJ,GAAG/I,OAASL,KAAKoJ,GAAG/I,OACnE,MAAMyJ,EAAe,GAAG9J,KAAK8I,WAAa,KAAO9I,KAAK8I,WAAa,MAAK,QAAkB9I,KAAKoJ,MAA0B,WAApBpJ,KAAK6I,WAA0B,KAAI,QAAkB7I,KAAKqJ,eAAerJ,KAAKzH,WAAa,OAAQ,QAAkByH,KAAKzH,YAAc,KAAO,KACpPyH,KAAKsF,KAAOwE,EAAaC,WAAW,IAAK,QAAQA,WAAW,IAAK,QAC7D/J,KAAKsF,KAAKuE,WAAW,YACvB7J,KAAKsF,KAAOtF,KAAKsF,KAAK4B,QAAQ,SAAU,KAE5C,CACA,eAAAqC,GACE,OAAQvJ,KAAK+I,YACX,IAAK,IACH,MAAO,qBACT,IAAK,IACH,MAAO,6BACT,QACE,MAAO,GAEb,GAIEiB,EAAwB,WACxBC,EAAe,EACfC,GAAgC,SAAQC,GAAQ,KAAeC,aAAaD,GAAK,YAAc,gBAC/FE,EAAU,MACZ,WAAAzB,GACE5I,KAAKsK,UAAY,GACjBtK,KAAKuK,QAA0B,IAAIjT,IACnC0I,KAAKwK,aAA+B,IAAIlT,IACxC0I,KAAKyK,MAAQ,GACbzK,KAAK0K,WAAa,GAElB1K,KAAK2K,WAA6B,IAAIrT,IACtC0I,KAAK4K,iBAAmB,EACxB5K,KAAK6K,UAAY,GACjB7K,KAAK2B,SAAW,CACdO,KAAM,EACNC,YAAa,GAEfnC,KAAK4B,aAAe,CAClBC,YAAa,EACbC,UAAW,EACXC,YAAa,EACbC,WAAY,EACZC,SAAU,GAEZjC,KAAK8K,eAAgC,SAAQnV,IAC3C,IAAIoV,GAAc,SAAO,mBAC0B,QAA9CA,EAAYC,SAAWD,GAAa,GAAG,KAC1CA,GAAc,SAAO,QAAQE,OAAO,OAAOC,KAAK,QAAS,kBAAkBC,MAAM,UAAW,KAElF,SAAOxV,GAASyV,OAAO,OACjBC,UAAU,UACtBC,GAAG,aAAcC,IACrB,MAAMC,GAAK,SAAOD,EAAME,eAExB,GAAc,OADAD,EAAGN,KAAK,SAEpB,OAEF,MAAMQ,EAAO1L,KAAK2L,wBAClBZ,EAAYa,aAAaC,SAAS,KAAKV,MAAM,UAAW,MACxDJ,EAAYzF,KAAKkG,EAAGN,KAAK,UAAUC,MAAM,OAAQW,OAAOC,QAAUL,EAAKpR,MAAQoR,EAAKtR,MAAQsR,EAAKpR,MAAQ,EAAI,MAAM6Q,MAAM,MAAOW,OAAOE,QAAUN,EAAKO,IAAM,GAAKC,SAASC,KAAKC,UAAY,MAC3LrB,EAAYsB,KAAKtB,EAAYsB,OAAOnF,QAAQ,gBAAiB,UAC7DsE,EAAGc,QAAQ,SAAS,EAAK,IACxBhB,GAAG,YAAaC,IACjBR,EAAYa,aAAaC,SAAS,KAAKV,MAAM,UAAW,IAC7C,SAAOI,EAAME,eACrBa,QAAQ,SAAS,EAAM,GAC1B,GACD,iBACHtM,KAAKuM,UAAY,KACjBvM,KAAKM,YAAc,KACnBN,KAAKwM,YAAc,KACnBxM,KAAKO,kBAAoB,KACzBP,KAAKyM,kBAAoB,KACzBzM,KAAK0M,gBAAkB,KACvB1M,KAAK2M,gBAAkB,KACvB3M,KAAK4M,WAA4B,SAAO,KAAM,UAAYC,OAAO,aACjE7M,KAAK6K,UAAUjU,KAAKoJ,KAAK8K,cAAcgC,KAAK9M,OAC5CA,KAAK+M,QACL/M,KAAKE,YAAcF,KAAKE,YAAY4M,KAAK9M,MACzCA,KAAKQ,sBAAwBR,KAAKQ,sBAAsBsM,KAAK9M,MAC7DA,KAAKS,aAAeT,KAAKS,aAAaqM,KAAK9M,MAC3CA,KAAKW,YAAcX,KAAKW,YAAYmM,KAAK9M,MACzCA,KAAKY,WAAaZ,KAAKY,WAAWkM,KAAK9M,MACvCA,KAAKa,SAAWb,KAAKa,SAASiM,KAAK9M,MACnCA,KAAKc,cAAgBd,KAAKc,cAAcgM,KAAK9M,MAC7CA,KAAKe,cAAgBf,KAAKe,cAAc+L,KAAK9M,MAC7CA,KAAKgB,UAAYhB,KAAKgB,UAAU8L,KAAK9M,MACrCA,KAAKI,aAAeJ,KAAKI,aAAa0M,KAAK9M,MAC3CA,KAAKsB,QAAUtB,KAAKsB,QAAQwL,KAAK9M,MACjCA,KAAKuB,YAAcvB,KAAKuB,YAAYuL,KAAK9M,MACzCA,KAAKwB,aAAexB,KAAKwB,aAAasL,KAAK9M,MAC3CA,KAAKsC,QAAUtC,KAAKsC,QAAQwK,KAAK9M,MACjCA,KAAKgN,cAAgBhN,KAAKgN,cAAcF,KAAK9M,MAC7CA,KAAK+M,MAAQ/M,KAAK+M,MAAMD,KAAK9M,MAC7BA,KAAKqC,WAAarC,KAAKqC,WAAWyK,KAAK9M,MACvCA,KAAKoC,cAAgBpC,KAAKoC,cAAc0K,KAAK9M,MAC7CA,KAAKuC,YAAcvC,KAAKuC,YAAYuK,KAAK9M,KAC3C,SAEE,QAAOA,KAAM,UACf,CACA,qBAAAiN,CAAsBC,GACpB,MAAM9D,EAAK,KAAegB,aAAa8C,GAAK,WAC5C,IAAIC,EAAc,GACdC,EAAYhE,EAChB,GAAIA,EAAGiE,QAAQ,KAAO,EAAG,CACvB,MAAM5G,EAAQ2C,EAAG3C,MAAM,KACvB2G,EAAYlD,EAAczD,EAAM,IAChC0G,EAAcjD,EAAczD,EAAM,GACpC,CACA,MAAO,CAAE2G,YAAW3Y,KAAM0Y,EAC5B,CACA,aAAArM,CAAcoM,EAAKI,GACjB,MAAMlE,EAAK,KAAegB,aAAa8C,GAAK,WACxCI,IACFA,EAAQpD,EAAcoD,IAExB,MAAM,UAAEF,GAAcpN,KAAKiN,sBAAsB7D,GACjDpJ,KAAKuK,QAAQ3S,IAAIwV,GAAWE,MAAQA,EACpCtN,KAAKuK,QAAQ3S,IAAIwV,GAAW9H,KAAO,GAAGgI,IAAQtN,KAAKuK,QAAQ3S,IAAIwV,GAAW3Y,KAAO,IAAIuL,KAAKuK,QAAQ3S,IAAIwV,GAAW3Y,QAAU,IAC7H,CAOA,QAAAoM,CAASqM,GACP,MAAM9D,EAAK,KAAegB,aAAa8C,GAAK,YACtC,UAAEE,EAAS,KAAE3Y,GAASuL,KAAKiN,sBAAsB7D,GACvD,GAAIpJ,KAAKuK,QAAQzW,IAAIsZ,GACnB,OAEF,MAAMrZ,EAAO,KAAeqW,aAAagD,GAAW,WACpDpN,KAAKuK,QAAQ5S,IAAI5D,EAAM,CACrBqV,GAAIrV,EACJU,OACA6Y,MAAOvZ,EACPuR,KAAM,GAAGvR,IAAOU,EAAO,OAAOA,QAAa,KAC3C8Y,MAAO,WACPC,WAAY,UACZC,QAAS,GACTC,QAAS,GACTC,YAAa,GACbC,OAAQ,GACRC,MAAO7D,EAAwBjW,EAAO,IAAMkW,IAE9CA,GACF,CACA,YAAA6D,CAAaR,EAAOS,GAClB,MAAMC,EAAiB,CACrB5E,GAAI,YAAYpJ,KAAK0K,WAAWpV,SAChCgY,QACAS,WAEF/N,KAAK0K,WAAW9T,KAAKoX,EACvB,CAOA,WAAAC,CAAYf,GACV,MAAM9D,EAAK,KAAegB,aAAa8C,GAAK,WAC5C,GAAIlN,KAAKuK,QAAQzW,IAAIsV,GACnB,OAAOpJ,KAAKuK,QAAQ3S,IAAIwR,GAAIyE,MAE9B,MAAM,IAAIjV,MAAM,oBAAsBwQ,EACxC,CACA,KAAA2D,GACE/M,KAAKsK,UAAY,GACjBtK,KAAKuK,QAA0B,IAAIjT,IACnC0I,KAAKyK,MAAQ,GACbzK,KAAK0K,WAAa,GAClB1K,KAAK6K,UAAY,GACjB7K,KAAK6K,UAAUjU,KAAKoJ,KAAK8K,cAAcgC,KAAK9M,OAC5CA,KAAK2K,WAA6B,IAAIrT,IACtC0I,KAAK4K,iBAAmB,EACxB5K,KAAKuM,UAAY,MACjB,SACF,CACA,QAAA2B,CAAS9E,GACP,OAAOpJ,KAAKuK,QAAQ3S,IAAIwR,EAC1B,CACA,UAAA+E,GACE,OAAOnO,KAAKuK,OACd,CACA,YAAA6D,GACE,OAAOpO,KAAKsK,SACd,CACA,QAAA+D,GACE,OAAOrO,KAAKyK,KACd,CACA,WAAAvK,CAAYoO,GACV,KAAIC,MAAM,oBAAsBC,KAAKC,UAAUH,IAC/C,MAAMI,EAAe,CACnB1O,KAAK4B,aAAaK,SAClBjC,KAAK4B,aAAaC,YAClB7B,KAAK4B,aAAaG,YAClB/B,KAAK4B,aAAaI,WAClBhC,KAAK4B,aAAaE,WAEhBwM,EAAcrN,SAASQ,QAAUzB,KAAK4B,aAAaK,UAAayM,EAAa1T,SAASsT,EAAcrN,SAASS,OAItG4M,EAAcrN,SAASS,QAAU1B,KAAK4B,aAAaK,UAAayM,EAAa1T,SAASsT,EAAcrN,SAASQ,QAKtHzB,KAAKa,SAASyN,EAAclN,KAC5BpB,KAAKa,SAASyN,EAAcjN,OAL5BrB,KAAKa,SAASyN,EAAclN,KAC5BpB,KAAK8N,aAAaQ,EAAcjN,IAAKiN,EAAclN,KACnDkN,EAAcjN,IAAM,aAAYrB,KAAK0K,WAAWpV,OAAS,KANzD0K,KAAKa,SAASyN,EAAcjN,KAC5BrB,KAAK8N,aAAaQ,EAAclN,IAAKkN,EAAcjN,KACnDiN,EAAclN,IAAM,aAAYpB,KAAK0K,WAAWpV,OAAS,IAS3DgZ,EAAclN,IAAMpB,KAAKiN,sBAAsBqB,EAAclN,KAAKgM,UAClEkB,EAAcjN,IAAMrB,KAAKiN,sBAAsBqB,EAAcjN,KAAK+L,UAClEkB,EAAcpN,eAAiB,KAAekJ,aAC5CkE,EAAcpN,eAAeb,QAC7B,WAEFiO,EAAcnN,eAAiB,KAAeiJ,aAC5CkE,EAAcnN,eAAed,QAC7B,WAEFL,KAAKsK,UAAU1T,KAAK0X,EACtB,CASA,aAAAvN,CAAcqM,EAAWuB,GACvB,MAAMC,EAAqB5O,KAAKiN,sBAAsBG,GAAWA,UACjEpN,KAAKuK,QAAQ3S,IAAIgX,GAAoBjB,YAAY/W,KAAK+X,EACxD,CAUA,SAAA3N,CAAUoM,EAAWyB,GACnB7O,KAAKa,SAASuM,GACd,MAAMwB,EAAqB5O,KAAKiN,sBAAsBG,GAAWA,UAC3D0B,EAAW9O,KAAKuK,QAAQ3S,IAAIgX,GAClC,GAAsB,iBAAXC,EAAqB,CAC9B,MAAME,EAAeF,EAAOxO,OACxB0O,EAAalF,WAAW,OAASkF,EAAaC,SAAS,MACzDF,EAASnB,YAAY/W,KAAKsT,EAAc6E,EAAajU,UAAU,EAAGiU,EAAazZ,OAAS,KAC/EyZ,EAAa1B,QAAQ,KAAO,EACrCyB,EAASrB,QAAQ7W,KAAK,IAAI+R,EAAYoG,EAAc,WAC3CA,GACTD,EAASpB,QAAQ9W,KAAK,IAAI+R,EAAYoG,EAAc,aAExD,CACF,CACA,UAAAnO,CAAWwM,EAAWM,GAChBlJ,MAAMyK,QAAQvB,KAChBA,EAAQwB,UACRxB,EAAQxZ,SAAS2a,GAAW7O,KAAKgB,UAAUoM,EAAWyB,KAE1D,CACA,OAAAvN,CAAQgE,EAAM8H,GACZ,MAAM+B,EAAO,CACX/F,GAAI,OAAOpJ,KAAKyK,MAAMnV,SACtBuX,MAAOO,EACP9H,QAEFtF,KAAKyK,MAAM7T,KAAKuY,EAClB,CACA,YAAA/O,CAAakN,GAIX,OAHIA,EAAMzD,WAAW,OACnByD,EAAQA,EAAMxS,UAAU,IAEnBoP,EAAcoD,EAAMjN,OAC7B,CAOA,WAAAM,CAAYyO,EAAKhC,GACfgC,EAAI3I,MAAM,KAAKvS,SAASgZ,IACtB,IAAI9D,EAAK8D,EACL,KAAKzD,KAAKyD,EAAI,MAChB9D,EAAKY,EAAwBZ,GAE/B,MAAMiG,EAAYrP,KAAKuK,QAAQ3S,IAAIwR,GAC/BiG,IACFA,EAAU7B,YAAc,IAAMJ,EAChC,GAEJ,CACA,WAAA7L,CAAY6N,EAAKjE,GACf,IAAK,MAAM/B,KAAMgG,EAAK,CACpB,IAAIE,EAAatP,KAAKwK,aAAa5S,IAAIwR,QACpB,IAAfkG,IACFA,EAAa,CAAElG,KAAIwE,OAAQ,GAAI2B,WAAY,IAC3CvP,KAAKwK,aAAa7S,IAAIyR,EAAIkG,IAExBnE,GACFA,EAAMjX,SAAS+E,IACb,GAAI,QAAQwQ,KAAKxQ,GAAI,CACnB,MAAMuW,EAAWvW,EAAEiO,QAAQ,OAAQ,UACnCoI,EAAWC,WAAW3Y,KAAK4Y,EAC7B,CACAF,EAAW1B,OAAOhX,KAAKqC,EAAE,IAG7B+G,KAAKuK,QAAQrW,SAASvB,IAChBA,EAAM6a,WAAWxS,SAASoO,IAC5BzW,EAAMib,OAAOhX,QAAQuU,EAAMlV,SAASgD,GAAMA,EAAEwN,MAAM,OACpD,GAEJ,CACF,CAOA,UAAApE,CAAW+M,EAAKK,GACdL,EAAI3I,MAAM,KAAKvS,SAASkV,SACN,IAAZqG,IACFzP,KAAKuK,QAAQ3S,IAAIwR,GAAIqG,QAAUvF,EAAcuF,GAC/C,GAEJ,CACA,UAAAC,CAAWtG,EAAIuG,GACb,OAAIA,GAAa3P,KAAK2K,WAAW7W,IAAI6b,GAC5B3P,KAAK2K,WAAW/S,IAAI+X,GAAWpF,QAAQ3S,IAAIwR,GAAIqG,QAEjDzP,KAAKuK,QAAQ3S,IAAIwR,GAAIqG,OAC9B,CAQA,OAAAnN,CAAQ8M,EAAKQ,EAASC,GACpB,MAAMC,GAAS,UACfV,EAAI3I,MAAM,KAAKvS,SAASgZ,IACtB,IAAI9D,EAAK8D,EACL,KAAKzD,KAAKyD,EAAI,MAChB9D,EAAKY,EAAwBZ,GAE/B,MAAM0F,EAAW9O,KAAKuK,QAAQ3S,IAAIwR,GAC9B0F,IACFA,EAASiB,KAAO,KAAcC,UAAUJ,EAASE,GACpB,YAAzBA,EAAOG,cACTnB,EAASoB,WAAa,OAEtBpB,EAASoB,WADkB,iBAAXL,EACM3F,EAAc2F,GAEd,SAE1B,IAEF7P,KAAKW,YAAYyO,EAAK,YACxB,CAQA,aAAAhN,CAAcgN,EAAKe,EAAcC,GAC/BhB,EAAI3I,MAAM,KAAKvS,SAASkV,IACtBpJ,KAAKqQ,aAAajH,EAAI+G,EAAcC,GACpCpQ,KAAKuK,QAAQ3S,IAAIwR,GAAIkH,cAAe,CAAI,IAE1CtQ,KAAKW,YAAYyO,EAAK,YACxB,CACA,YAAAiB,CAAaE,EAAQJ,EAAcC,GACjC,MAAMvC,EAAQ,KAAezD,aAAamG,GAAQ,WAElD,GAA6B,WADd,UACJN,cACT,OAEF,QAAqB,IAAjBE,EACF,OAEF,MAAM/G,EAAKyE,EACX,GAAI7N,KAAKuK,QAAQzW,IAAIsV,GAAK,CACxB,MAAMoH,EAASxQ,KAAKiO,YAAY7E,GAChC,IAAIqH,EAAU,GACd,GAA4B,iBAAjBL,EAA2B,CACpCK,EAAUL,EAAa3J,MAAM,iCAC7B,IAAK,IAAIvN,EAAI,EAAGA,EAAIuX,EAAQnb,OAAQ4D,IAAK,CACvC,IAAIwX,EAAOD,EAAQvX,GAAGmH,OAClBqQ,EAAK7G,WAAW,MAAQ6G,EAAK1B,SAAS,OACxC0B,EAAOA,EAAKhK,OAAO,EAAGgK,EAAKpb,OAAS,IAEtCmb,EAAQvX,GAAKwX,CACf,CACF,CACuB,IAAnBD,EAAQnb,QACVmb,EAAQ7Z,KAAK4Z,GAEfxQ,KAAK6K,UAAUjU,MAAK,KAClB,MAAM+Z,EAAOzE,SAAS0E,cAAc,QAAQJ,OAC/B,OAATG,GACFA,EAAKE,iBACH,SACA,KACE,KAAcC,QAAQX,KAAiBM,EAAQ,IAEjD,EAEJ,GAEJ,CACF,CACA,aAAAzD,CAAcrX,GACZqK,KAAK6K,UAAU3W,SAAS6c,IACtBA,EAAIpb,EAAQ,GAEhB,CACA,YAAAqb,GACE,OAAOhR,KAAKuM,SACd,CACA,YAAA/K,CAAayP,GACXjR,KAAKuM,UAAY0E,CACnB,CAOA,YAAAxQ,CAAa2I,GACPpJ,KAAK2K,WAAW7W,IAAIsV,KAGxBpJ,KAAK2K,WAAWhT,IAAIyR,EAAI,CACtBA,KACAmB,QAAyB,IAAIjT,IAC7B4Z,SAAU,CAAC,EACXrD,MAAO7D,EAAwBZ,EAAK,IAAMpJ,KAAK4K,mBAEjD5K,KAAK4K,mBACP,CACA,YAAAuG,CAAapd,GACX,OAAOiM,KAAK2K,WAAW/S,IAAI7D,EAC7B,CACA,aAAAqd,GACE,OAAOpR,KAAK2K,UACd,CAQA,qBAAAnK,CAAsB4I,EAAIiI,GACxB,GAAKrR,KAAK2K,WAAW7W,IAAIsV,GAGzB,IAAK,MAAMrV,KAAQsd,EAAY,CAC7B,MAAM,UAAEjE,GAAcpN,KAAKiN,sBAAsBlZ,GACjDiM,KAAKuK,QAAQ3S,IAAIwV,GAAWkE,OAASlI,EACrCpJ,KAAK2K,WAAW/S,IAAIwR,GAAImB,QAAQ5S,IAAIyV,EAAWpN,KAAKuK,QAAQ3S,IAAIwV,GAClE,CACF,CACA,WAAA7K,CAAY6G,EAAIwE,GACd,MAAM2D,EAAYvR,KAAKuK,QAAQ3S,IAAIwR,GACnC,GAAKwE,GAAW2D,EAGhB,IAAK,MAAMtY,KAAK2U,EACV3U,EAAE+B,SAAS,KACbuW,EAAU3D,OAAOhX,QAAQqC,EAAEwN,MAAM,MAEjC8K,EAAU3D,OAAOhX,KAAKqC,EAG5B,CAOA,cAAAuY,CAAe/c,GACb,IAAIgd,EACJ,OAAQhd,GACN,KAAK,EACHgd,EAAS,cACT,MACF,KAAK,EACHA,EAAS,YACT,MACF,KAAK,EACHA,EAAS,cACT,MACF,KAAK,EACHA,EAAS,aACT,MACF,KAAK,EACHA,EAAS,WACT,MACF,QACEA,EAAS,OAEb,OAAOA,CACT,CACA,OAAAC,GACE,MAAMrc,EAAQ,GACRsc,EAAQ,GACR7B,GAAS,UACf,IAAK,MAAM8B,KAAgB5R,KAAK2K,WAAWkH,OAAQ,CACjD,MAAMlC,EAAY3P,KAAK2K,WAAW/S,IAAIga,GACtC,GAAIjC,EAAW,CACb,MAAMxb,EAAO,CACXiV,GAAIuG,EAAUvG,GACdkE,MAAOqC,EAAUvG,GACjB0I,SAAS,EACTC,QAASjC,EAAOjD,MAAMkF,SAAW,GAEjCxE,MAAO,OACPyE,UAAW,CAAC,aAAc,iBAC1BC,KAAMnC,EAAOmC,MAEf5c,EAAMuB,KAAKzC,EACb,CACF,CACA,IAAK,MAAM+d,KAAYlS,KAAKuK,QAAQsH,OAAQ,CAC1C,MAAMxC,EAAYrP,KAAKuK,QAAQ3S,IAAIsa,GACnC,GAAI7C,EAAW,CACb,MAAMlb,EAAOkb,EACblb,EAAKge,SAAW9C,EAAUiC,OAC1Bnd,EAAK8d,KAAOnC,EAAOmC,KACnB5c,EAAMuB,KAAKzC,EACb,CACF,CACA,IAAIie,EAAM,EACV,IAAK,MAAMjD,KAAQnP,KAAKyK,MAAO,CAC7B2H,IACA,MAAMC,EAAW,CACfjJ,GAAI+F,EAAK/F,GACTkE,MAAO6B,EAAK7J,KACZwM,SAAS,EACTvE,MAAO,OACPwE,QAASjC,EAAOjD,MAAMkF,SAAW,EACjCC,UAAW,CACT,mBACA,sBACA,SAASlC,EAAOwC,eAAeC,eAC/B,WAAWzC,EAAOwC,eAAeE,mBAEnCP,KAAMnC,EAAOmC,MAEf5c,EAAMuB,KAAKyb,GACX,MAAMI,EAAczS,KAAKuK,QAAQ3S,IAAIuX,EAAKtC,QAAQzD,IAAM,GACxD,GAAIqJ,EAAa,CACf,MAAMC,EAAO,CACXtJ,GAAI,WAAWgJ,IACfO,MAAOxD,EAAK/F,GACZwJ,IAAKH,EACLhe,KAAM,SACNoe,UAAW,SACXtI,QAAS,WACTuI,eAAgB,OAChBC,aAAc,OACdC,eAAgB,GAChBC,WAAY,CAAC,IACb9H,MAAO,CAAC,cACR+H,QAAS,SACTjB,KAAMnC,EAAOmC,MAEfN,EAAM/a,KAAK8b,EACb,CACF,CACA,IAAK,MAAMS,KAAcnT,KAAK0K,WAAY,CACxC,MAAM0I,EAAgB,CACpBhK,GAAI+J,EAAW/J,GACfkE,MAAO6F,EAAW7F,MAClBwE,SAAS,EACTvE,MAAO,OACPyE,UAAW,CAAC,eACZC,KAAMnC,EAAOmC,MAEf5c,EAAMuB,KAAKwc,EACb,CACAhB,EAAM,EACN,IAAK,MAAM9D,KAAiBtO,KAAKsK,UAAW,CAC1C8H,IACA,MAAMM,EAAO,CACXtJ,IAAI,QAAUkF,EAAclN,IAAKkN,EAAcjN,IAAK,CAClDgS,OAAQ,KACRC,QAASlB,IAEXO,MAAOrE,EAAclN,IACrBwR,IAAKtE,EAAcjN,IACnB5M,KAAM,SACN6Y,MAAOgB,EAAcnO,MACrBoT,SAAU,IACVV,UAAW,SACXtI,QAAS,WACTuI,eAAgB9S,KAAKwR,eAAelD,EAAcrN,SAASQ,OAC3DsR,aAAc/S,KAAKwR,eAAelD,EAAcrN,SAASS,OACzD8R,gBAAkD,SAAjClF,EAAcpN,eAA4B,GAAKoN,EAAcpN,eAC9EuS,aAA+C,SAAjCnF,EAAcnN,eAA4B,GAAKmN,EAAcnN,eAC3E6R,eAAgB,GAChBC,WAAY,CAAC,yBACb9H,MAAOmD,EAAcnD,OAAS,GAC9B+H,QAA4C,GAAnC5E,EAAcrN,SAASU,SAAgB,SAAW,QAC3DsQ,KAAMnC,EAAOmC,MAEfN,EAAM/a,KAAK8b,EACb,CACA,MAAO,CAAErd,QAAOsc,QAAO+B,MAAO,CAAC,EAAG5D,SAAQvD,UAAWvM,KAAKgR,eAC5D,GAmKE2C,GA/J4B,SAAQzY,GAAY,gCAC1CA,EAAQ0Y,YAAc1Y,EAAQ2Y,+CAEvB3Y,EAAQ4Y,2HAUd5Y,EAAQ2Y,oDAGT3Y,EAAQ6Y,uCAGR7Y,EAAQ2Y,+CAIF3Y,EAAQ6Y,wDAGR7Y,EAAQ6Y,wJAWZ7Y,EAAQ6Y,yBACN7Y,EAAQ0Y,uEAMV1Y,EAAQ0Y,8GASV1Y,EAAQ6Y,uBACN7Y,EAAQ0Y,oDAIR1Y,EAAQ0Y,0GAOV1Y,EAAQ6Y,iEAKR7Y,EAAQ0Y,gEAKN1Y,EAAQ8Y,4LAcV9Y,EAAQ8Y,oCACN9Y,EAAQ8Y,4FAKV9Y,EAAQ8Y,oCACN9Y,EAAQ8Y,4FAKV9Y,EAAQ8Y,oCACN9Y,EAAQ8Y,4FAKV9Y,EAAQ8Y,oCACN9Y,EAAQ8Y,6HAMR9Y,EAAQ8Y,2HAMR9Y,EAAQ8Y,iIAMR9Y,EAAQ8Y,+HAMR9Y,EAAQ8Y,wFAKV9Y,EAAQ6Y,kCACN7Y,EAAQ8Y,sFAKV9Y,EAAQ6Y,kCACN7Y,EAAQ8Y,8LAYV9Y,EAAQ+Y,mBAEf,aAICC,GAAyB,SAAO,CAACC,EAAYC,EAAa,QAC5D,IAAKD,EAAWE,IACd,OAAOD,EAET,IAAInD,EAAMmD,EACV,IAAK,MAAME,KAAiBH,EAAWE,IACV,QAAvBC,EAAcC,OAChBtD,EAAMqD,EAAc3hB,OAGxB,OAAOse,CAAG,GACT,UA0BCuD,EAAmC,CACrCrG,YA1B+B,SAAO,SAAS7I,EAAMmP,GACrD,OAAOA,EAAWC,GAAGvG,YACvB,GAAG,cAyBDwG,MAxByB,SAAOC,eAAetP,EAAM8D,EAAIyL,EAAUC,GACnE,KAAIC,KAAK,SACT,KAAIA,KAAK,6BAA8B3L,GACvC,MAAM,cAAE6G,EAAepL,MAAOmQ,EAAI,OAAEC,IAAW,UACzCC,EAAcJ,EAAKJ,GAAGhD,UACtByD,GAAM,OAAkB/L,EAAI6G,GAClCiF,EAAYzgB,KAAOqgB,EAAKrgB,KACxBygB,EAAYE,iBAAkB,QAA6BH,GAC3DC,EAAYG,YAAcL,GAAMK,aAAe,GAC/CH,EAAYI,YAAcN,GAAMM,aAAe,GAC/CJ,EAAYK,QAAU,CAAC,cAAe,YAAa,cAAe,aAAc,YAChFL,EAAYM,UAAYpM,QAClB,QAAO8L,EAAaC,GAE1B,KAAcM,YACZN,EACA,wBACAH,GAAMU,gBAAkB,GACxBZ,EAAKJ,GAAG/H,oBAEV,OAAoBwI,EAPJ,EAOkB,eAAgBH,GAAMW,cAAe,EACzE,GAAG,QAIDzB,S,wFCh4DF,MAbA,SAAoB0B,GAClB,OAAO,SAASC,EAAYC,EAAWC,GACrC,IAAIC,EAAWzc,OAAOsc,GACtB,KAAK,EAAAI,EAAA,GAAYJ,GAAa,CAC5B,IAAIK,GAAW,OAAaJ,EAAW,GACvCD,GAAa,EAAAhE,EAAA,GAAKgE,GAClBC,EAAY,SAASK,GAAO,OAAOD,EAASF,EAASG,GAAMA,EAAKH,EAAW,CAC7E,CACA,IAAI5gB,EAAQwgB,EAAcC,EAAYC,EAAWC,GACjD,OAAO3gB,GAAS,EAAI4gB,EAASE,EAAWL,EAAWzgB,GAASA,QAASG,CACvE,CACF,E,oBCjBI6gB,EAAY5gB,KAAKC,IAiDrB,ICbA,EAFW,GDGX,SAAmB4gB,EAAOP,EAAWC,GACnC,IAAIzgB,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACvC,IAAKA,EACH,OAAQ,EAEV,IAAIF,EAAqB,MAAb2gB,EAAoB,GAAI,EAAAO,EAAA,GAAUP,GAI9C,OAHI3gB,EAAQ,IACVA,EAAQghB,EAAU9gB,EAASF,EAAO,KAE7B,OAAcihB,GAAO,OAAaP,EAAW,GAAI1gB,EAC1D,G,gFEjDImhB,EAAY,EAwBhB,MALA,SAAkBlD,GAChB,IAAIjK,IAAOmN,EACX,OAAO,OAASlD,GAAUjK,CAC5B,E,8BCxBIoN,EAAahhB,KAAKihB,KAClBL,EAAY5gB,KAAKC,IAyBrB,MAZA,SAAmBkd,EAAOC,EAAK8D,EAAMC,GAKnC,IAJA,IAAIvhB,GAAS,EACTE,EAAS8gB,EAAUI,GAAY5D,EAAMD,IAAU+D,GAAQ,IAAK,GAC5DngB,EAASiO,MAAMlP,GAEZA,KACLiB,EAAOogB,EAAYrhB,IAAWF,GAASud,EACvCA,GAAS+D,EAEX,OAAOngB,CACT,E,oBCIA,ICgBA,EDlCA,SAAqBogB,GACnB,OAAO,SAAShE,EAAOC,EAAK8D,GAa1B,OAZIA,GAAuB,iBAARA,IAAoB,OAAe/D,EAAOC,EAAK8D,KAChE9D,EAAM8D,OAAOnhB,GAGfod,GAAQ,EAAAiE,EAAA,GAASjE,QACLpd,IAARqd,GACFA,EAAMD,EACNA,EAAQ,GAERC,GAAM,EAAAgE,EAAA,GAAShE,GAEjB8D,OAAgBnhB,IAATmhB,EAAsB/D,EAAQC,EAAM,GAAK,GAAK,EAAAgE,EAAA,GAASF,GACvD,EAAU/D,EAAOC,EAAK8D,EAAMC,EACrC,CACF,CCgBY,G,SCpCZ,MAAME,EACJ,WAAAjO,GACE,IAAIkO,EAAW,CAAC,EAChBA,EAASC,MAAQD,EAASE,MAAQF,EAClC9W,KAAKiX,UAAYH,CACnB,CACA,OAAAI,GACE,IAAIJ,EAAW9W,KAAKiX,UAChB5jB,EAAQyjB,EAASE,MACrB,GAAI3jB,IAAUyjB,EAEZ,OADAK,EAAO9jB,GACAA,CAEX,CACA,OAAA+jB,CAAQ/jB,GACN,IAAIyjB,EAAW9W,KAAKiX,UAChB5jB,EAAM2jB,OAAS3jB,EAAM0jB,OACvBI,EAAO9jB,GAETA,EAAM0jB,MAAQD,EAASC,MACvBD,EAASC,MAAMC,MAAQ3jB,EACvByjB,EAASC,MAAQ1jB,EACjBA,EAAM2jB,MAAQF,CAChB,CACA,QAAAO,GAIE,IAHA,IAAIC,EAAO,GACPR,EAAW9W,KAAKiX,UAChBM,EAAOT,EAASE,MACbO,IAAST,GACdQ,EAAK1gB,KAAK4X,KAAKC,UAAU8I,EAAMC,IAC/BD,EAAOA,EAAKP,MAEd,MAAO,IAAMM,EAAK5d,KAAK,MAAQ,GACjC,EAGF,SAASyd,EAAO9jB,GACdA,EAAM2jB,MAAMD,MAAQ1jB,EAAM0jB,MAC1B1jB,EAAM0jB,MAAMC,MAAQ3jB,EAAM2jB,aACnB3jB,EAAM0jB,aACN1jB,EAAM2jB,KACf,CAEA,SAASQ,EAAenc,EAAGC,GACzB,GAAU,UAAND,GAAuB,UAANA,EACnB,OAAOC,CAEX,CCzCA,IAAImc,EAAoB,IAAW,GAEnC,SAASC,EAAUC,EAAGC,GACpB,GAAID,EAAEE,aAAe,EACnB,MAAO,GAET,IAAIhT,EAkEN,SAAoB8S,EAAGC,GACrB,IAAIE,EAAW,IAAI,IACfC,EAAQ,EACRC,EAAS,EAEb,IAAUL,EAAEtiB,SAAS,SAAUiG,GAC7Bwc,EAASG,QAAQ3c,EAAG,CAAEA,EAAGA,EAAG4c,GAAI,EAAGC,IAAK,GAC1C,IAIA,IAAUR,EAAEhG,SAAS,SAAUve,GAC7B,IAAIglB,EAAaN,EAASpF,KAAKtf,EAAEkI,EAAGlI,EAAEilB,IAAM,EACxCC,EAASV,EAASxkB,GAClBmlB,EAAaH,EAAaE,EAC9BR,EAASU,QAAQplB,EAAEkI,EAAGlI,EAAEilB,EAAGE,GAC3BP,EAASxiB,KAAKC,IAAIuiB,EAASF,EAAS3jB,KAAKf,EAAEkI,GAAG6c,KAAOG,GACrDP,EAAQviB,KAAKC,IAAIsiB,EAAQD,EAAS3jB,KAAKf,EAAEilB,GAAO,IAAKC,EACvD,IAEA,IAAIG,EAAU,EAAQT,EAASD,EAAQ,GAAGte,KAAI,WAC5C,OAAO,IAAIod,CACb,IACI6B,EAAUX,EAAQ,EAMtB,OAJA,IAAUD,EAASziB,SAAS,SAAUiG,GACpCqd,EAAaF,EAASC,EAASZ,EAAS3jB,KAAKmH,GAC/C,IAEO,CAAEsd,MAAOd,EAAUW,QAASA,EAASC,QAASA,EACvD,CAhGcG,CAAWlB,EAAGC,GAAYH,GAClCqB,EAUN,SAAqBnB,EAAGc,EAASC,GAC/B,IAIIrlB,EAJAylB,EAAU,GACVC,EAAUN,EAAQA,EAAQnjB,OAAS,GACnC0jB,EAAQP,EAAQ,GAGpB,KAAOd,EAAEE,aAAa,CACpB,KAAQxkB,EAAQ2lB,EAAM9B,WACpB+B,EAAWtB,EAAGc,EAASC,EAASrlB,GAElC,KAAQA,EAAQ0lB,EAAQ7B,WACtB+B,EAAWtB,EAAGc,EAASC,EAASrlB,GAElC,GAAIskB,EAAEE,YACJ,IAAK,IAAI3e,EAAIuf,EAAQnjB,OAAS,EAAG4D,EAAI,IAAKA,EAExC,GADA7F,EAAQolB,EAAQvf,GAAGge,UACR,CACT4B,EAAUA,EAAQtlB,OAAOylB,EAAWtB,EAAGc,EAASC,EAASrlB,GAAO,IAChE,KACF,CAGN,CAEA,OAAOylB,CACT,CAnCgBI,CAAYrU,EAAM+T,MAAO/T,EAAM4T,QAAS5T,EAAM6T,SAG5D,OAAO,IACL,IAAMI,GAAS,SAAU1lB,GACvB,OAAOukB,EAAEwB,SAAS/lB,EAAEkI,EAAGlI,EAAEilB,EAC3B,IAEJ,CA6BA,SAASY,EAAWtB,EAAGc,EAASC,EAASrlB,EAAO+lB,GAC9C,IAAIN,EAAUM,EAAsB,QAAK7jB,EAwBzC,OAtBA,IAAUoiB,EAAE0B,QAAQhmB,EAAMiI,IAAI,SAAUoX,GACtC,IAAI4F,EAASX,EAAEjF,KAAKA,GAChB4G,EAAS3B,EAAExjB,KAAKue,EAAKpX,GAErB8d,GACFN,EAAQliB,KAAK,CAAE0E,EAAGoX,EAAKpX,EAAG+c,EAAG3F,EAAK2F,IAGpCiB,EAAOnB,KAAOG,EACdK,EAAaF,EAASC,EAASY,EACjC,IAEA,IAAU3B,EAAEwB,SAAS9lB,EAAMiI,IAAI,SAAUoX,GACvC,IAAI4F,EAASX,EAAEjF,KAAKA,GAChB2F,EAAI3F,EAAK2F,EACTkB,EAAS5B,EAAExjB,KAAKkkB,GACpBkB,EAAW,IAAKjB,EAChBK,EAAaF,EAASC,EAASa,EACjC,IAEA5B,EAAEsB,WAAW5lB,EAAMiI,GAEZwd,CACT,CAkCA,SAASH,EAAaF,EAASC,EAASrlB,GACjCA,EAAM8kB,IAEC9kB,EAAU,GAGpBolB,EAAQplB,EAAM8kB,IAAM9kB,EAAU,GAAIqlB,GAAStB,QAAQ/jB,GAFnDolB,EAAQA,EAAQnjB,OAAS,GAAG8hB,QAAQ/jB,GAFpColB,EAAQ,GAAGrB,QAAQ/jB,EAMvB,CCxHA,SAASmmB,EAAI7B,GACX,IAAI8B,EAA8B,WAAxB9B,EAAEiB,QAAQc,UAAyBhC,EAAUC,EASvD,SAAkBA,GAChB,OAAO,SAAUvkB,GACf,OAAOukB,EAAEjF,KAAKtf,GAAGklB,MACnB,CACF,CAb0DV,CAASD,IAgBrE,SAAgBA,GACd,IAAI8B,EAAM,GACNvW,EAAQ,CAAC,EACTjL,EAAU,CAAC,EAEf,SAAS0hB,EAAIre,GACP/B,OAAOwK,UAAUC,eAAeP,KAAKxL,EAASqD,KAGlDrD,EAAQqD,IAAK,EACb4H,EAAM5H,IAAK,EACX,IAAUqc,EAAEwB,SAAS7d,IAAI,SAAUlI,GAC7BmG,OAAOwK,UAAUC,eAAeP,KAAKP,EAAO9P,EAAEilB,GAChDoB,EAAI7iB,KAAKxD,GAETumB,EAAIvmB,EAAEilB,EAEV,WACOnV,EAAM5H,GACf,CAGA,OADA,IAAUqc,EAAEtiB,QAASskB,GACdF,CACT,CAvC2EG,CAAOjC,GAChF,IAAU8B,GAAK,SAAUrmB,GACvB,IAAIka,EAAQqK,EAAEjF,KAAKtf,GACnBukB,EAAEkC,WAAWzmB,GACbka,EAAMwM,YAAc1mB,EAAEW,KACtBuZ,EAAMyM,UAAW,EACjBpC,EAAEa,QAAQplB,EAAEilB,EAAGjlB,EAAEkI,EAAGgS,EAAO,EAAW,OACxC,GAOF,C,kCCFA,MANA,SAAkB0M,EAAQC,GACxB,OAAO,OAAWD,EAAQC,GAAO,SAAStnB,EAAOunB,GAC/C,OAAO,EAAAC,EAAA,GAAMH,EAAQE,EACvB,GACF,E,oBCDA,ICSA,EDbA,SAAkBE,GAChB,OAAO,QAAY,OAASA,OAAM7kB,EAAW8kB,EAAA,GAAUD,EAAO,GAChE,CCOW,EAAS,SAASJ,EAAQC,GACnC,OAAiB,MAAVD,EAAiB,CAAC,EAAI,EAASA,EAAQC,EAChD,I,oBCTA,MAJA,SAAgBtnB,EAAO+gB,GACrB,OAAO/gB,EAAQ+gB,CACjB,E,UCiBA,MANA,SAAa2C,GACX,OAAQA,GAASA,EAAM/gB,QACnB,OAAa+gB,EAAOiE,EAAA,EAAU,QAC9B/kB,CACN,E,wCCgBA,MAVA,SAAmBykB,EAAQ9D,GACzB,IAAI3f,EAAS,CAAC,EAMd,OALA2f,GAAW,OAAaA,EAAU,IAElC,OAAW8D,GAAQ,SAASrnB,EAAOwjB,EAAK6D,IACtC,OAAgBzjB,EAAQ4f,EAAKD,EAASvjB,EAAOwjB,EAAK6D,GACpD,IACOzjB,CACT,E,wCClBA,EAJU,WACR,OAAO,IAAKgkB,KAAKC,KACnB,ECGA,SAASC,EAAa9C,EAAGljB,EAAMimB,EAAO3mB,GACpC,IAAIuH,EACJ,GACEA,EAAI,EAAWvH,SACR4jB,EAAEgD,QAAQrf,IAInB,OAFAof,EAAME,MAAQnmB,EACdkjB,EAAEM,QAAQ3c,EAAGof,GACNpf,CACT,CAsBA,SAASuf,EAAmBlD,GAC1B,IAAImD,EAAa,IAAI,IAAM,CAAEC,WAAYpD,EAAEqD,iBAAkBC,SAAStD,EAAEiB,SASxE,OARA,IAAUjB,EAAEtiB,SAAS,SAAUiG,GACxBqc,EAAEzG,SAAS5V,GAAGhG,QACjBwlB,EAAW7C,QAAQ3c,EAAGqc,EAAExjB,KAAKmH,GAEjC,IACA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7B0nB,EAAWtC,QAAQplB,EAAGukB,EAAEjF,KAAKtf,GAC/B,IACO0nB,CACT,CA4BA,SAASI,EAAcxP,EAAMyP,GAC3B,IAcIC,EAAIC,EAdJC,EAAI5P,EAAK4P,EACTC,EAAI7P,EAAK6P,EAITC,EAAKL,EAAMG,EAAIA,EACfG,EAAKN,EAAMI,EAAIA,EACflD,EAAI3M,EAAKgQ,MAAQ,EACjBC,EAAIjQ,EAAKkQ,OAAS,EAEtB,IAAKJ,IAAOC,EACV,MAAM,IAAI7iB,MAAM,6DAoBlB,OAhBIpD,KAAK0S,IAAIuT,GAAMpD,EAAI7iB,KAAK0S,IAAIsT,GAAMG,GAEhCF,EAAK,IACPE,GAAKA,GAEPP,EAAMO,EAAIH,EAAMC,EAChBJ,EAAKM,IAGDH,EAAK,IACPnD,GAAKA,GAEP+C,EAAK/C,EACLgD,EAAMhD,EAAIoD,EAAMD,GAGX,CAAEF,EAAGA,EAAIF,EAAIG,EAAGA,EAAIF,EAC7B,CAMA,SAASQ,EAAiBlE,GACxB,IAAImE,EAAW,IAAM,EAAQ,EAAQnE,GAAK,IAAI,WAC5C,MAAO,EACT,IAQA,OAPA,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GACdygB,EAAO5nB,EAAK4nB,KACX,IAAcA,KACjBD,EAASC,GAAM5nB,EAAK6nB,OAAS1gB,EAEjC,IACOwgB,CACT,CAkDA,SAASG,EAActE,EAAGtE,EAAQ0I,EAAMC,GACtC,IAAI7nB,EAAO,CACTunB,MAAO,EACPE,OAAQ,GAMV,OAJIlY,UAAUpO,QAAU,IACtBnB,EAAK4nB,KAAOA,EACZ5nB,EAAK6nB,MAAQA,GAERvB,EAAa9C,EAAG,SAAUxjB,EAAMkf,EACzC,CAEA,SAAS,EAAQsE,GACf,OAAO,EACL,IAAMA,EAAEtiB,SAAS,SAAUiG,GACzB,IAAIygB,EAAOpE,EAAExjB,KAAKmH,GAAGygB,KACrB,IAAK,IAAcA,GACjB,OAAOA,CAEX,IAEJ,CAuBA,SAAS,EAAKhoB,EAAMmoB,GAClB,IAAIvJ,EAAQ,IACZ,IACE,OAAOuJ,GACT,CAAE,QACAC,QAAQC,IAAIroB,EAAO,WAAa,IAAU4e,GAAS,KACrD,CACF,CAEA,SAAS0J,GAAOtoB,EAAMmoB,GACpB,OAAOA,GACT,CC/NA,SAAS,GAAcvE,EAAG2E,EAAMjJ,EAAQkJ,EAAIC,EAAQT,GAClD,IAAIzO,EAAQ,CAAEoO,MAAO,EAAGE,OAAQ,EAAGG,KAAMA,EAAMU,WAAYH,GACvDI,EAAOF,EAAOF,GAAMP,EAAO,GAC3BxE,EAAO,EAAkBI,EAAG,SAAUrK,EAAO+F,GACjDmJ,EAAOF,GAAMP,GAAQxE,EACrBI,EAAEgF,UAAUpF,EAAMgF,GACdG,GACF/E,EAAEa,QAAQkE,EAAMnF,EAAM,CAAEe,OAAQ,GAEpC,CCxBA,SAAS,GAAKX,GACZ,IAAIiF,EAAUjF,EAAEiB,QAAQiE,QAAQhlB,cAChB,OAAZ+kB,GAAgC,OAAZA,GAyB1B,SAAkBjF,GAChB,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7BwhB,GAAYnF,EAAExjB,KAAKmH,GACrB,IAEA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClB,IAAUsf,EAAKqK,OAAQD,IACnBvjB,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,MAC7CoK,GAAYpK,EAEhB,GACF,CApCIsK,CAASrF,GAGK,OAAZiF,GAAgC,OAAZA,KAuC1B,SAAgBjF,GACd,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B2hB,GAAUtF,EAAExjB,KAAKmH,GACnB,IAEA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClB,IAAUsf,EAAKqK,OAAQE,IACnB1jB,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,MAC7CuK,GAAUvK,EAEd,GACF,CAlDIwK,CAAOvF,GACPwF,GAAgBxF,GAEpB,CAEA,SAASwF,GAAgBxF,GACvB,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B8hB,GAAmBzF,EAAExjB,KAAKmH,GAC5B,IACA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7BgqB,GAAmBzF,EAAEjF,KAAKtf,GAC5B,GACF,CAEA,SAASgqB,GAAmB1C,GAC1B,IAAIrC,EAAIqC,EAAMgB,MACdhB,EAAMgB,MAAQhB,EAAMkB,OACpBlB,EAAMkB,OAASvD,CACjB,CAgBA,SAASyE,GAAYpC,GACnBA,EAAMa,GAAKb,EAAMa,CACnB,CAgBA,SAAS0B,GAAUvC,GACjB,IAAIY,EAAIZ,EAAMY,EACdZ,EAAMY,EAAIZ,EAAMa,EAChBb,EAAMa,EAAID,CACZ,CChDA,SAAS,GAAI3D,GACXA,EAAEiB,QAAQyE,YAAc,GACxB,IAAU1F,EAAEhG,SAAS,SAAUe,IAQjC,SAAuBiF,EAAGvkB,GACxB,IAAIkI,EAAIlI,EAAEkI,EACNgiB,EAAQ3F,EAAExjB,KAAKmH,GAAGygB,KAClB1D,EAAIjlB,EAAEilB,EACNkF,EAAQ5F,EAAExjB,KAAKkkB,GAAG0D,KAClBhoB,EAAOX,EAAEW,KACTypB,EAAY7F,EAAEjF,KAAKtf,GACnBqqB,EAAYD,EAAUC,UAE1B,GAAIF,IAAUD,EAAQ,EAAG,OAEzB3F,EAAEkC,WAAWzmB,GAcb,IACIwnB,EAAO1hB,EADPwhB,OAAQnlB,EAEZ,IAAK2D,EAAI,IAAKokB,EAAOA,EAAQC,IAASrkB,IAAKokB,EACzCE,EAAUT,OAAS,GAQnBnC,EAAQ,EAAkBjD,EAAG,OAP7B+C,EAAQ,CACNgB,MAAO,EACPE,OAAQ,EACR4B,UAAWA,EACXE,QAAStqB,EACT2oB,KAAMuB,GAEoC,MACxCA,IAAUG,IACZ/C,EAAMgB,MAAQ8B,EAAU9B,MACxBhB,EAAMkB,OAAS4B,EAAU5B,OACzBlB,EAAME,MAAQ,aACdF,EAAMnH,SAAWiK,EAAUjK,UAE7BoE,EAAEa,QAAQld,EAAGsf,EAAO,CAAEtC,OAAQkF,EAAUlF,QAAUvkB,GACxC,IAANmF,GACFye,EAAEiB,QAAQyE,YAAYzmB,KAAKgkB,GAE7Btf,EAAIsf,EAGNjD,EAAEa,QAAQld,EAAG+c,EAAG,CAAEC,OAAQkF,EAAUlF,QAAUvkB,EAChD,CA1DI4pB,CAAchG,EAAGjF,EACnB,GACF,C,eCEA,OANA,SAAe2D,EAAOH,GACpB,OAAQG,GAASA,EAAM/gB,QACnB,OAAa+gB,GAAO,OAAaH,EAAU,GAAI,WAC/C3gB,CACN,ECNA,SAASqoB,GAAYjG,GACnB,IAAI1f,EAAU,CAAC,EA2Bf,IAAU0f,EAAEoB,WAzBZ,SAASY,EAAIre,GACX,IAAIgS,EAAQqK,EAAExjB,KAAKmH,GACnB,GAAI/B,OAAOwK,UAAUC,eAAeP,KAAKxL,EAASqD,GAChD,OAAOgS,EAAMyO,KAEf9jB,EAAQqD,IAAK,EAEb,IAAIygB,EAAO,IACT,IAAMpE,EAAEwB,SAAS7d,IAAI,SAAUlI,GAC7B,OAAOumB,EAAIvmB,EAAEilB,GAAKV,EAAEjF,KAAKtf,GAAGyqB,MAC9B,KAYF,OARE9B,IAAS+B,OAAOC,mBAAhBhC,MACAA,IAIAA,EAAO,GAGDzO,EAAMyO,KAAOA,CACvB,GAGF,CAMA,SAASiC,GAAMrG,EAAGvkB,GAChB,OAAOukB,EAAExjB,KAAKf,EAAEilB,GAAG0D,KAAOpE,EAAExjB,KAAKf,EAAEkI,GAAGygB,KAAOpE,EAAEjF,KAAKtf,GAAGyqB,MACzD,CC/BA,SAASI,GAAatG,GACpB,IAOIjF,EAAMwL,EAPNC,EAAI,IAAI,IAAM,CAAEC,UAAU,IAG1BzL,EAAQgF,EAAEtiB,QAAQ,GAClBgpB,EAAO1G,EAAEE,YAIb,IAHAsG,EAAElG,QAAQtF,EAAO,CAAC,GAGX2L,GAAUH,EAAGxG,GAAK0G,GACvB3L,EAAO6L,GAAiBJ,EAAGxG,GAC3BuG,EAAQC,EAAExD,QAAQjI,EAAKpX,GAAK0iB,GAAMrG,EAAGjF,IAASsL,GAAMrG,EAAGjF,GACvD8L,GAAWL,EAAGxG,EAAGuG,GAGnB,OAAOC,CACT,CAMA,SAASG,GAAUH,EAAGxG,GAcpB,OADA,IAAUwG,EAAE9oB,SAZZ,SAASskB,EAAIre,GACX,IAAUqc,EAAE8G,UAAUnjB,IAAI,SAAUlI,GAClC,IAAIsrB,EAAQtrB,EAAEkI,EACZ+c,EAAI/c,IAAMojB,EAAQtrB,EAAEilB,EAAIqG,EACrBP,EAAExD,QAAQtC,IAAO2F,GAAMrG,EAAGvkB,KAC7B+qB,EAAElG,QAAQI,EAAG,CAAC,GACd8F,EAAE3F,QAAQld,EAAG+c,EAAG,CAAC,GACjBsB,EAAItB,GAER,GACF,IAGO8F,EAAEtG,WACX,CAMA,SAAS0G,GAAiBJ,EAAGxG,GAC3B,OAAO,GAAQA,EAAEhG,SAAS,SAAUve,GAClC,GAAI+qB,EAAExD,QAAQvnB,EAAEkI,KAAO6iB,EAAExD,QAAQvnB,EAAEilB,GACjC,OAAO2F,GAAMrG,EAAGvkB,EAEpB,GACF,CAEA,SAASorB,GAAWL,EAAGxG,EAAGuG,GACxB,IAAUC,EAAE9oB,SAAS,SAAUiG,GAC7Bqc,EAAExjB,KAAKmH,GAAGygB,MAAQmC,CACpB,GACF,C,yBCjF0B,IAAW,GCDX,IAAW,G,iCCKrB,E,OAAA,GAAa,UCGVvkB,OAAO,uFAa1B,ICxBI,GAAgB,kBAQhBglB,GAAW,IAAM,GAAgB,IACjCC,GAAU,kDACVC,GAAS,2BAETC,GAAc,KAAO,GAAgB,IACrCC,GAAa,kCACbC,GAAa,qCAIbC,GAPa,MAAQL,GAAU,IAAMC,GAAS,IAOtB,IACxBK,GAAW,oBAEXC,GAAQD,GAAWD,IADP,gBAAwB,CAACH,GAAaC,GAAYC,IAAYtlB,KAAK,KAAO,IAAMwlB,GAAWD,GAAW,MAElHG,GAAW,MAAQ,CAACN,GAAcF,GAAU,IAAKA,GAASG,GAAYC,GAAYL,IAAUjlB,KAAK,KAAO,IAG5FC,OAAOklB,GAAS,MAAQA,GAAS,KAAOO,GAAWD,GAAO,KCQ1E,SAAS,KAAkB,CAC3B,GAAepb,UAAY,IAAInL,M,eCvB/B,SAAS+gB,GAAIhC,EAAG0H,EAAIrD,GACb,KAAUqD,KACbA,EAAK,CAACA,IAGR,IAAIC,GAAc3H,EAAE4H,aAAe5H,EAAE6H,WAAa7H,EAAE8H,WAAW3S,KAAK6K,GAEhE+H,EAAM,GACNznB,EAAU,CAAC,EAQf,OAPA,IAAOonB,GAAI,SAAU/jB,GACnB,IAAKqc,EAAEgD,QAAQrf,GACb,MAAM,IAAI1C,MAAM,6BAA+B0C,GAGjDqkB,GAAMhI,EAAGrc,EAAa,SAAV0gB,EAAkB/jB,EAASqnB,EAAYI,EACrD,IACOA,CACT,CAEA,SAASC,GAAMhI,EAAGrc,EAAGskB,EAAW3nB,EAASqnB,EAAYI,GAC9CnmB,OAAOwK,UAAUC,eAAeP,KAAKxL,EAASqD,KACjDrD,EAAQqD,IAAK,EAERskB,GACHF,EAAI9oB,KAAK0E,GAEX,IAAOgkB,EAAWhkB,IAAI,SAAU+c,GAC9BsH,GAAMhI,EAAGU,EAAGuH,EAAW3nB,EAASqnB,EAAYI,EAC9C,IACIE,GACFF,EAAI9oB,KAAK0E,GAGf,C,QCIA,SAASukB,GAAelI,GACtBA,EdZF,SAAkBA,GAChB,IAAImD,GAAa,IAAI,KAAQG,SAAStD,EAAEiB,SAYxC,OAXA,IAAUjB,EAAEtiB,SAAS,SAAUiG,GAC7Bwf,EAAW7C,QAAQ3c,EAAGqc,EAAExjB,KAAKmH,GAC/B,IACA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7B,IAAI0sB,EAAchF,EAAWpI,KAAKtf,EAAEkI,EAAGlI,EAAEilB,IAAM,CAAEC,OAAQ,EAAGuF,OAAQ,GAChEvQ,EAAQqK,EAAEjF,KAAKtf,GACnB0nB,EAAWtC,QAAQplB,EAAEkI,EAAGlI,EAAEilB,EAAG,CAC3BC,OAAQwH,EAAYxH,OAAShL,EAAMgL,OACnCuF,OAAQroB,KAAKC,IAAIqqB,EAAYjC,OAAQvQ,EAAMuQ,SAE/C,IACO/C,CACT,CcFMiF,CAASpI,GACbiG,GAAYjG,GACZ,IAIIvkB,EAJA+qB,EAAIF,GAAatG,GAKrB,IAJAqI,GAAiB7B,GACjB8B,GAAc9B,EAAGxG,GAGTvkB,EAAI8sB,GAAU/B,IAEpBgC,GAAchC,EAAGxG,EAAGvkB,EADhBgtB,GAAUjC,EAAGxG,EAAGvkB,GAGxB,CAKA,SAAS6sB,GAAc9B,EAAGxG,GACxB,IAAI0H,EC/DN,SAAmB1H,EAAG0H,GACpB,OAAO1F,GAAIhC,EAAG0H,EAAI,OACpB,CD6DW,CAAclB,EAAGA,EAAE9oB,SAC5BgqB,EAAKA,EAAG7b,MAAM,EAAG6b,EAAG/pB,OAAS,GAC7B,IAAU+pB,GAAI,SAAU/jB,IAK1B,SAAwB6iB,EAAGxG,EAAG0I,GAC5B,IAAIC,EAAWnC,EAAEhqB,KAAKksB,GAClB/O,EAASgP,EAAShP,OACtB6M,EAAEzL,KAAK2N,EAAO/O,GAAQiP,SAAWC,GAAarC,EAAGxG,EAAG0I,EACtD,CARII,CAAetC,EAAGxG,EAAGrc,EACvB,GACF,CAYA,SAASklB,GAAarC,EAAGxG,EAAG0I,GAC1B,IACI/O,EADW6M,EAAEhqB,KAAKksB,GACA/O,OAElBoP,GAAc,EAEdC,EAAYhJ,EAAEjF,KAAK2N,EAAO/O,GAE1BsP,EAAW,EAyBf,OAvBKD,IACHD,GAAc,EACdC,EAAYhJ,EAAEjF,KAAKpB,EAAQ+O,IAG7BO,EAAWD,EAAUrI,OAErB,IAAUX,EAAE8G,UAAU4B,IAAQ,SAAUjtB,GACtC,IA2HsB+F,EAAGmC,EA3HrBulB,EAAYztB,EAAEkI,IAAM+kB,EACtB3M,EAAQmN,EAAYztB,EAAEilB,EAAIjlB,EAAEkI,EAE9B,GAAIoY,IAAUpC,EAAQ,CACpB,IAAIwP,EAAeD,IAAcH,EAC/BK,EAAcpJ,EAAEjF,KAAKtf,GAAGklB,OAG1B,GADAsI,GAAYE,EAAeC,GAAeA,EAoHtB5nB,EAnHFknB,EAmHK/kB,EAnHEoY,EAAVyK,EAoHP6C,QAAQ7nB,EAAGmC,GApHc,CAC/B,IAAI2lB,EAAgB9C,EAAEzL,KAAK2N,EAAO3M,GAAO6M,SACzCK,GAAYE,GAAgBG,EAAgBA,CAC9C,CACF,CACF,IAEOL,CACT,CAEA,SAASZ,GAAiBkB,EAAMC,GAC1Bzd,UAAUpO,OAAS,IACrB6rB,EAAOD,EAAK7rB,QAAQ,IAEtB+rB,GAAgBF,EAAM,CAAC,EAAG,EAAGC,EAC/B,CAEA,SAASC,GAAgBF,EAAMjpB,EAASopB,EAAS/lB,EAAGgW,GAClD,IAAIgQ,EAAMD,EACN/T,EAAQ4T,EAAK/sB,KAAKmH,GAkBtB,OAhBArD,EAAQqD,IAAK,EACb,IAAU4lB,EAAKzB,UAAUnkB,IAAI,SAAU+c,GAChC9e,OAAOwK,UAAUC,eAAeP,KAAKxL,EAASogB,KACjDgJ,EAAUD,GAAgBF,EAAMjpB,EAASopB,EAAShJ,EAAG/c,GAEzD,IAEAgS,EAAMgU,IAAMA,EACZhU,EAAMiU,IAAMF,IACR/P,EACFhE,EAAMgE,OAASA,SAGRhE,EAAMgE,OAGR+P,CACT,CAEA,SAASnB,GAAUgB,GACjB,OAAO,KAAOA,EAAKvP,SAAS,SAAUve,GACpC,OAAO8tB,EAAKxO,KAAKtf,GAAGmtB,SAAW,CACjC,GACF,CAEA,SAASH,GAAUjC,EAAGxG,EAAGjF,GACvB,IAAIpX,EAAIoX,EAAKpX,EACT+c,EAAI3F,EAAK2F,EAKRV,EAAEqJ,QAAQ1lB,EAAG+c,KAChB/c,EAAIoX,EAAK2F,EACTA,EAAI3F,EAAKpX,GAGX,IAAIkmB,EAASrD,EAAEhqB,KAAKmH,GAChBmmB,EAAStD,EAAEhqB,KAAKkkB,GAChBqJ,EAAYF,EACZG,GAAO,EAIPH,EAAOD,IAAME,EAAOF,MACtBG,EAAYD,EACZE,GAAO,GAGT,IAAIC,EAAa,KAASjK,EAAEhG,SAAS,SAAUe,GAC7C,OACEiP,IAASE,GAAa1D,EAAGA,EAAEhqB,KAAKue,EAAKpX,GAAIomB,IACzCC,IAASE,GAAa1D,EAAGA,EAAEhqB,KAAKue,EAAK2F,GAAIqJ,EAE7C,IAEA,OAAO,GAAQE,GAAY,SAAUlP,GACnC,OAAOsL,GAAMrG,EAAGjF,EAClB,GACF,CAEA,SAASyN,GAAchC,EAAGxG,EAAGvkB,EAAG0uB,GAC9B,IAAIxmB,EAAIlI,EAAEkI,EACN+c,EAAIjlB,EAAEilB,EACV8F,EAAEtE,WAAWve,EAAG+c,GAChB8F,EAAE3F,QAAQsJ,EAAExmB,EAAGwmB,EAAEzJ,EAAG,CAAC,GACrB2H,GAAiB7B,GACjB8B,GAAc9B,EAAGxG,GAInB,SAAqBwG,EAAGxG,GACtB,IAAIwJ,EAAO,KAAOhD,EAAE9oB,SAAS,SAAUiG,GACrC,OAAQqc,EAAExjB,KAAKmH,GAAGgW,MACpB,IACI+N,EE1MN,SAAkB1H,EAAG0H,GACnB,OAAO1F,GAAIhC,EAAG0H,EAAI,MACpB,CFwMW,CAAalB,EAAGgD,GACzB9B,EAAKA,EAAG7b,MAAM,GACd,IAAU6b,GAAI,SAAU/jB,GACtB,IAAIgW,EAAS6M,EAAEhqB,KAAKmH,GAAGgW,OACrBoB,EAAOiF,EAAEjF,KAAKpX,EAAGgW,GACjByQ,GAAU,EAEPrP,IACHA,EAAOiF,EAAEjF,KAAKpB,EAAQhW,GACtBymB,GAAU,GAGZpK,EAAExjB,KAAKmH,GAAGygB,KAAOpE,EAAExjB,KAAKmd,GAAQyK,MAAQgG,EAAUrP,EAAKmL,QAAUnL,EAAKmL,OACxE,GACF,CArBEmE,CAAY7D,EAAGxG,EACjB,CAiCA,SAASkK,GAAaX,EAAMM,EAAQS,GAClC,OAAOA,EAAUX,KAAOE,EAAOD,KAAOC,EAAOD,KAAOU,EAAUV,GAChE,CGlNA,SAASxF,GAAKpE,GACZ,OAAQA,EAAEiB,QAAQsJ,QAChB,IAAK,kBASL,QACEC,GAAqBxK,SAPvB,IAAK,cAcT,SAAyBA,GACvBiG,GAAYjG,GACZsG,GAAatG,EACf,CAhBMyK,CAAgBzK,GAChB,MACF,IAAK,eACH0K,GAAkB1K,GAKxB,CH9BAkI,GAAeG,iBAAmBA,GAClCH,GAAeI,cAAgBA,GAC/BJ,GAAeW,aAAeA,GAC9BX,GAAeK,UAAYA,GAC3BL,GAAeO,UAAYA,GAC3BP,GAAeM,cAAgBA,GG4B/B,IAAIkC,GAAoBzE,GAOxB,SAASuE,GAAqBxK,GAC5BkI,GAAelI,EACjB,C,0BCvBA,SAAS,GAAIA,GACX,IAAIwJ,EAAO,EAAkBxJ,EAAG,OAAQ,CAAC,EAAG,SACxC2K,EAqEN,SAAoB3K,GAClB,IAAI2K,EAAS,CAAC,EACd,SAAS3I,EAAIre,EAAGinB,GACd,IAAIrR,EAAWyG,EAAEzG,SAAS5V,GACtB4V,GAAYA,EAAS5b,QACvB,IAAU4b,GAAU,SAAUmP,GAC5B1G,EAAI0G,EAAOkC,EAAQ,EACrB,IAEFD,EAAOhnB,GAAKinB,CACd,CAIA,OAHA,IAAU5K,EAAEzG,YAAY,SAAU5V,GAChCqe,EAAIre,EAAG,EACT,IACOgnB,CACT,CApFeE,CAAW7K,GACpBiE,EAAS,EAAM,KAAS0G,IAAW,EACnCG,EAAU,EAAI7G,EAAS,EAE3BjE,EAAEiB,QAAQ8J,YAAcvB,EAGxB,IAAUxJ,EAAEhG,SAAS,SAAUve,GAC7BukB,EAAEjF,KAAKtf,GAAGyqB,QAAU4E,CACtB,IAGA,IAAInK,EA0EN,SAAoBX,GAClB,OAAO,KACLA,EAAEhG,SACF,SAAU+N,EAAKtsB,GACb,OAAOssB,EAAM/H,EAAEjF,KAAKtf,GAAGklB,MACzB,GACA,EAEJ,CAlFeqK,CAAWhL,GAAK,EAG7B,IAAUA,EAAEzG,YAAY,SAAUmP,GAChC,GAAI1I,EAAGwJ,EAAMsB,EAASnK,EAAQsD,EAAQ0G,EAAQjC,EAChD,IAIA1I,EAAEiB,QAAQgK,eAAiBH,CAC7B,CAEA,SAAS,GAAI9K,EAAGwJ,EAAMsB,EAASnK,EAAQsD,EAAQ0G,EAAQhnB,GACrD,IAAI4V,EAAWyG,EAAEzG,SAAS5V,GAC1B,GAAK4V,EAAS5b,OAAd,CAOA,IAAI2W,EAAM,EAAmB0L,EAAG,OAC5BkL,EAAS,EAAmBlL,EAAG,OAC/BrK,EAAQqK,EAAExjB,KAAKmH,GAEnBqc,EAAEgF,UAAU1Q,EAAK3Q,GACjBgS,EAAMwV,UAAY7W,EAClB0L,EAAEgF,UAAUkG,EAAQvnB,GACpBgS,EAAMyV,aAAeF,EAErB,IAAU3R,GAAU,SAAUmP,GAC5B,GAAI1I,EAAGwJ,EAAMsB,EAASnK,EAAQsD,EAAQ0G,EAAQjC,GAE9C,IAAI1pB,EAAYghB,EAAExjB,KAAKksB,GACnB2C,EAAWrsB,EAAUmsB,UAAYnsB,EAAUmsB,UAAYzC,EACvD4C,EAActsB,EAAUosB,aAAepsB,EAAUosB,aAAe1C,EAChE6C,EAAavsB,EAAUmsB,UAAYxK,EAAS,EAAIA,EAChDuF,EAASmF,IAAaC,EAAc,EAAIrH,EAAS0G,EAAOhnB,GAAK,EAEjEqc,EAAEa,QAAQvM,EAAK+W,EAAU,CACvB1K,OAAQ4K,EACRrF,OAAQA,EACRsF,aAAa,IAGfxL,EAAEa,QAAQyK,EAAaJ,EAAQ,CAC7BvK,OAAQ4K,EACRrF,OAAQA,EACRsF,aAAa,GAEjB,IAEKxL,EAAErG,OAAOhW,IACZqc,EAAEa,QAAQ2I,EAAMlV,EAAK,CAAEqM,OAAQ,EAAGuF,OAAQjC,EAAS0G,EAAOhnB,IAlC5D,MAJMA,IAAM6lB,GACRxJ,EAAEa,QAAQ2I,EAAM7lB,EAAG,CAAEgd,OAAQ,EAAGuF,OAAQ4E,GAuC9C,C,eCrEA,OAJA,SAAmB9vB,GACjB,OAAO,QAAUA,EAAOywB,EAC1B,ECSA,SAASC,GAAgB1L,EAAGoE,EAAMuH,GAChC,IAAInC,EAmCN,SAAwBxJ,GACtB,IAAIrc,EACJ,KAAOqc,EAAEgD,QAASrf,EAAI,EAAW,YACjC,OAAOA,CACT,CAvCaioB,CAAe5L,GACxBphB,EAAS,IAAI,IAAM,CAAEitB,UAAU,IAC5BvI,SAAS,CAAEkG,KAAMA,IACjBsC,qBAAoB,SAAUnoB,GAC7B,OAAOqc,EAAExjB,KAAKmH,EAChB,IA2BJ,OAzBA,IAAUqc,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GAChBgW,EAASqG,EAAErG,OAAOhW,IAEhBnH,EAAK4nB,OAASA,GAAS5nB,EAAKuvB,SAAW3H,GAAQA,GAAQ5nB,EAAKwvB,WAC9DptB,EAAO0hB,QAAQ3c,GACf/E,EAAOomB,UAAUrhB,EAAGgW,GAAU6P,GAG9B,IAAUxJ,EAAE2L,GAAchoB,IAAI,SAAUlI,GACtC,IAAI+F,EAAI/F,EAAEkI,IAAMA,EAAIlI,EAAEilB,EAAIjlB,EAAEkI,EAC1BoX,EAAOnc,EAAOmc,KAAKvZ,EAAGmC,GACtBgd,EAAU,IAAc5F,GAAsB,EAAdA,EAAK4F,OACvC/hB,EAAOiiB,QAAQrf,EAAGmC,EAAG,CAAEgd,OAAQX,EAAEjF,KAAKtf,GAAGklB,OAASA,GACpD,IAEI/e,OAAOwK,UAAUC,eAAeP,KAAKtP,EAAM,YAC7CoC,EAAO0hB,QAAQ3c,EAAG,CAChBsoB,WAAYzvB,EAAKyvB,WAAW7H,GAC5B8H,YAAa1vB,EAAK0vB,YAAY9H,KAItC,IAEOxlB,CACT,C,eC/CA,OAbA,SAAuButB,EAAOC,EAAQC,GAMpC,IALA,IAAI5uB,GAAS,EACTE,EAASwuB,EAAMxuB,OACf2uB,EAAaF,EAAOzuB,OACpBiB,EAAS,CAAC,IAELnB,EAAQE,GAAQ,CACvB,IAAI3C,EAAQyC,EAAQ6uB,EAAaF,EAAO3uB,QAASG,EACjDyuB,EAAWztB,EAAQutB,EAAM1uB,GAAQzC,EACnC,CACA,OAAO4D,CACT,ECGA,OAJA,SAAmButB,EAAOC,GACxB,OAAO,GAAcD,GAAS,GAAIC,GAAU,GAAI,KAClD,E,4CCDA,OAVA,SAAoB1N,EAAO6N,GACzB,IAAI5uB,EAAS+gB,EAAM/gB,OAGnB,IADA+gB,EAAM8N,KAAKD,GACJ5uB,KACL+gB,EAAM/gB,GAAU+gB,EAAM/gB,GAAQ3C,MAEhC,OAAO0jB,CACT,E,sBCsBA,OA9BA,SAA0B1jB,EAAO+gB,GAC/B,GAAI/gB,IAAU+gB,EAAO,CACnB,IAAI0Q,OAAyB7uB,IAAV5C,EACf0xB,EAAsB,OAAV1xB,EACZ2xB,EAAiB3xB,GAAUA,EAC3B4xB,GAAc,EAAAC,GAAA,GAAS7xB,GAEvB8xB,OAAyBlvB,IAAVme,EACfgR,EAAsB,OAAVhR,EACZiR,EAAiBjR,GAAUA,EAC3BkR,GAAc,EAAAJ,GAAA,GAAS9Q,GAE3B,IAAMgR,IAAcE,IAAgBL,GAAe5xB,EAAQ+gB,GACtD6Q,GAAeE,GAAgBE,IAAmBD,IAAcE,GAChEP,GAAaI,GAAgBE,IAC5BP,GAAgBO,IACjBL,EACH,OAAO,EAET,IAAMD,IAAcE,IAAgBK,GAAejyB,EAAQ+gB,GACtDkR,GAAeR,GAAgBE,IAAmBD,IAAcE,GAChEG,GAAaN,GAAgBE,IAC5BG,GAAgBH,IACjBK,EACH,OAAQ,CAEZ,CACA,OAAO,CACT,ECKA,OA3BA,SAAyB3K,EAAQtG,EAAOmR,GAOtC,IANA,IAAIzvB,GAAS,EACT0vB,EAAc9K,EAAO+K,SACrBC,EAActR,EAAMqR,SACpBzvB,EAASwvB,EAAYxvB,OACrB2vB,EAAeJ,EAAOvvB,SAEjBF,EAAQE,GAAQ,CACvB,IAAIiB,EAAS,GAAiBuuB,EAAY1vB,GAAQ4vB,EAAY5vB,IAC9D,GAAImB,EACF,OAAInB,GAAS6vB,EACJ1uB,EAGFA,GAAmB,QADdsuB,EAAOzvB,IACiB,EAAI,EAE5C,CAQA,OAAO4kB,EAAO5kB,MAAQse,EAAMte,KAC9B,ECOA,OA7BA,SAAqBygB,EAAYqP,EAAWL,GAExCK,EADEA,EAAU5vB,QACA,QAAS4vB,GAAW,SAAShP,GACvC,OAAI,EAAAjH,GAAA,GAAQiH,GACH,SAASvjB,GACd,OAAO,QAAQA,EAA2B,IAApBujB,EAAS5gB,OAAe4gB,EAAS,GAAKA,EAC9D,EAEKA,CACT,IAEY,CAACoE,EAAA,GAGf,IAAIllB,GAAS,EACb8vB,GAAY,QAASA,GAAW,QAAU,MAE1C,IAAI3uB,GAAS,QAAQsf,GAAY,SAASljB,EAAOwjB,EAAKN,GAIpD,MAAO,CAAE,UAHM,QAASqP,GAAW,SAAShP,GAC1C,OAAOA,EAASvjB,EAClB,IAC+B,QAAWyC,EAAO,MAASzC,EAC5D,IAEA,OAAO,GAAW4D,GAAQ,SAASyjB,EAAQtG,GACzC,OAAO,GAAgBsG,EAAQtG,EAAOmR,EACxC,GACF,ECCA,IAba,E,QAAA,IAAS,SAAShP,EAAYqP,GACzC,GAAkB,MAAdrP,EACF,MAAO,GAET,IAAIvgB,EAAS4vB,EAAU5vB,OAMvB,OALIA,EAAS,IAAK,OAAeugB,EAAYqP,EAAU,GAAIA,EAAU,IACnEA,EAAY,GACH5vB,EAAS,IAAK,OAAe4vB,EAAU,GAAIA,EAAU,GAAIA,EAAU,MAC5EA,EAAY,CAACA,EAAU,KAElB,GAAYrP,GAAY,QAAYqP,EAAW,GAAI,GAC5D,ICzBA,SAASC,GAAWxN,EAAGmE,GAErB,IADA,IAAIsJ,EAAK,EACAlsB,EAAI,EAAGA,EAAI4iB,EAASxmB,SAAU4D,EACrCksB,GAAMC,GAAmB1N,EAAGmE,EAAS5iB,EAAI,GAAI4iB,EAAS5iB,IAExD,OAAOksB,CACT,CAEA,SAASC,GAAmB1N,EAAG2N,EAAYC,GAuBzC,IAnBA,IAAIC,EAAW,GACbD,EACA,IAAMA,GAAY,SAAUjqB,EAAGpC,GAC7B,OAAOA,CACT,KAEEusB,EAAe,IACjB,IAAMH,GAAY,SAAUhqB,GAC1B,OAAO,GACL,IAAMqc,EAAEwB,SAAS7d,IAAI,SAAUlI,GAC7B,MAAO,CAAEsyB,IAAKF,EAASpyB,EAAEilB,GAAIC,OAAQX,EAAEjF,KAAKtf,GAAGklB,OACjD,IACA,MAEJ,KAIEqN,EAAa,EACVA,EAAaJ,EAAWjwB,QAAQqwB,IAAe,EACtD,IAAIC,EAAW,EAAID,EAAa,EAChCA,GAAc,EACd,IAAIzE,EAAO,IAAM,IAAI1c,MAAMohB,IAAW,WACpC,OAAO,CACT,IAGIR,EAAK,EAqBT,OApBA,IAEEK,EAAavxB,SAAQ,SAAUb,GAC7B,IAAI+B,EAAQ/B,EAAMqyB,IAAMC,EACxBzE,EAAK9rB,IAAU/B,EAAMilB,OAGrB,IAFA,IAAIuN,EAAY,EAETzwB,EAAQ,GAETA,EAAQ,IACVywB,GAAa3E,EAAK9rB,EAAQ,IAI5B8rB,EADA9rB,EAASA,EAAQ,GAAM,IACR/B,EAAMilB,OAEvB8M,GAAM/xB,EAAMilB,OAASuN,CACvB,KAGKT,CACT,CCpDA,SAASU,GAAiBtsB,EAASusB,GACjC,IAAIC,EAAgB,CAAC,EA+BrB,OA9BA,IAAUxsB,GAAS,SAAUnG,EAAO6F,GAClC,IAAI+sB,EAAOD,EAAc3yB,EAAMiI,GAAK,CAClC4qB,SAAU,EACVhO,GAAI,GACJC,IAAK,GACLkH,GAAI,CAAChsB,EAAMiI,GACXpC,EAAGA,GAEA,IAAc7F,EAAM8yB,cAEvBF,EAAIE,WAAa9yB,EAAM8yB,WAEvBF,EAAI3N,OAASjlB,EAAMilB,OAEvB,IAEA,IAAUyN,EAAGpU,SAAS,SAAUve,GAC9B,IAAIgzB,EAASJ,EAAc5yB,EAAEkI,GACzB+qB,EAASL,EAAc5yB,EAAEilB,GACxB,IAAc+N,IAAY,IAAcC,KAC3CA,EAAOH,WACPE,EAAOjO,IAAIvhB,KAAKovB,EAAc5yB,EAAEilB,IAEpC,IAUF,SAA4BiO,GAC1B,IAAI9sB,EAAU,GAEd,SAAS+sB,EAASC,GAChB,OAAO,SAAUlN,GACXA,EAAOmN,SAIT,IAAcnN,EAAO6M,aACrB,IAAcK,EAAOL,aACrB7M,EAAO6M,YAAcK,EAAOL,aAiCpC,SAAsBtW,EAAQzW,GAC5B,IAAIstB,EAAM,EACNpO,EAAS,EAETzI,EAAOyI,SACToO,GAAO7W,EAAOsW,WAAatW,EAAOyI,OAClCA,GAAUzI,EAAOyI,QAGflf,EAAOkf,SACToO,GAAOttB,EAAO+sB,WAAa/sB,EAAOkf,OAClCA,GAAUlf,EAAOkf,QAGnBzI,EAAOwP,GAAKjmB,EAAOimB,GAAG7rB,OAAOqc,EAAOwP,IACpCxP,EAAOsW,WAAaO,EAAMpO,EAC1BzI,EAAOyI,OAASA,EAChBzI,EAAO3W,EAAI1D,KAAKE,IAAI0D,EAAOF,EAAG2W,EAAO3W,GACrCE,EAAOqtB,QAAS,CAClB,CAlDQE,CAAaH,EAAQlN,EAEzB,CACF,CAEA,SAASsN,EAAUJ,GACjB,OAAO,SAAUjN,GACfA,EAAW,GAAE3iB,KAAK4vB,GACQ,KAApBjN,EAAO2M,UACXI,EAAU1vB,KAAK2iB,EAEnB,CACF,CAEA,KAAO+M,EAAUhxB,QAAQ,CACvB,IAAIjC,EAAQizB,EAAU/hB,MACtB/K,EAAQ5C,KAAKvD,GACb,IAAUA,EAAU,GAAE6b,UAAWqX,EAASlzB,IAC1C,IAAUA,EAAM8kB,IAAKyO,EAAUvzB,GACjC,CAEA,OAAO,IACL,KAASmG,GAAS,SAAUnG,GAC1B,OAAQA,EAAMozB,MAChB,KACA,SAAUpzB,GACR,OAAO,EAAOA,EAAO,CAAC,KAAM,IAAK,aAAc,UACjD,GAEJ,CA7CSwzB,CALS,KAASb,GAAe,SAAU3yB,GAEhD,OAAQA,EAAM6yB,QAChB,IAGF,CCzDA,SAAS/B,GAAK3qB,EAASstB,GACrB,IA0CuBC,EA1CnBC,E9BwNN,SAAmBnR,EAAYqG,GAC7B,IAAI3lB,EAAS,CAAE0wB,IAAK,GAAIC,IAAK,IAQ7B,OAPA,IAAUrR,GAAY,SAAUljB,GAC1BupB,EAAGvpB,GACL4D,EAAO0wB,IAAIrwB,KAAKjE,GAEhB4D,EAAO2wB,IAAItwB,KAAKjE,EAEpB,IACO4D,CACT,C8BlOc,CAAeiD,GAAS,SAAUnG,GAC5C,OAAOkG,OAAOwK,UAAUC,eAAeP,KAAKpQ,EAAO,aACrD,IACI8zB,EAAWH,EAAMC,IACnBG,EAAa,GAASJ,EAAME,KAAK,SAAU7zB,GACzC,OAAQA,EAAM6F,CAChB,IACAmmB,EAAK,GACLqH,EAAM,EACNpO,EAAS,EACT+O,EAAU,EAEZF,EAAShD,MA8Bc4C,IA9BSD,EA+BzB,SAAUV,EAAQC,GACvB,OAAID,EAAOD,WAAaE,EAAOF,YACrB,EACCC,EAAOD,WAAaE,EAAOF,WAC7B,EAGDY,EAA6BV,EAAOntB,EAAIktB,EAAOltB,EAAxCktB,EAAOltB,EAAImtB,EAAOntB,CACnC,IArCAmuB,EAAUC,GAAkBjI,EAAI+H,EAAYC,GAE5C,IAAUF,GAAU,SAAU9zB,GAC5Bg0B,GAAWh0B,EAAMgsB,GAAG/pB,OACpB+pB,EAAGzoB,KAAKvD,EAAMgsB,IACdqH,GAAOrzB,EAAM8yB,WAAa9yB,EAAMilB,OAChCA,GAAUjlB,EAAMilB,OAChB+O,EAAUC,GAAkBjI,EAAI+H,EAAYC,EAC9C,IAEA,IAAI9wB,EAAS,CAAE8oB,GAAI,IAAUA,IAK7B,OAJI/G,IACF/hB,EAAO4vB,WAAaO,EAAMpO,EAC1B/hB,EAAO+hB,OAASA,GAEX/hB,CACT,CAEA,SAAS+wB,GAAkBjI,EAAI+H,EAAYhyB,GAEzC,IADA,IAAImyB,EACGH,EAAW9xB,SAAWiyB,EAAO,IAAOH,IAAaluB,GAAK9D,GAC3DgyB,EAAW7iB,MACX8a,EAAGzoB,KAAK2wB,EAAKlI,IACbjqB,IAEF,OAAOA,CACT,CCvCA,SAASoyB,GAAa7P,EAAGrc,EAAGyqB,EAAIe,GAC9B,IAAIW,EAAU9P,EAAEzG,SAAS5V,GACrBnH,EAAOwjB,EAAExjB,KAAKmH,GACdosB,EAAKvzB,EAAOA,EAAKyvB,gBAAaruB,EAC9BoyB,EAAKxzB,EAAOA,EAAK0vB,iBAActuB,EAC/BqyB,EAAY,CAAC,EAEbF,IACFD,EAAU,KAASA,GAAS,SAAUpP,GACpC,OAAOA,IAAMqP,GAAMrP,IAAMsP,CAC3B,KAGF,IAAIE,EChBN,SAAoBlQ,EAAG8P,GACrB,OAAO,IAAMA,GAAS,SAAUnsB,GAC9B,IAAIwsB,EAAMnQ,EAAE0B,QAAQ/d,GACpB,GAAKwsB,EAAIxyB,OAEF,CACL,IAAIiB,EAAS,KACXuxB,GACA,SAAUpI,EAAKtsB,GACb,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAChB20B,EAAQpQ,EAAExjB,KAAKf,EAAEkI,GACnB,MAAO,CACLorB,IAAKhH,EAAIgH,IAAMhU,EAAK4F,OAASyP,EAAM/L,MACnC1D,OAAQoH,EAAIpH,OAAS5F,EAAK4F,OAE9B,GACA,CAAEoO,IAAK,EAAGpO,OAAQ,IAGpB,MAAO,CACLhd,EAAGA,EACH6qB,WAAY5vB,EAAOmwB,IAAMnwB,EAAO+hB,OAChCA,OAAQ/hB,EAAO+hB,OAEnB,CApBE,MAAO,CAAEhd,EAAGA,EAqBhB,GACF,CDVoB6qB,CAAWxO,EAAG8P,GAChC,IAAUI,GAAa,SAAUx0B,GAC/B,GAAIskB,EAAEzG,SAAS7d,EAAMiI,GAAGhG,OAAQ,CAC9B,IAAI0yB,EAAiBR,GAAa7P,EAAGtkB,EAAMiI,EAAGyqB,EAAIe,GAClDc,EAAUv0B,EAAMiI,GAAK0sB,EACjBzuB,OAAOwK,UAAUC,eAAeP,KAAKukB,EAAgB,gBA0CrCnY,EAzCDxc,EAyCSqgB,EAzCFsU,EA0CzB,IAAcnY,EAAOsW,aAMxBtW,EAAOsW,WAAazS,EAAMyS,WAC1BtW,EAAOyI,OAAS5E,EAAM4E,SANtBzI,EAAOsW,YACJtW,EAAOsW,WAAatW,EAAOyI,OAAS5E,EAAMyS,WAAazS,EAAM4E,SAC7DzI,EAAOyI,OAAS5E,EAAM4E,QACzBzI,EAAOyI,QAAU5E,EAAM4E,QA5CvB,CAuCJ,IAA0BzI,EAAQ6D,CAtChC,IAEA,IAAIla,EAAUssB,GAAiB+B,EAAa9B,IAuB9C,SAAyBvsB,EAASouB,GAChC,IAAUpuB,GAAS,SAAUnG,GAC3BA,EAAMgsB,GAAK,IACThsB,EAAMgsB,GAAG5lB,KAAI,SAAU6B,GACrB,OAAIssB,EAAUtsB,GACLssB,EAAUtsB,GAAG+jB,GAEf/jB,CACT,IAEJ,GACF,CAjCE2sB,CAAgBzuB,EAASouB,GAEzB,IAAIrxB,EAAS4tB,GAAK3qB,EAASstB,GAE3B,GAAIY,IACFnxB,EAAO8oB,GAAK,IAAU,CAACqI,EAAInxB,EAAO8oB,GAAIsI,IAClChQ,EAAEuQ,aAAaR,GAAIpyB,QAAQ,CAC7B,IAAI6yB,EAASxQ,EAAExjB,KAAKwjB,EAAEuQ,aAAaR,GAAI,IACrCU,EAASzQ,EAAExjB,KAAKwjB,EAAEuQ,aAAaP,GAAI,IAChCpuB,OAAOwK,UAAUC,eAAeP,KAAKlN,EAAQ,gBAChDA,EAAO4vB,WAAa,EACpB5vB,EAAO+hB,OAAS,GAElB/hB,EAAO4vB,YACJ5vB,EAAO4vB,WAAa5vB,EAAO+hB,OAAS6P,EAAOnM,MAAQoM,EAAOpM,QAAUzlB,EAAO+hB,OAAS,GACvF/hB,EAAO+hB,QAAU,CACnB,CAGF,OAAO/hB,CACT,CE1BA,SAASylB,GAAMrE,GACb,IAAIgM,EAAU,EAAahM,GACzB0Q,EAAkBC,GAAiB3Q,EAAG,EAAQ,EAAGgM,EAAU,GAAI,WAC/D4E,EAAgBD,GAAiB3Q,EAAG,EAAQgM,EAAU,GAAI,GAAI,GAAI,YAEhE7H,EClBC,SAAmBnE,GACxB,IAAI1f,EAAU,CAAC,EACXuwB,EAAc,KAAS7Q,EAAEtiB,SAAS,SAAUiG,GAC9C,OAAQqc,EAAEzG,SAAS5V,GAAGhG,MACxB,IACIquB,EAAU,EACZ,IAAM6E,GAAa,SAAUltB,GAC3B,OAAOqc,EAAExjB,KAAKmH,GAAGygB,IACnB,KAEE0M,EAAS,IAAM,EAAQ9E,EAAU,IAAI,WACvC,MAAO,EACT,IAUI+E,EAAY,GAASF,GAAa,SAAUltB,GAC9C,OAAOqc,EAAExjB,KAAKmH,GAAGygB,IACnB,IAGA,OAFA,IAAU2M,GAXV,SAAS/O,EAAIre,GACX,IAAI,IAAMrD,EAASqD,GAAnB,CACArD,EAAQqD,IAAK,EACb,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GAClBmtB,EAAOt0B,EAAK4nB,MAAMnlB,KAAK0E,GACvB,IAAUqc,EAAE6H,WAAWlkB,GAAIqe,EAJE,CAK/B,IAOO8O,CACT,CDViBE,CAAUhR,GACzBiR,GAAYjR,EAAGmE,GAKf,IAHA,IACE+M,EADEC,EAAShL,OAAOC,kBAGX7kB,EAAI,EAAG6vB,EAAW,EAAGA,EAAW,IAAK7vB,IAAK6vB,EAAU,CAC3DC,GAAiB9vB,EAAI,EAAImvB,EAAkBE,EAAervB,EAAI,GAAK,GAGnE,IAAIksB,EAAKD,GAAWxN,EADpBmE,EAAW,EAAsBnE,IAE7ByN,EAAK0D,IACPC,EAAW,EACXF,EAAO,GAAY/M,GACnBgN,EAAS1D,EAEb,CAEAwD,GAAYjR,EAAGkR,EACjB,CAEA,SAASP,GAAiB3Q,EAAGsR,EAAO3F,GAClC,OAAO,IAAM2F,GAAO,SAAUlN,GAC5B,OAAOsH,GAAgB1L,EAAGoE,EAAMuH,EAClC,GACF,CAEA,SAAS0F,GAAiBE,EAAapC,GACrC,IAAIf,EAAK,IAAI,IACb,IAAUmD,GAAa,SAAUC,GAC/B,IAAIhI,EAAOgI,EAAGvQ,QAAQuI,KAClBiI,EAAS5B,GAAa2B,EAAIhI,EAAM4E,EAAIe,GACxC,IAAUsC,EAAO/J,IAAI,SAAU/jB,EAAGpC,GAChCiwB,EAAGh1B,KAAKmH,GAAG0gB,MAAQ9iB,CACrB,IE7DJ,SAAgCye,EAAGoO,EAAI1G,GACrC,IACEgK,EADE3M,EAAO,CAAC,EAGZ,IAAU2C,GAAI,SAAU/jB,GAItB,IAHA,IACEgW,EACAgY,EAFEjJ,EAAQ1I,EAAErG,OAAOhW,GAGd+kB,GAAO,CASZ,IARA/O,EAASqG,EAAErG,OAAO+O,KAEhBiJ,EAAY5M,EAAKpL,GACjBoL,EAAKpL,GAAU+O,IAEfiJ,EAAYD,EACZA,EAAWhJ,GAETiJ,GAAaA,IAAcjJ,EAE7B,YADA0F,EAAGvN,QAAQ8Q,EAAWjJ,GAGxBA,EAAQ/O,CACV,CACF,GAyBF,CFcIiY,CAAuBJ,EAAIpD,EAAIqD,EAAO/J,GACxC,GACF,CAEA,SAASuJ,GAAYjR,EAAGmE,GACtB,IAAUA,GAAU,SAAU0N,GAC5B,IAAUA,GAAO,SAAUluB,EAAGpC,GAC5Bye,EAAExjB,KAAKmH,GAAG0gB,MAAQ9iB,CACpB,GACF,GACF,CGxEA,SAASuwB,GAAkB9R,GACzB,IAAI+R,EAoEN,SAAmB/R,GACjB,IAAIphB,EAAS,CAAC,EACVgrB,EAAM,EAEV,SAAS5H,EAAIre,GACX,IAAIgmB,EAAMC,EACV,IAAU5J,EAAEzG,SAAS5V,GAAIqe,GACzBpjB,EAAO+E,GAAK,CAAEgmB,IAAKA,EAAKC,IAAKA,IAC/B,CAGA,OAFA,IAAU5J,EAAEzG,WAAYyI,GAEjBpjB,CACT,CAhFsB,CAAUohB,GAE9B,IAAUA,EAAEiB,QAAQyE,aAAa,SAAU/hB,GAUzC,IATA,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GACdoiB,EAAUvpB,EAAKupB,QACfiM,EAsCR,SAAkBhS,EAAG+R,EAAepuB,EAAG+c,GACrC,IAII/G,EACAsY,EALAC,EAAQ,GACRC,EAAQ,GACRxI,EAAM9rB,KAAKE,IAAIg0B,EAAcpuB,GAAGgmB,IAAKoI,EAAcrR,GAAGiJ,KACtDC,EAAM/rB,KAAKC,IAAIi0B,EAAcpuB,GAAGimB,IAAKmI,EAAcrR,GAAGkJ,KAK1DjQ,EAAShW,EACT,GACEgW,EAASqG,EAAErG,OAAOA,GAClBuY,EAAMjzB,KAAK0a,SACJA,IAAWoY,EAAcpY,GAAQgQ,IAAMA,GAAOC,EAAMmI,EAAcpY,GAAQiQ,MACnFqI,EAAMtY,EAGNA,EAAS+G,EACT,MAAQ/G,EAASqG,EAAErG,OAAOA,MAAasY,GACrCE,EAAMlzB,KAAK0a,GAGb,MAAO,CAAE4I,KAAM2P,EAAMr2B,OAAOs2B,EAAM5a,WAAY0a,IAAKA,EACrD,CA7DmBG,CAASpS,EAAG+R,EAAehM,EAAQpiB,EAAGoiB,EAAQrF,GACzD6B,EAAOyP,EAASzP,KAChB0P,EAAMD,EAASC,IACfI,EAAU,EACVC,EAAQ/P,EAAK8P,GACbE,GAAY,EAET5uB,IAAMoiB,EAAQrF,GAAG,CAGtB,GAFAlkB,EAAOwjB,EAAExjB,KAAKmH,GAEV4uB,EAAW,CACb,MAAQD,EAAQ/P,EAAK8P,MAAcJ,GAAOjS,EAAExjB,KAAK81B,GAAOtG,QAAUxvB,EAAK4nB,MACrEiO,IAGEC,IAAUL,IACZM,GAAY,EAEhB,CAEA,IAAKA,EAAW,CACd,KACEF,EAAU9P,EAAK5kB,OAAS,GACxBqiB,EAAExjB,KAAM81B,EAAQ/P,EAAK8P,EAAU,IAAKtG,SAAWvvB,EAAK4nB,MAEpDiO,IAEFC,EAAQ/P,EAAK8P,EACf,CAEArS,EAAEgF,UAAUrhB,EAAG2uB,GACf3uB,EAAIqc,EAAE6H,WAAWlkB,GAAG,EACtB,CACF,GACF,C,eCTA,OAJA,SAAgB0e,EAAQ9D,GACtB,OAAO8D,IAAU,OAAWA,GAAQ,QAAa9D,GACnD,E,sBCKA,OANA,SAAe8D,EAAQ9D,GACrB,OAAiB,MAAV8D,EACHA,GACA,QAAQA,GAAQ,QAAa9D,GAAWiU,GAAA,EAC9C,ECGA,SAASC,GAAmBzS,EAAGmE,GAC7B,IAAIuO,EAAY,CAAC,EAoCjB,OADA,KAASvO,GAjCT,SAAoBwO,EAAWd,GAC7B,IAEEe,EAAK,EAGLC,EAAU,EACVC,EAAkBH,EAAUh1B,OAC5Bo1B,EAAW,IAAOlB,GAsBpB,OApBA,IAAUA,GAAO,SAAUluB,EAAGpC,GAC5B,IAAImf,EAsEV,SAAmCV,EAAGrc,GACpC,GAAIqc,EAAExjB,KAAKmH,GAAGsf,MACZ,OAAO,KAAOjD,EAAEuQ,aAAa5sB,IAAI,SAAUnC,GACzC,OAAOwe,EAAExjB,KAAKgF,GAAGyhB,KACnB,GAEJ,CA5Ec+P,CAA0BhT,EAAGrc,GACnCsvB,EAAKvS,EAAIV,EAAExjB,KAAKkkB,GAAG2D,MAAQyO,GAEzBpS,GAAK/c,IAAMovB,KACb,IAAUlB,EAAMhmB,MAAMgnB,EAAStxB,EAAI,IAAI,SAAU2xB,GAC/C,IAAUlT,EAAEuQ,aAAa2C,IAAW,SAAU1xB,GAC5C,IAAI2xB,EAASnT,EAAExjB,KAAKgF,GAClB4xB,EAAOD,EAAO9O,QACX+O,EAAOR,GAAMK,EAAKG,IAAWD,EAAOlQ,OAASjD,EAAExjB,KAAK02B,GAAUjQ,OACjEoQ,GAAYX,EAAWlxB,EAAG0xB,EAE9B,GACF,IAEAL,EAAUtxB,EAAI,EACdqxB,EAAKK,EAET,IAEOpB,CACT,IAGOa,CACT,CAsDA,SAASW,GAAYX,EAAW/uB,EAAG+c,GACjC,GAAI/c,EAAI+c,EAAG,CACT,IAAI4N,EAAM3qB,EACVA,EAAI+c,EACJA,EAAI4N,CACN,CAEA,IAAIgF,EAAaZ,EAAU/uB,GACtB2vB,IACHZ,EAAU/uB,GAAK2vB,EAAa,CAAC,GAE/BA,EAAW5S,IAAK,CAClB,CAEA,SAAS6S,GAAYb,EAAW/uB,EAAG+c,GACjC,GAAI/c,EAAI+c,EAAG,CACT,IAAI4N,EAAM3qB,EACVA,EAAI+c,EACJA,EAAI4N,CACN,CACA,QAASoE,EAAU/uB,IAAM/B,OAAOwK,UAAUC,eAAeP,KAAK4mB,EAAU/uB,GAAI+c,EAC9E,CAkDA,SAAS8S,GAAqBxT,EAAGmE,EAAUqF,EAAMiK,EAAOC,GAMtD,IAAIC,EAAK,CAAC,EACRC,EAkDJ,SAAyB5T,EAAGmE,EAAUqF,EAAMkK,GAC1C,IAAIG,EAAa,IAAI,IACnBC,EAAa9T,EAAEiB,QACf8S,EAgHJ,SAAajJ,EAASkJ,EAASN,GAC7B,OAAO,SAAU1T,EAAGrc,EAAG+c,GACrB,IAGI6F,EAHAsD,EAAS7J,EAAExjB,KAAKmH,GAChBmmB,EAAS9J,EAAExjB,KAAKkkB,GAChBqO,EAAM,EAIV,GADAA,GAAOlF,EAAO9F,MAAQ,EAClBniB,OAAOwK,UAAUC,eAAeP,KAAK+d,EAAQ,YAC/C,OAAQA,EAAOjO,SAAS1b,eACtB,IAAK,IACHqmB,GAASsD,EAAO9F,MAAQ,EACxB,MACF,IAAK,IACHwC,EAAQsD,EAAO9F,MAAQ,EAa7B,GATIwC,IACFwI,GAAO2E,EAAanN,GAASA,GAE/BA,EAAQ,EAERwI,IAAQlF,EAAO5G,MAAQ+Q,EAAUlJ,GAAW,EAC5CiE,IAAQjF,EAAO7G,MAAQ+Q,EAAUlJ,GAAW,EAE5CiE,GAAOjF,EAAO/F,MAAQ,EAClBniB,OAAOwK,UAAUC,eAAeP,KAAKge,EAAQ,YAC/C,OAAQA,EAAOlO,SAAS1b,eACtB,IAAK,IACHqmB,EAAQuD,EAAO/F,MAAQ,EACvB,MACF,IAAK,IACHwC,GAASuD,EAAO/F,MAAQ,EAS9B,OALIwC,IACFwI,GAAO2E,EAAanN,GAASA,GAE/BA,EAAQ,EAEDwI,CACT,CACF,CA5JYkF,CAAIH,EAAWI,QAASJ,EAAWK,QAAST,GAgBtD,OAdA,IAAUvP,GAAU,SAAU0N,GAC5B,IAAIrwB,EACJ,IAAUqwB,GAAO,SAAUluB,GACzB,IAAIywB,EAAQ5K,EAAK7lB,GAEjB,GADAkwB,EAAWvT,QAAQ8T,GACf5yB,EAAG,CACL,IAAI6yB,EAAQ7K,EAAKhoB,GACf8yB,EAAUT,EAAW9Y,KAAKsZ,EAAOD,GACnCP,EAAWhT,QAAQwT,EAAOD,EAAOv2B,KAAKC,IAAIi2B,EAAM/T,EAAGrc,EAAGnC,GAAI8yB,GAAW,GACvE,CACA9yB,EAAImC,CACN,GACF,IAEOkwB,CACT,CAtEaU,CAAgBvU,EAAGmE,EAAUqF,EAAMkK,GAC5C5O,EAAa4O,EAAa,aAAe,cAE3C,SAASc,EAAQC,EAAWC,GAI1B,IAHA,IAAInpB,EAAQqoB,EAAOl2B,QACfsb,EAAOzN,EAAMqB,MACbtM,EAAU,CAAC,EACR0Y,GACD1Y,EAAQ0Y,GACVyb,EAAUzb,IAEV1Y,EAAQ0Y,IAAQ,EAChBzN,EAAMtM,KAAK+Z,GACXzN,EAAQA,EAAM1P,OAAO64B,EAAc1b,KAGrCA,EAAOzN,EAAMqB,KAEjB,CA6BA,OARA4nB,GAlBA,SAAexb,GACb2a,EAAG3a,GAAQ4a,EAAOlS,QAAQ1I,GAAM2b,QAAO,SAAU5M,EAAKtsB,GACpD,OAAOoC,KAAKC,IAAIiqB,EAAK4L,EAAGl4B,EAAEkI,GAAKiwB,EAAO7Y,KAAKtf,GAC7C,GAAG,EACL,GAcem4B,EAAOrD,aAAapb,KAAKye,IACxCY,GAZA,SAAexb,GACb,IAAIjb,EAAM61B,EAAOpS,SAASxI,GAAM2b,QAAO,SAAU5M,EAAKtsB,GACpD,OAAOoC,KAAKE,IAAIgqB,EAAK4L,EAAGl4B,EAAEilB,GAAKkT,EAAO7Y,KAAKtf,GAC7C,GAAG0qB,OAAOC,mBAEN5pB,EAAOwjB,EAAExjB,KAAKwc,GACdjb,IAAQooB,OAAOC,mBAAqB5pB,EAAKsoB,aAAeA,IAC1D6O,EAAG3a,GAAQnb,KAAKC,IAAI61B,EAAG3a,GAAOjb,GAElC,GAGe61B,EAAO/L,WAAW1S,KAAKye,IAGtC,IAAUH,GAAO,SAAU9vB,GACzBgwB,EAAGhwB,GAAKgwB,EAAGnK,EAAK7lB,GAClB,IAEOgwB,CACT,CAqFA,SAASiB,GAAU5U,GACjB,IAII6U,EAJA1Q,EAAW,EAAsBnE,GACjC0S,EAAY,IAAQD,GAAmBzS,EAAGmE,GAzQhD,SAA4BnE,EAAGmE,GAC7B,IAAIuO,EAAY,CAAC,EAEjB,SAASoC,EAAKC,EAAOlH,EAAUmH,EAAUC,EAAiBC,GACxD,IAAIvxB,EACJ,IAAU,EAAQkqB,EAAUmH,IAAW,SAAUzzB,GAC/CoC,EAAIoxB,EAAMxzB,GACNye,EAAExjB,KAAKmH,GAAGsf,OACZ,IAAUjD,EAAEuQ,aAAa5sB,IAAI,SAAUnC,GACrC,IAAI2zB,EAAQnV,EAAExjB,KAAKgF,GACf2zB,EAAMlS,QAAUkS,EAAM9Q,MAAQ4Q,GAAmBE,EAAM9Q,MAAQ6Q,IACjE7B,GAAYX,EAAWlxB,EAAGmC,EAE9B,GAEJ,GACF,CAyBA,OADA,KAASwgB,GAtBT,SAAoBiR,EAAOL,GACzB,IACEM,EADEC,GAAgB,EAElBzH,EAAW,EAgBb,OAdA,IAAUkH,GAAO,SAAUpxB,EAAG4xB,GAC5B,GAAwB,WAApBvV,EAAExjB,KAAKmH,GAAGsf,MAAoB,CAChC,IAAIsN,EAAevQ,EAAEuQ,aAAa5sB,GAC9B4sB,EAAa5yB,SACf03B,EAAerV,EAAExjB,KAAK+zB,EAAa,IAAIlM,MACvCyQ,EAAKC,EAAOlH,EAAU0H,EAAgBD,EAAcD,GAEpDxH,EAAW0H,EACXD,EAAeD,EAEnB,CACAP,EAAKC,EAAOlH,EAAUkH,EAAMp3B,OAAQ03B,EAAcD,EAAMz3B,OAC1D,IAEOo3B,CACT,IAGOrC,CACT,CA+N2D8C,CAAmBxV,EAAGmE,IAE3EsR,EAAM,CAAC,EAEX,IAAU,CAAC,IAAK,MAAM,SAAUC,GAC9Bb,EAA4B,MAATa,EAAevR,EAAW,KAASA,GAAU5M,UAChE,IAAU,CAAC,IAAK,MAAM,SAAUoe,GAChB,MAAVA,IACFd,EAAmB,IAAMA,GAAkB,SAAUe,GACnD,OAAO,KAASA,GAAOre,SACzB,KAGF,IAAIse,GAAuB,MAATH,EAAe1V,EAAEuQ,aAAevQ,EAAE6H,YAAY1S,KAAK6K,GACjEyT,EApMV,SAA2BzT,EAAGmE,EAAUuO,EAAWmD,GACjD,IAAIrM,EAAO,CAAC,EACViK,EAAQ,CAAC,EACT1F,EAAM,CAAC,EAkCT,OA7BA,IAAU5J,GAAU,SAAU0N,GAC5B,IAAUA,GAAO,SAAUluB,EAAG0gB,GAC5BmF,EAAK7lB,GAAKA,EACV8vB,EAAM9vB,GAAKA,EACXoqB,EAAIpqB,GAAK0gB,CACX,GACF,IAEA,IAAUF,GAAU,SAAU0N,GAC5B,IAAIiE,GAAW,EACf,IAAUjE,GAAO,SAAUluB,GACzB,IAAIoyB,EAAKF,EAAWlyB,GACpB,GAAIoyB,EAAGp4B,OAAQ,CACbo4B,EAAK,GAASA,GAAI,SAAUrV,GAC1B,OAAOqN,EAAIrN,EACb,IAEA,IADA,IAAIsV,GAAMD,EAAGp4B,OAAS,GAAK,EAClB4D,EAAI1D,KAAKo4B,MAAMD,GAAKE,EAAKr4B,KAAKihB,KAAKkX,GAAKz0B,GAAK20B,IAAM30B,EAAG,CAC7D,IAAImf,EAAIqV,EAAGx0B,GACPkyB,EAAM9vB,KAAOA,GAAKmyB,EAAU/H,EAAIrN,KAAO6S,GAAYb,EAAW/uB,EAAG+c,KACnE+S,EAAM/S,GAAK/c,EACX8vB,EAAM9vB,GAAK6lB,EAAK7lB,GAAK6lB,EAAK9I,GAC1BoV,EAAU/H,EAAIrN,GAElB,CACF,CACF,GACF,IAEO,CAAE8I,KAAMA,EAAMiK,MAAOA,EAC9B,CA8JkB0C,CAAkBnW,EAAG6U,EAAkBnC,EAAWmD,GAC1DlC,EAAKH,GAAqBxT,EAAG6U,EAAkBpB,EAAMjK,KAAMiK,EAAMA,MAAiB,MAAVkC,GAC9D,MAAVA,IACFhC,EAAK,EAAYA,GAAI,SAAUhQ,GAC7B,OAAQA,CACV,KAEF8R,EAAIC,EAAOC,GAAShC,CACtB,GACF,IAEA,IAAIyC,EArFN,SAAoCpW,EAAGyV,GACrC,OAAO,GAAQ,KAASA,IAAM,SAAU9B,GACtC,IAAI71B,EAAMqoB,OAAOkQ,kBACbt4B,EAAMooB,OAAOC,kBASjB,OAPA,GAAQuN,GAAI,SAAUhQ,EAAGhgB,GACvB,IAAI2yB,EAkIV,SAAetW,EAAGrc,GAChB,OAAOqc,EAAExjB,KAAKmH,GAAGogB,KACnB,CApIsBA,CAAM/D,EAAGrc,GAAK,EAE9B7F,EAAMD,KAAKC,IAAI6lB,EAAI2S,EAAWx4B,GAC9BC,EAAMF,KAAKE,IAAI4lB,EAAI2S,EAAWv4B,EAChC,IAEOD,EAAMC,CACf,GACF,CAuEsBw4B,CAA2BvW,EAAGyV,GAElD,OAhEF,SAA0BA,EAAKe,GAC7B,IAAIC,EAAc,KAASD,GACzBE,EAAa,IAAMD,GACnBE,EAAa,EAAMF,GAErB,IAAU,CAAC,IAAK,MAAM,SAAUf,GAC9B,IAAU,CAAC,IAAK,MAAM,SAAUC,GAC9B,IAEEpP,EAFEqQ,EAAYlB,EAAOC,EACrBhC,EAAK8B,EAAImB,GAEX,GAAIjD,IAAO6C,EAAX,CAEA,IAAIK,EAAS,KAASlD,IACtBpN,EAAkB,MAAVoP,EAAgBe,EAAa,IAAMG,GAAUF,EAAa,EAAME,MAGtEpB,EAAImB,GAAa,EAAYjD,GAAI,SAAUhQ,GACzC,OAAOA,EAAI4C,CACb,IARwB,CAU5B,GACF,GACF,CAyCEuQ,CAAiBrB,EAAKW,GAvCxB,SAAiBX,EAAKhC,GACpB,OAAO,EAAYgC,EAAIsB,IAAI,SAAUC,EAAQrzB,GAC3C,GAAI8vB,EACF,OAAOgC,EAAIhC,EAAMvzB,eAAeyD,GAEhC,IAAIgwB,EAAK,GAAS,IAAM8B,EAAK9xB,IAC7B,OAAQgwB,EAAG,GAAKA,EAAG,IAAM,CAE7B,GACF,CA+BSsD,CAAQxB,EAAKzV,EAAEiB,QAAQwS,MAChC,CC9WA,SAASyD,GAASlX,IASlB,SAAmBA,GACjB,IAAImE,EAAW,EAAsBnE,GACjCmX,EAAUnX,EAAEiB,QAAQmW,QACpBC,EAAQ,EACZ,IAAUlT,GAAU,SAAU0N,GAC5B,IAAIyF,EAAY,EACd,IAAMzF,GAAO,SAAUluB,GACrB,OAAOqc,EAAExjB,KAAKmH,GAAGsgB,MACnB,KAEF,IAAU4N,GAAO,SAAUluB,GACzBqc,EAAExjB,KAAKmH,GAAGigB,EAAIyT,EAAQC,EAAY,CACpC,IACAD,GAASC,EAAYH,CACvB,GACF,EArBEI,CAFAvX,EAAI,EAAwBA,IAG5B,GAAS4U,GAAU5U,IAAI,SAAU2D,EAAGhgB,GAClCqc,EAAExjB,KAAKmH,GAAGggB,EAAIA,CAChB,GACF,CCEA,SAASrG,GAAO0C,EAAGwX,GACjB,IAAIC,EAAOD,GAAQA,EAAKE,YAAc,EAAY,GAClDD,EAAK,UAAU,KACb,IAAIE,EAAcF,EAAK,sBAAsB,IA+FjD,SAA0BG,GACxB,IAAI5X,EAAI,IAAI,IAAM,CAAEoD,YAAY,EAAMyI,UAAU,IAC5C5K,EAAQ4W,GAAaD,EAAW3W,SAoBpC,OAlBAjB,EAAEsD,SACA,IAAQ,CAAC,EAAGwU,GAAeC,GAAkB9W,EAAO+W,IAAgB,EAAO/W,EAAOgX,MAGpF,IAAUL,EAAWl6B,SAAS,SAAUiG,GACtC,IAAInH,EAAOq7B,GAAaD,EAAWp7B,KAAKmH,IACxCqc,EAAEM,QAAQ3c,EAAG,IAAWo0B,GAAkBv7B,EAAM07B,IAAeC,KAC/DnY,EAAEgF,UAAUrhB,EAAGi0B,EAAWje,OAAOhW,GACnC,IAEA,IAAUi0B,EAAW5d,SAAS,SAAUve,GACtC,IAAIsf,EAAO8c,GAAaD,EAAW7c,KAAKtf,IACxCukB,EAAEa,QACAplB,EACA,IAAQ,CAAC,EAAG28B,GAAcL,GAAkBhd,EAAMsd,IAAe,EAAOtd,EAAMud,KAElF,IAEOtY,CACT,CAtHuDuY,CAAiBvY,KACpEyX,EAAK,eAAe,IAKxB,SAAmBzX,EAAGyX,GACpBA,EAAK,8BAA8B,IAyHrC,SAAgCzX,GAC9B,IAAIiB,EAAQjB,EAAEiB,QACdA,EAAMmW,SAAW,EACjB,IAAUpX,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClBsf,EAAKmL,QAAU,EACqB,MAAhCnL,EAAKa,SAAS1b,gBACM,OAAlB+gB,EAAMiE,SAAsC,OAAlBjE,EAAMiE,QAClCnK,EAAKgJ,OAAShJ,EAAKyd,YAEnBzd,EAAKkJ,QAAUlJ,EAAKyd,YAG1B,GACF,CAvI2CC,CAAuBzY,KAChEyX,EAAK,uBAAuB,IAiT9B,SAAyBzX,GACvB,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,GAAIA,EAAEkI,IAAMlI,EAAEilB,EAAG,CACf,IAAIlkB,EAAOwjB,EAAExjB,KAAKf,EAAEkI,GACfnH,EAAKk8B,YACRl8B,EAAKk8B,UAAY,IAEnBl8B,EAAKk8B,UAAUz5B,KAAK,CAAExD,EAAGA,EAAGka,MAAOqK,EAAEjF,KAAKtf,KAC1CukB,EAAEkC,WAAWzmB,EACf,CACF,GACF,CA5ToCk9B,CAAgB3Y,KAClDyX,EAAK,eAAe,IAAM,EAAYzX,KACtCyX,EAAK,wBAAwB,IAAM,GAAiBzX,KACpDyX,EAAK,YAAY,IAAMrT,GAAK,EAAwBpE,MACpDyX,EAAK,8BAA8B,IA0IrC,SAAgCzX,GAC9B,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClB,GAAIsf,EAAKgJ,OAAShJ,EAAKkJ,OAAQ,CAC7B,IAAItgB,EAAIqc,EAAExjB,KAAKf,EAAEkI,GAEbgS,EAAQ,CAAEyO,MADNpE,EAAExjB,KAAKf,EAAEilB,GACM0D,KAAOzgB,EAAEygB,MAAQ,EAAIzgB,EAAEygB,KAAM3oB,EAAGA,GACvD,EAAkBukB,EAAG,aAAcrK,EAAO,MAC5C,CACF,GACF,CApJ2CijB,CAAuB5Y,KAChEyX,EAAK,wBAAwB,IzCqI/B,SAA0BzX,GAExB,IAAItR,EAAS,IACX,IAAMsR,EAAEtiB,SAAS,SAAUiG,GACzB,OAAOqc,EAAExjB,KAAKmH,GAAGygB,IACnB,KAGE0M,EAAS,GACb,IAAU9Q,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAIygB,EAAOpE,EAAExjB,KAAKmH,GAAGygB,KAAO1V,EACvBoiB,EAAO1M,KACV0M,EAAO1M,GAAQ,IAEjB0M,EAAO1M,GAAMnlB,KAAK0E,EACpB,IAEA,IAAI4iB,EAAQ,EACR0E,EAAiBjL,EAAEiB,QAAQgK,eAC/B,IAAU6F,GAAQ,SAAUpJ,EAAInmB,GAC1B,IAAcmmB,IAAOnmB,EAAI0pB,GAAmB,IAC5C1E,EACOA,GACT,IAAUmB,GAAI,SAAU/jB,GACtBqc,EAAExjB,KAAKmH,GAAGygB,MAAQmC,CACpB,GAEJ,GACF,CyCjKqC,CAAsBvG,KACzDyX,EAAK,4BAA4B,IvB8FnC,SAAiBzX,GACf,IAAI8T,EAAa9T,EAAEiB,QACnBjB,EAAEsB,WAAWwS,EAAW/I,oBACjB+I,EAAW/I,YAClB,IAAU/K,EAAEhG,SAAS,SAAUve,GAClBukB,EAAEjF,KAAKtf,GACT+vB,aACPxL,EAAEkC,WAAWzmB,EAEjB,GACF,CuBxGyC,CAAqBukB,KAC5DyX,EAAK,sBAAsB,IzCqH7B,SAAwBzX,GACtB,IAAIjiB,EAAM,IACR,IAAMiiB,EAAEtiB,SAAS,SAAUiG,GACzB,OAAOqc,EAAExjB,KAAKmH,GAAGygB,IACnB,KAEF,IAAUpE,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GACd,IAAMnH,EAAM,UACdA,EAAK4nB,MAAQrmB,EAEjB,GACF,CyCjImC,CAAoBiiB,KACrDyX,EAAK,wBAAwB,IAkJ/B,SAA0BzX,GACxB,IAAIgM,EAAU,EACd,IAAUhM,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GACdnH,EAAK2uB,YACP3uB,EAAKuvB,QAAU/L,EAAExjB,KAAKA,EAAK2uB,WAAW/G,KACtC5nB,EAAKwvB,QAAUhM,EAAExjB,KAAKA,EAAK4uB,cAAchH,KAEzC4H,EAAU,EAAMA,EAASxvB,EAAKwvB,SAElC,IACAhM,EAAEiB,QAAQ+K,QAAUA,CACtB,CA9JqC6M,CAAiB7Y,KACpDyX,EAAK,8BAA8B,IA+JrC,SAAgCzX,GAC9B,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GACC,eAAfnH,EAAKymB,QACPjD,EAAEjF,KAAKve,EAAKf,GAAGqqB,UAAYtpB,EAAK4nB,KAChCpE,EAAEsB,WAAW3d,GAEjB,GACF,CAvK2Cm1B,CAAuB9Y,KAChEyX,EAAK,qBAAqB,IAAM,GAAczX,KAC9CyX,EAAK,yBAAyB,IAAM3F,GAAkB9R,KACtDyX,EAAK,yBAAyB,IxCjChC,SAA2BzX,GAkBzB,IAAUA,EAAEzG,YAjBZ,SAASyI,EAAIre,GACX,IAAI4V,EAAWyG,EAAEzG,SAAS5V,GACtBnH,EAAOwjB,EAAExjB,KAAKmH,GAKlB,GAJI4V,EAAS5b,QACX,IAAU4b,EAAUyI,GAGlBpgB,OAAOwK,UAAUC,eAAeP,KAAKtP,EAAM,WAAY,CACzDA,EAAKyvB,WAAa,GAClBzvB,EAAK0vB,YAAc,GACnB,IAAK,IAAI9H,EAAO5nB,EAAKuvB,QAASC,EAAUxvB,EAAKwvB,QAAU,EAAG5H,EAAO4H,IAAW5H,EAC1E,GAAcpE,EAAG,aAAc,MAAOrc,EAAGnH,EAAM4nB,GAC/C,GAAcpE,EAAG,cAAe,MAAOrc,EAAGnH,EAAM4nB,EAEpD,CACF,GAGF,CwCcsC2U,CAAkB/Y,KACtDyX,EAAK,aAAa,IAAMpT,GAAMrE,KAC9ByX,EAAK,uBAAuB,IAgT9B,SAAyBzX,GACvB,IAAI8Q,EAAS,EAAsB9Q,GACnC,IAAU8Q,GAAQ,SAAUe,GAC1B,IAAImH,EAAa,EACjB,IAAUnH,GAAO,SAAUluB,EAAGpC,GAC5B,IAAI/E,EAAOwjB,EAAExjB,KAAKmH,GAClBnH,EAAK6nB,MAAQ9iB,EAAIy3B,EACjB,IAAUx8B,EAAKk8B,WAAW,SAAUO,GAClC,EACEjZ,EACA,WACA,CACE+D,MAAOkV,EAAStjB,MAAMoO,MACtBE,OAAQgV,EAAStjB,MAAMsO,OACvBG,KAAM5nB,EAAK4nB,KACXC,MAAO9iB,KAAMy3B,EACbv9B,EAAGw9B,EAASx9B,EACZka,MAAOsjB,EAAStjB,OAElB,MAEJ,WACOnZ,EAAKk8B,SACd,GACF,GACF,CAzUoCQ,CAAgBlZ,KAClDyX,EAAK,8BAA8B,IvCrCrC,SAAgBzX,GACd,IAAIiF,EAAUjF,EAAEiB,QAAQiE,QAAQhlB,cAChB,OAAZ+kB,GAAgC,OAAZA,GACtBO,GAAgBxF,EAEpB,CuCgC2C,CAAwBA,KACjEyX,EAAK,gBAAgB,IAAMP,GAASlX,KACpCyX,EAAK,yBAAyB,IAwUhC,SAA2BzX,GACzB,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GAClB,GAAmB,aAAfnH,EAAKymB,MAAsB,CAC7B,IAAIkW,EAAWnZ,EAAExjB,KAAKA,EAAKf,EAAEkI,GACzBggB,EAAIwV,EAASxV,EAAIwV,EAASpV,MAAQ,EAClCH,EAAIuV,EAASvV,EACbC,EAAKrnB,EAAKmnB,EAAIA,EACdG,EAAKqV,EAASlV,OAAS,EAC3BjE,EAAEa,QAAQrkB,EAAKf,EAAGe,EAAKmZ,OACvBqK,EAAEsB,WAAW3d,GACbnH,EAAKmZ,MAAMyP,OAAS,CAClB,CAAEzB,EAAGA,EAAK,EAAIE,EAAM,EAAGD,EAAGA,EAAIE,GAC9B,CAAEH,EAAGA,EAAK,EAAIE,EAAM,EAAGD,EAAGA,EAAIE,GAC9B,CAAEH,EAAGA,EAAIE,EAAID,EAAGA,GAChB,CAAED,EAAGA,EAAK,EAAIE,EAAM,EAAGD,EAAGA,EAAIE,GAC9B,CAAEH,EAAGA,EAAK,EAAIE,EAAM,EAAGD,EAAGA,EAAIE,IAEhCtnB,EAAKmZ,MAAMgO,EAAInnB,EAAKmnB,EACpBnnB,EAAKmZ,MAAMiO,EAAIpnB,EAAKonB,CACtB,CACF,GACF,CA9VsCwV,CAAkBpZ,KACtDyX,EAAK,yBAAyB,IAwQhC,SAA2BzX,GACzB,IAAUA,EAAEtiB,SAAS,SAAUiG,GAC7B,GAAIqc,EAAEzG,SAAS5V,GAAGhG,OAAQ,CACxB,IAAInB,EAAOwjB,EAAExjB,KAAKmH,GACd6iB,EAAIxG,EAAExjB,KAAKA,EAAK2uB,WAChBkO,EAAIrZ,EAAExjB,KAAKA,EAAK4uB,cAChBvnB,EAAImc,EAAExjB,KAAK,IAAOA,EAAKyvB,aACvB9e,EAAI6S,EAAExjB,KAAK,IAAOA,EAAK0vB,cAE3B1vB,EAAKunB,MAAQlmB,KAAK0S,IAAIpD,EAAEwW,EAAI9f,EAAE8f,GAC9BnnB,EAAKynB,OAASpmB,KAAK0S,IAAI8oB,EAAEzV,EAAI4C,EAAE5C,GAC/BpnB,EAAKmnB,EAAI9f,EAAE8f,EAAInnB,EAAKunB,MAAQ,EAC5BvnB,EAAKonB,EAAI4C,EAAE5C,EAAIpnB,EAAKynB,OAAS,CAC/B,CACF,IAEA,IAAUjE,EAAEtiB,SAAS,SAAUiG,GACL,WAApBqc,EAAExjB,KAAKmH,GAAGsf,OACZjD,EAAEsB,WAAW3d,EAEjB,GACF,CA7RsC21B,CAAkBtZ,KACtDyX,EAAK,sBAAsB,ItC4C7B,SAAczX,GACZ,IAAUA,EAAEiB,QAAQyE,aAAa,SAAU/hB,GACzC,IAEI+c,EAFAlkB,EAAOwjB,EAAExjB,KAAKmH,GACd41B,EAAY/8B,EAAKqpB,UAGrB,IADA7F,EAAEa,QAAQrkB,EAAKupB,QAASwT,GACjB/8B,EAAKymB,OACVvC,EAAIV,EAAE6H,WAAWlkB,GAAG,GACpBqc,EAAEsB,WAAW3d,GACb41B,EAAUnU,OAAOnmB,KAAK,CAAE0kB,EAAGnnB,EAAKmnB,EAAGC,EAAGpnB,EAAKonB,IACxB,eAAfpnB,EAAKymB,QACPsW,EAAU5V,EAAInnB,EAAKmnB,EACnB4V,EAAU3V,EAAIpnB,EAAKonB,EACnB2V,EAAUxV,MAAQvnB,EAAKunB,MACvBwV,EAAUtV,OAASznB,EAAKynB,QAE1BtgB,EAAI+c,EACJlkB,EAAOwjB,EAAExjB,KAAKmH,EAElB,GACF,CsChEmC,CAAeqc,KAChDyX,EAAK,4BAA4B,IA0OnC,SAA8BzX,GAC5B,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClB,GAAImG,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,KAI7C,OAHsB,MAAlBA,EAAKa,UAAsC,MAAlBb,EAAKa,WAChCb,EAAKgJ,OAAShJ,EAAKyd,aAEbzd,EAAKa,UACX,IAAK,IACHb,EAAK4I,GAAK5I,EAAKgJ,MAAQ,EAAIhJ,EAAKyd,YAChC,MACF,IAAK,IACHzd,EAAK4I,GAAK5I,EAAKgJ,MAAQ,EAAIhJ,EAAKyd,YAIxC,GACF,CA3PyCgB,CAAqBxZ,KAC5DyX,EAAK,4BAA4B,IAAM,GAAsBzX,KAC7DyX,EAAK,sBAAsB,IA4J7B,SAAwBzX,GACtB,IAAIyZ,EAAOtT,OAAOC,kBACdsT,EAAO,EACPC,EAAOxT,OAAOC,kBACdwT,EAAO,EACP9F,EAAa9T,EAAEiB,QACf4Y,EAAU/F,EAAWgG,SAAW,EAChCC,EAAUjG,EAAWkG,SAAW,EAEpC,SAASC,EAAYlX,GACnB,IAAIY,EAAIZ,EAAMY,EACVC,EAAIb,EAAMa,EACVlD,EAAIqC,EAAMgB,MACVC,EAAIjB,EAAMkB,OACdwV,EAAO57B,KAAKE,IAAI07B,EAAM9V,EAAIjD,EAAI,GAC9BgZ,EAAO77B,KAAKC,IAAI47B,EAAM/V,EAAIjD,EAAI,GAC9BiZ,EAAO97B,KAAKE,IAAI47B,EAAM/V,EAAII,EAAI,GAC9B4V,EAAO/7B,KAAKC,IAAI87B,EAAMhW,EAAII,EAAI,EAChC,CAEA,IAAUhE,EAAEtiB,SAAS,SAAUiG,GAC7Bs2B,EAAYja,EAAExjB,KAAKmH,GACrB,IACA,IAAUqc,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GACdmG,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,MAC7Ckf,EAAYlf,EAEhB,IAEA0e,GAAQI,EACRF,GAAQI,EAER,IAAU/Z,EAAEtiB,SAAS,SAAUiG,GAC7B,IAAInH,EAAOwjB,EAAExjB,KAAKmH,GAClBnH,EAAKmnB,GAAK8V,EACVj9B,EAAKonB,GAAK+V,CACZ,IAEA,IAAU3Z,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GAClB,IAAUsf,EAAKqK,QAAQ,SAAUhY,GAC/BA,EAAEuW,GAAK8V,EACPrsB,EAAEwW,GAAK+V,CACT,IACI/3B,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,OAC7CA,EAAK4I,GAAK8V,GAER73B,OAAOwK,UAAUC,eAAeP,KAAKiP,EAAM,OAC7CA,EAAK6I,GAAK+V,EAEd,IAEA7F,EAAW/P,MAAQ2V,EAAOD,EAAOI,EACjC/F,EAAW7P,OAAS2V,EAAOD,EAAOI,CACpC,CAnNmCG,CAAela,KAChDyX,EAAK,4BAA4B,IAoNnC,SAA8BzX,GAC5B,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,IAGI0+B,EAAIC,EAHJrf,EAAOiF,EAAEjF,KAAKtf,GACd4+B,EAAQra,EAAExjB,KAAKf,EAAEkI,GACjB22B,EAAQta,EAAExjB,KAAKf,EAAEilB,GAEhB3F,EAAKqK,QAKR+U,EAAKpf,EAAKqK,OAAO,GACjBgV,EAAKrf,EAAKqK,OAAOrK,EAAKqK,OAAOznB,OAAS,KALtCod,EAAKqK,OAAS,GACd+U,EAAKG,EACLF,EAAKC,GAKPtf,EAAKqK,OAAOrc,QAAQ,EAAmBsxB,EAAOF,IAC9Cpf,EAAKqK,OAAOnmB,KAAK,EAAmBq7B,EAAOF,GAC7C,GACF,CArOyCG,CAAqBva,KAC5DyX,EAAK,qBAAqB,IAyP5B,SAAuCzX,GACrC,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,IAAIsf,EAAOiF,EAAEjF,KAAKtf,GACdsf,EAAKqH,UACPrH,EAAKqK,OAAO7N,SAEhB,GACF,CAhQkCijB,CAA8Bxa,KAC9DyX,EAAK,oBAAoB,IjDJ3B,SAAczX,GACZ,IAAUA,EAAEhG,SAAS,SAAUve,GAC7B,IAAIka,EAAQqK,EAAEjF,KAAKtf,GACnB,GAAIka,EAAMyM,SAAU,CAClBpC,EAAEkC,WAAWzmB,GAEb,IAAI0mB,EAAcxM,EAAMwM,mBACjBxM,EAAMyM,gBACNzM,EAAMwM,YACbnC,EAAEa,QAAQplB,EAAEilB,EAAGjlB,EAAEkI,EAAGgS,EAAOwM,EAC7B,CACF,GACF,CiDRiC,CAAanC,IAC9C,CAjC8Bya,CAAU9C,EAAaF,KACjDA,EAAK,sBAAsB,IAwC/B,SAA0BG,EAAYD,GACpC,IAAUC,EAAWl6B,SAAS,SAAUiG,GACtC,IAAI+2B,EAAa9C,EAAWp7B,KAAKmH,GAC7Bg3B,EAAchD,EAAYn7B,KAAKmH,GAE/B+2B,IACFA,EAAW/W,EAAIgX,EAAYhX,EAC3B+W,EAAW9W,EAAI+W,EAAY/W,EAEvB+T,EAAYpe,SAAS5V,GAAGhG,SAC1B+8B,EAAW3W,MAAQ4W,EAAY5W,MAC/B2W,EAAWzW,OAAS0W,EAAY1W,QAGtC,IAEA,IAAU2T,EAAW5d,SAAS,SAAUve,GACtC,IAAIi/B,EAAa9C,EAAW7c,KAAKtf,GAC7Bk/B,EAAchD,EAAY5c,KAAKtf,GAEnCi/B,EAAWtV,OAASuV,EAAYvV,OAC5BxjB,OAAOwK,UAAUC,eAAeP,KAAK6uB,EAAa,OACpDD,EAAW/W,EAAIgX,EAAYhX,EAC3B+W,EAAW9W,EAAI+W,EAAY/W,EAE/B,IAEAgU,EAAW3W,QAAQ8C,MAAQ4T,EAAY1W,QAAQ8C,MAC/C6T,EAAW3W,QAAQgD,OAAS0T,EAAY1W,QAAQgD,MAClD,CArEqC2W,CAAiB5a,EAAG2X,IAAa,GAEtE,CAqEA,IAAIK,GAAgB,CAAC,UAAW,UAAW,UAAW,UAAW,WAC7DF,GAAgB,CAAEV,QAAS,GAAIjD,QAAS,GAAID,QAAS,GAAIhP,QAAS,MAClE+S,GAAa,CAAC,YAAa,SAAU,UAAW,SAChDC,GAAe,CAAC,QAAS,UACzBC,GAAe,CAAEpU,MAAO,EAAGE,OAAQ,GACnCoU,GAAe,CAAC,SAAU,SAAU,QAAS,SAAU,eACvDD,GAAe,CACjBlS,OAAQ,EACRvF,OAAQ,EACRoD,MAAO,EACPE,OAAQ,EACRuU,YAAa,GACb5c,SAAU,KAER0c,GAAY,CAAC,YAkSjB,SAASP,GAAkB8C,EAAK9X,GAC9B,OAAO,EAAY,EAAO8X,EAAK9X,GAAQoD,OACzC,CAEA,SAAS0R,GAAa9U,GACpB,IAAI+X,EAAW,CAAC,EAIhB,OAHA,IAAU/X,GAAO,SAAUpf,EAAGD,GAC5Bo3B,EAASp3B,EAAExD,eAAiByD,CAC9B,IACOm3B,CACT,C,kGCpYIC,EAAoB,cAAc,aAElC,QAAO1yB,KAAM,oBACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,cACT,GAIEC,EAAc,CAChBz3B,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAIH,GAAqB,gBACpEI,gBAAgC,SAAO,IAAM,IAAI,MAAwB,oBAG7E,SAASC,EAAoBC,EAAU,KACrC,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIE,GAAQ,SACZ,OAAwB,CAAED,WAC1B,KACAL,GAGF,OADAK,EAAOE,gBAAgBC,SAASF,GACzB,CAAED,SAAQC,QACnB,EACA,QAAOH,EAAqB,sB,2lBC7CrB,SAASM,EAAiBC,GAC7B,SAASC,IAAoB,CAE7BA,EAAgBxvB,UAAYuvB,EAC5B,MAAME,EAAe,IAAID,EACzB,SAASE,IACL,cAAcD,EAAaE,GAC/B,CAQI,OALJD,IACAA,IAIWH,CAMf,CCQA,MArBA,SAAmBjd,EAAO1D,EAAOC,GAC/B,IAAIxd,GAAS,EACTE,EAAS+gB,EAAM/gB,OAEfqd,EAAQ,IACVA,GAASA,EAAQrd,EAAS,EAAKA,EAASqd,IAE1CC,EAAMA,EAAMtd,EAASA,EAASsd,GACpB,IACRA,GAAOtd,GAETA,EAASqd,EAAQC,EAAM,EAAMA,EAAMD,IAAW,EAC9CA,KAAW,EAGX,IADA,IAAIpc,EAASiO,MAAMlP,KACVF,EAAQE,GACfiB,EAAOnB,GAASihB,EAAMjhB,EAAQud,GAEhC,OAAOpc,CACT,E,UCSA,MATA,SAAc8f,EAAO3R,EAAGivB,GACtB,IAAIr+B,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACvC,OAAKA,GAGLoP,EAAKivB,QAAep+B,IAANmP,EAAmB,GAAI,EAAA4R,EAAA,GAAU5R,GACxC,EAAU2R,EAAO3R,EAAI,EAAI,EAAIA,EAAGpP,IAH9B,EAIX,E,sECxBI,EAHciE,OAAOwK,UAGQC,eA8CjC,GAZa,QAAe,SAASgW,EAAQ5gB,GAC3C,IAAI,OAAYA,KAAW,EAAA6c,EAAA,GAAY7c,IACrC,OAAWA,GAAQ,EAAAyY,EAAA,GAAKzY,GAAS4gB,QAGnC,IAAK,IAAI7D,KAAO/c,EACV,EAAeqK,KAAKrK,EAAQ+c,KAC9B,OAAY6D,EAAQ7D,EAAK/c,EAAO+c,GAGtC,I,wCCnBA,MAbA,SAAgB6D,EAAQlE,GACtB,GAAc,MAAVkE,EACF,MAAO,CAAC,EAEV,IAAI8J,GAAQ,QAAS,OAAa9J,IAAS,SAASsC,GAClD,MAAO,CAACA,EACV,IAEA,OADAxG,GAAY,OAAaA,IAClB,OAAWkE,EAAQ8J,GAAO,SAASnxB,EAAOunB,GAC/C,OAAOpE,EAAUnjB,EAAOunB,EAAK,GAC/B,GACF,E,oBCjBA,MAJA,SAAsBvnB,GACpB,OAAO,EAAAihC,EAAA,GAAajhC,IAVN,oBAUgB,OAAWA,EAC3C,E,oBCVIkhC,EAAe,KAAY,IAASC,SAqBxC,EAFeD,GAAe,OAAUA,GAAgB,ECtBxD,SAASE,EAAWC,GAChB,OAQmBxB,EARDwB,GASX,EAAAC,EAAA,GAASzB,EAAI0B,QAAwB,KAAd1B,EAAI0B,MARvBF,EAAQE,MAGRF,EAAQjgC,KAIvB,IAAuBy+B,CAFvB,CAKO,MAAM2B,EACT,cAAIh8B,GACA,OAAO6H,KAAKo0B,WAChB,CACA,cAAIj8B,CAAWxF,GACXqN,KAAKo0B,YAAczhC,CACvB,CACA,WAAAiW,CAAYwrB,GACRp0B,KAAKo0B,YAAcA,CACvB,CACA,MAAAC,CAAOC,GACHA,EAAQC,MAAMv0B,OACd,EAAA9L,EAAA,GAAQ8L,KAAK7H,YAAaq8B,IACtBA,EAAKH,OAAOC,EAAQ,GAE5B,EAEG,MAAM,UAAoBH,EAC7B,WAAAvrB,CAAY1N,GACRy3B,MAAM,IACN3yB,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,CACA,cAAInD,CAAWA,GAEf,CACA,cAAIA,GACA,YAA4B5C,IAAxByK,KAAK00B,eACE10B,KAAK00B,eAAev8B,WAExB,EACX,CACA,MAAAk8B,CAAOC,GACHA,EAAQC,MAAMv0B,KAElB,EAEG,MAAM20B,UAAaR,EACtB,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAK40B,QAAU,GACf,EAAO50B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAMu5B,UAAoBV,EAC7B,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAK80B,mBAAoB,EACzB,EAAO90B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAMy5B,UAAeZ,EACxB,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAM05B,UAA4Bb,EACrC,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAM25B,UAAyCd,EAClD,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAM45B,UAAmBf,EAC5B,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAM65B,UAAgChB,EACzC,WAAAvrB,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAM85B,UAAoBjB,EAC7B,cAAIh8B,GACA,OAAO6H,KAAKo0B,WAChB,CACA,cAAIj8B,CAAWxF,GACXqN,KAAKo0B,YAAczhC,CACvB,CACA,WAAAiW,CAAY1N,GACRy3B,MAAMz3B,EAAQ/C,YACd6H,KAAKy0B,IAAM,EACXz0B,KAAK80B,mBAAoB,EACzB90B,KAAKq1B,eAAgB,EACrB,EAAOr1B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,EAEG,MAAMg6B,EACT,WAAA1sB,CAAY1N,GACR8E,KAAKy0B,IAAM,EACX,EAAOz0B,KAAM,EAAO9E,GAAUI,QAAY/F,IAAN+F,IACxC,CACA,MAAA+4B,CAAOC,GACHA,EAAQC,MAAMv0B,KAClB,EAKG,SAASu1B,EAAoBphC,GAChC,SAASqhC,EAAkBr9B,GACvB,OAAO,OAAIA,EAAYo9B,EAC3B,CAEA,GAAIphC,aAAgB,EAAa,CAC7B,MAAMshC,EAAwB,CAC1BhhC,KAAM,cACNV,KAAMI,EAAKuhC,gBACXjB,IAAKtgC,EAAKsgC,KAKd,OAHI,EAAAR,EAAA,GAAS9/B,EAAKmZ,SACdmoB,EAAsBnoB,MAAQnZ,EAAKmZ,OAEhCmoB,CACX,CACK,GAAIthC,aAAgB0gC,EACrB,MAAO,CACHpgC,KAAM,cACN0D,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgB4gC,EACrB,MAAO,CACHtgC,KAAM,SACNggC,IAAKtgC,EAAKsgC,IACVt8B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgB6gC,EACrB,MAAO,CACHvgC,KAAM,sBACNggC,IAAKtgC,EAAKsgC,IACVt8B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgB8gC,EACrB,MAAO,CACHxgC,KAAM,mCACNggC,IAAKtgC,EAAKsgC,IACVkB,UAAYJ,EAAoB,IAAID,EAAS,CAAEM,aAAczhC,EAAKwhC,aAClEx9B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgBghC,EACrB,MAAO,CACH1gC,KAAM,0BACNggC,IAAKtgC,EAAKsgC,IACVkB,UAAYJ,EAAoB,IAAID,EAAS,CAAEM,aAAczhC,EAAKwhC,aAClEx9B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgB+gC,EACrB,MAAO,CACHzgC,KAAM,aACNggC,IAAKtgC,EAAKsgC,IACVt8B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgBihC,EACrB,MAAO,CACH3gC,KAAM,cACNggC,IAAKtgC,EAAKsgC,IACVt8B,WAAYq9B,EAAkBrhC,EAAKgE,aAGtC,GAAIhE,aAAgBmhC,EAAU,CAC/B,MAAMO,EAAqB,CACvBphC,KAAM,WACNV,KAAMI,EAAKyhC,aAAa7hC,KACxBuZ,MAAOymB,EAAW5/B,EAAKyhC,cACvBnB,IAAKtgC,EAAKsgC,MAEV,EAAAR,EAAA,GAAS9/B,EAAKmZ,SACduoB,EAAmBC,cAAgB3hC,EAAKmZ,OAE5C,MAAM4F,EAAU/e,EAAKyhC,aAAaG,QAMlC,OALI5hC,EAAKyhC,aAAaG,UAClBF,EAAmB3iB,QAAU,EAASA,GAChCA,EAAQ9Z,OACR8Z,GAEH2iB,CACX,CACK,GAAI1hC,aAAgBwgC,EACrB,MAAO,CACHlgC,KAAM,OACNV,KAAMI,EAAKJ,KACX6gC,QAASzgC,EAAKygC,QACdz8B,WAAYq9B,EAAkBrhC,EAAKgE,aAKvC,MAAMS,MAAM,uBAEpB,CC9NO,MAAM,EACT,KAAA27B,CAAMpgC,GACF,MAAM6hC,EAAU7hC,EAChB,OAAQ6hC,EAAQptB,aACZ,KAAK,EACD,OAAO5I,KAAKi2B,iBAAiBD,GACjC,KAAKnB,EACD,OAAO70B,KAAKk2B,iBAAiBF,GACjC,KAAKjB,EACD,OAAO/0B,KAAKm2B,YAAYH,GAC5B,KAAKhB,EACD,OAAOh1B,KAAKo2B,yBAAyBJ,GACzC,KAAKf,EACD,OAAOj1B,KAAKq2B,sCAAsCL,GACtD,KAAKb,EACD,OAAOn1B,KAAKs2B,6BAA6BN,GAC7C,KAAKd,EACD,OAAOl1B,KAAKu2B,gBAAgBP,GAChC,KAAKZ,EACD,OAAOp1B,KAAKw2B,iBAAiBR,GACjC,KAAKV,EACD,OAAOt1B,KAAKy2B,cAAcT,GAC9B,KAAKrB,EACD,OAAO30B,KAAK02B,UAAUV,GAE1B,QACI,MAAMp9B,MAAM,wBAExB,CAEA,gBAAAq9B,CAAiB9hC,GAAQ,CAEzB,gBAAA+hC,CAAiB/hC,GAAQ,CAEzB,WAAAgiC,CAAYhiC,GAAQ,CAEpB,eAAAoiC,CAAgBpiC,GAAQ,CAExB,wBAAAiiC,CAAyBjiC,GAAQ,CAEjC,qCAAAkiC,CAAsCliC,GAAQ,CAE9C,4BAAAmiC,CAA6BniC,GAAQ,CAErC,gBAAAqiC,CAAiBriC,GAAQ,CAEzB,aAAAsiC,CAActiC,GAAQ,CAEtB,SAAAuiC,CAAUviC,GAAQ,E,wBC5BtB,MAVA,SAAkB0hB,EAAYC,GAC5B,IAAIvf,EAMJ,OAJA,OAASsf,GAAY,SAASljB,EAAOyC,EAAOygB,GAE1C,QADAtf,EAASuf,EAAUnjB,EAAOyC,EAAOygB,GAEnC,MACStf,CACX,E,oBC+BA,MARA,SAAcsf,EAAYC,EAAW6d,GACnC,IAAIvZ,GAAO,EAAAnL,EAAA,GAAQ4G,GAAc,IAAY,EAI7C,OAHI8d,IAAS,OAAe9d,EAAYC,EAAW6d,KACjD7d,OAAYvgB,GAEP6kB,EAAKvE,GAAY,OAAaC,EAAW,GAClD,E,WCzCIM,GAAY5gB,KAAKC,IA6CrB,OAbA,SAAkBogB,EAAYljB,EAAOojB,EAAW4d,GAC9C9d,GAAa,EAAAI,EAAA,GAAYJ,GAAcA,GAAa,OAAOA,GAC3DE,EAAaA,IAAc4d,GAAS,EAAArd,EAAA,GAAUP,GAAa,EAE3D,IAAIzgB,EAASugB,EAAWvgB,OAIxB,OAHIygB,EAAY,IACdA,EAAYK,GAAU9gB,EAASygB,EAAW,KAErC,EAAAke,EAAA,GAASpe,GACXE,GAAazgB,GAAUugB,EAAWxI,QAAQ1a,EAAOojB,IAAc,IAC7DzgB,IAAU,QAAYugB,EAAYljB,EAAOojB,IAAc,CAChE,EC5BA,OAZA,SAAoBM,EAAOP,GAIzB,IAHA,IAAI1gB,GAAS,EACTE,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,SAE9BF,EAAQE,GACf,IAAKwgB,EAAUO,EAAMjhB,GAAQA,EAAOihB,GAClC,OAAO,EAGX,OAAO,CACT,ECAA,OATA,SAAmBR,EAAYC,GAC7B,IAAIvf,GAAS,EAKb,OAJA,OAASsf,GAAY,SAASljB,EAAOyC,EAAOygB,GAE1C,OADAtf,IAAWuf,EAAUnjB,EAAOyC,EAAOygB,EAErC,IACOtf,CACT,ECqCA,OARA,SAAesf,EAAYC,EAAW6d,GACpC,IAAIvZ,GAAO,EAAAnL,EAAA,GAAQ4G,GAAc,GAAa,GAI9C,OAHI8d,IAAS,OAAe9d,EAAYC,EAAW6d,KACjD7d,OAAYvgB,GAEP6kB,EAAKvE,GAAY,OAAaC,EAAW,GAClD,ECzCO,SAAS6gB,GAAenC,EAAMoC,EAAiB,IAIlD,SAH2BpC,aAAgBO,GACvCP,aAAgBU,GAChBV,aAAgBW,KAOhBX,aAAgBY,EAET,EAAKZ,EAAKr8B,YAAa0+B,GACnBF,GAAeE,EAASD,OAG9BpC,aAAgB,GAAe,GAASoC,EAAgBpC,MAIxDA,aAAgBL,IACjBK,aAAgB,GAChBoC,EAAehgC,KAAK49B,GAEjB,GAAMA,EAAKr8B,YAAa0+B,GACpBF,GAAeE,EAASD,OAM3C,CAIO,SAASE,GAAqBtC,GAEjC,GAAIA,aAAgB,EAChB,MAAO,UAEN,GAAIA,aAAgBO,EACrB,MAAO,SAEN,GAAIP,aAAgBY,EACrB,MAAO,KAEN,GAAIZ,aAAgBQ,EACrB,MAAO,eAEN,GAAIR,aAAgBS,EACrB,MAAO,mBAEN,GAAIT,aAAgBW,EACrB,MAAO,WAEN,GAAIX,aAAgBU,EACrB,MAAO,OAEN,GAAIV,aAAgBc,EACrB,MAAO,UAIP,MAAM18B,MAAM,uBAEpB,CCxEO,MAAMm+B,GACT,IAAAC,CAAKxC,EAAMyC,EAAW,KAClB,EAAA/iC,EAAA,GAAQsgC,EAAKr8B,YAAY,CAAC0+B,EAASzhC,KAC/B,MAAM8hC,EAAW,EAAK1C,EAAKr8B,WAAY/C,EAAQ,GAE/C,GAAIyhC,aAAmB,EACnB72B,KAAKm3B,YAAYN,EAASK,EAAUD,QAEnC,GAAIJ,aAAmBvB,EACxBt1B,KAAKo3B,aAAaP,EAASK,EAAUD,QAEpC,GAAIJ,aAAmBhC,EACxB70B,KAAKq3B,SAASR,EAASK,EAAUD,QAEhC,GAAIJ,aAAmB9B,EACxB/0B,KAAKs3B,WAAWT,EAASK,EAAUD,QAElC,GAAIJ,aAAmB7B,EACxBh1B,KAAKu3B,eAAeV,EAASK,EAAUD,QAEtC,GAAIJ,aAAmB5B,EACxBj1B,KAAKw3B,kBAAkBX,EAASK,EAAUD,QAEzC,GAAIJ,aAAmB1B,EACxBn1B,KAAKy3B,YAAYZ,EAASK,EAAUD,QAEnC,GAAIJ,aAAmB3B,EACxBl1B,KAAK03B,SAASb,EAASK,EAAUD,OAEhC,MAAIJ,aAAmBzB,GAIxB,MAAMx8B,MAAM,wBAHZoH,KAAK23B,OAAOd,EAASK,EAAUD,EAInC,IAER,CACA,YAAAG,CAAa5iC,EAAU0iC,EAAUD,GAAY,CAC7C,WAAAE,CAAYS,EAASV,EAAUD,GAAY,CAC3C,QAAAI,CAASQ,EAAUX,EAAUD,GAEzB,MAAMa,EAAaZ,EAAS1jC,OAAOyjC,GACnCj3B,KAAKg3B,KAAKa,EAAUC,EACxB,CACA,UAAAR,CAAWS,EAAYb,EAAUD,GAE7B,MAAMa,EAAaZ,EAAS1jC,OAAOyjC,GACnCj3B,KAAKg3B,KAAKe,EAAYD,EAC1B,CACA,cAAAP,CAAeS,EAAgBd,EAAUD,GAErC,MAAMgB,EAAqB,CACvB,IAAIlD,EAAO,CAAE58B,WAAY6/B,EAAe7/B,cAC1C3E,OAAO0jC,EAAUD,GACnBj3B,KAAKg3B,KAAKgB,EAAgBC,EAC9B,CACA,iBAAAT,CAAkBU,EAAmBhB,EAAUD,GAE3C,MAAMkB,EAAwBC,GAA+BF,EAAmBhB,EAAUD,GAC1Fj3B,KAAKg3B,KAAKkB,EAAmBC,EACjC,CACA,QAAAT,CAASW,EAAUnB,EAAUD,GAEzB,MAAMqB,EAAe,CACjB,IAAIvD,EAAO,CAAE58B,WAAYkgC,EAASlgC,cACpC3E,OAAO0jC,EAAUD,GACnBj3B,KAAKg3B,KAAKqB,EAAUC,EACxB,CACA,WAAAb,CAAYc,EAAarB,EAAUD,GAE/B,MAAMuB,EAAkBJ,GAA+BG,EAAarB,EAAUD,GAC9Ej3B,KAAKg3B,KAAKuB,EAAaC,EAC3B,CACA,MAAAb,CAAOc,EAAQvB,EAAUD,GAErB,MAAMa,EAAaZ,EAAS1jC,OAAOyjC,IAEnC,EAAA/iC,EAAA,GAAQukC,EAAOtgC,YAAaugC,IAIxB,MAAMC,EAAc,IAAI9D,EAAY,CAAE18B,WAAY,CAACugC,KACnD14B,KAAKg3B,KAAK2B,EAAab,EAAW,GAE1C,EAEJ,SAASM,GAA+BQ,EAAY1B,EAAUD,GAS1D,MARmB,CACf,IAAIlC,EAAO,CACP58B,WAAY,CACR,IAAIm9B,EAAS,CAAEM,aAAcgD,EAAWjD,aAC1CniC,OAAOolC,EAAWzgC,eAGM3E,OAAO0jC,EAAUD,EAEvD,C,eC7EA,OAJA,SAAc5gB,GACZ,OAAQA,GAASA,EAAM/gB,QAAU,QAAS+gB,GAAS,EACrD,E,WCpBO,SAASzgB,GAAM4+B,GAElB,GAAIA,aAAgB,EAShB,OAAO5+B,GAAM4+B,EAAKE,gBAEjB,GAAIF,aAAgBc,EACrB,MAqCG,CArCqBd,EAqCXoB,cAnCZ,GHhBF,SAAwBpB,GAC3B,OAAQA,aAAgBK,GACpBL,aAAgBO,GAChBP,aAAgBU,GAChBV,aAAgBQ,GAChBR,aAAgBS,GAChBT,aAAgBW,GAChBX,aAAgBc,GAChBd,aAAgBG,CACxB,CGOakE,CAAerE,GACpB,OASD,SAA0BA,GAC7B,IAAIsE,EAAW,GACf,MAAMC,EAAMvE,EAAKr8B,WACjB,IAEI6gC,EAFAC,EAAiB,EACjBC,EAAyBH,EAAIzjC,OAAS2jC,EAGtCE,GAA0B,EAE9B,KAAOD,GAA0BC,GAC7BH,EAAcD,EAAIE,GAClBE,EAA0BxC,GAAeqC,GACzCF,EAAWA,EAAStlC,OAAOoC,GAAMojC,IACjCC,GAAkC,EAClCC,EAAyBH,EAAIzjC,OAAS2jC,EAE1C,OAAO,GAAKH,EAChB,CA1BeM,CAAiB5E,GAEvB,GHuBF,SAAyBA,GAC5B,OAAOA,aAAgBY,CAC3B,CGzBaiE,CAAgB7E,GACrB,OAwBD,SAA2BA,GAC9B,MAAM8E,GAAwB,OAAI9E,EAAKr8B,YAAaohC,GACzC3jC,GAAM2jC,KAEjB,OAAO,IAAK,QAAQD,GACxB,CA7BeE,CAAkBhF,GAGzB,MAAM57B,MAAM,uBAEpB,CC1BO,MAAM,GAAK,SCMX,MAAM6gC,WAA4B1C,GACrC,WAAAnuB,CAAY8wB,GACR/G,QACA3yB,KAAK05B,QAAUA,EACf15B,KAAK25B,QAAU,CAAC,CACpB,CACA,YAAAC,GAEI,OADA55B,KAAKg3B,KAAKh3B,KAAK05B,SACR15B,KAAK25B,OAChB,CACA,YAAAvC,CAAa5iC,EAAU0iC,EAAUD,GAEjC,CACA,WAAAE,CAAYS,EAASV,EAAUD,GAC3B,MAAM4C,GAgBgCtM,EAhBWqK,EAAQlD,eAgBZoF,EAhB4BlC,EAAQnD,IAiB9ElH,EAAMx5B,KAAO+lC,EAAoB,GAhBhC95B,KAAK05B,QAAQ3lC,MAelB,IAAuCw5B,EAAOuM,EAd7C,MAAMC,EAAW7C,EAAS1jC,OAAOyjC,GAE3B+C,EAAuBpkC,GADZ,IAAIi/B,EAAY,CAAE18B,WAAY4hC,KAE/C/5B,KAAK25B,QAAQE,GAAcG,CAC/B,E,2DCYJ,OAhBA,SAAgBlkB,GACd,GAAwB,mBAAbA,EACT,MAAM,IAAImkB,UAxBQ,uBA0BpB,OAAO,WACL,IAAI12B,EAAOG,UACX,OAAQH,EAAKjO,QACX,KAAK,EAAG,OAAQwgB,EAAUrS,KAAKzD,MAC/B,KAAK,EAAG,OAAQ8V,EAAUrS,KAAKzD,KAAMuD,EAAK,IAC1C,KAAK,EAAG,OAAQuS,EAAUrS,KAAKzD,KAAMuD,EAAK,GAAIA,EAAK,IACnD,KAAK,EAAG,OAAQuS,EAAUrS,KAAKzD,KAAMuD,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAE9D,OAAQuS,EAAUhQ,MAAM9F,KAAMuD,EAChC,CACF,ECQA,OALA,SAAgBsS,EAAYC,GAE1B,QADW,EAAA7G,EAAA,GAAQ4G,GAAc,KAAc,MACnCA,EAAY,IAAO,OAAaC,EAAW,IACzD,E,WCvCI,GAAYtgB,KAAKC,IAqCrB,OAZA,SAAiB4gB,EAAO1jB,EAAOojB,GAC7B,IAAIzgB,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACvC,IAAKA,EACH,OAAQ,EAEV,IAAIF,EAAqB,MAAb2gB,EAAoB,GAAI,EAAAO,EAAA,GAAUP,GAI9C,OAHI3gB,EAAQ,IACVA,EAAQ,GAAUE,EAASF,EAAO,KAE7B,QAAYihB,EAAO1jB,EAAOyC,EACnC,E,kEC2BA,OA7CA,SAAwBihB,EAAO0N,EAAQ7N,EAAUgkB,GAC/C,IAAI9kC,GAAS,EACT4F,EAAW,KACXm/B,GAAW,EACX7kC,EAAS+gB,EAAM/gB,OACfiB,EAAS,GACT6jC,EAAerW,EAAOzuB,OAE1B,IAAKA,EACH,OAAOiB,EAEL2f,IACF6N,GAAS,OAASA,GAAQ,OAAU7N,KAElCgkB,GACFl/B,EAAW,KACXm/B,GAAW,GAEJpW,EAAOzuB,QA/BK,MAgCnB0F,EAAW,KACXm/B,GAAW,EACXpW,EAAS,IAAI,KAASA,IAExBsW,EACA,OAASjlC,EAAQE,GAAQ,CACvB,IAAI3C,EAAQ0jB,EAAMjhB,GACdklC,EAAuB,MAAZpkB,EAAmBvjB,EAAQujB,EAASvjB,GAGnD,GADAA,EAASunC,GAAwB,IAAVvnC,EAAeA,EAAQ,EAC1CwnC,GAAYG,GAAaA,EAAU,CAErC,IADA,IAAIC,EAAcH,EACXG,KACL,GAAIxW,EAAOwW,KAAiBD,EAC1B,SAASD,EAGb9jC,EAAOK,KAAKjE,EACd,MACUqI,EAAS+oB,EAAQuW,EAAUJ,IACnC3jC,EAAOK,KAAKjE,EAEhB,CACA,OAAO4D,CACT,E,iCChCA,IANiB,SAAS,SAAS8f,EAAO0N,GACxC,OAAO,EAAAyW,GAAA,GAAkBnkB,GACrB,GAAeA,GAAO,QAAY0N,EAAQ,EAAGyW,GAAA,GAAmB,IAChE,EACN,ICAA,OAfA,SAAiBnkB,GAMf,IALA,IAAIjhB,GAAS,EACTE,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACnCmlC,EAAW,EACXlkC,EAAS,KAEJnB,EAAQE,GAAQ,CACvB,IAAI3C,EAAQ0jB,EAAMjhB,GACdzC,IACF4D,EAAOkkC,KAAc9nC,EAEzB,CACA,OAAO4D,CACT,ECNA,OAJA,SAAc8f,GACZ,OAAQA,GAASA,EAAM/gB,OAAU+gB,EAAM,QAAK9gB,CAC9C,E,UCpBO,SAASmlC,GAAYC,GAEpBxe,SAAWA,QAAQrZ,OACnBqZ,QAAQrZ,MAAM,UAAU63B,IAEhC,CACO,SAASC,GAAcD,GAEtBxe,SAAWA,QAAQ0e,MAEnB1e,QAAQ0e,KAAK,YAAYF,IAEjC,CCXA,IAAIG,GAAiB,CAAC,EACtB,MAAMC,GAAe,IAAI,KAClB,SAASC,GAAaC,GACzB,MAAMC,EAAYD,EAAO5jB,WACzB,GAAIyjB,GAAe92B,eAAek3B,GAC9B,OAAOJ,GAAeI,GAErB,CACD,MAAMC,EAAYJ,GAAa7nB,QAAQgoB,GAEvC,OADAJ,GAAeI,GAAaC,EACrBA,CACX,CACJ,CCRA,MAAMC,GAAyB,gEAClBC,GAA8B,oDACpC,SAASC,GAA8BL,EAAQM,GAAsB,GACxE,IACI,MAAMC,EAAMR,GAAaC,GAEzB,OADmBQ,GAA0BD,EAAI7oC,MAAO,CAAC,EAAG6oC,EAAIxiC,MAAM0iC,WAE1E,CACA,MAAOtoC,GAIH,GAAIA,EAAEuoC,UAAYP,GACVG,GACAX,GAAc,GAAGS,6BACcJ,EAAO5jB,kOAMzC,CACD,IAAIukB,EAAY,GACZL,IACAK,EACI,gKAGRlB,GAAY,GAAGW,2BACYJ,EAAO5jB,0IAG9BukB,EACR,CACJ,CACA,MAAO,EACX,CACO,SAASH,GAA0BD,EAAKjlC,EAAQmlC,GACnD,OAAQF,EAAI/mC,MACR,IAAK,cACD,IAAK,IAAIyE,EAAI,EAAGA,EAAIsiC,EAAI7oC,MAAM2C,OAAQ4D,IAClCuiC,GAA0BD,EAAI7oC,MAAMuG,GAAI3C,EAAQmlC,GAEpD,MACJ,IAAK,cACD,MAAMG,EAAQL,EAAI7oC,MAClB,IAAK,IAAIuG,EAAI,EAAGA,EAAI2iC,EAAMvmC,OAAQ4D,IAAK,CACnC,MAAM4iC,EAAOD,EAAM3iC,GAEnB,OAAQ4iC,EAAKrnC,MACT,IAAK,YAIL,IAAK,qBAEL,IAAK,YACL,IAAK,oBACL,IAAK,cACL,IAAK,eACL,IAAK,kBACD,SAER,MAAMsnC,EAAOD,EACb,OAAQC,EAAKtnC,MACT,IAAK,YACDunC,GAAwBD,EAAKppC,MAAO4D,EAAQmlC,GAC5C,MACJ,IAAK,MACD,IAAwB,IAApBK,EAAKE,WACL,MAAMrjC,MAAMwiC,KAEhB,EAAAlnC,EAAA,GAAQ6nC,EAAKppC,OAAQupC,IACjB,GAAoB,iBAATA,EACPF,GAAwBE,EAAM3lC,EAAQmlC,OAErC,CAED,MAAMvhC,EAAQ+hC,EAEd,IAAmB,IAAfR,EACA,IAAK,IAAIS,EAAYhiC,EAAMiiC,KAAMD,GAAahiC,EAAMkiC,GAAIF,IACpDH,GAAwBG,EAAW5lC,EAAQmlC,OAI9C,CAED,IAAK,IAAIS,EAAYhiC,EAAMiiC,KAAMD,GAAahiC,EAAMkiC,IAAMF,EAAYG,GAAoBH,IACtFH,GAAwBG,EAAW5lC,EAAQmlC,GAG/C,GAAIvhC,EAAMkiC,IAAMC,GAAoB,CAChC,MAAMC,EAAcpiC,EAAMiiC,MAAQE,GAC5BniC,EAAMiiC,KACNE,GACAE,EAAcriC,EAAMkiC,GACpBI,EAAYC,GAAyBH,GACrCI,EAAYD,GAAyBF,GAC3C,IAAK,IAAII,EAAaH,EAAWG,GAAcD,EAAWC,IACtDrmC,EAAOqmC,GAAcA,CAE7B,CACJ,CACJ,KAEJ,MACJ,IAAK,QACDnB,GAA0BM,EAAKppC,MAAO4D,EAAQmlC,GAC9C,MAEJ,QACI,MAAM9iC,MAAM,wBAGpB,MAAMikC,OAA2CtnC,IAApBwmC,EAAKe,YAAwD,IAA5Bf,EAAKe,WAAWC,QAC9E,GAGe,UAAdhB,EAAKtnC,OAA8C,IAA1BuoC,GAAgBjB,IAEvB,UAAdA,EAAKtnC,OAA6C,IAAzBooC,EAC1B,KAER,CACA,MAEJ,QACI,MAAMjkC,MAAM,yBAGpB,OAAO,OAAOrC,EAClB,CACA,SAASylC,GAAwBE,EAAM3lC,EAAQmlC,GAC3C,MAAMuB,EAAmBP,GAAyBR,GAClD3lC,EAAO0mC,GAAoBA,GACR,IAAfvB,GAIR,SAA0BQ,EAAM3lC,GAC5B,MAAM2mC,EAAOC,OAAOC,aAAalB,GAC3BmB,EAAYH,EAAKI,cAEvB,GAAID,IAAcH,EAAM,CACpB,MAAMD,EAAmBP,GAAyBW,EAAUE,WAAW,IACvEhnC,EAAO0mC,GAAoBA,CAC/B,KACK,CACD,MAAMO,EAAYN,EAAKrlC,cACvB,GAAI2lC,IAAcN,EAAM,CACpB,MAAMD,EAAmBP,GAAyBc,EAAUD,WAAW,IACvEhnC,EAAO0mC,GAAoBA,CAC/B,CACJ,CACJ,CAlBQQ,CAAiBvB,EAAM3lC,EAE/B,CAiBA,SAASmnC,GAASzlB,EAAS0lB,GACvB,OAAO,EAAAxqC,GAAA,GAAK8kB,EAAQtlB,OAAQirC,IACxB,GAA2B,iBAAhBA,EACP,OAAO,GAASD,EAAiBC,GAEhC,CAED,MAAMzjC,EAAQyjC,EACd,YAAsGroC,KAA9F,EAAApC,GAAA,GAAKwqC,GAAkBE,GAAe1jC,EAAMiiC,MAAQyB,GAAcA,GAAc1jC,EAAMkiC,IAClG,IAER,CACA,SAASW,GAAgBxB,GACrB,MAAMsB,EAAatB,EAAIsB,WACvB,SAAIA,GAAqC,IAAvBA,EAAWC,YAGxBvB,EAAI7oC,SAGF,EAAAsc,EAAA,GAAQusB,EAAI7oC,OACb,GAAM6oC,EAAI7oC,MAAOqqC,IACjBA,GAAgBxB,EAAI7oC,OAC9B,CACA,MAAMmrC,WAAuB,KACzB,WAAAl1B,CAAY+0B,GACRhL,QACA3yB,KAAK29B,gBAAkBA,EACvB39B,KAAK+9B,OAAQ,CACjB,CACA,aAAAC,CAAc7pC,GAEV,IAAmB,IAAf6L,KAAK+9B,MAAT,CAKA,OAAQ5pC,EAAKM,MACT,IAAK,YAED,YADAuL,KAAKi+B,eAAe9pC,GAExB,IAAK,oBAED,YADA6L,KAAKk+B,uBAAuB/pC,GAGpCw+B,MAAMqL,cAAc7pC,EAXpB,CAYJ,CACA,cAAAgqC,CAAehqC,GACP,GAAS6L,KAAK29B,gBAAiBxpC,EAAKxB,SACpCqN,KAAK+9B,OAAQ,EAErB,CACA,QAAAK,CAASjqC,GACDA,EAAK8nC,gBACwC1mC,IAAzCmoC,GAASvpC,EAAM6L,KAAK29B,mBACpB39B,KAAK+9B,OAAQ,QAI4BxoC,IAAzCmoC,GAASvpC,EAAM6L,KAAK29B,mBACpB39B,KAAK+9B,OAAQ,EAGzB,EAEG,SAASM,GAAiBC,EAAWprB,GACxC,GAAIA,aAAmBvZ,OAAQ,CAC3B,MAAM6hC,EAAMR,GAAa9nB,GACnBqrB,EAAiB,IAAIT,GAAeQ,GAE1C,OADAC,EAAehK,MAAMiH,GACd+C,EAAeR,KAC1B,CAEI,YAEOxoC,KAFC,EAAApC,GAAA,GAAK+f,GAAUgqB,GACZ,GAASoB,EAAWpB,EAAKK,WAAW,KAGvD,CCxOA,MAAMxH,GAAU,UACHyI,GAAe,cACfC,GAAQ,QACd,IAAIC,GAAsD,kBAA9B,IAAI/kC,OAAO,QAAQglC,OAO/C,SAASC,GAAkBC,EAAY3jC,GAS1C,MAAM4jC,GARN5jC,GAAU,EAAA6jC,GAAA,GAAS7jC,EAAS,CACxB8jC,UAAWN,GACXnwB,OAAO,EACP0wB,UAAU,EACVC,iBAAkB,OAClBC,yBAA0B,CAAC,KAAM,MACjCL,OAAQ,CAACnE,EAAKjiC,IAAWA,OAENomC,OAIvB,IAAIM,EAHJN,EAAO,mCAAmC,MAw0B9C,WACI,IAAI,EAAAO,EAAA,GAAQC,IAA4B,CACpCA,GAA4B,IAAI96B,MAAM,OACtC,IAAK,IAAItL,EAAI,EAAGA,EAAI,MAAOA,IACvBomC,GAA0BpmC,GAAKA,EAAI,IAAM,OAASA,EAAI,KAAOA,CAErE,CACJ,CA90BQqmC,EAAiC,IAGrCT,EAAO,mBAAmB,KACtBM,EAAoB,GAAOP,GAAaW,GAC7BA,EAASzJ,MAAa0J,GAAMC,IACrC,IAEN,IACIC,EA2EAC,EACAC,EACAC,EACAC,EACAC,EA+BAC,EAgBAC,EACAC,EACAC,EACAC,EAlIAC,GAAY,EAEhBxB,EAAO,sBAAsB,KACzBwB,GAAY,EACZX,GAAyB,OAAIP,GAAoBI,IAC7C,MAAMe,EAAcf,EAASzJ,IAE7B,GAAI,EAASwK,GAAc,CACvB,MAAMC,EAAeD,EAAYnnC,OACjC,OAA4B,IAAxBonC,EAAalrC,QAEI,MAAjBkrC,GACiB,MAAjBA,GACiB,MAAjBA,GACCD,EAAY7E,WAGgB,IAAxB8E,EAAalrC,QACE,OAApBkrC,EAAa,IAEZ,GAAS,CACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACDA,EAAa,IAOTtlC,EAAQ8jC,UACTyB,GAAcF,GACdG,GAAgBH,GALfC,EAAa,GA1BbA,CAiCf,CACK,IAAI,EAAAG,GAAA,GAAWJ,GAGhB,OAFAD,GAAY,EAEL,CAAE72B,KAAM82B,GAEd,GAA2B,iBAAhBA,EAGZ,OAFAD,GAAY,EAELC,EAEN,GAA2B,iBAAhBA,EAA0B,CACtC,GAA2B,IAAvBA,EAAYjrC,OACZ,OAAOirC,EAEN,CACD,MAAMK,EAAsBL,EAAYr5B,QAAQ,sBAAuB,QACjE25B,EAAgB,IAAIlnC,OAAOinC,GACjC,OAAO1lC,EAAQ8jC,UACTyB,GAAcI,GACdH,GAAgBG,EAC1B,CACJ,CAEI,MAAMjoC,MAAM,uBAChB,GACF,IAONkmC,EAAO,gBAAgB,KACnBc,GAAmB,OAAIR,GAAoBI,GAAaA,EAASsB,eACjEjB,GAAoB,OAAIT,GAAoB2B,IACxC,MAAMC,EAAYD,EAAME,MAExB,GAAID,IAAcvB,GAAMyB,QAAxB,CAGK,IAAI,EAAAjN,EAAA,GAAS+M,GACd,OAAOA,EAEN,IAAI,EAAAG,GAAA,GAAYH,GACjB,OAAO,EAGP,MAAMpoC,MAAM,uBAChB,KAEJknC,GAA8B,OAAIV,GAAoB2B,IAClD,MAAMK,EAAgBL,EAAMM,WAC5B,GAAID,EAAe,CAIf,OAHwB,EAAAnyB,EAAA,GAAQmyB,IAC1B,OAAIA,GAAgB3sC,GAAS,GAAQ2qC,EAAmB3qC,KACxD,CAAC,GAAQ2qC,EAAmBgC,GAEtC,KAEJrB,GAAuB,OAAIX,GAAoB2B,GAAUA,EAAMO,YAC/DtB,GAAsB,OAAIZ,GAAoB2B,IAAU,EAAAjtC,EAAA,GAAIitC,EAAO,aAAY,IAGnFjC,EAAO,4BAA4B,KAC/B,MAAMyC,EAA0BC,GAAatmC,EAAQikC,0BACrDc,GAAgC,OAAIb,GAAoBpL,IAAY,IACnC,eAA7B94B,EAAQgkC,mBACRe,GAAgC,OAAIb,GAAoBpL,IAChD,EAAAlgC,EAAA,GAAIkgC,EAAS,iBACJA,EAAQyN,aAGmD,IAA5DC,GAAsB1N,EAASuN,IACnClD,GAAiBkD,EAAyBvN,EAAQ+B,WAGlE,IAMJ+I,EAAO,mBAAmB,KACtBoB,GAAuB,OAAId,EAAmBuC,IAC9CxB,GAAoB,OAAIR,EAAwBiC,IAChDxB,GAAc,EAAA9T,GAAA,GAAO8S,GAAmB,CAAC1f,EAAKqhB,KAC1C,MAAMC,EAAYD,EAAME,MAIxB,OAHI,EAAAhN,EAAA,GAAS+M,IAAgBA,IAAcvB,GAAMyB,UAC7CxhB,EAAIshB,GAAa,IAEdthB,CAAG,GACX,CAAC,GACJ2gB,GAAqB,OAAIV,GAAwB,CAACrkB,EAAGmZ,KAC1C,CACHvhB,QAASysB,EAAuBlL,GAChCoN,UAAW/B,EAA4BrL,GACvCqN,kBAAmB7B,EAA8BxL,GACjDsN,SAAU7B,EAAqBzL,GAC/BuN,MAAO7B,EAAkB1L,GACzBv6B,MAAO2lC,EAAkBpL,GACzB79B,KAAMmpC,EAAqBtL,GAC3BlwB,IAAKy7B,EAAoBvL,GACzBqM,aAAclB,EAAiBnL,GAC/BwN,UAAW7C,EAAkB3K,MAEnC,IAEN,IAAIyN,GAAiB,EACjBC,EAA+B,GAkEnC,OAjEKjnC,EAAQ+jC,UACTH,EAAO,2BAA2B,KAC9BqD,GAA+B,EAAA7V,GAAA,GAAO8S,GAAmB,CAAC7oC,EAAQ6rC,EAAa3N,KAC3E,GAAmC,iBAAxB2N,EAAYrM,QAAsB,CACzC,MACMsM,EAAe3F,GADJ0F,EAAYrM,QAAQwH,WAAW,IAEhD+E,GAAiB/rC,EAAQ8rC,EAAchC,EAAmB5L,GAC9D,MACK,IAAI,EAAAxlB,EAAA,GAAQmzB,EAAYG,kBAAmB,CAC5C,IAAIC,GACJ,EAAAtuC,EAAA,GAAQkuC,EAAYG,kBAAmBE,IACnC,MAGMC,EAAmBhG,GAHa,iBAAd+F,EAClBA,EAAUlF,WAAW,GACrBkF,GAMFD,IAAqBE,IACrBF,EAAmBE,EACnBJ,GAAiB/rC,EAAQmsC,EAAkBrC,EAAmB5L,IAClE,GAER,MACK,GAAI,EAAS2N,EAAYrM,SAC1B,GAAIqM,EAAYrM,QAAQ4M,QACpBT,GAAiB,EACbhnC,EAAQqgC,qBACRb,GAAY,GAAGW,2BACc+G,EAAYrM,QAAQ1e,8QAMpD,CACD,MAAMurB,EAAiBtH,GAA8B8G,EAAYrM,QAAS76B,EAAQqgC,sBAI9E,EAAA8D,EAAA,GAAQuD,KAIRV,GAAiB,IAErB,EAAAhuC,EAAA,GAAQ0uC,GAAiB1G,IACrBoG,GAAiB/rC,EAAQ2lC,EAAMmE,EAAmB5L,GAAK,GAE/D,MAGIv5B,EAAQqgC,qBACRb,GAAY,GAAGW,mBACM+G,EAAYruC,qPAIrCmuC,GAAiB,EAErB,OAAO3rC,CAAM,GACd,GAAG,IAGP,CACH6pC,YAAaA,EACbC,mBAAoBA,EACpB8B,6BAA8BA,EAC9B7B,UAAWA,EACX4B,eAAgBA,EAExB,CACO,SAASW,GAAiBhE,EAAYiE,GACzC,IAAIC,EAAS,GACb,MAAMC,EAqBH,SAA6BnE,GAChC,MAAMoE,GAA+B,EAAAxvC,GAAA,GAAOorC,GAAaW,KAC7C,EAAA1rC,EAAA,GAAI0rC,EAAUzJ,MAEpBgN,GAAS,OAAIE,GAA+BzD,IACvC,CACH7D,QAAS,iBACL6D,EAASzrC,KACT,uCACJU,KAAMyuC,GAAyBC,gBAC/BtE,WAAY,CAACW,OAGf4D,EAAQ,GAAWvE,EAAYoE,GACrC,MAAO,CAAEF,SAAQK,QACrB,CApC0BC,CAAoBxE,GAC1CkE,EAASA,EAAOvvC,OAAOwvC,EAAcD,QACrC,MAAMO,EAmCH,SAA6BzE,GAChC,MAAM0E,GAA+B,EAAA9vC,GAAA,GAAOorC,GAAaW,IACrD,MAAMtsB,EAAUssB,EAASzJ,IACzB,QAAS,EAAS7iB,KACb,EAAAytB,GAAA,GAAWztB,KACX,EAAApf,EAAA,GAAIof,EAAS,UACb,EAAA+gB,EAAA,GAAS/gB,GAAS,IAErB6vB,GAAS,OAAIQ,GAA+B/D,IACvC,CACH7D,QAAS,iBACL6D,EAASzrC,KADJ,0JAITU,KAAMyuC,GAAyBM,gBAC/B3E,WAAY,CAACW,OAGf4D,EAAQ,GAAWvE,EAAY0E,GACrC,MAAO,CAAER,SAAQK,QACrB,CAvD0BK,CAAoBT,EAAcI,OAClDM,EAAkBJ,EAAcF,MAMtC,OALAL,EAASA,EAAOvvC,OAAO8vC,EAAcP,QACrCA,EAASA,EAAOvvC,OAMpB,SAA+BqrC,GAC3B,IAAIkE,EAAS,GACb,MAAMY,GAAqB,EAAAlwC,GAAA,GAAOorC,GAAauD,GAAgB,EAASA,EAAYrM,OAMpF,OALAgN,EAASA,EAAOvvC,OA6Cb,SAA8BqrC,GACjC,MAAM+E,UAAwB,KAC1B,WAAAh7B,GACI+pB,SAASjvB,WACT1D,KAAK+9B,OAAQ,CACjB,CACA,cAAA8F,CAAe1vC,GACX6L,KAAK+9B,OAAQ,CACjB,EAEJ,MAAM+F,GAAe,EAAArwC,GAAA,GAAOorC,GAAaW,IACrC,MAAMtsB,EAAUssB,EAASzJ,QACzB,IACI,MAAMgO,EAAY/I,GAAa9nB,GACzB8wB,EAAmB,IAAIJ,EAE7B,OADAI,EAAiBzP,MAAMwP,GAChBC,EAAiBjG,KAC5B,CACA,MAAO3qC,GAGH,OAAO6wC,GAAaC,KAAKhxB,EAAQ9Z,OACrC,KAEE2pC,GAAS,OAAIe,GAAetE,IACvB,CACH7D,QAAS,oDAEL6D,EAASzrC,KAFJ,+IAMTU,KAAMyuC,GAAyBiB,iBAC/BtF,WAAY,CAACW,OAGrB,OAAOuD,CACX,CAlF2BqB,CAAqBT,IAC5CZ,EAASA,EAAOvvC,OAmGb,SAAgCqrC,GACnC,MAAMwF,UAA0B,KAC5B,WAAAz7B,GACI+pB,SAASjvB,WACT1D,KAAK+9B,OAAQ,CACjB,CACA,gBAAAuG,CAAiBnwC,GACb6L,KAAK+9B,OAAQ,CACjB,EAEJ,MAAM+F,GAAe,EAAArwC,GAAA,GAAOorC,GAAaW,IACrC,MAAMtsB,EAAUssB,EAASzJ,QACzB,IACI,MAAMgO,EAAY/I,GAAa9nB,GACzBqxB,EAAqB,IAAIF,EAE/B,OADAE,EAAmBhQ,MAAMwP,GAClBQ,EAAmBxG,KAC9B,CACA,MAAO3qC,GAGH,OAAOoxC,GAAeN,KAAKhxB,EAAQ9Z,OACvC,KAEE2pC,GAAS,OAAIe,GAAetE,IACvB,CACH7D,QAAS,oDAEL6D,EAASzrC,KAFJ,yJAMTU,KAAMyuC,GAAyBuB,iBAC/B5F,WAAY,CAACW,OAGrB,OAAOuD,CACX,CAxI2B2B,CAAuBf,IAC9CZ,EAASA,EAAOvvC,OAwIb,SAA8BqrC,GACjC,MAAM8F,GAAe,EAAAlxC,GAAA,GAAOorC,GAAaW,IACrC,MAAMtsB,EAAUssB,EAASzJ,IACzB,OAAO7iB,aAAmBvZ,SAAWuZ,EAAQ0xB,WAAa1xB,EAAQ2xB,OAAO,IAEvE9B,GAAS,OAAI4B,GAAenF,IACvB,CACH7D,QAAS,iBACL6D,EAASzrC,KACT,oEACJU,KAAMyuC,GAAyB4B,wBAC/BjG,WAAY,CAACW,OAGrB,OAAOuD,CACX,CAvJ2BgC,CAAqBpB,IAC5CZ,EAASA,EAAOvvC,OAwJb,SAA+BqrC,GAClC,MAAMd,EAAQ,GACd,IAAIiH,GAAoB,OAAInG,GAAaoG,IAC9B,EAAA3Y,GAAA,GAAOuS,GAAY,CAACtoC,EAAQ2uC,KAC3BD,EAAUlP,QAAQ38B,SAAW8rC,EAAUnP,QAAQ38B,QAC9C,GAAS2kC,EAAOmH,IACjBA,EAAUnP,UAAY0J,GAAMC,KAG5B3B,EAAMnnC,KAAKsuC,GACX3uC,EAAOK,KAAKsuC,IAGT3uC,IACR,MAEPyuC,EAAoB,GAAQA,GAC5B,MAAMG,GAAoB,EAAA1xC,GAAA,GAAOuxC,GAAoBI,GAC1CA,EAAiB9vC,OAAS,IAE/BytC,GAAS,OAAIoC,GAAoBE,IACnC,MAAMC,GAAiB,OAAID,GAAiB7F,GACjCA,EAASzrC,OAGpB,MAAO,CACH4nC,QAAS,6BAFS,GAAM0J,GAAgBtP,+DAGkBuP,EAAe5rC,KAAK,WAC9EjF,KAAMyuC,GAAyBqC,yBAC/B1G,WAAYwG,EACf,IAEL,OAAOtC,CACX,CAzL2ByC,CAAsB7B,IAC7CZ,EAASA,EAAOvvC,OA+Eb,SAA+BqrC,GAClC,MAAM4G,GAAqB,EAAAhyC,GAAA,GAAOorC,GAAaW,GAC3BA,EAASzJ,QACVmO,KAAK,MAElBnB,GAAS,OAAI0C,GAAqBjG,IAC7B,CACH7D,QAAS,iBACL6D,EAASzrC,KACT,qDACJU,KAAMyuC,GAAyBwC,oBAC/B7G,WAAY,CAACW,OAGrB,OAAOuD,CACX,CA9F2B4C,CAAsBhC,IACtCZ,CACX,CAf2B6C,CAAsBlC,IAC7CX,EAASA,EAAOvvC,OAqMb,SAA8BqrC,GACjC,MAAMnwB,GAAe,EAAAjb,GAAA,GAAOorC,GAAakC,IACrC,KAAK,EAAAjtC,EAAA,GAAIitC,EAAO,SACZ,OAAO,EAEX,MAAM7mC,EAAQ6mC,EAAME,MACpB,OAAO/mC,IAAUulC,GAAMyB,SAAWhnC,IAAUulC,GAAMC,MAAO,EAAAzL,EAAA,GAAS/5B,EAAM,IAEtE6oC,GAAS,OAAIr0B,GAAe8wB,IACvB,CACH7D,QAAS,iBACL6D,EAASzrC,KACT,gEACJU,KAAMyuC,GAAyB2C,yBAC/BhH,WAAY,CAACW,OAGrB,OAAOuD,CACX,CAvN2B+C,CAAqBpC,IAC5CX,EAASA,EAAOvvC,OAuNb,SAAiCqrC,EAAYkH,GAChD,MAAMC,GAAe,EAAAvyC,GAAA,GAAOorC,GAAakC,QACTxrC,IAApBwrC,EAAMO,YAA4B,GAASyE,EAAYhF,EAAMO,aAEnEyB,GAAS,OAAIiD,GAAehS,IAGvB,CACH2H,QAHQ,iBAAiB3H,EAAQjgC,kEAAkEigC,EAAQsN,kCAI3G7sC,KAAMyuC,GAAyB+C,yBAC/BpH,WAAY,CAAC7K,OAGrB,OAAO+O,CACX,CArO2BmD,CAAwBxC,EAAiBZ,IAChEC,EAASA,EAAOvvC,OAqOb,SAAiCqrC,GACpC,MAAMkE,EAAS,GACToD,GAAc,EAAA7Z,GAAA,GAAOuS,GAAY,CAACtoC,EAAQy9B,EAASS,KACrD,MAAMvhB,EAAU8gB,EAAQ+B,QACxB,OAAI7iB,IAAYusB,GAAMC,MAKlB,EAAAzL,EAAA,GAAS/gB,GACT3c,EAAOK,KAAK,CAAE+L,IAAKuQ,EAASuhB,MAAKwN,UAAWjO,IAEvC,EAAS9gB,IA2C1B,SAAoB+nB,GAEhB,MAAMmL,EAAY,CACd,IACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KAEJ,YAA0E7wC,KAAlE,EAAApC,GAAA,GAAKizC,GAAYlJ,IAA0C,IAAjCjC,EAAO7hC,OAAOiU,QAAQ6vB,IAC5D,CA7DsCmJ,CAAWnzB,IACrC3c,EAAOK,KAAK,CAAE+L,IAAKuQ,EAAQ9Z,OAAQq7B,MAAKwN,UAAWjO,KAR5Cz9B,CAUE,GACd,IAgBH,OAfA,EAAArC,EAAA,GAAQ2qC,GAAY,CAAC7K,EAASsS,MAC1B,EAAApyC,EAAA,GAAQiyC,GAAa,EAAGxjC,MAAK8xB,MAAKwN,gBAC9B,GAAIqE,EAAU7R,GAe1B,SAAuB9xB,EAAKuQ,GAExB,GAAI,EAASA,GAAU,CACnB,MAAMqzB,EAAcrzB,EAAQzJ,KAAK9G,GACjC,OAAuB,OAAhB4jC,GAA8C,IAAtBA,EAAYnxC,KAC/C,CACK,IAAI,EAAAurC,GAAA,GAAWztB,GAEhB,OAAOA,EAAQvQ,EAAK,EAAG,GAAI,CAAC,GAE3B,IAAI,EAAA7O,EAAA,GAAIof,EAAS,QAElB,OAAOA,EAAQzJ,KAAK9G,EAAK,EAAG,GAAI,CAAC,GAEhC,GAAuB,iBAAZuQ,EACZ,OAAOA,IAAYvQ,EAGnB,MAAM/J,MAAM,uBAEpB,CAnCiC4tC,CAAc7jC,EAAKqxB,EAAQ+B,SAAU,CACtD,MAAM4E,EAAM,YAAYsH,EAAUluC,2EACeigC,EAAQjgC,iHAGzDgvC,EAAOnsC,KAAK,CACR+kC,QAAShB,EACTlmC,KAAMyuC,GAAyBuD,oBAC/B5H,WAAY,CAAC7K,EAASiO,IAE9B,IACF,IAECc,CACX,CAtQ2B2D,CAAwBhD,IACxCX,CACX,CAgDA,MAAMkB,GAAe,WAuDrB,MAAMO,GAAiB,iBAsMhB,SAAS9D,GAAgBxtB,GAC5B,MAAMla,EAAQka,EAAQwoB,WAAa,IAAM,GAGzC,OAAO,IAAI/hC,OAAO,OAAOuZ,EAAQ9Z,UAAWJ,EAChD,CACO,SAASynC,GAAcvtB,GAC1B,MAAMla,EAAQka,EAAQwoB,WAAa,KAAO,IAG1C,OAAO,IAAI/hC,OAAO,GAAGuZ,EAAQ9Z,SAAUJ,EAC3C,CA0DO,SAAS2tC,GAA4BC,EAAiBC,EAAY1H,GACrE,MAAM2H,EAAW,GACjB,IAAIC,GAAkB,EACtB,MAAMC,EAAgB,IAAQ,SAAQ,OAAOJ,EAAgBK,SACvDC,EAAqB,GAAOF,GAAgBxH,GAAaA,EAASzJ,MAAa0J,GAAMC,KACrFyH,EAAsB3F,GAAarC,GAsCzC,OArCI0H,IACA,EAAA3yC,EAAA,GAAQgzC,GAAqBlT,IACzB,MAAMoT,EAAY1F,GAAsB1N,EAASmT,GACjD,IAAkB,IAAdC,EAAqB,CACrB,MAAMzL,EA8If,SAAoC3H,EAASqT,GAEhD,GAAIA,EAAQC,QAAUpE,GAAyBqE,oBAC3C,MACI,2FAA4BvT,EAAQjgC,oCAClBszC,EAAQG,+GAG7B,GAAIH,EAAQC,QAAUpE,GAAyBuE,kBAChD,MACI,sGAA4BzT,EAAQjgC,sHAIxC,MAAM6E,MAAM,uBAEpB,CA9JgC8uC,CAA2B1T,EAASoT,GAC9CO,EAAoB,CACtBhM,UACAlnC,KAAM2yC,EAAUE,MAChBrF,UAAWjO,GAEf8S,EAASlwC,KAAK+wC,EAClB,MAGQ,EAAA7zC,EAAA,GAAIkgC,EAAS,gBACe,IAAxBA,EAAQyN,cACRsF,GAAkB,GAIlB1I,GAAiB8I,EAAqBnT,EAAQ+B,WAC9CgR,GAAkB,EAG9B,IAGJF,IAAeE,GACfD,EAASlwC,KAAK,CACV+kC,QAAS,uRAKTlnC,KAAMyuC,GAAyB0E,uBAGhCd,CACX,CAiBO,SAASnF,GAAgBM,GAC5B,MAAM/uB,EAAU+uB,EAAUlM,QAE1B,GAAI,EAAS7iB,GACT,OAAO,EAEN,IAAI,EAAAytB,GAAA,GAAWztB,GAEhB,OAAO,EAEN,IAAI,EAAApf,EAAA,GAAIof,EAAS,QAElB,OAAO,EAEN,IAAI,EAAA+gB,EAAA,GAAS/gB,GACd,OAAO,EAGP,MAAMta,MAAM,uBAEpB,CACO,SAASgpC,GAAe1uB,GAC3B,UAAI,EAAA+gB,EAAA,GAAS/gB,IAA+B,IAAnBA,EAAQ5d,SACtB4d,EAAQqqB,WAAW,EAKlC,CAIO,MAAMsK,GAAgC,CAEzC3D,KAAM,SAAU5+B,GACZ,MAAMN,EAAMM,EAAKhQ,OACjB,IAAK,IAAI4D,EAAI8G,KAAK8nC,UAAW5uC,EAAI8L,EAAK9L,IAAK,CACvC,MAAMmO,EAAI/B,EAAKi4B,WAAWrkC,GAC1B,GAAU,KAANmO,EAEA,OADArH,KAAK8nC,UAAY5uC,EAAI,GACd,EAEN,GAAU,KAANmO,EAOL,OAN+B,KAA3B/B,EAAKi4B,WAAWrkC,EAAI,GACpB8G,KAAK8nC,UAAY5uC,EAAI,EAGrB8G,KAAK8nC,UAAY5uC,EAAI,GAElB,CAEf,CACA,OAAO,CACX,EACA4uC,UAAW,GAEf,SAASpG,GAAsB1N,EAASuN,GACpC,IAAI,EAAAztC,EAAA,GAAIkgC,EAAS,eAGb,OAAO,EAIP,GAAI,EAASA,EAAQ+B,SAAU,CAC3B,IAEIsI,GAAiBkD,EAAyBvN,EAAQ+B,QACtD,CACA,MAAO3iC,GAEH,MAAO,CACHk0C,MAAOpE,GAAyBqE,oBAChCC,OAAQp0C,EAAEuoC,QAElB,CACA,OAAO,CACX,CACK,IAAI,EAAA1H,EAAA,GAASD,EAAQ+B,SAEtB,OAAO,EAEN,GAAI4L,GAAgB3N,GAErB,MAAO,CAAEsT,MAAOpE,GAAyBuE,mBAGzC,MAAM7uC,MAAM,uBAGxB,CAkBA,SAAS4oC,GAAauG,GASlB,OARkB,OAAIA,GAAeC,IAC7B,EAAA/T,EAAA,GAAS+T,GACFA,EAAYzK,WAAW,GAGvByK,GAInB,CACA,SAAS1F,GAAiB7oC,EAAK0c,EAAKxjB,QACf4C,IAAbkE,EAAI0c,GACJ1c,EAAI0c,GAAO,CAACxjB,GAGZ8G,EAAI0c,GAAKvf,KAAKjE,EAEtB,CACO,MAAM2pC,GAAqB,IAgBlC,IAAIgD,GAA4B,GACzB,SAAS5C,GAAyBuL,GACrC,OAAOA,EAAW3L,GACZ2L,EACA3I,GAA0B2I,EACpC,C,qCCz1BO,SAASC,GAAM9tB,GAClB,MAAMzH,GAAQ,IAAI4H,MAAO4tB,UACnBC,EAAMhuB,IAGZ,MAAO,CAAEgV,MAFG,IAAI7U,MAAO4tB,UACHx1B,EACEhgB,MAAOy1C,EACjC,CCLO,SAASC,GAAuBC,EAAaC,GAChD,MAAMC,EAAeF,EAAYxH,aACjC,OAAI0H,IAAiBD,EAAezH,eAII,IAA5ByH,EAAeE,WACiC,IAApDF,EAAeG,mBAAmBF,EAE9C,CAGO,SAASG,GAAmCrkC,EAAO0vB,GACtD,OAAO1vB,EAAMw8B,eAAiB9M,EAAQ8M,YAC1C,CACO,IAAI8H,GAAoB,EACxB,MAAMC,GAAkB,CAAC,EACzB,SAASC,GAAkBjK,GAE9B,MAAMkK,EAUH,SAA0BlK,GAC7B,IAAItoC,GAAS,EAAAyyC,EAAA,GAAMnK,GACfoK,EAAapK,EACbqK,GAAY,EAChB,KAAOA,GAAW,CACdD,EAAa,IAAQ,SAAQ,OAAIA,GAAa7G,GAAgBA,EAAY+G,eAC1E,MAAMC,EAAgB,GAAWH,EAAY1yC,GAC7CA,EAASA,EAAO/C,OAAO41C,IACnB,EAAA/J,EAAA,GAAQ+J,GACRF,GAAY,EAGZD,EAAaG,CAErB,CACA,OAAO7yC,CACX,CA1BiC8yC,CAAiBxK,IA2B3C,SAAiCA,IACpC,EAAA3qC,EAAA,GAAQ2qC,GAAauD,IAwDlB,IAAyCpO,EAvDnCsV,GAAoBlH,KACrByG,GAAgBD,IAAqBxG,EACrCA,EAAYtB,aAAe8H,MAG3BW,GAAsBnH,MACrB,EAAAnzB,EAAA,GAAQmzB,EAAY+G,cAIrB/G,EAAY+G,WAAa,CAAC/G,EAAY+G,aAErCI,GAAsBnH,KACvBA,EAAY+G,WAAa,IA0CWnV,EAxCHoO,GAyClC,EAAAtuC,EAAA,GAAIkgC,EAAS,qBAxCZoO,EAAYoH,gBAAkB,IA0CnC,SAA4CxV,GAC/C,OAAO,EAAAlgC,EAAA,GAAIkgC,EAAS,qBACxB,CA1CayV,CAAmCrH,KACpCA,EAAYsG,mBAAqB,CAAC,EACtC,GAER,CAjDIgB,CAAwBX,GA2DrB,SAAiClK,IACpC,EAAA3qC,EAAA,GAAQ2qC,GAAauD,IACjBuH,GAA8B,GAAIvH,EAAY,GAEtD,CA7DIwH,CAAwBb,GAgDrB,SAAoClK,IACvC,EAAA3qC,EAAA,GAAQ2qC,GAAauD,IAEjBA,EAAYoH,gBAAkB,IAC9B,EAAAt1C,EAAA,GAAQkuC,EAAYsG,oBAAoB,CAACN,EAAKjyB,KAC1CisB,EAAYoH,gBAAgB5yC,KAAKiyC,GAAgB1yB,GAAK2qB,aAAa,GACrE,GAEV,CAvDI+I,CAA2Bd,IAC3B,EAAA70C,EAAA,GAAQ60C,GAAuB/U,IAC3BA,EAAQyU,SAAWzU,EAAQwV,gBAAgBl0C,OAAS,CAAC,GAE7D,CAyDO,SAASq0C,GAA8BzvB,EAAM4vB,IAChD,EAAA51C,EAAA,GAAQgmB,GAAO6vB,IACXD,EAASpB,mBAAmBqB,EAASjJ,eAAgB,CAAI,KAE7D,EAAA5sC,EAAA,GAAQ41C,EAASX,YAAaa,IAC1B,MAAMC,EAAU/vB,EAAK1mB,OAAOs2C,GAEvB,GAASG,EAASD,IACnBL,GAA8BM,EAASD,EAC3C,GAER,CACO,SAASV,GAAoBtV,GAChC,OAAO,EAAAlgC,EAAA,GAAIkgC,EAAS,eACxB,CACO,SAASuV,GAAsBvV,GAClC,OAAO,EAAAlgC,EAAA,GAAIkgC,EAAS,aACxB,CAOO,SAASkW,GAAYlW,GACxB,OAAO,EAAAlgC,EAAA,GAAIkgC,EAAS,eACxB,CChHO,MAAMmW,GAA4B,CACrC,gCAAAC,CAAiC9lC,GAC7B,MAAO,uDAAuDA,EAAM+lC,iCACxE,EACA,gCAAAC,CAAiCC,EAAUC,EAAal1C,EAAQkQ,EAAMilC,GAClE,MAAQ,2BAA2BF,EAASG,OAAOF,mBAA6BA,cAA6Bl1C,eACjH,GCAG,IAAI4tC,IACX,SAAWA,GACPA,EAAyBA,EAA0C,gBAAI,GAAK,kBAC5EA,EAAyBA,EAA0C,gBAAI,GAAK,kBAC5EA,EAAyBA,EAA2C,iBAAI,GAAK,mBAC7EA,EAAyBA,EAAkD,wBAAI,GAAK,0BACpFA,EAAyBA,EAAmD,yBAAI,GAAK,2BACrFA,EAAyBA,EAAmD,yBAAI,GAAK,2BACrFA,EAAyBA,EAAmD,yBAAI,GAAK,2BACrFA,EAAyBA,EAAgE,sCAAI,GAAK,wCAClGA,EAAyBA,EAAkE,wCAAI,GAAK,0CACpGA,EAAyBA,EAA6E,mDAAI,GAAK,qDAC/GA,EAAyBA,EAAoE,0CAAI,IAAM,4CACvGA,EAAyBA,EAA2C,iBAAI,IAAM,mBAC9EA,EAAyBA,EAA8C,oBAAI,IAAM,sBACjFA,EAAyBA,EAA+C,qBAAI,IAAM,uBAClFA,EAAyBA,EAA8C,oBAAI,IAAM,sBACjFA,EAAyBA,EAA8C,oBAAI,IAAM,sBACjFA,EAAyBA,EAA4C,kBAAI,IAAM,oBAC/EA,EAAyBA,EAA0E,gDAAI,IAAM,iDAChH,CAnBD,CAmBGA,KAA6BA,GAA2B,CAAC,IAC5D,MAAMyH,GAAuB,CACzBC,+BAA+B,EAC/B1L,iBAAkB,OAClB2L,uBAAwB,YACxB1L,yBAA0B,CAAC,KAAM,MACjC5D,qBAAqB,EACrB0D,UAAU,EACV6L,qBAAsBX,GACtBY,eAAe,EACfC,iBAAiB,EACjBC,iBAAiB,GAErB1xC,OAAO2xC,OAAOP,IACP,MAAMlL,GACT,WAAA72B,CAAYg+B,EAAiB92B,EAAS66B,IAoClC,GAnCA3qC,KAAK4mC,gBAAkBA,EACvB5mC,KAAKmrC,sBAAwB,GAC7BnrC,KAAKorC,uBAAyB,GAC9BprC,KAAKqgC,mBAAqB,CAAC,EAC3BrgC,KAAKmiC,6BAA+B,CAAC,EACrCniC,KAAKinC,MAAQ,GACbjnC,KAAKogC,YAAc,CAAC,EACpBpgC,KAAKqrC,iBAAkB,EACvBrrC,KAAKsrC,eAAgB,EACrBtrC,KAAKsgC,WAAY,EACjBtgC,KAAKurC,mBAAqB,CAAC,EAG3BvrC,KAAKwrC,WAAa,CAACC,EAAWC,KAG1B,IAA2B,IAAvB1rC,KAAK+qC,cAAwB,CAC7B/qC,KAAK2rC,kBACL,MAAMC,EAAS,IAAIpnC,MAAMxE,KAAK2rC,gBAAkB,GAAGjyC,KAAK,MACpDsG,KAAK2rC,gBAAkB3rC,KAAK6rC,mBAC5B1vB,QAAQC,IAAI,GAAGwvB,YAAcH,MAEjC,MAAM,KAAErc,EAAI,MAAEz8B,GAAUu1C,GAAMwD,GAExBI,EAAc1c,EAAO,GAAKjT,QAAQ0e,KAAO1e,QAAQC,IAKvD,OAJIpc,KAAK2rC,gBAAkB3rC,KAAK6rC,mBAC5BC,EAAY,GAAGF,SAAcH,YAAoBrc,OAErDpvB,KAAK2rC,kBACEh5C,CACX,CAEI,OAAO+4C,GACX,EAEkB,kBAAX57B,EACP,MAAMlX,MAAM,8HAIhBoH,KAAK8P,OAAS,EAAO,CAAC,EAAG66B,GAAsB76B,GAC/C,MAAMi8B,EAAe/rC,KAAK8P,OAAOi7B,eACZ,IAAjBgB,GACA/rC,KAAK6rC,kBAAoBG,IACzBhsC,KAAK+qC,eAAgB,GAEQ,iBAAjBgB,IACZ/rC,KAAK6rC,kBAAoBE,EACzB/rC,KAAK+qC,eAAgB,GAEzB/qC,KAAK2rC,iBAAmB,EACxB3rC,KAAKwrC,WAAW,qBAAqB,KACjC,IAAIS,EACAC,GAAoB,EACxBlsC,KAAKwrC,WAAW,yBAAyB,KACrC,GAAIxrC,KAAK8P,OAAO+6B,yBACZF,GAAqBE,uBAErB7qC,KAAK8P,OAAO+6B,uBAAyBhD,QAGrC,GAAI7nC,KAAK8P,OAAOqvB,2BACZwL,GAAqBxL,yBACrB,MAAMvmC,MAAM,oLAIpB,GAAIkX,EAAOmvB,UAAYnvB,EAAOyrB,oBAC1B,MAAM3iC,MAAM,sEAEhBoH,KAAKqrC,gBAAkB,kBAAkBnH,KAAKlkC,KAAK8P,OAAOovB,kBAC1Dl/B,KAAKsrC,cAAgB,QAAQpH,KAAKlkC,KAAK8P,OAAOovB,mBAE1C,EAAAjwB,EAAA,GAAQ23B,GACRqF,EAAmB,CACfhF,MAAO,CAAEkF,aAAa,EAAAnD,EAAA,GAAMpC,IAC5BuF,YAAa3N,KAKjB0N,GAAoB,EACpBD,GAAmB,EAAAjD,EAAA,GAAMpC,GAC7B,KAEgC,IAAhC5mC,KAAK8P,OAAOk7B,kBACZhrC,KAAKwrC,WAAW,wBAAwB,KACpCxrC,KAAKmrC,sBAAwBnrC,KAAKmrC,sBAAsB33C,OJ8crE,SAA8BozC,GACjC,MAAM7D,EAAS,GAsDf,OApDK,EAAAjvC,EAAA,GAAI8yC,EAAiBpI,KACtBuE,EAAOnsC,KAAK,CACR+kC,QAAS,sDACL6C,GACA,iCACJ/pC,KAAMyuC,GAAyBkJ,yCAGlC,EAAAt4C,EAAA,GAAI8yC,EAAiBnI,KACtBsE,EAAOnsC,KAAK,CACR+kC,QAAS,yFAGTlnC,KAAMyuC,GAAyBmJ,2CAGnC,EAAAv4C,EAAA,GAAI8yC,EAAiBnI,MACrB,EAAA3qC,EAAA,GAAI8yC,EAAiBpI,OACpB,EAAA1qC,EAAA,GAAI8yC,EAAgBK,MAAOL,EAAgBuF,cAC5CpJ,EAAOnsC,KAAK,CACR+kC,QAAS,kDAAkD6C,QAAkBoI,EAAgBuF,qCAE7F13C,KAAMyuC,GAAyBoJ,sDAGnC,EAAAx4C,EAAA,GAAI8yC,EAAiBnI,MACrB,EAAAvqC,EAAA,GAAQ0yC,EAAgBK,OAAO,CAACsF,EAAeC,MAC3C,EAAAt4C,EAAA,GAAQq4C,GAAe,CAACnK,EAAaqK,KACjC,IAAI,EAAAtL,GAAA,GAAYiB,GACZW,EAAOnsC,KAAK,CACR+kC,QACI,sEAAI6Q,iBAA4BC,OACpCh4C,KAAMyuC,GAAyBwJ,iDAGlC,IAAI,EAAA54C,EAAA,GAAIsuC,EAAa,cAAe,CACrC,MAAMP,GAAY,EAAA5yB,EAAA,GAAQmzB,EAAYf,YAChCe,EAAYf,WACZ,CAACe,EAAYf,aACnB,EAAAntC,EAAA,GAAQ2tC,GAAY8K,KACX,EAAAxL,GAAA,GAAYwL,IACZ,GAASJ,EAAeI,IACzB5J,EAAOnsC,KAAK,CACR+kC,QAAS,8DAA8DgR,EAAc54C,mBAAmBquC,EAAYruC,0BAA0By4C,OAC9I/3C,KAAMyuC,GAAyB0J,iDAEvC,GAER,IACF,IAGH7J,CACX,CItgBmF8J,CAAqBZ,EAAkBjsC,KAAKqrC,gBAAiBrrC,KAAK8P,OAAOqvB,0BAA0B,IAEtKn/B,KAAKwrC,WAAW,+BAA+B,KAC3CxrC,KAAKorC,uBAAyBprC,KAAKorC,uBAAuB53C,OAAOmzC,GAA4BsF,EAAkBjsC,KAAKqrC,gBAAiBrrC,KAAK8P,OAAOqvB,0BAA0B,KAInL8M,EAAiBhF,MAAQgF,EAAiBhF,MACpCgF,EAAiBhF,MACjB,CAAC,GAGP,EAAA/yC,EAAA,GAAQ+3C,EAAiBhF,OAAO,CAACsF,EAAeC,KAC5CP,EAAiBhF,MAAMuF,GAAgB,GAAOD,GAAgBnK,IAAgB,EAAAjB,GAAA,GAAYiB,IAAa,IAE3G,MAAM0K,GAAe,EAAAj7B,EAAA,GAAKo6B,EAAiBhF,OAoC3C,IAnCA,EAAA/yC,EAAA,GAAQ+3C,EAAiBhF,OAAO,CAAC8F,EAAYC,KACzChtC,KAAKwrC,WAAW,UAAUwB,iBAA2B,KAUjD,GATAhtC,KAAKinC,MAAMrwC,KAAKo2C,IACoB,IAAhChtC,KAAK8P,OAAOk7B,iBACZhrC,KAAKwrC,WAAW,oBAAoB,KAChCxrC,KAAKmrC,sBAAwBnrC,KAAKmrC,sBAAsB33C,OAAOqvC,GAAiBkK,EAAYD,GAAc,KAM9G,EAAAzN,EAAA,GAAQr/B,KAAKmrC,uBAAwB,CAErC,IAAI8B,EADJnE,GAAkBiE,GAElB/sC,KAAKwrC,WAAW,qBAAqB,KACjCyB,EAAoBrO,GAAkBmO,EAAY,CAC9C5N,yBAA0Bn/B,KAAK8P,OAAOqvB,yBACtCD,iBAAkBpvB,EAAOovB,iBACzB3D,oBAAqBzrB,EAAOyrB,oBAC5B0D,SAAUnvB,EAAOmvB,SACjBH,OAAQ9+B,KAAKwrC,YACf,IAENxrC,KAAKqgC,mBAAmB2M,GACpBC,EAAkB5M,mBACtBrgC,KAAKmiC,6BAA6B6K,GAC9BC,EAAkB9K,6BACtBniC,KAAKogC,YAAc,EAAO,CAAC,EAAGpgC,KAAKogC,YAAa6M,EAAkB7M,aAClEpgC,KAAKsgC,UAAY2M,EAAkB3M,WAAatgC,KAAKsgC,UACrDtgC,KAAKurC,mBAAmByB,GACpBC,EAAkB/K,cAC1B,IACF,IAENliC,KAAKmsC,YAAcF,EAAiBE,cAC/B,EAAA9M,EAAA,GAAQr/B,KAAKmrC,yBACbnrC,KAAK8P,OAAO86B,8BAA+B,CAC5C,MAGMsC,GAHiB,OAAIltC,KAAKmrC,uBAAwBroC,GAC7CA,EAAM64B,UAE2BjiC,KAAK,6BACjD,MAAM,IAAId,MAAM,4CAA8Cs0C,EAClE,EAEA,EAAAh5C,EAAA,GAAQ8L,KAAKorC,wBAAyBzD,IAClC/M,GAAc+M,EAAkBhM,QAAQ,IAE5C37B,KAAKwrC,WAAW,wCAAwC,KAqBpD,GAjBI9M,IACA1+B,KAAKmtC,UAAY7yB,GAAA,EACjBta,KAAKuF,MAAQvF,KAAKotC,gBAGlBptC,KAAKqtC,gBAAkBC,GAAA,EACvBttC,KAAKuF,MAAQvF,KAAKutC,eAElBrB,IACAlsC,KAAKwtC,YAAcF,GAAA,IAEM,IAAzBttC,KAAKqrC,kBACLrrC,KAAKytC,iBAAmBnzB,GAAA,IAED,IAAvBta,KAAKsrC,gBACLtrC,KAAK0tC,iCAAmCJ,GAAA,GAExC,QAAQpJ,KAAKlkC,KAAK8P,OAAOovB,kBACzBl/B,KAAK2tC,oBAAsB3tC,KAAK4tC,qBAE/B,GAAI,aAAa1J,KAAKlkC,KAAK8P,OAAOovB,kBACnCl/B,KAAK2tC,oBAAsB3tC,KAAK6tC,yBAE/B,KAAI,cAAc3J,KAAKlkC,KAAK8P,OAAOovB,kBAIpC,MAAMtmC,MAAM,8CAA8CoH,KAAK8P,OAAOovB,qBAHtEl/B,KAAK2tC,oBAAsB3tC,KAAK8tC,qBAIpC,CACI9tC,KAAKsgC,WACLtgC,KAAK+tC,SAAW/tC,KAAKguC,kBACrBhuC,KAAKiuC,cAAgBjuC,KAAKkuC,0BAG1BluC,KAAK+tC,SAAW/tC,KAAKmuC,0BACrBnuC,KAAKiuC,cAAgBjuC,KAAKouC,sBAC9B,IAEJpuC,KAAKwrC,WAAW,gCAAgC,KAC5C,MAAM6C,GAAmB,EAAA/hB,GAAA,GAAOtsB,KAAKurC,oBAAoB,CAAC+C,EAAmBpM,EAAgBqM,MAClE,IAAnBrM,GACAoM,EAAkB13C,KAAK23C,GAEpBD,IACR,IACH,GAAIx+B,EAAOyrB,uBAAwB,EAAA8D,EAAA,GAAQgP,GACvC,MAAMz1C,MAAM,kBAAkBy1C,EAAiB30C,KAAK,qOAGxD,IAEJsG,KAAKwrC,WAAW,0BAA0B,KNxOlD1Q,GAAiB,CAAC,CMyOkB,IAE5B96B,KAAKwrC,WAAW,oBAAoB,KAChCnY,EAAiBrzB,KAAK,GACxB,GAEV,CACA,QAAAwuC,CAASlpC,EAAMmpC,EAAczuC,KAAKmsC,aAC9B,KAAK,EAAA9M,EAAA,GAAQr/B,KAAKmrC,uBAAwB,CACtC,MAGM+B,GAHiB,OAAIltC,KAAKmrC,uBAAwBroC,GAC7CA,EAAM64B,UAE2BjiC,KAAK,6BACjD,MAAM,IAAId,MAAM,uEACZs0C,EACR,CACA,OAAOltC,KAAK0uC,iBAAiBppC,EAAMmpC,EACvC,CAKA,gBAAAC,CAAiBppC,EAAMmpC,GACnB,IAAIv1C,EAAGy1C,EAAGtzC,EAAGuzC,EAAe/M,EAAWgN,EAAcC,EAASC,EAAYC,EAAa90C,EAAO85B,EAASib,EAAUC,EAAwBvU,EAAKp1B,EAC9I,MAAMqvB,EAAUtvB,EACV6pC,EAAYva,EAAQt/B,OAC1B,IAAI+Q,EAAS,EACT+oC,EAAqB,EAKzB,MAAMC,EAAwBrvC,KAAKsgC,UAC7B,EACA9qC,KAAKo4B,MAAMtoB,EAAKhQ,OAAS,IACzBg6C,EAAgB,IAAI9qC,MAAM6qC,GAC1BtM,EAAS,GACf,IAAIv9B,EAAOxF,KAAKqrC,gBAAkB,OAAI91C,EAClCk1C,EAASzqC,KAAKqrC,gBAAkB,OAAI91C,EACxC,MAAMg6C,EJsZP,SAA0BnP,GAC7B,MAAMoP,EAAe,CAAC,EAChBC,GAAY,EAAA59B,EAAA,GAAKuuB,GAWvB,OAVA,EAAAlsC,EAAA,GAAQu7C,GAAYC,IAChB,MAAMC,EAAiBvP,EAAYsP,GAEnC,KAAI,EAAAzgC,EAAA,GAAQ0gC,GAIR,MAAM/2C,MAAM,wBAHZ42C,EAAaE,GAAW,EAI5B,IAEGF,CACX,CIpauBI,CAAiB5vC,KAAKogC,aAC/ByG,EAAa7mC,KAAKqrC,gBAClBwE,EAAwB7vC,KAAK8P,OAAO+6B,uBAC1C,IAAIiF,EAAyB,EACzBzP,EAAqB,GACrB0P,EAAmC,GACvC,MAAMC,EAAY,GACZC,EAAa,GAEnB,IAAIC,EACJ,SAASC,IACL,OAAO9P,CACX,CACA,SAAS+P,EAA6BnI,GAClC,MAAMhL,EAAmBP,GAAyBuL,GAC5CoI,EAAmBN,EAAiC9S,GAC1D,YAAyB1nC,IAArB86C,EACOJ,EAGAI,CAEf,CAdA92C,OAAO2xC,OAAO+E,GAed,MAAMK,EAAYC,IAEd,GAAyB,IAArBP,EAAU16C,aAGuBC,IAAjCg7C,EAAStO,UAAUX,UAAyB,CAG5C,MAAM3G,EAAM36B,KAAK8P,OAAOg7B,qBAAqBV,iCAAiCmG,GAC9ExN,EAAOnsC,KAAK,CACRyP,OAAQkqC,EAAS/F,YACjBhlC,KAAM+qC,EAASC,UACf/F,OAAQ8F,EAASE,YACjBn7C,OAAQi7C,EAASlG,MAAM/0C,OACvBqmC,QAAShB,GAEjB,KACK,CACDqV,EAAUzrC,MACV,MAAMmsC,GAAU,EAAAnpB,GAAA,GAAKyoB,GACrB3P,EAAqBrgC,KAAKqgC,mBAAmBqQ,GAC7CX,EACI/vC,KAAKmiC,6BAA6BuO,GACtCZ,EAAyBzP,EAAmB/qC,OAC5C,MAAMq7C,EAAqB3wC,KAAKurC,mBAAmBmF,KAAqC,IAAzB1wC,KAAK8P,OAAOmvB,SAEvEiR,EADAH,GAAoCY,EACdP,EAGAD,CAE9B,GAEJ,SAASS,EAAUF,GACfV,EAAUp5C,KAAK85C,GACfX,EACI/vC,KAAKmiC,6BAA6BuO,GACtCrQ,EAAqBrgC,KAAKqgC,mBAAmBqQ,GAC7CZ,EAAyBzP,EAAmB/qC,OAC5Cw6C,EAAyBzP,EAAmB/qC,OAC5C,MAAMq7C,EAAqB3wC,KAAKurC,mBAAmBmF,KAAqC,IAAzB1wC,KAAK8P,OAAOmvB,SAEvEiR,EADAH,GAAoCY,EACdP,EAGAD,CAE9B,CAIA,IAAIU,EADJD,EAAUntC,KAAKzD,KAAMyuC,GAErB,MAAMxD,EAAkBjrC,KAAK8P,OAAOm7B,gBACpC,KAAO5kC,EAAS8oC,GAAW,CACvBN,EAAe,KACf,MAAMiC,EAAelc,EAAQ2I,WAAWl3B,GAClC0qC,EAA2Bb,EAAoBY,GAC/CE,EAAuBD,EAAyBz7C,OACtD,IAAK4D,EAAI,EAAGA,EAAI83C,EAAsB93C,IAAK,CACvC23C,EAAaE,EAAyB73C,GACtC,MAAMqnC,EAAcsQ,EAAW39B,QAC/B47B,EAAU,KAEV,MAAMmC,EAAiBJ,EAAW7O,MAuBlC,IAtBuB,IAAnBiP,EACIH,IAAiBG,IAEjBpC,EAAetO,IAGU,IAAxBsQ,EAAW9O,UAChBx8B,EAAQg7B,EAAY92B,KAAKmrB,EAASvuB,EAAQipC,EAAeC,GAC3C,OAAVhqC,GACAspC,EAAetpC,EAAM,QACChQ,IAAlBgQ,EAAMupC,UACNA,EAAUvpC,EAAMupC,UAIpBD,EAAe,OAInB7uC,KAAKqtC,gBAAgB9M,EAAal6B,GAClCwoC,EAAe7uC,KAAKuF,MAAMg7B,EAAaj7B,EAAMe,IAE5B,OAAjBwoC,EAAuB,CAIvB,GADAhN,EAAYgP,EAAWhP,eACLtsC,IAAdssC,EAAyB,CAGzB,MAAMqP,EAAkBrP,EAAUvsC,OAClC,IAAK+F,EAAI,EAAGA,EAAI61C,EAAiB71C,IAAK,CAClC,MAAM81C,EAAkB9Q,EAAmBwB,EAAUxmC,IAC/C+1C,EAAmBD,EAAgBj+B,QAoBzC,GAnBA67B,EAAa,MAGoB,IAA7BoC,EAAgBpP,UAChBx8B,EAAQ6rC,EAAiB3nC,KAAKmrB,EAASvuB,EAAQipC,EAAeC,GAChD,OAAVhqC,GACAqpC,EAAgBrpC,EAAM,QACAhQ,IAAlBgQ,EAAMupC,UACNC,EAAaxpC,EAAMupC,UAIvBF,EAAgB,OAIpB5uC,KAAKqtC,gBAAgB+D,EAAkB/qC,GACvCuoC,EAAgB5uC,KAAKuF,MAAM6rC,EAAkB9rC,EAAMe,IAEnDuoC,GAAiBA,EAAct5C,OAASu5C,EAAav5C,OAAQ,CAC7Du5C,EAAeD,EACfE,EAAUC,EACV8B,EAAaM,EAGb,KACJ,CACJ,CACJ,CACA,KACJ,CACJ,CAEA,GAAqB,OAAjBtC,EAAuB,CAqBvB,GApBAG,EAAcH,EAAav5C,OAC3B4E,EAAQ22C,EAAW32C,WACL3E,IAAV2E,IACA85B,EAAU6c,EAAW/P,aAGrBmO,EAAWjvC,KAAK2tC,oBAAoBkB,EAAcxoC,EAAQ2tB,EAAS6c,EAAW5O,UAAWz8B,EAAMilC,EAAQuE,GACvGhvC,KAAKiuC,cAAcgB,EAAUH,IAEf,IAAV50C,EACAk1C,EAAqBpvC,KAAK+tC,SAASuB,EAAeF,EAAoBH,GAGtEM,EAAOr1C,GAAOtD,KAAKq4C,IAG3B3pC,EAAOtF,KAAKmtC,UAAU7nC,EAAM0pC,GAC5B3oC,GAAkB2oC,EAElBvE,EAASzqC,KAAKytC,iBAAiBhD,EAAQuE,IACpB,IAAfnI,IAAwD,IAAjCgK,EAAW/O,kBAA4B,CAC9D,IACIuP,EACAC,EAFAC,EAAkB,EAGtB1B,EAAsB/H,UAAY,EAClC,GACIuJ,EAAkBxB,EAAsB3L,KAAK2K,IACrB,IAApBwC,IACAC,EAAkBzB,EAAsB/H,UAAY,EACpDyJ,YAEqB,IAApBF,GACe,IAApBE,IACA/rC,GAAc+rC,EACd9G,EAASuE,EAAcsC,EACvBtxC,KAAK0tC,iCAAiCuB,EAAU/0C,EAAOo3C,EAAiBC,EAAiB/rC,EAAMilC,EAAQuE,GAE/G,CAEAhvC,KAAKwtC,YAAYqD,EAAYP,EAAUM,EAAW3B,EACtD,KACK,CAED,MAAMuC,EAAmBnrC,EACnBorC,EAAYjsC,EACZksC,EAAcjH,EACpB,IAAIkH,GAAuC,IAApB1G,EACvB,MAA4B,IAArB0G,GAA8BtrC,EAAS8oC,GAI1C,IAFA7pC,EAAOtF,KAAKmtC,UAAU7nC,EAAM,GAC5Be,IACKsoC,EAAI,EAAGA,EAAImB,EAAwBnB,IAAK,CACzC,MAAMkC,EAAaxQ,EAAmBsO,GAChCpO,EAAcsQ,EAAW39B,QAEzB+9B,EAAiBJ,EAAW7O,MAelC,IAduB,IAAnBiP,EACIrc,EAAQ2I,WAAWl3B,KAAY4qC,IAE/BU,GAAmB,IAGM,IAAxBd,EAAW9O,SAChB4P,EACiE,OAA7DpR,EAAY92B,KAAKmrB,EAASvuB,EAAQipC,EAAeC,IAGrDvvC,KAAKqtC,gBAAgB9M,EAAal6B,GAClCsrC,EAA8C,OAA3BpR,EAAY92B,KAAKnE,KAEf,IAArBqsC,EACA,KAER,CAaJ,GAXAzC,EAAY7oC,EAASmrC,EACrB/G,EAASzqC,KAAKytC,iBAAiBhD,EAAQyE,GAEvCvU,EAAM36B,KAAK8P,OAAOg7B,qBAAqBR,iCAAiC1V,EAAS4c,EAAkBtC,EAAWuC,EAAWC,GACzH3O,EAAOnsC,KAAK,CACRyP,OAAQmrC,EACRhsC,KAAMisC,EACNhH,OAAQiH,EACRp8C,OAAQ45C,EACRvT,QAAShB,KAEW,IAApBsQ,EACA,KAER,CACJ,CAOA,OAJKjrC,KAAKsgC,YAENgP,EAAch6C,OAAS85C,GAEpB,CACHwC,OAAQtC,EACRC,OAAQA,EACRxM,OAAQA,EAEhB,CACA,WAAAyK,CAAY19B,EAAQwgC,EAAUM,EAAW3B,GACrC,IAAmB,IAAfn/B,EAAOvL,IAAc,CAGrB,MAAMstC,EAAW/hC,EAAOlZ,KACxB05C,EAASrB,QACQ15C,IAAbs8C,GACAjB,EAAUntC,KAAKzD,KAAM6xC,EAE7B,WACyBt8C,IAAhBua,EAAOlZ,MACZg6C,EAAUntC,KAAKzD,KAAM8P,EAAOlZ,KAEpC,CACA,SAAAu2C,CAAU7nC,EAAMhQ,GACZ,OAAOgQ,EAAKxK,UAAUxF,EAC1B,CACA,eAAA+3C,CAAgBpS,EAAQ6W,GACpB7W,EAAO6M,UAAYgK,CACvB,CAEA,gCAAApE,CAAiCuB,EAAU/0C,EAAO63C,EAAWR,EAAiB/rC,EAAMilC,EAAQuE,GACxF,IAAIgD,EAAcC,OACJ18C,IAAV2E,IAEA83C,EAAeD,IAAc/C,EAAc,EAC3CiD,EAAmBD,GAAgB,EAAI,EACb,IAApBT,IAA0C,IAAjBS,IAE3B/C,EAASiD,QAAU1sC,EAAOysC,EAG1BhD,EAASkD,UAAY1H,EAAS,EAAKwH,GAI/C,CACA,gBAAAxE,CAAiB2E,EAAWpD,GACxB,OAAOoD,EAAYpD,CACvB,CACA,qBAAAlB,CAAsBzD,EAAOG,EAAa1J,EAAcmB,GACpD,MAAO,CACHoI,QACAG,cACA1J,eACAmB,YAER,CACA,oBAAA4L,CAAqBxD,EAAOG,EAAa1J,EAAcmB,EAAWuO,EAAWC,GACzE,MAAO,CACHpG,QACAG,cACAgG,YACAC,cACA3P,eACAmB,YAER,CACA,eAAA2L,CAAgBvD,EAAOG,EAAa1J,EAAcmB,EAAWuO,EAAWC,EAAazB,GACjF,MAAO,CACH3E,QACAG,cACA6H,UAAW7H,EAAcwE,EAAc,EACvCwB,YACA0B,QAAS1B,EACTC,cACA0B,UAAW1B,EAAczB,EAAc,EACvClO,eACAmB,YAER,CACA,iBAAA+L,CAAkBsE,EAAal9C,EAAOm9C,GAElC,OADAD,EAAY17C,KAAK27C,GACVn9C,CACX,CACA,yBAAA+4C,CAA0BmE,EAAal9C,EAAOm9C,GAG1C,OAFAD,EAAYl9C,GAASm9C,IACrBn9C,CAEJ,CACA,qBAAAg5C,CAAsB9pC,EAAOwqC,GAAW,CACxC,uBAAAZ,CAAwB5pC,EAAOwqC,GACX,OAAZA,IACAxqC,EAAMwqC,QAAUA,EAExB,CACA,aAAA1B,CAAcl6B,EAAS5N,EAAMe,GAEzB,OAAc,IADA6M,EAAQgxB,KAAK5+B,GAEhBA,EAAKxK,UAAUuL,EAAQ6M,EAAQ40B,WAEnC,IACX,CACA,aAAAyF,CAAcr6B,EAAS5N,GACnB,MAAMihC,EAAcrzB,EAAQzJ,KAAKnE,GACjC,OAAuB,OAAhBihC,EAAuBA,EAAY,GAAK,IACnD,EC7nBG,SAAS,GAAWvS,GACvB,OAAI,GAAcA,GACPA,EAAQE,MAGRF,EAAQjgC,IAEvB,CAIO,SAAS,GAAcy+B,GAC1B,OAAO,EAAAyB,EAAA,GAASzB,EAAI0B,QAAwB,KAAd1B,EAAI0B,KACtC,CDknBAuL,GAAMyB,QAAU,6LAEhBzB,GAAMC,GAAK,iBCnnBX,MAAM8S,GAAS,SACTrJ,GAAa,aACbjV,GAAQ,QACR+M,GAAQ,QACRK,GAAY,YACZmR,GAAW,WACXpR,GAAa,aACbI,GAAc,cACdc,GAAmB,mBAClB,SAASmQ,GAAY5iC,GACxB,OAEJ,SAA6BA,GACzB,MAAMoD,EAAUpD,EAAOoD,QACjB+uB,EAAY,CAAC,EACnBA,EAAUluC,KAAO+b,EAAO/b,MACnB,EAAAotC,GAAA,GAAYjuB,KACb+uB,EAAUlM,QAAU7iB,GAExB,IAAI,EAAApf,EAAA,GAAIgc,EAAQ0iC,IACZ,KAAM,6IAGN,EAAA1+C,EAAA,GAAIgc,EAAQq5B,MAEZlH,EAAUkH,WAAar5B,EAAOq5B,KAElCL,GAAkB,CAAC7G,KACf,EAAAnuC,EAAA,GAAIgc,EAAQokB,MACZ+N,EAAU/N,MAAQpkB,EAAOokB,MAEzB,EAAApgC,EAAA,GAAIgc,EAAQmxB,MACZgB,EAAUhB,MAAQnxB,EAAOmxB,MAEzB,EAAAntC,EAAA,GAAIgc,EAAQ2iC,MACZxQ,EAAUwQ,SAAW3iC,EAAO2iC,MAE5B,EAAA3+C,EAAA,GAAIgc,EAAQwxB,MACZW,EAAUX,UAAYxxB,EAAOwxB,MAE7B,EAAAxtC,EAAA,GAAIgc,EAAQuxB,MACZY,EAAUZ,WAAavxB,EAAOuxB,MAE9B,EAAAvtC,EAAA,GAAIgc,EAAQ2xB,MACZQ,EAAUR,YAAc3xB,EAAO2xB,MAE/B,EAAA3tC,EAAA,GAAIgc,EAAQyyB,MACZN,EAAUM,iBAAmBzyB,EAAOyyB,KAExC,OAAON,CACX,CAxCW0Q,CAAoB7iC,EAC/B,CAwCO,MAAM/J,GAAM2sC,GAAY,CAAE3+C,KAAM,MAAOmf,QAASusB,GAAMC,KAEtD,SAASiO,GAAoB3Z,EAASqW,EAAOG,EAAa6H,EAAW7B,EAAW0B,EAASzB,EAAa0B,GACzG,MAAO,CACH9H,QACAG,cACA6H,YACA7B,YACA0B,UACAzB,cACA0B,YACArR,aAAc9M,EAAQ8M,aACtBmB,UAAWjO,EAEnB,CACO,SAAS4e,GAAatuC,EAAO0vB,GAChC,OAAOqU,GAAuB/jC,EAAO0vB,EACzC,CAhBA8U,GAAkB,CAAC/iC,KClEZ,MAAM8sC,GAA6B,CACtC,yBAAAC,EAA0B,SAAE5tC,EAAQ,OAAE6tC,EAAM,SAAEC,EAAQ,SAAEC,IAMpD,MADY,aAJK,GAAc/tC,GAEzB,UAAO,GAAWA,SAClB,wBAAqBA,EAASnR,gCACmBg/C,EAAO1I,YAElE,EACA,6BAAA6I,EAA8B,eAAEC,EAAc,SAAEF,IAC5C,MAAO,6CAA+CE,EAAe9I,KACzE,EACA,uBAAA+I,EAAwB,oBAAEC,EAAmB,OAAEN,EAAM,SAAEC,EAAQ,sBAAEM,EAAqB,SAAEL,IACpF,MAAMM,EAAY,cAGZC,EAAY,iBADC,GAAMT,GAAQ1I,MACiB,IAClD,GAAIiJ,EACA,OAAOC,EAAYD,EAAwBE,EAE1C,CACD,MAAMC,GAAoB,EAAAnnB,GAAA,GAAO+mB,GAAqB,CAAC98C,EAAQm9C,IAAiBn9C,EAAO/C,OAAOkgD,IAAe,IACvGC,GAA0B,OAAIF,GAAoBG,GAAa,KAAI,OAAIA,GAAWC,GAAkB,GAAWA,KAAgBn6C,KAAK,WAG1I,OAAO65C,EADuB,4CADC,OAAII,GAAyB,CAACG,EAASrf,IAAQ,KAAKA,EAAM,MAAMqf,MACCp6C,KAAK,QAC1D85C,CAC/C,CACJ,EACA,qBAAAO,EAAsB,uBAAEC,EAAsB,OAAEjB,EAAM,sBAAEO,EAAqB,SAAEL,IAC3E,MAAMM,EAAY,cAGZC,EAAY,iBADC,GAAMT,GAAQ1I,MACiB,IAClD,GAAIiJ,EACA,OAAOC,EAAYD,EAAwBE,EAM3C,OAAOD,EADH,mGAF4B,OAAIS,GAAyBJ,GAAa,KAAI,OAAIA,GAAWC,GAAkB,GAAWA,KAAgBn6C,KAAK,UAE/GA,KAAK,SACM85C,CAEnD,GAEJj6C,OAAO2xC,OAAO2H,IACP,MAAMoB,GAAsC,CAC/C,sBAAAC,CAAuBC,EAAcC,GAOjC,MANY,gEACRA,EAAc1e,gBADN,gCAIRye,EAAapgD,KACb,IAER,GAESsgD,GAAuC,CAChD,wBAAAC,CAAyBH,EAAcI,GAYnC,MAAMC,EAAeL,EAAapgD,KAC5B0gD,EAAgB,GAAMF,GACtBn/C,EAAQq/C,EAAchgB,IACtBigB,EAAU5d,GAAqB2d,GAC/BE,GAf8BngB,EAeaigB,aAdzBnf,EACTd,EAAKoB,aAAa7hC,KAEpBygC,aAAgB,EACdA,EAAKkB,gBAGL,GARf,IAAoClB,EAiBpC,IAAImG,EAAM,KAAK+Z,IADUt/C,EAAQ,EACWA,EAAQ,QAAQu/C,EAAgB,oBAAoBA,MAAoB,iDAChFJ,EAAej/C,0CAA0Ck/C,iJAM7F,OAFA7Z,EAAMA,EAAIzzB,QAAQ,UAAW,KAC7ByzB,EAAMA,EAAIzzB,QAAQ,SAAU,MACrByzB,CACX,EACA,2BAAAia,CAA4BhhD,GAMxB,MAJI,iHAA2EA,EAAKG,kPAKxF,EACA,oCAAA8gD,CAAqC35C,GACjC,MAAM45C,GAAU,OAAI55C,EAAQ65C,YAAaC,GAAY,GAAWA,KAAUt7C,KAAK,MACzEu7C,EAAyC,IAA5B/5C,EAAQg6C,YAAYzgB,IAAY,GAAKv5B,EAAQg6C,YAAYzgB,IAM5E,MALe,4BAA4Bv5B,EAAQi6C,iBAAiBz7C,KAAK,gDAC5Du7C,cAAuB/5C,EAAQi5C,aAAapgD,iBACjD+gD,qKAIZ,EACA,8BAAAM,CAA+Bl6C,GAC3B,MAAM45C,GAAU,OAAI55C,EAAQ65C,YAAaM,GAAY,GAAWA,KAAU37C,KAAK,MACzEu7C,EAAyC,IAA5B/5C,EAAQg6C,YAAYzgB,IAAY,GAAKv5B,EAAQg6C,YAAYzgB,IAC5E,IAAI6gB,EAAc,qCAAqCp6C,EAAQi6C,iBAAiBz7C,KAAK,gBAAgBu7C,cACrF/5C,EAAQi5C,aAAapgD,iBAC7B+gD,+DAKR,OAJAQ,GACIA,mHAGGA,CACX,EACA,yBAAAC,CAA0Br6C,GACtB,IAAIw5C,EAAU5d,GAAqB57B,EAAQs6C,YACZ,IAA3Bt6C,EAAQs6C,WAAW/gB,MACnBigB,GAAWx5C,EAAQs6C,WAAW/gB,KAIlC,MAFe,mBAAmBigB,mBAAyBx5C,EAAQi5C,aAAapgD,2EAGpF,EAGA,mBAAA0hD,CAAoBv6C,GAEhB,MAAO,YACX,EACA,0BAAAw6C,CAA2Bx6C,GAIvB,MAHe,iCAAiCA,EAAQy6C,eAAiB,YAC3Dz6C,EAAQg6C,YAAYzgB,gBAAgBv5B,EAAQi5C,aAAapgD,qEAG3E,EACA,6BAAA6hD,CAA8B16C,GAG1B,MADI,8DAAMA,EAAQg6C,YAAYzgB,gBAAgBv5B,EAAQi5C,aAAapgD,qBAAqBmH,EAAQg6C,YAAY/8C,WAAW7C,OAAS,iBAEpI,EACA,uBAAAugD,CAAwB36C,GACpB,MAAM+3C,EAAW/3C,EAAQi5C,aAAapgD,KAUtC,MAJI,4CAAUk/C,kIAJY,GAAGA,aADX,OAAI/3C,EAAQ46C,mBAAoBC,GAAaA,EAAShiD,OAEnEP,OAAO,CAACy/C,IACRv5C,KAAK,+IAOd,EAGA,yBAAAs8C,CAA0B96C,GAEtB,MAAO,YACX,EACA,2BAAA+6C,CAA4B/6C,GACxB,IAAI+3C,EAEAA,EADA/3C,EAAQi5C,wBAAwBxf,EACrBz5B,EAAQi5C,aAAapgD,KAGrBmH,EAAQi5C,aAGvB,MADe,iCAAiClB,4CAAmD/3C,EAAQg7C,eAE/G,GCpKG,MAAMC,WAA+B,EACxC,WAAAvtC,CAAYwtC,EAAeC,GACvB1jB,QACA3yB,KAAKo2C,cAAgBA,EACrBp2C,KAAKq2C,eAAiBA,EACtBr2C,KAAK+iC,OAAS,EAClB,CACA,WAAAuT,IACI,EAAApiD,EAAA,IAAQ,OAAO8L,KAAKo2C,gBAAiB5hB,IACjCx0B,KAAKu2C,aAAe/hB,EACpBA,EAAKH,OAAOr0B,KAAK,GAEzB,CACA,gBAAAi2B,CAAiB9hC,GACb,MAAME,EAAM2L,KAAKo2C,cAAcjiD,EAAKuhC,iBACpC,GAAKrhC,EAUDF,EAAKugC,eAAiBrgC,MAVhB,CACN,MAAMsmC,EAAM36B,KAAKq2C,eAAenC,uBAAuBl0C,KAAKu2C,aAAcpiD,GAC1E6L,KAAK+iC,OAAOnsC,KAAK,CACb+kC,QAAShB,EACTlmC,KAAM+hD,GAA0BC,uBAChCxD,SAAUjzC,KAAKu2C,aAAaxiD,KAC5B2iD,kBAAmBviD,EAAKuhC,iBAEhC,CAIJ,E,0BCdJ,OAXA,SAAyBrf,EAAOsgC,EAAQzgC,EAAU0gC,GAIhD,IAHA,IAAIxhD,GAAS,EACTE,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,SAE9BF,EAAQE,GAAQ,CACvB,IAAI3C,EAAQ0jB,EAAMjhB,GAClBuhD,EAAOC,EAAajkD,EAAOujB,EAASvjB,GAAQ0jB,EAC9C,CACA,OAAOugC,CACT,ECCA,OAPA,SAAwB/gC,EAAY8gC,EAAQzgC,EAAU0gC,GAIpD,OAHA,OAAS/gC,GAAY,SAASljB,EAAOwjB,EAAKN,GACxC8gC,EAAOC,EAAajkD,EAAOujB,EAASvjB,GAAQkjB,EAC9C,IACO+gC,CACT,ECIA,OATA,SAA0BD,EAAQE,GAChC,OAAO,SAAShhC,EAAYK,GAC1B,IAAIkE,GAAO,EAAAnL,EAAA,GAAQ4G,GAAc,GAAkB,GAC/C+gC,EAAcC,EAAcA,IAAgB,CAAC,EAEjD,OAAOz8B,EAAKvE,EAAY8gC,GAAQ,OAAazgC,EAAU,GAAI0gC,EAC7D,CACF,ECbI,GAHcr9C,OAAOwK,UAGQC,eAiCjC,GARc,IAAiB,SAASzN,EAAQ5D,EAAOwjB,GACjD,GAAe1S,KAAKlN,EAAQ4f,GAC9B5f,EAAO4f,GAAKvf,KAAKjE,IAEjB,QAAgB4D,EAAQ4f,EAAK,CAACxjB,GAElC,ICAA,ICjCWmkD,GDiCX,GAVA,SAAmBzgC,EAAO3R,EAAGivB,GAC3B,IAAIr+B,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACvC,OAAKA,GAGLoP,EAAKivB,QAAep+B,IAANmP,EAAmB,GAAI,EAAA4R,EAAA,GAAU5R,GAExC,EAAU2R,EAAO,GADxB3R,EAAIpP,EAASoP,GACkB,EAAI,EAAIA,IAJ9B,EAKX,EEhCO,MAAMqyC,WAAyChgB,GAClD,WAAAnuB,CAAY8wB,EAASxf,GACjByY,QACA3yB,KAAK05B,QAAUA,EACf15B,KAAKka,KAAOA,EACZla,KAAKg3C,iBAAmB,GACxBh3C,KAAKi3C,mBAAqB,GAC1Bj3C,KAAKk3C,yBAA2B,EAChCl3C,KAAK+9B,OAAQ,EACb/9B,KAAKm3C,eAAgB,CACzB,CACA,YAAAvd,GAEI,GADA55B,KAAK+9B,OAAQ,EACT/9B,KAAKka,KAAKk9B,UAAU,KAAOp3C,KAAK05B,QAAQ3lC,KACxC,MAAM6E,MAAM,uDAUhB,OAPAoH,KAAKo3C,WAAY,EAAApO,EAAA,GAAMhpC,KAAKka,KAAKk9B,WAAWloC,UAC5ClP,KAAKq3C,iBAAkB,EAAArO,EAAA,GAAMhpC,KAAKka,KAAKm9B,iBAAiBnoC,UAExDlP,KAAKo3C,UAAU7yC,MACfvE,KAAKq3C,gBAAgB9yC,MACrBvE,KAAKs3C,qBACLt3C,KAAKg3B,KAAKh3B,KAAK05B,SACR15B,KAAKg3C,gBAChB,CACA,IAAAhgB,CAAKxC,EAAMyC,EAAW,IAEbj3B,KAAK+9B,OACNpL,MAAMqE,KAAKxC,EAAMyC,EAEzB,CACA,WAAAE,CAAYS,EAASV,EAAUD,GAE3B,GAAIW,EAAQlD,eAAe3gC,OAASiM,KAAKi3C,oBACrCrf,EAAQnD,MAAQz0B,KAAKk3C,yBAA0B,CAC/C,MAAMnd,EAAW7C,EAAS1jC,OAAOyjC,GACjCj3B,KAAKs3C,qBACLt3C,KAAKg3B,KAAKY,EAAQlD,eAAgBqF,EACtC,CACJ,CACA,kBAAAud,IAEQ,EAAAjY,EAAA,GAAQr/B,KAAKo3C,YAGbp3C,KAAKi3C,mBAAqB,GAC1Bj3C,KAAKk3C,yBAA2B,EAChCl3C,KAAKm3C,eAAgB,IAGrBn3C,KAAKi3C,mBAAqBj3C,KAAKo3C,UAAU7yC,MACzCvE,KAAKk3C,yBAA2Bl3C,KAAKq3C,gBAAgB9yC,MAE7D,EAEG,MAAMgzC,WAA6BR,GACtC,WAAAnuC,CAAY8wB,EAASxf,GACjByY,MAAM+G,EAASxf,GACfla,KAAKka,KAAOA,EACZla,KAAKw3C,iBAAmB,GACxBx3C,KAAKy3C,uBAAyB,EAC9Bz3C,KAAKw3C,iBAAmBx3C,KAAKka,KAAKw9B,QAAQ3jD,KAC1CiM,KAAKy3C,uBAAyBz3C,KAAKka,KAAKy9B,iBAC5C,CACA,YAAAvgB,CAAa5iC,EAAU0iC,EAAUD,GAC7B,GAAIj3B,KAAKm3C,eACL3iD,EAASohC,aAAa7hC,OAASiM,KAAKw3C,kBACpChjD,EAASigC,MAAQz0B,KAAKy3C,yBACrBz3C,KAAK+9B,MAAO,CACb,MAAMhE,EAAW7C,EAAS1jC,OAAOyjC,GAC3B2gB,EAAW,IAAI/iB,EAAY,CAAE18B,WAAY4hC,IAC/C/5B,KAAKg3C,iBAAmBphD,GAAMgiD,GAC9B53C,KAAK+9B,OAAQ,CACjB,CACJ,EAMG,MAAM8Z,WAAkD9gB,GAC3D,WAAAnuB,CAAYkvC,EAAS7C,GACjBtiB,QACA3yB,KAAK83C,QAAUA,EACf93C,KAAKi1C,WAAaA,EAClBj1C,KAAKzJ,OAAS,CACV+N,WAAO/O,EACP0/C,gBAAY1/C,EACZwiD,iBAAaxiD,EAErB,CACA,YAAAqkC,GAEI,OADA55B,KAAKg3B,KAAKh3B,KAAK83C,SACR93C,KAAKzJ,MAChB,EAEG,MAAMyhD,WAAoCH,GAC7C,QAAAngB,CAASW,EAAUnB,EAAUD,GACzB,GAAIoB,EAAS5D,MAAQz0B,KAAKi1C,WAAY,CAClC,MAAMgD,EAAiB,GAAO/gB,EAAS1jC,OAAOyjC,IAC9Cj3B,KAAKzJ,OAAOwhD,iBAAiCxiD,IAAnB0iD,EACtBA,aAA0B3iB,IAC1Bt1B,KAAKzJ,OAAO+N,MAAQ2zC,EAAeriB,aACnC51B,KAAKzJ,OAAO0+C,WAAagD,EAAexjB,IAEhD,MAEI9B,MAAM+E,SAASW,EAAUnB,EAAUD,EAE3C,EAEG,MAAMihB,WAAuCL,GAChD,WAAApgB,CAAYc,EAAarB,EAAUD,GAC/B,GAAIsB,EAAY9D,MAAQz0B,KAAKi1C,WAAY,CACrC,MAAMkD,EAAoB,GAAOjhB,EAAS1jC,OAAOyjC,IACjDj3B,KAAKzJ,OAAOwhD,iBAAoCxiD,IAAtB4iD,EACtBA,aAA6B7iB,IAC7Bt1B,KAAKzJ,OAAO+N,MAAQ6zC,EAAkBviB,aACtC51B,KAAKzJ,OAAO0+C,WAAakD,EAAkB1jB,IAEnD,MAEI9B,MAAM8E,YAAYc,EAAarB,EAAUD,EAEjD,EAEG,MAAMmhB,WAA0CP,GACnD,cAAAtgB,CAAeS,EAAgBd,EAAUD,GACrC,GAAIe,EAAevD,MAAQz0B,KAAKi1C,WAAY,CACxC,MAAMoD,EAAuB,GAAOnhB,EAAS1jC,OAAOyjC,IACpDj3B,KAAKzJ,OAAOwhD,iBAAuCxiD,IAAzB8iD,EACtBA,aAAgC/iB,IAChCt1B,KAAKzJ,OAAO+N,MAAQ+zC,EAAqBziB,aACzC51B,KAAKzJ,OAAO0+C,WAAaoD,EAAqB5jB,IAEtD,MAEI9B,MAAM4E,eAAeS,EAAgBd,EAAUD,EAEvD,EAGG,MAAMqhB,WAA6CT,GACtD,iBAAArgB,CAAkB+gB,EAAmBrhB,EAAUD,GAC3C,GAAIshB,EAAkB9jB,MAAQz0B,KAAKi1C,WAAY,CAC3C,MAAMuD,EAAoC,GAAOthB,EAAS1jC,OAAOyjC,IACjEj3B,KAAKzJ,OAAOwhD,iBAAoDxiD,IAAtCijD,EACtBA,aAA6CljB,IAC7Ct1B,KAAKzJ,OAAO+N,MAAQk0C,EAAkC5iB,aACtD51B,KAAKzJ,OAAO0+C,WAAauD,EAAkC/jB,IAEnE,MAEI9B,MAAM6E,kBAAkB+gB,EAAmBrhB,EAAUD,EAE7D,EAEG,SAASwhB,GAAkBC,EAAWC,EAAW/E,EAAW,IAE/DA,GAAW,EAAA5K,EAAA,GAAM4K,GACjB,IAAIr9C,EAAS,GACT2C,EAAI,EAMR,SAAS0/C,EAAuBzgD,GAC5B,MAAM2B,EAAe2+C,GAAoCtgD,EAJ1C3E,OAAO,EAAKklD,EAAWx/C,EAAI,IAI4By/C,EAAW/E,GACjF,OAAOr9C,EAAO/C,OAAOsG,EACzB,CAQA,KAAO85C,EAASt+C,OAASqjD,GAAaz/C,EAAIw/C,EAAUpjD,QAAQ,CACxD,MAAMk/B,EAAOkkB,EAAUx/C,GAEvB,GAAIs7B,aAAgBK,EAChB,OAAO+jB,EAAuBpkB,EAAKr8B,YAElC,GAAIq8B,aAAgB,EACrB,OAAOokB,EAAuBpkB,EAAKr8B,YAElC,GAAIq8B,aAAgBO,EACrBx+B,EAASqiD,EAAuBpkB,EAAKr8B,gBAEpC,IAAIq8B,aAAgBQ,EAAqB,CAM1C,OAAO4jB,EALQpkB,EAAKr8B,WAAW3E,OAAO,CAClC,IAAI0hC,EAAW,CACX/8B,WAAYq8B,EAAKr8B,eAI7B,CACK,GAAIq8B,aAAgBS,EAAkC,CAOvD,OAAO2jB,EANQ,CACX,IAAI/jB,EAAY,CAAE18B,WAAYq8B,EAAKr8B,aACnC,IAAI+8B,EAAW,CACX/8B,WAAY,CAAC,IAAIm9B,EAAS,CAAEM,aAAcpB,EAAKmB,aAAcniC,OAAOghC,EAAKr8B,eAIrF,CACK,GAAIq8B,aAAgBW,EAAyB,CAC9C,MAAM0jB,EAASrkB,EAAKr8B,WAAW3E,OAAO,CAClC,IAAI0hC,EAAW,CACX/8B,WAAY,CAAC,IAAIm9B,EAAS,CAAEM,aAAcpB,EAAKmB,aAAcniC,OAAOghC,EAAKr8B,gBAGjF5B,EAASqiD,EAAuBC,EACpC,MACK,GAAIrkB,aAAgBU,EAAY,CACjC,MAAM2jB,EAASrkB,EAAKr8B,WAAW3E,OAAO,CAClC,IAAI0hC,EAAW,CACX/8B,WAAYq8B,EAAKr8B,eAGzB5B,EAASqiD,EAAuBC,EACpC,KACK,IAAIrkB,aAAgBY,EASrB,OARA,EAAAlhC,EAAA,GAAQsgC,EAAKr8B,YAAa2gD,KAIc,KAAhC,EAAAzZ,EAAA,GAAQyZ,EAAQ3gD,cAChB5B,EAASqiD,EAAuBE,EAAQ3gD,YAC5C,IAEG5B,EAEN,KAAIi+B,aAAgBc,GAIrB,MAAM18B,MAAM,wBAHZg7C,EAASh9C,KAAK49B,EAAKoB,aAIvB,EACA18B,GACJ,CAKA,OAJA3C,EAAOK,KAAK,CACRmiD,YAAanF,EACboF,UAAW,EAAKN,EAAWx/C,KAExB3C,CACX,CACO,SAAS0iD,GAAwBC,EAAY5G,EAAa6G,EAAYC,GACzE,MAAMC,EAAoB,qBAEpBC,EAAwB,CAACD,GACzBE,EAAmB,mBACzB,IAAIC,GAAoB,EACxB,MAAMC,EAAoBnH,EAAYh9C,OAChCokD,EAA2BD,EAAoBL,EAAe,EAC9D7iD,EAAS,GACTojD,EAAgB,GAOtB,IANAA,EAAc/iD,KAAK,CACf69B,KAAM,EACNmlB,IAAKV,EACL9B,UAAW,GACXC,gBAAiB,OAEb,EAAAhY,EAAA,GAAQsa,IAAgB,CAC5B,MAAM/F,EAAW+F,EAAcp1C,MAE/B,GAAIqvC,IAAa2F,EAAkB,CAC3BC,IACA,EAAAjyB,GAAA,GAAKoyB,GAAellB,KAAOilB,GAE3BC,EAAcp1C,MAElB,QACJ,CACA,MAAMs1C,EAAUjG,EAASgG,IACnBnN,EAAUmH,EAASnf,IACnBqlB,EAAgBlG,EAASwD,UACzB2C,EAAsBnG,EAASyD,gBAErC,IAAI,EAAAhY,EAAA,GAAQwa,GACR,SAEJ,MAAMrlB,EAAOqlB,EAAQ,GAErB,GAAIrlB,IAAS6kB,EAAmB,CAC5B,MAAMW,EAAW,CACbvlB,IAAKgY,EACLmN,IAAK,EAAKC,GACVzC,UAAW,GAAU0C,GACrBzC,gBAAiB,GAAU0C,IAE/BJ,EAAc/iD,KAAKojD,EACvB,MACK,GAAIxlB,aAAgBc,EAErB,GAAImX,EAAUgN,EAAoB,EAAG,CACjC,MAAMQ,EAAUxN,EAAU,EAE1B,GAAI0M,EADgB7G,EAAY2H,GACJzlB,EAAKoB,cAAe,CAC5C,MAAMokB,EAAW,CACbvlB,IAAKwlB,EACLL,IAAK,EAAKC,GACVzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAKojD,EACvB,CAEJ,KACK,IAAIvN,IAAYgN,EAAoB,EAWrC,MAAM7gD,MAAM,wBATZrC,EAAOK,KAAK,CACRsjD,cAAe1lB,EAAKoB,aACpBukB,oBAAqB3lB,EAAKC,IAC1B2iB,UAAW0C,EACXzC,gBAAiB0C,IAErBP,GAAoB,CAIxB,MAEC,GAAIhlB,aAAgB,EAAa,CAClC,MAAM4lB,GAAe,EAAApR,EAAA,GAAM8Q,GAC3BM,EAAaxjD,KAAK49B,EAAKkB,iBACvB,MAAM2kB,GAAqB,EAAArR,EAAA,GAAM+Q,GACjCM,EAAmBzjD,KAAK49B,EAAKC,KAC7B,MAAMulB,EAAW,CACbvlB,IAAKgY,EACLmN,IAAKplB,EAAKr8B,WAAW3E,OAAO8lD,EAAuB,EAAKO,IACxDzC,UAAWgD,EACX/C,gBAAiBgD,GAErBV,EAAc/iD,KAAKojD,EACvB,MACK,GAAIxlB,aAAgBO,EAAQ,CAE7B,MAAMulB,EAAkB,CACpB7lB,IAAKgY,EACLmN,IAAK,EAAKC,GACVzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK0jD,GAEnBX,EAAc/iD,KAAK2iD,GACnB,MAAMgB,EAAe,CACjB9lB,IAAKgY,EACLmN,IAAKplB,EAAKr8B,WAAW3E,OAAO,EAAKqmD,IACjCzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK2jD,EACvB,MACK,GAAI/lB,aAAgBQ,EAAqB,CAE1C,MAAMwlB,EAAkB,IAAItlB,EAAW,CACnC/8B,WAAYq8B,EAAKr8B,WACjBs8B,IAAKD,EAAKC,MAGRulB,EAAW,CACbvlB,IAAKgY,EACLmN,IAHYplB,EAAKr8B,WAAW3E,OAAO,CAACgnD,GAAkB,EAAKX,IAI3DzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAKojD,EACvB,MACK,GAAIxlB,aAAgBS,EAAkC,CAEvD,MAAMwlB,EAAgB,IAAInlB,EAAS,CAC/BM,aAAcpB,EAAKmB,YAEjB6kB,EAAkB,IAAItlB,EAAW,CACnC/8B,WAAY,CAACsiD,GAAejnD,OAAOghC,EAAKr8B,YACxCs8B,IAAKD,EAAKC,MAGRulB,EAAW,CACbvlB,IAAKgY,EACLmN,IAHYplB,EAAKr8B,WAAW3E,OAAO,CAACgnD,GAAkB,EAAKX,IAI3DzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAKojD,EACvB,MACK,GAAIxlB,aAAgBW,EAAyB,CAE9C,MAAMmlB,EAAkB,CACpB7lB,IAAKgY,EACLmN,IAAK,EAAKC,GACVzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK0jD,GAEnBX,EAAc/iD,KAAK2iD,GACnB,MAAMkB,EAAgB,IAAInlB,EAAS,CAC/BM,aAAcpB,EAAKmB,YAEjB+kB,EAAgB,IAAIxlB,EAAW,CACjC/8B,WAAY,CAACsiD,GAAejnD,OAAOghC,EAAKr8B,YACxCs8B,IAAKD,EAAKC,MAGR8lB,EAAe,CACjB9lB,IAAKgY,EACLmN,IAHYplB,EAAKr8B,WAAW3E,OAAO,CAACknD,GAAgB,EAAKb,IAIzDzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK2jD,EACvB,MACK,GAAI/lB,aAAgBU,EAAY,CAEjC,MAAMolB,EAAkB,CACpB7lB,IAAKgY,EACLmN,IAAK,EAAKC,GACVzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK0jD,GAEnBX,EAAc/iD,KAAK2iD,GAEnB,MAAMmB,EAAgB,IAAIxlB,EAAW,CACjC/8B,WAAYq8B,EAAKr8B,WACjBs8B,IAAKD,EAAKC,MAGR8lB,EAAe,CACjB9lB,IAAKgY,EACLmN,IAHYplB,EAAKr8B,WAAW3E,OAAO,CAACknD,GAAgB,EAAKb,IAIzDzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK2jD,EACvB,MACK,GAAI/lB,aAAgBY,EAErB,IAAK,IAAIl8B,EAAIs7B,EAAKr8B,WAAW7C,OAAS,EAAG4D,GAAK,EAAGA,IAAK,CAClD,MACMyhD,EAAc,CAChBlmB,IAAKgY,EACLmN,IAHYplB,EAAKr8B,WAAWe,GAGff,WAAW3E,OAAO,EAAKqmD,IACpCzC,UAAW0C,EACXzC,gBAAiB0C,GAErBJ,EAAc/iD,KAAK+jD,GACnBhB,EAAc/iD,KAAK2iD,EACvB,MAEC,GAAI/kB,aAAgBK,EACrB8kB,EAAc/iD,KAAK,CACf69B,IAAKgY,EACLmN,IAAKplB,EAAKr8B,WAAW3E,OAAO,EAAKqmD,IACjCzC,UAAW0C,EACXzC,gBAAiB0C,QAGpB,MAAIvlB,aAAgBG,GAKrB,MAAM/7B,MAAM,wBAHZ+gD,EAAc/iD,KAAKgkD,GAAmBpmB,EAAMiY,EAASqN,EAAeC,GAIxE,CACJ,CACA,OAAOxjD,CACX,CACA,SAASqkD,GAAmB9C,EAASrL,EAASqN,EAAeC,GACzD,MAAMK,GAAe,EAAApR,EAAA,GAAM8Q,GAC3BM,EAAaxjD,KAAKkhD,EAAQ/jD,MAC1B,MAAM8mD,GAAyB,EAAA7R,EAAA,GAAM+Q,GAGrC,OADAc,EAAuBjkD,KAAK,GACrB,CACH69B,IAAKgY,EACLmN,IAAK9B,EAAQ3/C,WACbi/C,UAAWgD,EACX/C,gBAAiBwD,EAEzB,CD5dO,SAASC,GAAYtmB,GAExB,GAAIA,aAAgBO,GAAmB,WAATP,EAC1B,OAAOsiB,GAAUiE,OAEhB,GAAIvmB,aAAgBU,GAAuB,eAATV,EACnC,OAAOsiB,GAAUkE,WAEhB,GAAIxmB,aAAgBQ,GACZ,wBAATR,EACA,OAAOsiB,GAAUmE,qBAEhB,GAAIzmB,aAAgBS,GACZ,qCAATT,EACA,OAAOsiB,GAAUoE,oCAEhB,GAAI1mB,aAAgBW,GACZ,4BAATX,EACA,OAAOsiB,GAAUqE,0BAEhB,GAAI3mB,aAAgBY,GAAwB,gBAATZ,EACpC,OAAOsiB,GAAUsE,YAGjB,MAAMxiD,MAAM,uBAEpB,CACO,SAASyiD,GAAkBngD,GAC9B,MAAM,WAAE+5C,EAAU,KAAErhD,EAAI,SAAE0nD,EAAQ,aAAEC,GAAiBrgD,EAC/CzG,EAAOqmD,GAAYQ,GACzB,OAAI7mD,IAASqiD,GAAUsE,YACZI,GAAuBvG,EAAYrhD,EAAM2nD,GAGzCE,GAAiCxG,EAAYrhD,EAAMa,EAAM8mD,EAExE,CA2BO,SAASG,GAA+BC,EAAMtmB,EAAeud,EAAcgJ,GAC9E,MAAMC,EAAYF,EAAKrmD,OACjBwmD,EAA0B,GAAMH,GAAO7C,GAClC,GAAMA,GAAUlF,GACQ,IAApBA,EAASt+C,WAIxB,GAAI+/B,EAIA,OAAO,SAAU0mB,GAIb,MAAMC,GAAa,OAAID,GAASjD,GAAYA,EAAQmD,OACpD,IAAK,IAAI99B,EAAI,EAAGA,EAAI09B,EAAW19B,IAAK,CAChC,MAAM26B,EAAU6C,EAAKx9B,GACf+9B,EAAiBpD,EAAQxjD,OACzB6mD,EAAgBH,EAAW79B,GACjC,QAAsB5oB,IAAlB4mD,IAA4D,IAA7BA,EAAc14C,KAAKzD,MAItDg6C,EAAU,IAAK,IAAIrL,EAAI,EAAGA,EAAIuN,EAAgBvN,IAAK,CAC/C,MAAMiF,EAAWkF,EAAQnK,GACnByN,EAAiBxI,EAASt+C,OAChC,IAAK,IAAI4D,EAAI,EAAGA,EAAIkjD,EAAgBljD,IAAK,CACrC,MAAMmjD,EAAYr8C,KAAKs8C,GAAGpjD,EAAI,GAC9B,IAA6C,IAAzC05C,EAAayJ,EAAWzI,EAAS16C,IAGjC,SAAS8gD,CAEjB,CAGA,OAAO77B,CACX,CAGJ,CAGJ,EAEC,GAAI29B,IAA4BF,EAAsB,CAGvD,MAAMW,GAAkB,OAAIZ,GAAO7C,IACxB,QAAQA,KAEb0D,GAAc,EAAAlwB,GAAA,GAAOiwB,GAAiB,CAAChmD,EAAQuiD,EAASrkB,MAC1D,EAAAvgC,EAAA,GAAQ4kD,GAAU1W,KACT,EAAAtuC,EAAA,GAAIyC,EAAQ6rC,EAAYtB,gBACzBvqC,EAAO6rC,EAAYtB,cAAgBrM,IAEvC,EAAAvgC,EAAA,GAAQkuC,EAAYoH,iBAAkBiT,KAC7B,EAAA3oD,EAAA,GAAIyC,EAAQkmD,KACblmD,EAAOkmD,GAAqBhoB,EAChC,GACF,IAECl+B,IACR,CAAC,GAIJ,OAAO,WACH,MAAM8lD,EAAYr8C,KAAKs8C,GAAG,GAC1B,OAAOE,EAAYH,EAAUvb,aACjC,CACJ,CAOI,OAAO,WACH,IAAK,IAAI3iB,EAAI,EAAGA,EAAI09B,EAAW19B,IAAK,CAChC,MAAM26B,EAAU6C,EAAKx9B,GACf+9B,EAAiBpD,EAAQxjD,OAC/B0kD,EAAU,IAAK,IAAIrL,EAAI,EAAGA,EAAIuN,EAAgBvN,IAAK,CAC/C,MAAMiF,EAAWkF,EAAQnK,GACnByN,EAAiBxI,EAASt+C,OAChC,IAAK,IAAI4D,EAAI,EAAGA,EAAIkjD,EAAgBljD,IAAK,CACrC,MAAMmjD,EAAYr8C,KAAKs8C,GAAGpjD,EAAI,GAC9B,IAA6C,IAAzC05C,EAAayJ,EAAWzI,EAAS16C,IAGjC,SAAS8gD,CAEjB,CAGA,OAAO77B,CACX,CAGJ,CAGJ,CAER,CACO,SAASu+B,GAAwChkB,EAAKka,EAAcgJ,GACvE,MAAME,EAA0B,GAAMpjB,GAAMkb,GACb,IAApBA,EAASt+C,SAEdqnD,EAAajkB,EAAIpjC,OAGvB,GAAIwmD,IAA4BF,EAAsB,CAClD,MAAMgB,GAAoB,QAAQlkB,GAClC,GAAiC,IAA7BkkB,EAAkBtnD,SAClB,EAAA+pC,EAAA,GAAQud,EAAkB,GAAGpT,iBAAkB,CAC/C,MACMqT,EADoBD,EAAkB,GACK9b,aACjD,OAAO,WACH,OAAO9gC,KAAKs8C,GAAG,GAAGxb,eAAiB+b,CACvC,CACJ,CACK,CACD,MAAML,GAAc,EAAAlwB,GAAA,GAAOswB,GAAmB,CAACrmD,EAAQ6rC,EAAa3N,KAChEl+B,EAAO6rC,EAAYtB,eAAgB,GACnC,EAAA5sC,EAAA,GAAQkuC,EAAYoH,iBAAkBiT,IAClClmD,EAAOkmD,IAAqB,CAAI,IAE7BlmD,IACR,IACH,OAAO,WACH,MAAM8lD,EAAYr8C,KAAKs8C,GAAG,GAC1B,OAA+C,IAAxCE,EAAYH,EAAUvb,aACjC,CACJ,CACJ,CAEI,OAAO,WACHkZ,EAAU,IAAK,IAAIrL,EAAI,EAAGA,EAAIgO,EAAYhO,IAAK,CAC3C,MAAMiF,EAAWlb,EAAIiW,GACfyN,EAAiBxI,EAASt+C,OAChC,IAAK,IAAI4D,EAAI,EAAGA,EAAIkjD,EAAgBljD,IAAK,CACrC,MAAMmjD,EAAYr8C,KAAKs8C,GAAGpjD,EAAI,GAC9B,IAA6C,IAAzC05C,EAAayJ,EAAWzI,EAAS16C,IAGjC,SAAS8gD,CAEjB,CAEA,OAAO,CACX,CAEA,OAAO,CACX,CAER,EArOA,SAAWlD,GACPA,EAAUA,EAAkB,OAAI,GAAK,SACrCA,EAAUA,EAAsB,WAAI,GAAK,aACzCA,EAAUA,EAAgC,qBAAI,GAAK,uBACnDA,EAAUA,EAA+C,oCAAI,GAAK,sCAClEA,EAAUA,EAAqC,0BAAI,GAAK,4BACxDA,EAAUA,EAAuB,YAAI,GAAK,aAC7C,CAPD,CAOGA,KAAcA,GAAY,CAAC,IA+N9B,MAAMgG,WAAmC/lB,GACrC,WAAAnuB,CAAY8wB,EAASqjB,EAAkBC,GACnCrqB,QACA3yB,KAAK05B,QAAUA,EACf15B,KAAK+8C,iBAAmBA,EACxB/8C,KAAKg9C,eAAiBA,CAC1B,CACA,YAAApjB,GAEI,OADA55B,KAAKg3B,KAAKh3B,KAAK05B,SACR15B,KAAKi9C,OAChB,CACA,aAAAC,CAAc/oD,EAAMgpD,EAAkBjmB,EAAUD,GAC5C,OAAI9iC,EAAKsgC,MAAQz0B,KAAK+8C,kBAClB/8C,KAAKg9C,iBAAmBG,IACxBn9C,KAAKi9C,QAAU/lB,EAAS1jC,OAAOyjC,IACxB,EAIf,CACA,UAAAK,CAAWS,EAAYb,EAAUD,GACxBj3B,KAAKk9C,cAAcnlB,EAAY+e,GAAUiE,OAAQ7jB,EAAUD,IAC5DtE,MAAM2E,WAAWS,EAAYb,EAAUD,EAE/C,CACA,cAAAM,CAAeS,EAAgBd,EAAUD,GAChCj3B,KAAKk9C,cAAcllB,EAAgB8e,GAAUmE,qBAAsB/jB,EAAUD,IAC9EtE,MAAM2E,WAAWU,EAAgBd,EAAUD,EAEnD,CACA,iBAAAO,CAAkBU,EAAmBhB,EAAUD,GACtCj3B,KAAKk9C,cAAchlB,EAAmB4e,GAAUoE,oCAAqChkB,EAAUD,IAChGtE,MAAM2E,WAAWY,EAAmBhB,EAAUD,EAEtD,CACA,QAAAS,CAASW,EAAUnB,EAAUD,GACpBj3B,KAAKk9C,cAAc7kB,EAAUye,GAAUkE,WAAY9jB,EAAUD,IAC9DtE,MAAM2E,WAAWe,EAAUnB,EAAUD,EAE7C,CACA,WAAAQ,CAAYc,EAAarB,EAAUD,GAC1Bj3B,KAAKk9C,cAAc3kB,EAAaue,GAAUqE,0BAA2BjkB,EAAUD,IAChFtE,MAAM2E,WAAWiB,EAAarB,EAAUD,EAEhD,EAKJ,MAAMmmB,WAAsC,EACxC,WAAAx0C,CAAYm0C,EAAkBC,EAAgBK,GAC1C1qB,QACA3yB,KAAK+8C,iBAAmBA,EACxB/8C,KAAKg9C,eAAiBA,EACtBh9C,KAAKq9C,UAAYA,EACjBr9C,KAAKzJ,OAAS,EAClB,CACA,aAAA2mD,CAAc/oD,EAAMmpD,GACZnpD,EAAKsgC,MAAQz0B,KAAK+8C,kBAClB/8C,KAAKg9C,iBAAmBM,QACJ/nD,IAAnByK,KAAKq9C,WAA2BlpD,IAAS6L,KAAKq9C,YAC/Cr9C,KAAKzJ,OAASpC,EAAKgE,WAE3B,CACA,WAAAg+B,CAAYhiC,GACR6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUiE,OACvC,CACA,eAAAxkB,CAAgBpiC,GACZ6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUkE,WACvC,CACA,wBAAA5kB,CAAyBjiC,GACrB6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUmE,qBACvC,CACA,qCAAA5kB,CAAsCliC,GAClC6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUoE,oCACvC,CACA,4BAAA5kB,CAA6BniC,GACzB6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUqE,0BACvC,CACA,gBAAA3kB,CAAiBriC,GACb6L,KAAKk9C,cAAc/oD,EAAM2iD,GAAUsE,YACvC,EAEJ,SAASmC,GAAwBl/B,GAC7B,MAAM9nB,EAAS,IAAIiO,MAAM6Z,GACzB,IAAK,IAAInlB,EAAI,EAAGA,EAAImlB,EAAMnlB,IACtB3C,EAAO2C,GAAK,GAEhB,OAAO3C,CACX,CAMA,SAASinD,GAAetjC,GACpB,IAAIrI,EAAO,CAAC,IACZ,IAAK,IAAI3Y,EAAI,EAAGA,EAAIghB,EAAK5kB,OAAQ4D,IAAK,CAClC,MAAM86B,EAAU9Z,EAAKhhB,GACfukD,EAAa,GACnB,IAAK,IAAI9O,EAAI,EAAGA,EAAI98B,EAAKvc,OAAQq5C,IAAK,CAClC,MAAM+O,EAAiB7rC,EAAK88B,GAC5B8O,EAAW7mD,KAAK8mD,EAAiB,IAAM1pB,EAAQ8M,cAC/C,IAAK,IAAI3iB,EAAI,EAAGA,EAAI6V,EAAQwV,gBAAgBl0C,OAAQ6oB,IAAK,CACrD,MAAMw/B,EAAsB,IAAM3pB,EAAQwV,gBAAgBrrB,GAC1Ds/B,EAAW7mD,KAAK8mD,EAAiBC,EACrC,CACJ,CACA9rC,EAAO4rC,CACX,CACA,OAAO5rC,CACX,CAIA,SAAS+rC,GAAmBC,EAAmBC,EAAgBrpB,GAC3D,IAAK,IAAIspB,EAAa,EAAGA,EAAaF,EAAkBvoD,OAAQyoD,IAAc,CAE1E,GAAIA,IAAetpB,EACf,SAEJ,MAAMupB,EAAyBH,EAAkBE,GACjD,IAAK,IAAIE,EAAY,EAAGA,EAAYH,EAAexoD,OAAQ2oD,IAAa,CAEpE,IAA0C,IAAtCD,EADcF,EAAeG,IAE7B,OAAO,CAEf,CACJ,CAEA,OAAO,CACX,CACO,SAASC,GAAkCC,EAAU9iD,GACxD,MAAM+iD,GAAc,OAAID,GAAWrF,GAAYL,GAAkB,CAACK,GAAU,KACtEuF,EAAcd,GAAwBa,EAAY9oD,QAClDgpD,GAAa,OAAIF,GAAc1K,IACjC,MAAM6K,EAAO,CAAC,EAOd,OANA,EAAArqD,EAAA,GAAQw/C,GAAehjC,IACnB,MAAMmB,EAAO2rC,GAAe9sC,EAAKqoC,cACjC,EAAA7kD,EAAA,GAAQ2d,GAAO69B,IACX6O,EAAK7O,IAAW,CAAI,GACtB,IAEC6O,CAAI,IAEf,IAAIC,EAAUJ,EAEd,IAAK,IAAIK,EAAa,EAAGA,GAAcpjD,EAAGojD,IAAc,CACpD,MAAMC,EAAcF,EACpBA,EAAUjB,GAAwBmB,EAAYppD,QAE9C,IAAK,IAAIqpD,EAAS,EAAGA,EAASD,EAAYppD,OAAQqpD,IAAU,CACxD,MAAMC,EAA0BF,EAAYC,GAE5C,IAAK,IAAIE,EAAc,EAAGA,EAAcD,EAAwBtpD,OAAQupD,IAAe,CACnF,MAAMC,EAAiBF,EAAwBC,GAAa9F,YACtDC,EAAY4F,EAAwBC,GAAa7F,UACjD+F,EAAavB,GAAesB,GAGlC,GAFiBlB,GAAmBU,EAAYS,EAAYJ,KAE5C,EAAAtf,EAAA,GAAQ2Z,IAAc8F,EAAexpD,SAAW+F,EAAG,CAC/D,MAAM2jD,EAAgBX,EAAYM,GAElC,IAAoD,IAAhDM,GAAaD,EAAeF,GAA2B,CACvDE,EAAcpoD,KAAKkoD,GAEnB,IAAK,IAAInQ,EAAI,EAAGA,EAAIoQ,EAAWzpD,OAAQq5C,IAAK,CACxC,MAAMe,EAAUqP,EAAWpQ,GAC3B2P,EAAWK,GAAQjP,IAAW,CAClC,CACJ,CACJ,KAEK,CACD,MAAMwP,EAA6BzG,GAAkBO,EAAWyF,EAAa,EAAGK,GAChFN,EAAQG,GAAUH,EAAQG,GAAQnrD,OAAO0rD,IAEzC,EAAAhrD,EAAA,GAAQgrD,GAA6BxuC,IACjC,MAAMquC,EAAavB,GAAe9sC,EAAKqoC,cACvC,EAAA7kD,EAAA,GAAQ6qD,GAAa5oC,IACjBmoC,EAAWK,GAAQxoC,IAAO,CAAI,GAChC,GAEV,CACJ,CACJ,CACJ,CACA,OAAOkoC,CACX,CACO,SAAS7C,GAAuBvG,EAAYkK,EAAa9jD,EAAGo9B,GAC/D,MAAMnE,EAAU,IAAI8oB,GAA8BnI,EAAY6B,GAAUsE,YAAa3iB,GAErF,OADA0mB,EAAY9qB,OAAOC,GACZ4pB,GAAkC5pB,EAAQ/9B,OAAQ8E,EAC7D,CACO,SAASogD,GAAiCxG,EAAYkK,EAAa7D,EAAUjgD,GAChF,MAAM+jD,EAAmB,IAAIhC,GAA8BnI,EAAYqG,GACvE6D,EAAY9qB,OAAO+qB,GACnB,MAAMC,EAAYD,EAAiB7oD,OAE7B+oD,EADiB,IAAIxC,GAA2BqC,EAAalK,EAAYqG,GAC/C1hB,eAGhC,OAAOskB,GAAkC,CAFtB,IAAIrpB,EAAgB,CAAE18B,WAAYknD,IACnC,IAAIxqB,EAAgB,CAAE18B,WAAYmnD,KACcjkD,EACtE,CACO,SAAS4jD,GAAaM,EAAaC,GACtCC,EAAkB,IAAK,IAAIvmD,EAAI,EAAGA,EAAIqmD,EAAYjqD,OAAQ4D,IAAK,CAC3D,MAAMwmD,EAAYH,EAAYrmD,GAC9B,GAAIwmD,EAAUpqD,SAAWkqD,EAAWlqD,OAApC,CAGA,IAAK,IAAIq5C,EAAI,EAAGA,EAAI+Q,EAAUpqD,OAAQq5C,IAAK,CACvC,MAAMgR,EAAYH,EAAW7Q,GACvBiR,EAAWF,EAAU/Q,GAG3B,IAAuB,KAFAgR,IAAcC,QACuBrqD,IAAxDqqD,EAASlX,mBAAmBiX,EAAU7e,eAEtC,SAAS2e,CAEjB,CACA,OAAO,CAVP,CAWJ,CACA,OAAO,CACX,CASO,SAASI,GAA0BC,GACtC,OAAO,GAAMA,GAAiBC,GAAmB,GAAMA,GAAiBC,GAAe,GAAMA,GAAa17C,IAAU,EAAA+6B,EAAA,GAAQ/6B,EAAMklC,sBACtI,CEvcO,SAASyW,GAAgBC,EAAWrhB,EAAYwX,EAAgBH,GACnE,MAAMiK,GAAkB,EAAAlqD,GAAA,GAAQiqD,GAAY3J,GAMhD,SAAsCpC,EAAckC,GAChD,MAAM+J,EAAmB,IAAIC,GAC7BlM,EAAa9f,OAAO+rB,GACpB,MAAME,EAAqBF,EAAiBG,eACtCC,EAAmB,GAAQF,EAAoBG,IAC/CC,EAAa,EAAOF,GAAmBG,GAClCA,EAAUrrD,OAAS,IAExBytC,GAAS,QAAI,OAAO2d,IAAcE,IACpC,MAAMC,EAAY,GAAMD,GAClBjmB,EAAM0b,EAAe/B,yBAAyBH,EAAcyM,GAC5DlM,EAAU5d,GAAqB+pB,GAC/BC,EAAW,CACbnlB,QAAShB,EACTlmC,KAAM+hD,GAA0BuK,sBAChC9N,SAAUkB,EAAapgD,KACvB2gD,QAASA,EACTO,WAAY4L,EAAUpsB,KAEpBusB,EAAQC,GAA2BJ,GAIzC,OAHIG,IACAF,EAASI,UAAYF,GAElBF,CAAQ,IAEnB,OAAO/d,CACX,CAhCiEoe,CAA6B5K,EAAcF,KAClG+K,EAkZV,SAAgDlB,EAAWrhB,EAAYwX,GACnE,MAAMtT,EAAS,GACTse,GAAa,OAAIxiB,GAAayiB,GAAcA,EAAUvtD,OAY5D,OAXA,EAAAG,EAAA,GAAQgsD,GAAYnK,IAChB,MAAMwL,EAAexL,EAAShiD,KAC9B,GAAI,GAASstD,EAAYE,GAAe,CACpC,MAAM/Z,EAAS6O,EAAezB,4BAA4BmB,GAC1DhT,EAAOnsC,KAAK,CACR+kC,QAAS6L,EACT/yC,KAAM+hD,GAA0BgL,gCAChCvO,SAAUsO,GAElB,KAEGxe,CACX,CAjayC0e,CAAuCvB,EAAWrhB,EAAYwX,GAC7FqL,GAAoB,EAAAzrD,GAAA,GAAQiqD,GAAYyB,GAgQ3C,SAA6BxN,EAAckC,GAC9C,MAAMuL,EAAc,IAAIC,GACxB1N,EAAa9f,OAAOutB,GACpB,MAAME,EAAMF,EAAYG,aAClBhf,GAAS,EAAA9sC,GAAA,GAAQ6rD,GAAME,GACrBA,EAAO7pD,WAAW7C,OAAS,IACpB,CACH,CACIqmC,QAAS0a,EAAeT,8BAA8B,CAClDzB,aAAcA,EACde,YAAa8M,IAEjBvtD,KAAM+hD,GAA0ByL,cAChChP,SAAUkB,EAAapgD,KACvBkhD,WAAY+M,EAAOvtB,MAKpB,KAGf,OAAOsO,CACX,CAvR8Dmf,CAAoBP,EAAStL,KACjF8L,GAAsB,EAAAlsD,GAAA,GAAQiqD,GAAYyB,GA0E7C,SAAyC/tD,EAAMwuD,EAAUh1C,EAAWipC,GACvE,MAAMtT,EAAS,GACTsf,GAAc,EAAA/1B,GAAA,GAAO81B,GAAU,CAAC7rD,EAAQorD,IACtCA,EAAQ5tD,OAASH,EAAKG,KACfwC,EAAS,EAEbA,GACR,GACH,GAAI8rD,EAAc,EAAG,CACjB,MAAM7a,EAAS6O,EAAeJ,4BAA4B,CACtD9B,aAAcvgD,EACdsiD,YAAa9oC,IAEjB21B,EAAOnsC,KAAK,CACR+kC,QAAS6L,EACT/yC,KAAM+hD,GAA0B8L,oBAChCrP,SAAUr/C,EAAKG,MAEvB,CACA,OAAOgvC,CACX,CA9FgEwf,CAAgCZ,EAASzB,EAAWhK,EAAaG,KAC7H,OAAO8J,EAAgB3sD,OAAO4tD,EAA8BM,EAAmBS,EACnF,CA4BO,SAAS1B,GAAgCjsB,GAC5C,MAAO,GAAGsC,GAAqBtC,QAAWA,EAAKC,SAASwsB,GAA2BzsB,IACvF,CACA,SAASysB,GAA2BzsB,GAChC,OAAIA,aAAgBc,EACTd,EAAKoB,aAAa7hC,KAEpBygC,aAAgB,EACdA,EAAKkB,gBAGL,EAEf,CACO,MAAM2qB,WAAsC,EAC/C,WAAAz3C,GACI+pB,SAASjvB,WACT1D,KAAKugD,eAAiB,EAC1B,CACA,gBAAAtqB,CAAiBusB,GACbxiD,KAAKugD,eAAe3pD,KAAK4rD,EAC7B,CACA,WAAArsB,CAAYssB,GACRziD,KAAKugD,eAAe3pD,KAAK6rD,EAC7B,CACA,4BAAAnsB,CAA6BosB,GACzB1iD,KAAKugD,eAAe3pD,KAAK8rD,EAC7B,CACA,wBAAAtsB,CAAyBusB,GACrB3iD,KAAKugD,eAAe3pD,KAAK+rD,EAC7B,CACA,qCAAAtsB,CAAsCusB,GAClC5iD,KAAKugD,eAAe3pD,KAAKgsD,EAC7B,CACA,eAAArsB,CAAgBssB,GACZ7iD,KAAKugD,eAAe3pD,KAAKisD,EAC7B,CACA,gBAAArsB,CAAiBssB,GACb9iD,KAAKugD,eAAe3pD,KAAKksD,EAC7B,CACA,aAAArsB,CAAcjiC,GACVwL,KAAKugD,eAAe3pD,KAAKpC,EAC7B,EAyCG,SAASuuD,GAAwBjL,EAAS/B,EAAUM,EAAgBn8B,EAAO,IAC9E,MAAM6oB,EAAS,GACTigB,EAAmBC,GAAqBlN,EAAS59C,YACvD,IAAI,EAAAknC,EAAA,GAAQ2jB,GACR,MAAO,GAEN,CACD,MAAM/P,EAAW6E,EAAQ/jD,KACE,GAASivD,EAAkBlL,IAElD/U,EAAOnsC,KAAK,CACR+kC,QAAS0a,EAAeR,wBAAwB,CAC5C1B,aAAc2D,EACdhC,kBAAmB57B,IAEvBzlB,KAAM+hD,GAA0B0M,eAChCjQ,SAAUA,IAKlB,MAAMkQ,EAAiB,GAAWH,EAAkB9oC,EAAK1mB,OAAO,CAACskD,KAC3DsL,GAAsB,EAAAntD,GAAA,GAAQktD,GAAiBE,IACjD,MAAMpZ,GAAU,EAAAjB,EAAA,GAAM9uB,GAEtB,OADA+vB,EAAQrzC,KAAKysD,GACNN,GAAwBjL,EAASuL,EAAahN,EAAgBpM,EAAQ,IAEjF,OAAOlH,EAAOvvC,OAAO4vD,EACzB,CACJ,CACO,SAASH,GAAqB9qD,GACjC,IAAI5B,EAAS,GACb,IAAI,EAAA8oC,EAAA,GAAQlnC,GACR,OAAO5B,EAEX,MAAMsqD,EAAY,GAAM1oD,GAExB,GAAI0oD,aAAqB,EACrBtqD,EAAOK,KAAKiqD,EAAUnsB,qBAErB,GAAImsB,aAAqBhsB,GAC1BgsB,aAAqB9rB,GACrB8rB,aAAqB7rB,GACrB6rB,aAAqB5rB,GACrB4rB,aAAqB1rB,GACrB0rB,aAAqB3rB,EACrB3+B,EAASA,EAAO/C,OAAOyvD,GAAqBpC,EAAU1oD,kBAErD,GAAI0oD,aAAqBzrB,EAE1B7+B,GAAS,SAAQ,OAAIsqD,EAAU1oD,YAAamrD,GAAeL,GAAqBK,EAAWnrD,oBAE1F,KAAI0oD,aAAqBvrB,GAI1B,MAAM18B,MAAM,wBAEhB,MAAM2qD,EAAkB5sB,GAAekqB,GACjC2C,EAAUrrD,EAAW7C,OAAS,EACpC,GAAIiuD,GAAmBC,EAAS,CAC5B,MAAMC,EAAO,EAAKtrD,GAClB,OAAO5B,EAAO/C,OAAOyvD,GAAqBQ,GAC9C,CAEI,OAAOltD,CAEf,CACA,MAAMsrD,WAAoB,EACtB,WAAAj5C,GACI+pB,SAASjvB,WACT1D,KAAK+hD,aAAe,EACxB,CACA,gBAAAvrB,CAAiBriC,GACb6L,KAAK+hD,aAAanrD,KAAKzC,EAC3B,EAgCG,SAASuvD,GAAyCvP,EAAcwP,EAAoBtN,GACvF,MAAMuL,EAAc,IAAIC,GACxB1N,EAAa9f,OAAOutB,GACpB,IAAIE,EAAMF,EAAYG,aAGtBD,EAAM,GAAOA,GAAME,IAAwC,IAA7BA,EAAOltB,oBACrC,MAAMiO,GAAS,EAAA9sC,GAAA,GAAQ6rD,GAAME,IACzB,MAAM4B,EAAiB5B,EAAOvtB,IACxBovB,EAAqB7B,EAAOzG,cAAgBoI,EAC5C7pD,EAAe0hD,GAAuBoI,EAAgBzP,EAAc0P,EAAoB7B,GACxF8B,EA2Ed,SAAsChqD,EAAco7C,EAAathD,EAAMyiD,GACnE,MAAM0N,EAAsB,GACtBC,GAAuB,EAAA13B,GAAA,GAAOxyB,GAAc,CAACvD,EAAQuiD,EAASiF,MAEH,IAAzD7I,EAAY/8C,WAAW4lD,GAAYjpB,oBAGvC,EAAA5gC,EAAA,GAAQ4kD,GAAUlF,IACd,MAAMqQ,EAAwB,CAAClG,IAC/B,EAAA7pD,EAAA,GAAQ4F,GAAc,CAACoqD,EAAcC,KAC7BpG,IAAeoG,GACflF,GAAaiF,EAActQ,KAEmC,IAA9DsB,EAAY/8C,WAAWgsD,GAAiBrvB,mBACxCmvB,EAAsBrtD,KAAKutD,EAC/B,IAEAF,EAAsB3uD,OAAS,IAC9B2pD,GAAa8E,EAAqBnQ,KACnCmQ,EAAoBntD,KAAKg9C,GACzBr9C,EAAOK,KAAK,CACR+kD,KAAMsI,EACN/pC,KAAM05B,IAEd,IAnBOr9C,IAsBZ,IACG6tD,GAAa,OAAIJ,GAAuBK,IAC1C,MAAMC,GAAc,OAAID,EAAkB1I,MAAOoC,GAAeA,EAAa,IAO7E,MAAO,CACHpiB,QAPgB0a,EAAejB,+BAA+B,CAC9DjB,aAAcvgD,EACdshD,YAAaA,EACbC,iBAAkBmP,EAClBvP,WAAYsP,EAAkBnqC,OAI9BzlB,KAAM+hD,GAA0B+N,eAChCtR,SAAUr/C,EAAKG,KACfkhD,WAAYC,EAAYzgB,IACxB36B,aAAcuqD,EAAkB1I,KACnC,IAEL,OAAOyI,CACX,CAxHoCI,CAA6B1qD,EAAckoD,EAAQ7N,EAAckC,GACvFoO,EAwHP,SAA4C3qD,EAAco7C,EAAathD,EAAMyiD,GAEhF,MAAMqO,GAAkB,EAAAp4B,GAAA,GAAOxyB,GAAc,CAACvD,EAAQuiD,EAASrkB,KAC3D,MAAMkwB,GAAkB,OAAI7L,GAAUlF,IAC3B,CAAEnf,IAAKA,EAAKva,KAAM05B,MAE7B,OAAOr9C,EAAO/C,OAAOmxD,EAAgB,GACtC,IACG5hB,EAAS,IAAQ,EAAA9sC,GAAA,GAAQyuD,GAAkBE,IAG7C,IAA0C,IAFlB1P,EAAY/8C,WAAWysD,EAAenwB,KAE1CK,kBAChB,MAAO,GAEX,MAAM+vB,EAAYD,EAAenwB,IAC3BqwB,EAAaF,EAAe1qC,KAC5B6qC,GAAmC,EAAAtxD,GAAA,GAAOixD,GAAkBM,IAE9D,OAGI,IADJ9P,EAAY/8C,WAAW6sD,EAAiBvwB,KAAKK,mBAEzCkwB,EAAiBvwB,IAAMowB,IFmEFxxC,EEhEA2xC,EAAiB9qC,KFgETxG,EEhEeoxC,EFiEhDzxC,EAAO/d,OAASoe,EAAMpe,QAC1B,GAAM+d,GAAQ,CAAC2gB,EAASS,KACpB,MAAMwwB,EAAevxC,EAAM+gB,GAC3B,OAAQT,IAAYixB,GAChBA,EAAavc,mBAAmB1U,EAAQ8M,aAAc,KAL/D,IAA8BztB,EAAQK,CEhE2B,IAmBhE,OAjB6B,OAAIqxC,GAAmCG,IAChE,MAAMZ,EAAc,CAACY,EAAkBzwB,IAAM,EAAGowB,EAAY,GACtD5P,EAAiC,IAApBC,EAAYzgB,IAAY,GAAKygB,EAAYzgB,IAO5D,MAAO,CACHkH,QAPY0a,EAAexB,qCAAqC,CAChEV,aAAcvgD,EACdshD,YAAaA,EACbC,iBAAkBmP,EAClBvP,WAAYmQ,EAAkBhrC,OAI9BzlB,KAAM+hD,GAA0B2O,sBAChClS,SAAUr/C,EAAKG,KACfkhD,WAAYA,EACZn7C,aAAcwqD,EACjB,GAEsB,KAE/B,OAAOvhB,CACX,CAvK0CqiB,CAAmCtrD,EAAckoD,EAAQ7N,EAAckC,GACzG,OAAOyN,EAAoBtwD,OAAOixD,EAA0B,IAEhE,OAAO1hB,CACX,CACO,MAAMsiB,WAA4B,EACrC,WAAAz8C,GACI+pB,SAASjvB,WACT1D,KAAKugD,eAAiB,EAC1B,CACA,4BAAAjqB,CAA6BosB,GACzB1iD,KAAKugD,eAAe3pD,KAAK8rD,EAC7B,CACA,wBAAAtsB,CAAyBusB,GACrB3iD,KAAKugD,eAAe3pD,KAAK+rD,EAC7B,CACA,qCAAAtsB,CAAsCusB,GAClC5iD,KAAKugD,eAAe3pD,KAAKgsD,EAC7B,CACA,eAAArsB,CAAgBssB,GACZ7iD,KAAKugD,eAAe3pD,KAAKisD,EAC7B,EC3QG,SAAS,GAAe3nD,GAC3B,MAAMoqD,GAAgB,EAAAvmB,GAAA,GAAS7jC,EAAS,CACpCm7C,eAAgBpC,KAEdsR,EAAgB,CAAC,EAIvB,OAHA,EAAArxD,EAAA,GAAQgH,EAAQhI,OAAQU,IACpB2xD,EAAc3xD,EAAKG,MAAQH,CAAI,ITPhC,SAAwBssD,EAAW7J,GACtC,MAAMmP,EAAc,IAAIrP,GAAuB+J,EAAW7J,GAE1D,OADAmP,EAAYlP,cACLkP,EAAYziB,MACvB,CSKW,CAAkBwiB,EAAeD,EAAcjP,eAC1D,CCZA,MAAMoP,GAA6B,2BAC7BC,GAA0B,uBAC1BC,GAAuB,qBACvBC,GAAiC,6BACjCC,GAA8B,CAChCJ,GACAC,GACAC,GACAC,IAIG,SAASE,GAAuBhjD,GAEnC,OAAO,GAAS+iD,GAA6B/iD,EAAM/O,KACvD,CALAwF,OAAO2xC,OAAO2a,IAMd,MAAME,WAA6BntD,MAC/B,WAAAgQ,CAAY+yB,EAASr3B,GACjBquB,MAAMgJ,GACN37B,KAAKsE,MAAQA,EACbtE,KAAKgmD,eAAiB,GAEtBzsD,OAAO0sD,eAAejmD,gBAAiB+D,WAEnCnL,MAAMstD,mBACNttD,MAAMstD,kBAAkBlmD,KAAMA,KAAK4I,YAE3C,EAEG,MAAMu9C,WAAiCJ,GAC1C,WAAAn9C,CAAY+yB,EAASr3B,EAAO8hD,GACxBzzB,MAAMgJ,EAASr3B,GACftE,KAAKomD,cAAgBA,EACrBpmD,KAAKjM,KAAO0xD,EAChB,EAEG,MAAMY,WAA6BN,GACtC,WAAAn9C,CAAY+yB,EAASr3B,EAAO8hD,GACxBzzB,MAAMgJ,EAASr3B,GACftE,KAAKomD,cAAgBA,EACrBpmD,KAAKjM,KAAO2xD,EAChB,EAEG,MAAMY,WAAmCP,GAC5C,WAAAn9C,CAAY+yB,EAASr3B,GACjBquB,MAAMgJ,EAASr3B,GACftE,KAAKjM,KAAO6xD,EAChB,EAEG,MAAMW,WAA2BR,GACpC,WAAAn9C,CAAY+yB,EAASr3B,EAAO8hD,GACxBzzB,MAAMgJ,EAASr3B,GACftE,KAAKomD,cAAgBA,EACrBpmD,KAAKjM,KAAO4xD,EAChB,EClDG,MAAMa,GAAiB,CAAC,EAClBC,GAA6B,0BACnC,MAAMC,WAAgC9tD,MACzC,WAAAgQ,CAAY+yB,GACRhJ,MAAMgJ,GACN37B,KAAKjM,KAAO0yD,EAChB,EAqPG,SAASE,GAA4BC,EAAUrjD,EAAMsjD,EAAeC,EAAcC,EAAgBC,EAAgBC,GACrH,MAAM9wC,EAAMnW,KAAKknD,4BAA4BJ,EAAcC,GAC3D,IAAII,EAAoBnnD,KAAKonD,iBAAiBjxC,GAC9C,QAA0B5gB,IAAtB4xD,EAAiC,CACjC,MAAM5F,EAAevhD,KAAKqnD,sBAG1BF,EADe,IAAIH,EADChnD,KAAKsnD,qBAAqB/F,GACCwF,GACpBntB,eAC3B55B,KAAKonD,iBAAiBjxC,GAAOgxC,CACjC,CACA,IAAII,EAA0BJ,EAAkB7iD,MAC5CkjD,EAAaL,EAAkBlS,WACnC,MAAM8C,EAAcoP,EAAkBpP,YAGP,IAA3B/3C,KAAKynD,WAAWnyD,QAChByiD,QAC4BxiD,IAA5BgyD,IACAA,EAA0BxhD,GAC1ByhD,EAAa,QAIejyD,IAA5BgyD,QAAwDhyD,IAAfiyD,GAGzCxnD,KAAK0nD,kCAAkCH,EAAyBC,EAAYP,IAI5EjnD,KAAK2nD,wBAAwBf,EAAUrjD,EAAMsjD,EAAeU,EAEpE,CC1RO,MAWMK,GAAmB,KACnBC,GAAe,KACfC,GAAuB,KAE7B,SAASZ,GAA4Ba,EAASjB,EAAc7R,GAC/D,OAAOA,EAAa6R,EAAeiB,CACvC,CClBO,MAAMC,GACT,WAAAp/C,CAAY1N,GACR,IAAIlE,EACJgJ,KAAKu7C,aACiF,QAAjFvkD,EAAKkE,aAAyC,EAASA,EAAQqgD,oBAAiC,IAAPvkD,EAAgBA,EAAKixD,GAAsB1M,YAC7I,CACA,QAAA2M,CAAShtD,GACL,MAAMitD,EAAsBnoD,KAAK+iD,wBAAwB7nD,EAAQhI,OACjE,IAAI,EAAAmsC,EAAA,GAAQ8oB,GAAsB,CAC9B,MAAMC,EAAiBpoD,KAAKqoD,4BAA4BntD,EAAQhI,OAC1Do1D,EAAsBtoD,KAAK0jD,yCAAyCxoD,EAAQhI,MAAO8M,KAAKu7C,cACxFgN,EAAwBvoD,KAAKwoD,kCAAkCttD,EAAQhI,MAAO8M,KAAKu7C,cAOzF,MANkB,IACX4M,KACAC,KACAE,KACAC,EAGX,CACA,OAAOJ,CACX,CACA,uBAAApF,CAAwB7vD,GACpB,OAAO,EAAA+C,GAAA,GAAQ/C,GAAQu1D,GAAgB1F,GAAwB0F,EAAaA,EAAapU,KAC7F,CACA,2BAAAgU,CAA4Bn1D,GACxB,OAAO,EAAA+C,GAAA,GAAQ/C,GAAQu1D,GLiLxB,SAAoCtU,EAAckC,GACrD,MAAMuL,EAAc,IAAIC,GACxB1N,EAAa9f,OAAOutB,GACpB,MAAME,EAAMF,EAAYG,aAyBxB,OAxBe,EAAA9rD,GAAA,GAAQ6rD,GAAME,IACzB,MAAM0G,EAAa,GAAU1G,EAAO7pD,YACpC,OAAO,EAAAlC,GAAA,GAAQyyD,GAAY,CAACC,EAAiB5K,KACzC,MAAM6K,EAAqB3P,GAAwB,CAAC0P,GAAkB,GAAItgB,GAAwB,GAClG,OAAI,EAAAhJ,EAAA,GAAQupB,GACD,CACH,CACIjtB,QAAS0a,EAAeX,2BAA2B,CAC/CvB,aAAcA,EACde,YAAa8M,EACbrM,eAAgBoI,IAEpBtpD,KAAM+hD,GAA0BqS,oBAChC5V,SAAUkB,EAAapgD,KACvBkhD,WAAY+M,EAAOvtB,IACnB8qB,YAAaxB,EAAa,IAK3B,EACX,GACF,GAGV,CK9M+C+K,CAA2BL,EAAapU,KACnF,CACA,wCAAAqP,CAAyCxwD,EAAOqoD,GAC5C,OAAO,EAAAtlD,GAAA,GAAQ/C,GAAQu1D,GAAgB/E,GAAyC+E,EAAalN,EAAclH,KAC/G,CACA,iCAAAmU,CAAkCt1D,EAAOqoD,GACrC,OLoQD,SAA2CwN,EAAexN,EAAclF,GAC3E,MAAMtT,EAAS,GAwBf,OAvBA,EAAA7uC,EAAA,GAAQ60D,GAAgBN,IACpB,MAAMrI,EAAmB,IAAIiF,GAC7BoD,EAAYp0B,OAAO+rB,GACnB,MAAME,EAAqBF,EAAiBG,gBAC5C,EAAArsD,EAAA,GAAQosD,GAAqB0I,IACzB,MAAM1N,EAAWR,GAAYkO,GACvBnF,EAAqBmF,EAASzN,cAAgBA,EAG9C0N,EADQxN,GADSuN,EAASv0B,IAC+Bg0B,EAAanN,EAAUuI,GAClD,GACpC,IAAI,EAAAxkB,EAAA,IAAQ,QAAQ4pB,IAAyB,CACzC,MAAMzhB,EAAS6O,EAAed,0BAA0B,CACpDpB,aAAcsU,EACdjT,WAAYwT,IAEhBjmB,EAAOnsC,KAAK,CACR+kC,QAAS6L,EACT/yC,KAAM+hD,GAA0B0S,uBAChCjW,SAAUwV,EAAY10D,MAE9B,IACF,IAECgvC,CACX,CK9ReylB,CAAkCt1D,EAAOqoD,EAAclH,GAClE,CACA,4BAAA8U,CAA6BjuD,GACzB,OPWD,SAAiC+5C,EAAYkK,EAAa5D,EAAclmB,EAAeumB,EAAsBwN,GAChH,MAAMtJ,EAAiBtE,GAAuBvG,EAAYkK,EAAa5D,GAIvE,OAAO6N,EAActJ,EAAgBzqB,EAHhBwqB,GAA0BC,GACzCnX,GACAN,GAC4DuT,EACtE,COjBeyN,CAAwBnuD,EAAQ6rD,eAAgB7rD,EAAQtH,KAAMsH,EAAQqgD,aAAcrgD,EAAQm6B,cAAen6B,EAAQ0gD,qBAAsBF,GACpJ,CACA,yBAAA4N,CAA0BpuD,GACtB,OP2BD,SAA2C+5C,EAAYkK,EAAa9jD,EAAGugD,EAAsBN,EAAUiO,GAC1G,MAAMzJ,EAAiBrE,GAAiCxG,EAAYkK,EAAa7D,EAAUjgD,GACrFu3C,EAAeiN,GAA0BC,GACzCnX,GACAN,GACN,OAAOkhB,EAAiBzJ,EAAe,GAAIlN,EAAcgJ,EAC7D,COjCe4N,CAAkCtuD,EAAQ6rD,eAAgB7rD,EAAQtH,KAAMsH,EAAQqgD,aAAcrgD,EAAQ0gD,qBAAsBd,GAAY5/C,EAAQogD,UAAWoB,GACtK,ECgFJ,MAAM0D,GAAmB,IAzCzB,cAAyC,EACrC,WAAAx3C,GACI+pB,SAASjvB,WACT1D,KAAKypD,WAAa,CACdhH,OAAQ,GACRvN,YAAa,GACbM,WAAY,GACZkU,wBAAyB,GACzBC,oBAAqB,GACrBC,iCAAkC,GAE1C,CACA,KAAAC,GACI7pD,KAAKypD,WAAa,CACdhH,OAAQ,GACRvN,YAAa,GACbM,WAAY,GACZkU,wBAAyB,GACzBC,oBAAqB,GACrBC,iCAAkC,GAE1C,CACA,WAAAzzB,CAAYssB,GACRziD,KAAKypD,WAAWhH,OAAO7rD,KAAK6rD,EAChC,CACA,4BAAAnsB,CAA6BosB,GACzB1iD,KAAKypD,WAAWC,wBAAwB9yD,KAAK8rD,EACjD,CACA,wBAAAtsB,CAAyBusB,GACrB3iD,KAAKypD,WAAWE,oBAAoB/yD,KAAK+rD,EAC7C,CACA,qCAAAtsB,CAAsCusB,GAClC5iD,KAAKypD,WAAWG,iCAAiChzD,KAAKgsD,EAC1D,CACA,eAAArsB,CAAgBssB,GACZ7iD,KAAKypD,WAAWjU,WAAW5+C,KAAKisD,EACpC,CACA,gBAAArsB,CAAiBssB,GACb9iD,KAAKypD,WAAWvU,YAAYt+C,KAAKksD,EACrC,GCnHG,SAASgH,GAA0BC,EAAkBC,IAEZ,IAAxCC,MAAMF,EAAiBvf,cAIvBuf,EAAiBvf,YAAcwf,EAAgBxf,YAC/Cuf,EAAiB1X,UAAY2X,EAAgB3X,WAMxC0X,EAAiB1X,UAAY2X,EAAgB3X,YAAc,IAChE0X,EAAiB1X,UAAY2X,EAAgB3X,UAErD,CAQO,SAAS6X,GAAoBH,EAAkBC,IAEN,IAAxCC,MAAMF,EAAiBvf,cAIvBuf,EAAiBvf,YAAcwf,EAAgBxf,YAC/Cuf,EAAiBtZ,YAAcuZ,EAAgBvZ,YAC/CsZ,EAAiBvZ,UAAYwZ,EAAgBxZ,UAC7CuZ,EAAiB1X,UAAY2X,EAAgB3X,UAC7C0X,EAAiB5X,UAAY6X,EAAgB7X,UAC7C4X,EAAiB7X,QAAU8X,EAAgB9X,SAMtC6X,EAAiB1X,UAAY2X,EAAgB3X,YAAc,IAChE0X,EAAiB1X,UAAY2X,EAAgB3X,UAC7C0X,EAAiB5X,UAAY6X,EAAgB7X,UAC7C4X,EAAiB7X,QAAU8X,EAAgB9X,QAEnD,CCpDO,SAASiY,GAAe33B,EAAK43B,GAChC7wD,OAAO8wD,eAAe73B,EAFb,OAEwB,CAC7B83B,YAAY,EACZC,cAAc,EACdC,UAAU,EACV73D,MAAOy3D,GAEf,CCNO,SAASK,GAAaC,EAAK1J,GAC9B,MAAM2J,GAAgB,EAAA94C,EAAA,GAAK64C,GACrBE,EAAsBD,EAAcr1D,OAC1C,IAAK,IAAI4D,EAAI,EAAGA,EAAI0xD,EAAqB1xD,IAAK,CAC1C,MACM2xD,EAAiBH,EADDC,EAAczxD,IAE9B4xD,EAAuBD,EAAev1D,OAC5C,IAAK,IAAIq5C,EAAI,EAAGA,EAAImc,EAAsBnc,IAAK,CAC3C,MAAMoc,EAAYF,EAAelc,QAEFp5C,IAA3Bw1D,EAAUjqB,cACV9gC,KAAK+qD,EAAUh3D,MAAMg3D,EAAU75C,SAAU8vC,EAEjD,CACJ,CAEJ,CACO,SAASgK,GAAqC9U,EAAanjD,GAC9D,MAAMk4D,EAAqB,WAAc,EAIzCd,GAAec,EAAoB/U,EAAc,iBACjD,MAAMgV,EAAgB,CAClB32B,MAAO,SAAUx9B,EAASiqD,GAQtB,IANI,EAAA/xC,EAAA,GAAQlY,KAGRA,EAAUA,EAAQ,MAGlB,EAAAoqC,GAAA,GAAYpqC,GAGhB,OAAOiJ,KAAKjJ,EAAQhD,MAAMgD,EAAQma,SAAU8vC,EAChD,EACAmK,gBAAiB,WACb,MAAMC,EAgCX,SAAyBC,EAAiBt4D,GAC7C,MAAMu4D,EAGH,SAAmCD,EAAiBt4D,GACvD,MAAMw4D,GAAmB,EAAA93D,GAAA,GAAOV,GAAYwuD,IACa,KAA9C,EAAA5gB,GAAA,GAAW0qB,EAAgB9J,MAEhCxe,GAAS,OAAIwoB,GAAmBhK,IAC3B,CACH5mB,IAAK,4BAA4B4mB,SAAqB8J,EAAgBziD,YAAgB,oBACtFnU,KAAM+2D,GAA0BC,eAChCC,WAAYnK,MAGpB,OAAO,GAAQxe,EACnB,CAf0B4oB,CAA0BN,EAAiBt4D,GACjE,OAAOu4D,CACX,CAnC6CH,CAAgBnrD,KAAMjN,GACvD,KAAK,EAAAssC,EAAA,GAAQ+rB,GAA2B,CACpC,MAAMQ,GAAgB,OAAIR,GAA2BS,GAAiBA,EAAalxB,MACnF,MAAM/hC,MAAM,mCAAmCoH,KAAK4I,YAAY7U,aACzD63D,EAAclyD,KAAK,QAAQwN,QAAQ,MAAO,UACrD,CACJ,GAKJ,OAHA+jD,EAAmBlnD,UAAYmnD,GACFtiD,YAAcqiD,EAC3CA,EAAmBa,YAAc/4D,EAC1Bk4D,CACX,CAeO,IAAIO,IACX,SAAWA,GACPA,EAA0BA,EAA4C,iBAAI,GAAK,mBAC/EA,EAA0BA,EAA0C,eAAI,GAAK,gBAChF,CAHD,CAGGA,KAA8BA,GAA4B,CAAC,I,eChE9D,MAAMO,GAAwB,CAC1BC,YAAa,8DAEjBzyD,OAAO2xC,OAAO6gB,IACd,MAAME,IAAmB,EACnBC,GAAiB12D,KAAK22D,IAAI,ENLO,GMKuB,EACxDC,GAAM1Z,GAAY,CAAE3+C,KAAM,wBAAyBmf,QAASusB,GAAMC,KACxEoJ,GAAkB,CAACsjB,KACnB,MAAMC,GAAwB1e,GAAoBye,GAAK,gJAKtD,GAAI,GAAI,GAAI,GAAI,GAAI,GACrB7yD,OAAO2xC,OAAOmhB,IACd,MAAMC,GAA0B,CAC5Bv4D,KAAM,gJAENmd,SAAU,CAAC,GA8Mf,SAASq7C,GAAWC,EAAiBC,EAAaxX,EAAYyX,GAAY,GACtEC,GAAuB1X,GACvB,MAAM2X,GAAW,QAAK5sD,KAAK6sD,oBACrBC,GAAgB,EAAAnsB,GAAA,GAAW8rB,GAAeA,EAAcA,EAAYM,IACpEC,EAAU,IAAIR,EAAgB,CAAEr0D,WAAY,GAAIs8B,IAAKwgB,IAW3D,OAVIyX,IACAM,EAAQr3B,UAAY82B,EAAYQ,MAEhC,EAAAn5D,EAAA,GAAI24D,EAAa,mBACjBO,EAAQzR,aAAekR,EAAYS,eAEvCltD,KAAK6sD,mBAAmBj2D,KAAKo2D,GAC7BF,EAAcrpD,KAAKzD,MACnB4sD,EAASz0D,WAAWvB,KAAKo2D,GACzBhtD,KAAK6sD,mBAAmBtoD,MACjBwnD,EACX,CACA,SAASoB,GAAaV,EAAaxX,GAC/B0X,GAAuB1X,GACvB,MAAM2X,GAAW,QAAK5sD,KAAK6sD,oBAErBO,GAAsC,KAAzB,EAAAn+C,EAAA,GAAQw9C,GACrB9Q,GAAsB,IAAfyR,EAAuBX,EAAcA,EAAYM,IACxDM,EAAY,IAAIj4B,EAAY,CAC9Bj9B,WAAY,GACZs8B,IAAKwgB,EACLngB,kBAAmBs4B,IAAiD,IAAnCX,EAAYa,sBAE7C,EAAAx5D,EAAA,GAAI24D,EAAa,mBACjBY,EAAU9R,aAAekR,EAAYS,eAEzC,MAAM73B,EAAgB,EAAKsmB,GAAO7C,IAAY,EAAAnY,GAAA,GAAWmY,EAAQmD,QAiBjE,OAhBAoR,EAAUh4B,cAAgBA,EAC1Bu3B,EAASz0D,WAAWvB,KAAKy2D,IACzB,EAAAn5D,EAAA,GAAQynD,GAAO7C,IACX,MAAMyU,EAAc,IAAI14B,EAAY,CAAE18B,WAAY,KAClDk1D,EAAUl1D,WAAWvB,KAAK22D,IACtB,EAAAz5D,EAAA,GAAIglD,EAAS,sBACbyU,EAAYz4B,kBAAoBgkB,EAAQwU,oBAGnC,EAAAx5D,EAAA,GAAIglD,EAAS,UAClByU,EAAYz4B,mBAAoB,GAEpC90B,KAAK6sD,mBAAmBj2D,KAAK22D,GAC7BzU,EAAQ0U,IAAI/pD,KAAKzD,MACjBA,KAAK6sD,mBAAmBtoD,KAAK,IAE1BwnD,EACX,CACA,SAAS0B,GAAah5B,GAClB,OAAe,IAARA,EAAY,GAAK,GAAGA,GAC/B,CACA,SAASk4B,GAAuBl4B,GAC5B,GAAIA,EAAM,GAAKA,EAAMy3B,GAAgB,CACjC,MAAMppD,EAAQ,IAAIlK,MAElB,kCAAkC67B,8DAC0By3B,GAAiB,KAE7E,MADAppD,EAAM4qD,sBAAuB,EACvB5qD,CACV,CACJ,CCnRO,MAAM6qD,GAAchgB,GAAoB5nC,GAAK,GAAI6nD,IAAKA,IAAKA,IAAKA,IAAKA,IAAKA,KACjFr0D,OAAO2xC,OAAOyiB,IACP,MAAM1F,GAAwB1uD,OAAO2xC,OAAO,CAC/CD,iBAAiB,EACjBsQ,aAAc,EACdK,sBAAsB,EACtBiS,WAAW,EACX/iB,qBAAsB+H,GACtBib,qBAAsB,OACtB/iB,eAAe,EACfC,iBAAiB,IAER+iB,GAAsBx0D,OAAO2xC,OAAO,CAC7C8iB,kBAAmB,KAAe,EAClCC,eAAe,IAEZ,IAAIzX,GClCiB0X,GDmDrB,SAASC,GAAUx7D,OAAQ4C,GAC9B,OAAO,WACH,OAAO5C,CACX,CACJ,EApBA,SAAW6jD,GACPA,EAA0BA,EAA6C,kBAAI,GAAK,oBAChFA,EAA0BA,EAA+C,oBAAI,GAAK,sBAClFA,EAA0BA,EAAiD,sBAAI,GAAK,wBACpFA,EAA0BA,EAAiD,sBAAI,GAAK,wBACpFA,EAA0BA,EAAkD,uBAAI,GAAK,yBACrFA,EAA0BA,EAA0C,eAAI,GAAK,iBAC7EA,EAA0BA,EAA+C,oBAAI,GAAK,sBAClFA,EAA0BA,EAA0C,eAAI,GAAK,iBAC7EA,EAA0BA,EAA2D,gCAAI,GAAK,kCAC9FA,EAA0BA,EAA8C,mBAAI,GAAK,qBACjFA,EAA0BA,EAAkD,uBAAI,IAAM,yBACtFA,EAA0BA,EAAiD,sBAAI,IAAM,wBACrFA,EAA0BA,EAAyC,cAAI,IAAM,gBAC7EA,EAA0BA,EAAuD,4BAAI,IAAM,6BAC9F,CAfD,CAeGA,KAA8BA,GAA4B,CAAC,IAMvD,MAAMhuC,GAIT,0BAAO4lD,CAAoBC,GACvB,MAAMz1D,MAAM,8HAEhB,CACA,mBAAAw1D,GACIpuD,KAAKwrC,WAAW,uBAAuB,KACnC,IAAI8iB,EACJtuD,KAAKuuD,kBAAmB,EACxB,MAAMnhD,EAAYpN,KAAKoN,UACvBpN,KAAKwrC,WAAW,eAAe,KAI3BnY,EAAiBrzB,KAAK,IAE1BA,KAAKwrC,WAAW,qBAAqB,KACjC,IACIxrC,KAAKwuD,mBAEL,EAAAt6D,EAAA,GAAQ8L,KAAKyuD,mBAAoBlN,IAC7B,MACMmN,EADc1uD,KAAKuhD,GACwC,sBACjE,IAAIoN,EACJ3uD,KAAKwrC,WAAW,GAAG+V,UAAqB,KACpCoN,EAAmB3uD,KAAK4uD,mBAAmBrN,EAAcmN,EAAsB,IAEnF1uD,KAAK6uD,qBAAqBtN,GAAgBoN,CAAgB,GAElE,CACA,QACI3uD,KAAK8uD,kBACT,KAEJ,IAAIC,EAAiB,GA2CrB,GA1CA/uD,KAAKwrC,WAAW,qBAAqB,KACjCujB,EAAiB,GAAe,CAC5B77D,OAAO,OAAO8M,KAAK6uD,wBAEvB7uD,KAAKgvD,iBAAmBhvD,KAAKgvD,iBAAiBx7D,OAAOu7D,EAAe,IAExE/uD,KAAKwrC,WAAW,uBAAuB,KAGnC,IAAI,EAAAnM,EAAA,GAAQ0vB,KAA4C,IAAzB/uD,KAAKgrC,gBAA2B,CAC3D,MAAMikB,GV1FM/zD,EU0F6B,CACrChI,OAAO,OAAO8M,KAAK6uD,sBACnBhwB,YAAY,OAAO7+B,KAAKkvD,WACxB7Y,eAAgBhC,GAChB6B,YAAa9oC,GV1F1B,IAHPlS,GAAU,EAAA6jC,GAAA,GAAS7jC,EAAS,CACxBm7C,eAAgBhC,MAEcnhD,MAAOgI,EAAQ2jC,WAAY3jC,EAAQm7C,eAAgBn7C,EAAQg7C,cU4FvEiZ,EXxGnB,SAA2Bj0D,GAC9B,MAAMk0D,EAAmCl0D,EAAQm0D,kBAAkBnH,SAAS,CACxEh1D,MAAOgI,EAAQhI,MACf2rC,WAAY3jC,EAAQ2jC,WACpBqX,YAAah7C,EAAQg7C,cAEzB,OAAO,OAAIkZ,GAAmCE,GAAkB/1D,OAAOg2D,OAAO,CAAE96D,KAAM+hD,GAA0BgZ,6BAA+BF,IACnJ,CWiGsDG,CAAkB,CAChDJ,kBAAmBrvD,KAAKqvD,kBACxBn8D,OAAO,OAAO8M,KAAK6uD,sBACnBhwB,YAAY,OAAO7+B,KAAKkvD,WACxBhZ,YAAa9oC,IAEjBpN,KAAKgvD,iBAAmBhvD,KAAKgvD,iBAAiBx7D,OAAOy7D,EAAkBE,EAC3E,CVvGT,IAAyBj0D,CUuGhB,KAGA,EAAAmkC,EAAA,GAAQr/B,KAAKgvD,oBAEThvD,KAAKirC,iBACLjrC,KAAKwrC,WAAW,0BAA0B,KACtC,MAAMkkB,ErC/FvB,SAAgCC,GACnC,MAAMC,EAAgB,CAAC,EAKvB,OAJA,EAAA17D,EAAA,GAAQy7D,GAAiBj2B,IACrB,MAAMm2B,EAAiB,IAAIp2B,GAAoBC,GAASE,eACxD,EAAOg2B,EAAeC,EAAe,IAElCD,CACX,CqCwF2CE,EAAuB,OAAO9vD,KAAK6uD,uBACtD7uD,KAAK+vD,cAAgBL,CAAU,IAGvC1vD,KAAKwrC,WAAW,6BAA6B,KACzC,IAAIx0C,EAAI8B,EAC4C,QAAnDA,GAAM9B,EAAKgJ,KAAKqvD,mBAAmBW,kBAA+B,IAAPl3D,GAAyBA,EAAG2K,KAAKzM,EAAI,CAC7F9D,OAAO,OAAO8M,KAAK6uD,wBAEvB7uD,KAAKiwD,8BAA6B,OAAOjwD,KAAK6uD,sBAAsB,MAGvErmD,GAAO0nD,oCACP,EAAA7wB,EAAA,GAAQr/B,KAAKgvD,kBAEd,MADAV,GAAgB,OAAItuD,KAAKgvD,kBAAmBlO,GAAaA,EAASnlB,UAC5D,IAAI/iC,MAAM,wCAAwC01D,EAAc50D,KAAK,yCAC/E,GAER,CACA,WAAAkP,CAAYunD,EAAiBrgD,GACzB9P,KAAKgvD,iBAAmB,GACxBhvD,KAAKuuD,kBAAmB,EACxB,MAAM6B,EAAOpwD,KAUb,GATAowD,EAAKC,iBAAiBvgD,GACtBsgD,EAAKE,mBACLF,EAAKG,eAAezgD,GACpBsgD,EAAKI,qBAAqBL,EAAiBrgD,GAC3CsgD,EAAKK,gBAAgB3gD,GACrBsgD,EAAKM,gBAAgB5gD,GACrBsgD,EAAKO,oBACLP,EAAKQ,iBAAiB9gD,GACtBsgD,EAAKS,sBAAsB/gD,IACvB,EAAAhc,EAAA,GAAIgc,EAAQ,iBACZ,MAAM,IAAIlX,MAAM,uQAKpBoH,KAAKgrC,iBAAkB,EAAAl3C,EAAA,GAAIgc,EAAQ,mBAC7BA,EAAOk7B,gBACPid,GAAsBjd,eAChC,EAQJxiC,GAAO0nD,kCAAmC,EC7KdhC,GD8KhB1lD,GAAQ,CR9Jb,MACH,eAAAioD,CAAgB3gD,GACZ9P,KAAKonD,iBAAmB,CAAC,EACzBpnD,KAAK+vD,cAAgB,CAAC,EACtB/vD,KAAKirC,iBAAkB,EAAAn3C,EAAA,GAAIgc,EAAQ,mBAC7BA,EAAOm7B,gBACPgd,GAAsBhd,gBAIxBjrC,KAAKirC,kBACLjrC,KAAK2mD,4BAA8BA,GAE3C,CACA,gBAAAmK,CAAiB98B,GACb,MAAM+8B,EAAcpjB,GAAoB3Z,EAAS,GAAI45B,IAAKA,IAAKA,IAAKA,IAAKA,IAAKA,KAE9E,OADAmD,EAAYC,sBAAuB,EAC5BD,CACX,CACA,gCAAAE,CAAiCj9B,GAC7B,OAAO,CACX,CACA,+BAAAk9B,CAAgCl9B,GAC5B,OAAO,CACX,CACA,uBAAA2zB,CAAwBwJ,EAAaC,EAAiBC,EAAeC,GAEjE,MAAMC,EAAgBvxD,KAAKwxD,sBACrBC,EAAkBzxD,KAAK0xD,mBACvB1L,EAAiB,GACvB,IAAI2L,GAAoB,EACxB,MAAMC,EAAyB5xD,KAAKs8C,GAAG,GACvC,IAAIgF,EAAYthD,KAAKs8C,GAAG,GACxB,MAAMuV,EAAuB,KACzB,MAAMzL,EAAgBpmD,KAAKs8C,GAAG,GAGxB3hB,EAAM36B,KAAK8qC,qBAAqBgI,0BAA0B,CAC5D5tC,SAAUosD,EACVve,OAAQ6e,EACR5e,SAAUoT,EACVnT,SAAUjzC,KAAKqnD,wBAEbvkD,EAAQ,IAAIqjD,GAAyBxrB,EAAKi3B,EAAwB5xD,KAAKs8C,GAAG,IAEhFx5C,EAAMkjD,eAAiB,GAAUA,GACjChmD,KAAK8xD,WAAWhvD,EAAM,EAE1B,MAAQ6uD,GAAmB,CAEvB,GAAI3xD,KAAK4yC,aAAa0O,EAAWgQ,GAE7B,YADAO,IAGC,GAAIR,EAAc5tD,KAAKzD,MAKxB,OAHA6xD,SAEAV,EAAYrrD,MAAM9F,KAAMoxD,GAGnBpxD,KAAK4yC,aAAa0O,EAAWiQ,GAClCI,GAAoB,GAGpBrQ,EAAYthD,KAAK+xD,aACjB/xD,KAAKgyD,kBAAkB1Q,EAAW0E,GAE1C,CAIAhmD,KAAKiyD,iBAAiBR,EAC1B,CACA,iCAAA/J,CAAkCH,EAAyBC,EAAYP,GAGnE,OAAiB,IAAbA,IAIAjnD,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAIiL,KAK9BvnD,KAAKkyD,mBAMLlyD,KAAKmyD,yBAAyB5K,EAAyBvnD,KAAKoyD,4BAA4B7K,EAAyBC,GAIzH,CAEA,2BAAA4K,CAA4Bp+B,EAASq+B,GACjC,MAAMC,EAActyD,KAAKuyD,sBAAsBv+B,EAASq+B,GAExD,OADgBryD,KAAKwyD,0BAA0BF,EAEnD,CACA,iBAAAG,CAAkBnB,EAAiB33B,GAC/B,GAAI35B,KAAK0yD,mCAAmCpB,EAAiB33B,GAEzD,OADoB35B,KAAK8wD,iBAAiBQ,GAG9C,GAAItxD,KAAK2yD,kCAAkCrB,GAAkB,CACzD,MAAMsB,EAAU5yD,KAAK+xD,aAErB,OADA/xD,KAAK6yD,eACED,CACX,CACA,MAAM,IAAIlM,GAAwB,gBACtC,CACA,wBAAAyL,CAAyBW,EAAen5B,GACpC,OAAQ35B,KAAK0yD,mCAAmCI,EAAen5B,IAC3D35B,KAAK2yD,kCAAkCG,EAC/C,CACA,kCAAAJ,CAAmCpB,EAAiB33B,GAChD,IAAK35B,KAAKixD,iCAAiCK,GACvC,OAAO,EAGX,IAAI,EAAAjyB,EAAA,GAAQ1F,GACR,OAAO,EAEX,MAAMo5B,EAAgB/yD,KAAKs8C,GAAG,GAI9B,YADO/mD,KAF0B,EAAApC,GAAA,GAAKwmC,GAAUq5B,GACrChzD,KAAK4yC,aAAamgB,EAAeC,IAGhD,CACA,iCAAAL,CAAkCrB,GAC9B,QAAKtxD,KAAKkxD,gCAAgCI,IAGRtxD,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAIgV,EAEpE,CACA,wBAAA2B,CAAyBnyB,GACrB,MAAMoyB,EAAYlzD,KAAKmzD,mBACjBC,EAAuBpzD,KAAKqzD,0BAA0BH,GAC5D,OAAO,GAASE,EAAsBtyB,EAC1C,CACA,mBAAA0wB,GACI,MAAM8B,EAA4BtzD,KAAKuzD,mBAEvC,IAAIlX,EAAYr8C,KAAKs8C,GAAG,GACpBjhD,EAAI,EACR,OAAa,CACT,MAAMm4D,GAAa,EAAArgE,GAAA,GAAKmgE,GAA4BG,GAC/B7gB,GAAayJ,EAAWoX,KAG7C,QAAmBl+D,IAAfi+D,EACA,OAAOA,EAEXnX,EAAYr8C,KAAKs8C,GAAGjhD,GACpBA,GACJ,CACJ,CACA,gBAAA83D,GAEI,GAA+B,IAA3BnzD,KAAKynD,WAAWnyD,OAChB,OAAOkxD,GAEX,MAAMkN,EAAoB1zD,KAAK2zD,+BACzBC,EAAc5zD,KAAK6zD,qCACnBC,EAAoB9zD,KAAK+zD,mCAC/B,MAAO,CACH9gB,SAAUjzC,KAAKg0D,wBAAwBN,GACvCO,iBAAkBL,EAClBM,OAAQl0D,KAAKg0D,wBAAwBF,GAE7C,CACA,uBAAAK,GACI,MAAMC,EAAoBp0D,KAAKynD,WACzB4M,EAA0Br0D,KAAKs0D,sBACrC,OAAO,OAAIF,GAAmB,CAACnhB,EAAUxe,IACzB,IAARA,EACO+xB,GAEJ,CACHvT,SAAUjzC,KAAKg0D,wBAAwB/gB,GACvCghB,iBAAkBI,EAAwB5/B,GAC1Cy/B,OAAQl0D,KAAKg0D,wBAAwBI,EAAkB3/B,EAAM,MAGzE,CACA,gBAAA8+B,GACI,MAAMgB,GAAc,OAAIv0D,KAAKm0D,2BAA4BzkB,GAC9C1vC,KAAKqzD,0BAA0B3jB,KAE1C,OAAO,QAAQ6kB,EACnB,CACA,yBAAAlB,CAA0BH,GACtB,GAAIA,IAAc1M,GACd,MAAO,CAACzgD,IAEZ,MAAM8zB,EAAaq5B,EAAUjgB,SAAWigB,EAAUe,iBAAmB,GAAKf,EAAUgB,OACpF,OAAOl0D,KAAK+vD,cAAcl2B,EAC9B,CAGA,iBAAAm4B,CAAkB1tD,EAAOkwD,GAIrB,OAHKx0D,KAAK4yC,aAAatuC,EAAOyB,KAC1ByuD,EAAa59D,KAAK0N,GAEfkwD,CACX,CACA,QAAAC,CAASzgC,GACL,MAAMgyB,EAAiB,GACvB,IAAI4M,EAAU5yD,KAAKs8C,GAAG,GACtB,MAA+C,IAAxCt8C,KAAK4yC,aAAaggB,EAAS5+B,IAC9B4+B,EAAU5yD,KAAK+xD,aACf/xD,KAAKgyD,kBAAkBY,EAAS5M,GAGpC,OAAO,GAAUA,EACrB,CACA,2BAAAW,CAA4BC,EAAUrjD,EAAMsjD,EAAeC,EAAcC,EAAgBC,EAAgBC,GAGzG,CACA,qBAAAsL,CAAsBv+B,EAASq+B,GAS3B,MANoB,CAChBjb,UAHkBp3C,KAAK00D,4BAIvBrd,iBAHwB,EAAArO,EAAA,GAAMhpC,KAAKs0D,uBAInC5c,QAAS1jB,EACT2jB,kBAAmB0a,EAG3B,CACA,yBAAAqC,GACI,OAAO,OAAI10D,KAAKynD,YAAakN,GAAkB30D,KAAKg0D,wBAAwBW,IAChF,GGtPG,MACH,cAAApE,CAAezgD,GACX9P,KAAK47C,sBAAuB,EAAA9nD,EAAA,GAAIgc,EAAQ,wBAClCA,EAAO8rC,qBACPqM,GAAsBrM,qBAC5B57C,KAAKu7C,cAAe,EAAAznD,EAAA,GAAIgc,EAAQ,gBAC1BA,EAAOyrC,aACP0M,GAAsB1M,aAC5Bv7C,KAAKqvD,mBAAoB,EAAAv7D,EAAA,GAAIgc,EAAQ,qBAC/BA,EAAOu/C,kBACP,IAAIrH,GAAqB,CAAEzM,aAAcv7C,KAAKu7C,eACpDv7C,KAAK40D,oBAAsB,IAAIt9D,GACnC,CACA,4BAAA24D,CAA6B/8D,IACzB,EAAAgB,EAAA,GAAQhB,GAAQ6iD,IACZ/1C,KAAKwrC,WAAW,GAAGuK,EAAShiD,uBAAuB,KAC/C,MAAM,YAAEmhD,EAAW,WAAEM,EAAU,OAAEiN,EAAM,oBAAEkH,EAAmB,iCAAEC,EAAgC,wBAAEF,GAqGzG,SAAwB91D,GAC3BwsD,GAAiByJ,QACjBj2D,EAAKygC,OAAO+rB,IACZ,MAAMqJ,EAAarJ,GAAiBqJ,WAGpC,OADArJ,GAAiByJ,QACVJ,CACX,CA5G6IoL,CAAe9e,IAC5I,EAAA7hD,EAAA,GAAQghD,GAAc8T,IAClB,MAAM8L,EAA2B,IAAjB9L,EAASv0B,IAAY,GAAKu0B,EAASv0B,IACnDz0B,KAAKwrC,WAAW,GAAG1U,GAAqBkyB,KAAY8L,KAAW,KAC3D,MAAMC,EAAS/0D,KAAKqvD,kBAAkBlG,6BAA6B,CAC/DpC,eAAgBiC,EAASv0B,IACzB7gC,KAAMmiD,EACNwF,aAAcyN,EAASzN,cAAgBv7C,KAAKu7C,aAC5ClmB,cAAe2zB,EAAS3zB,cACxBumB,qBAAsB57C,KAAK47C,uBAEzBzlC,EAAM+wC,GAA4BlnD,KAAKg1D,oBAAoBjf,EAAShiD,MFrB5E,IEqB2Fi1D,EAASv0B,KAClGz0B,KAAKi1D,eAAe9+C,EAAK4+C,EAAO,GAClC,KAEN,EAAA7gE,EAAA,GAAQshD,GAAawT,IACjBhpD,KAAKk1D,qBAAqBnf,EAAUiT,EAASv0B,IFxBzC,IEwBwD,aAAcu0B,EAASzN,aAAczkB,GAAqBkyB,GAAU,KAEpI,EAAA90D,EAAA,GAAQuuD,GAASuG,IACbhpD,KAAKk1D,qBAAqBnf,EAAUiT,EAASv0B,IF5BvC,IE4BwD,SAAUu0B,EAASzN,aAAczkB,GAAqBkyB,GAAU,KAElI,EAAA90D,EAAA,GAAQy1D,GAAsBX,IAC1BhpD,KAAKk1D,qBAAqBnf,EAAUiT,EAASv0B,IAAKmzB,GAAkB,sBAAuBoB,EAASzN,aAAczkB,GAAqBkyB,GAAU,KAErJ,EAAA90D,EAAA,GAAQ01D,GAAmCZ,IACvChpD,KAAKk1D,qBAAqBnf,EAAUiT,EAASv0B,IAAKqzB,GAAsB,mCAAoCkB,EAASzN,aAAczkB,GAAqBkyB,GAAU,KAEtK,EAAA90D,EAAA,GAAQw1D,GAA0BV,IAC9BhpD,KAAKk1D,qBAAqBnf,EAAUiT,EAASv0B,IAAKozB,GAAc,0BAA2BmB,EAASzN,aAAczkB,GAAqBkyB,GAAU,GACnJ,GACJ,GAEV,CACA,oBAAAkM,CAAqBthE,EAAMmzD,EAAgBoO,EAAS7Z,EAAU8Z,EAAkBC,GAC5Er1D,KAAKwrC,WAAW,GAAG6pB,IAAmC,IAAnBtO,EAAuB,GAAKA,KAAkB,KAC7E,MAAMgO,EAAS/0D,KAAKqvD,kBAAkB/F,0BAA0B,CAC5DvC,iBACAnzD,OACA2nD,aAAc6Z,GAAoBp1D,KAAKu7C,aACvCK,qBAAsB57C,KAAK47C,qBAC3BN,aAEEnlC,EAAM+wC,GAA4BlnD,KAAKg1D,oBAAoBphE,EAAKG,MAAOohE,EAASpO,GACtF/mD,KAAKi1D,eAAe9+C,EAAK4+C,EAAO,GAExC,CAEA,2BAAA7N,CAA4BJ,EAAc7R,GAEtC,OAAOiS,GADmBlnD,KAAK2zD,+BACuB7M,EAAc7R,EACxE,CACA,kBAAAqgB,CAAmBn/C,GACf,OAAOnW,KAAK40D,oBAAoBh9D,IAAIue,EACxC,CAEA,cAAA8+C,CAAe9+C,EAAKxjB,GAChBqN,KAAK40D,oBAAoBj9D,IAAIwe,EAAKxjB,EACtC,GO1EG,MACH,eAAA+9D,CAAgB5gD,GAOZ,GANA9P,KAAKu1D,UAAY,GAEjBv1D,KAAK6tD,UAAY/9C,EAAO+9C,UACxB7tD,KAAK8tD,sBAAuB,EAAAh6D,EAAA,GAAIgc,EAAQ,wBAClCA,EAAOg+C,qBACP7F,GAAsB6F,qBACvB9tD,KAAK6tD,UAQN,GAAI,QAAQ3pB,KAAKlkC,KAAK8tD,sBACd9tD,KAAKirC,iBACLjrC,KAAKw1D,yBAA2BtL,GAChClqD,KAAKy1D,wBAA0BvL,GAC/BlqD,KAAK01D,YAAcpoB,GAAA,EACnBttC,KAAK21D,uBAAyB31D,KAAK41D,qCAGnC51D,KAAKw1D,yBAA2BloB,GAAA,EAChCttC,KAAKy1D,wBAA0BnoB,GAAA,EAC/BttC,KAAK01D,YAAc11D,KAAK61D,gBACxB71D,KAAK21D,uBAAyB31D,KAAK81D,wCAGtC,GAAI,cAAc5xB,KAAKlkC,KAAK8tD,sBACzB9tD,KAAKirC,iBACLjrC,KAAKw1D,yBAA2B1L,GAChC9pD,KAAKy1D,wBAA0B3L,GAC/B9pD,KAAK01D,YAAcpoB,GAAA,EACnBttC,KAAK21D,uBACD31D,KAAK+1D,2CAGT/1D,KAAKw1D,yBAA2BloB,GAAA,EAChCttC,KAAKy1D,wBAA0BnoB,GAAA,EAC/BttC,KAAK01D,YAAc11D,KAAKg2D,sBACxBh2D,KAAK21D,uBACD31D,KAAKi2D,6CAGZ,KAAI,QAAQ/xB,KAAKlkC,KAAK8tD,sBAOvB,MAAMl1D,MAAM,kDAAkDkX,EAAOg+C,yBANrE9tD,KAAKw1D,yBAA2BloB,GAAA,EAChCttC,KAAKy1D,wBAA0BnoB,GAAA,EAC/BttC,KAAK01D,YAAcpoB,GAAA,EACnBttC,KAAK21D,uBAAyBroB,GAAA,CAIlC,MA7CAttC,KAAKk2D,yBAA2B5oB,GAAA,EAChCttC,KAAKm2D,sBAAwB7oB,GAAA,EAC7BttC,KAAKo2D,gBAAkB9oB,GAAA,EACvBttC,KAAKq2D,mBAAqB/oB,GAAA,EAC1BttC,KAAK01D,YAAcpoB,GAAA,CA2C3B,CACA,wCAAAyoB,CAAyCh/D,GACrCA,EAAQu/D,SAAW,CACf9rB,YAAaojB,IACbvb,UAAWub,IAEnB,CACA,uCAAAqI,CAAwCl/D,GACpCA,EAAQu/D,SAAW,CAKf9rB,YAAaxqC,KAAKs8C,GAAG,GAAG9R,YACxB6H,UAAWub,IAEnB,CACA,kCAAAgI,CAAmC7+D,GAC/BA,EAAQu/D,SAAW,CACf9rB,YAAaojB,IACbpd,UAAWod,IACXnd,YAAamd,IACbvb,UAAWub,IACX1b,QAAS0b,IACTzb,UAAWyb,IAEnB,CAMA,iCAAAkI,CAAkC/+D,GAC9B,MAAMslD,EAAYr8C,KAAKs8C,GAAG,GAC1BvlD,EAAQu/D,SAAW,CACf9rB,YAAa6R,EAAU7R,YACvBgG,UAAW6L,EAAU7L,UACrBC,YAAa4L,EAAU5L,YACvB4B,UAAWub,IACX1b,QAAS0b,IACTzb,UAAWyb,IAEnB,CACA,wBAAAsI,CAAyBK,GACrB,MAAMx/D,EAAU,CACZhD,KAAMwiE,EACNrlD,SAAU3X,OAAOqK,OAAO,OAE5B5D,KAAK21D,uBAAuB5+D,GAC5BiJ,KAAKu1D,UAAU3+D,KAAKG,EACxB,CACA,qBAAAo/D,GACIn2D,KAAKu1D,UAAUhxD,KACnB,CACA,eAAAsxD,CAAgBW,GAEZ,MAAMC,EAAYz2D,KAAKs8C,GAAG,GACpB72C,EAAM+wD,EAAYF,SAGpB7wD,EAAI+kC,aAAeisB,EAAUjsB,aAAgB,GAC7C/kC,EAAI4sC,UAAYokB,EAAUpkB,UAC1B5sC,EAAIysC,QAAUukB,EAAUvkB,QACxBzsC,EAAI0sC,UAAYskB,EAAUtkB,YAI1B1sC,EAAI+kC,YAAcojB,IAClBnoD,EAAI+qC,UAAYod,IAChBnoD,EAAIgrC,YAAcmd,IAE1B,CACA,qBAAAoI,CAAsBQ,GAClB,MAAMC,EAAYz2D,KAAKs8C,GAAG,GAEpB72C,EAAM+wD,EAAYF,SAGpB7wD,EAAI+kC,aAAeisB,EAAUjsB,aAAgB,EAC7C/kC,EAAI4sC,UAAYokB,EAAUpkB,UAI1B5sC,EAAI+kC,YAAcojB,GAE1B,CACA,eAAAwI,CAAgBjgD,EAAKugD,GACjB,MAAMC,EAAU32D,KAAKu1D,UAAUv1D,KAAKu1D,UAAUjgE,OAAS,GNhGxD,IAA0BnB,EAAMmQ,EAAOsyD,EAAPtyD,EMiGLoyD,ENjGYE,EMiGGzgD,ONhGR5gB,KADRpB,EMiGRwiE,GNhGZzlD,SAAS0lD,GACdziE,EAAK+c,SAAS0lD,GAAiB,CAACtyD,GAGhCnQ,EAAK+c,SAAS0lD,GAAehgE,KAAK0N,GM8FlCtE,KAAKw1D,yBAAyBmB,EAAQL,SAAUI,EACpD,CACA,kBAAAL,CAAmBQ,EAAe5jB,GAC9B,MAAM6jB,EAAa92D,KAAKu1D,UAAUv1D,KAAKu1D,UAAUjgE,OAAS,IN9F3D,SAA8BnB,EAAM8+C,EAAU8jB,QACjBxhE,IAA5BpB,EAAK+c,SAAS+hC,GACd9+C,EAAK+c,SAAS+hC,GAAY,CAAC8jB,GAG3B5iE,EAAK+c,SAAS+hC,GAAUr8C,KAAKmgE,EAErC,CMwFQC,CAAqBF,EAAY7jB,EAAU4jB,GAE3C72D,KAAKy1D,wBAAwBqB,EAAWR,SAAUO,EAAcP,SACpE,CACA,4BAAAW,GACI,IAAI,EAAA91B,GAAA,GAAYnhC,KAAKk3D,2BAA4B,CAC7C,MAAMC,EAA+BnM,GAAqChrD,KAAKoN,WAAW,EAAAyE,EAAA,GAAK7R,KAAK6uD,uBAEpG,OADA7uD,KAAKk3D,0BAA4BC,EAC1BA,CACX,CACA,OAAOn3D,KAAKk3D,yBAChB,CACA,wCAAAE,GACI,IAAI,EAAAj2B,GAAA,GAAYnhC,KAAKq3D,uCAAwC,CACzD,MAAMC,EJtHX,SAAkDphB,EAAanjD,EAAWwkE,GAC7E,MAAMtM,EAAqB,WAAc,EAIzCd,GAAec,EAAoB/U,EAAc,6BACjD,MAAMshB,EAAoBj+D,OAAOqK,OAAO2zD,EAAgBxzD,WAMxD,OALA,EAAA7P,EAAA,GAAQnB,GAAYkgD,IAChBukB,EAAkBvkB,GAAYwX,EAAY,KAE9CQ,EAAmBlnD,UAAYyzD,GACF5uD,YAAcqiD,EACpCA,CACX,CIyGmCwM,CAAyCz3D,KAAKoN,WAAW,EAAAyE,EAAA,GAAK7R,KAAK6uD,sBAAuB7uD,KAAKi3D,gCAEtH,OADAj3D,KAAKq3D,sCAAwCC,EACtCA,CACX,CACA,OAAOt3D,KAAKq3D,qCAChB,CACA,4BAAA1D,GACI,MAAMvc,EAAYp3C,KAAKynD,WACvB,OAAOrQ,EAAUA,EAAU9hD,OAAS,EACxC,CACA,gCAAAy+D,GACI,MAAM3c,EAAYp3C,KAAKynD,WACvB,OAAOrQ,EAAUA,EAAU9hD,OAAS,EACxC,CACA,kCAAAu+D,GACI,MAAMxc,EAAkBr3C,KAAKs0D,sBAC7B,OAAOjd,EAAgBA,EAAgB/hD,OAAS,EACpD,GCpLG,MACH,gBAAAg7D,GACItwD,KAAK03D,UAAY,GACjB13D,KAAK23D,gBAAkB,EACvB33D,KAAKysC,SAAW,CACpB,CACA,SAAIzpC,CAAM40D,GAGN,IAA8B,IAA1B53D,KAAKuuD,iBACL,MAAM31D,MAAM,oFAIhBoH,KAAK6pD,QACL7pD,KAAK03D,UAAYE,EACjB53D,KAAK23D,gBAAkBC,EAAStiE,MACpC,CACA,SAAI0N,GACA,OAAOhD,KAAK03D,SAChB,CAEA,UAAA3F,GACI,OAAI/xD,KAAKysC,SAAWzsC,KAAK03D,UAAUpiE,OAAS,GACxC0K,KAAK6yD,eACE7yD,KAAKs8C,GAAG,IAGRqR,EAEf,CAGA,EAAArR,CAAGub,GACC,MAAMC,EAAY93D,KAAKysC,QAAUorB,EACjC,OAAIC,EAAY,GAAK93D,KAAK23D,iBAAmBG,EAClCnK,GAGA3tD,KAAK03D,UAAUI,EAE9B,CACA,YAAAjF,GACI7yD,KAAKysC,SACT,CACA,gBAAAilB,GACI,OAAO1xD,KAAKysC,OAChB,CACA,gBAAAwlB,CAAiBhtD,GACbjF,KAAKysC,QAAUxnC,CACnB,CACA,eAAA8yD,GACI/3D,KAAKysC,SAAW,CACpB,CACA,qBAAAurB,GACIh4D,KAAKysC,QAAUzsC,KAAK03D,UAAUpiE,OAAS,CAC3C,CACA,gBAAA2iE,GACI,OAAOj4D,KAAK0xD,kBAChB,GCtDG,MACH,oBAAAlB,CAAqBL,EAAiBrgD,GAclC,GAbA9P,KAAKoN,UAAYpN,KAAK4I,YAAY7U,KAElCiM,KAAKk4D,oBAAsB,CAAC,EAC5Bl4D,KAAKg1D,oBAAsB,CAAC,EAC5Bh1D,KAAKm4D,iBAAmB,IACxBn4D,KAAK4yC,aAAejK,GACpB3oC,KAAKo4D,WAAa,EAClBp4D,KAAKyuD,kBAAoB,GACzBzuD,KAAKkvD,UAAY,CAAC,EAClBlvD,KAAKq4D,oBAAsB,GAC3Br4D,KAAKynD,WAAa,GAClBznD,KAAKs0D,sBAAwB,GAC7Bt0D,KAAK6uD,qBAAuB,CAAC,GACzB,EAAA/6D,EAAA,GAAIgc,EAAQ,qBACZ,MAAMlX,MAAM,oLAIhB,IAAI,EAAAqW,EAAA,GAAQkhD,GAAkB,CAI1B,IAAI,EAAA9wB,EAAA,GAAQ8wB,GACR,MAAMv3D,MAAM,+IAIhB,GAA8C,iBAAnCu3D,EAAgB,GAAG3lB,YAC1B,MAAM5xC,MAAM,iLAIpB,CACA,IAAI,EAAAqW,EAAA,GAAQkhD,GACRnwD,KAAKkvD,WAAY,EAAA5iC,GAAA,GAAO6jC,GAAiB,CAACzwC,EAAKsU,KAC3CtU,EAAIsU,EAAQjgC,MAAQigC,EACbtU,IACR,CAAC,QAEH,IAAI,EAAA5rB,EAAA,GAAIq8D,EAAiB,UAC1B,IAAM,SAAQ,OAAOA,EAAgBlpB,QAASiD,IAAc,CAC5D,MAAMlD,GAAgB,SAAQ,OAAOmpB,EAAgBlpB,QAC/CqxB,EAAe,GAAKtxB,GAC1BhnC,KAAKkvD,WAAY,EAAA5iC,GAAA,GAAOgsC,GAAc,CAAC54C,EAAKsU,KACxCtU,EAAIsU,EAAQjgC,MAAQigC,EACbtU,IACR,CAAC,EACR,KACK,MAAI,EAAA64C,GAAA,GAASpI,GAId,MAAM,IAAIv3D,MAAM,0IAHhBoH,KAAKkvD,WAAY,EAAAlmB,EAAA,GAAMmnB,EAK3B,CAGAnwD,KAAKkvD,UAAe,IAAInpD,GACxB,MAAMihC,GAAgB,EAAAlzC,EAAA,GAAIq8D,EAAiB,UACrC,SAAQ,OAAOA,EAAgBlpB,SAC/B,OAAOkpB,GACPqI,EAAwB,GAAMxxB,GAAgByxB,IAAqB,EAAAp5B,EAAA,GAAQo5B,EAAiBjvB,mBAClGxpC,KAAK4yC,aAAe4lB,EACd7vB,GACAN,GAINS,IAAkB,OAAO9oC,KAAKkvD,WAClC,CACA,UAAAwJ,CAAWzlB,EAAU0lB,EAAM7oD,GACvB,GAAI9P,KAAKuuD,iBACL,MAAM31D,MAAM,iBAAiBq6C,+KAGjC,MAAMgb,GAAgB,EAAAn6D,EAAA,GAAIgc,EAAQ,iBAC5BA,EAAOm+C,cACPF,GAAoBE,cACpBD,GAAoB,EAAAl6D,EAAA,GAAIgc,EAAQ,qBAChCA,EAAOk+C,kBACPD,GAAoBC,kBAGpB4K,EAAY54D,KAAKm4D,kBAAoB,GAI3C,IAAIU,EAmCJ,OAtCA74D,KAAKm4D,mBACLn4D,KAAKk4D,oBAAoBU,GAAa3lB,EACtCjzC,KAAKg1D,oBAAoB/hB,GAAY2lB,EAKjCC,GADmB,IAAnB74D,KAAK6tD,UACe,YAA8BtqD,GAC9C,IACIvD,KAAK84D,0BAA0BF,EAAW3lB,EAAUjzC,KAAKo4D,YACzDO,EAAK7yD,MAAM9F,KAAMuD,GACjB,MAAMw1D,EAAM/4D,KAAKu1D,UAAUv1D,KAAKu1D,UAAUjgE,OAAS,GAEnD,OADA0K,KAAK01D,YAAYqD,GACVA,CACX,CACA,MAAO3lE,GACH,OAAO4M,KAAKg5D,gBAAgB5lE,EAAG66D,EAAeD,EAClD,CACA,QACIhuD,KAAKi5D,wBACT,CACJ,EAGoB,YAAiC11D,GACjD,IAEI,OADAvD,KAAK84D,0BAA0BF,EAAW3lB,EAAUjzC,KAAKo4D,YAClDO,EAAK7yD,MAAM9F,KAAMuD,EAC5B,CACA,MAAOnQ,GACH,OAAO4M,KAAKg5D,gBAAgB5lE,EAAG66D,EAAeD,EAClD,CACA,QACIhuD,KAAKi5D,wBACT,CACJ,EAEuB1/D,OAAOg2D,OAAOsJ,EAAmB,CAAE5lB,WAAUyb,sBAAuBiK,GAEnG,CACA,eAAAK,CAAgB5lE,EAAG8lE,EAAqBlL,GACpC,MAAMmL,EAAgD,IAA3Bn5D,KAAKynD,WAAWnyD,OAKrC8jE,EAAgBF,IAAwBl5D,KAAKkyD,kBAAoBlyD,KAAKirC,gBAC5E,GAAI6a,GAAuB1yD,GAAI,CAC3B,MAAMimE,EAAajmE,EACnB,GAAIgmE,EAAe,CACf,MAAM7H,EAAgBvxD,KAAKwxD,sBAC3B,GAAIxxD,KAAKizD,yBAAyB1B,GAAgB,CAE9C,GADA8H,EAAWrT,eAAiBhmD,KAAKy0D,SAASlD,GACtCvxD,KAAK6tD,UAAW,CAChB,MAAMyL,EAAmBt5D,KAAKu1D,UAAUv1D,KAAKu1D,UAAUjgE,OAAS,GAEhE,OADAgkE,EAAiBC,eAAgB,EAC1BD,CACX,CAEI,OAAOtL,EAAkB56D,EAEjC,CAEI,GAAI4M,KAAK6tD,UAAW,CAChB,MAAMyL,EAAmBt5D,KAAKu1D,UAAUv1D,KAAKu1D,UAAUjgE,OAAS,GAChEgkE,EAAiBC,eAAgB,EACjCF,EAAWC,iBAAmBA,CAClC,CAEA,MAAMD,CAEd,CACK,GAAIF,EAKL,OAHAn5D,KAAKg4D,wBAGEhK,EAAkB56D,GAIzB,MAAMimE,CAEd,CAGI,MAAMjmE,CAEd,CAEA,cAAAomE,CAAeC,EAAmBxkB,GAC9B,MAAM9+B,EAAMnW,KAAKknD,4BX/KC,IW+KuCjS,GACzD,OAAOj1C,KAAK05D,oBAAoBD,EAAmBxkB,EAAY9+B,EACnE,CACA,mBAAAujD,CAAoBD,EAAmBxkB,EAAY9+B,GAC/C,IACIzd,EADA24D,EAAgBrxD,KAAKs1D,mBAAmBn/C,GAE5C,GAAiC,mBAAtBsjD,EAAkC,CACzC/gE,EAAS+gE,EAAkB1M,IAC3B,MAAMj3C,EAAY2jD,EAAkBxd,KAEpC,QAAkB1mD,IAAdugB,EAAyB,CACzB,MAAM6jD,EAAuBtI,EAC7BA,EAAgB,IACLv7C,EAAUrS,KAAKzD,OAAS25D,EAAqBl2D,KAAKzD,KAEjE,CACJ,MAEItH,EAAS+gE,EAEb,IAAiC,IAA7BpI,EAAc5tD,KAAKzD,MACnB,OAAOtH,EAAO+K,KAAKzD,KAG3B,CACA,kBAAA45D,CAAmB7S,EAAgB0S,GAC/B,MAAMI,EAAQ75D,KAAKknD,4BAA4BU,GAAkBb,GACjE,OAAO/mD,KAAK85D,wBAAwB/S,EAAgB0S,EAAmBI,EAC3E,CACA,uBAAAC,CAAwB/S,EAAgB0S,EAAmBtjD,GACvD,IACIzd,EADA24D,EAAgBrxD,KAAKs1D,mBAAmBn/C,GAE5C,GAAiC,mBAAtBsjD,EAAkC,CACzC/gE,EAAS+gE,EAAkB1M,IAC3B,MAAMj3C,EAAY2jD,EAAkBxd,KAEpC,QAAkB1mD,IAAdugB,EAAyB,CACzB,MAAM6jD,EAAuBtI,EAC7BA,EAAgB,IACLv7C,EAAUrS,KAAKzD,OAAS25D,EAAqBl2D,KAAKzD,KAEjE,CACJ,MAEItH,EAAS+gE,EAEb,IAAiC,IAA7BpI,EAAc5tD,KAAKzD,MAQnB,MAAMA,KAAK+5D,wBAAwBhT,EAAgBjQ,GAAUmE,qBAAsBwe,EAAkBO,SARlE,CACnC,IAAI/S,EAAWjnD,KAAKi6D,mBAAmBvhE,GACvC,MAAoC,IAA7B24D,EAAc5tD,KAAKzD,QACT,IAAbinD,GACAA,EAAWjnD,KAAKi6D,mBAAmBvhE,EAE3C,CAQAsH,KAAK2mD,4BAA4B3mD,KAAK45D,mBAAoB,CAAC7S,EAAgB0S,GAAoBpI,EAAezJ,GAAkBb,EAAgB3O,GACpJ,CACA,0BAAA8hB,CAA2BnT,EAAgB7rD,GACvC,MAAM2+D,EAAQ75D,KAAKknD,4BAA4BY,GAAsBf,GACrE/mD,KAAKm6D,gCAAgCpT,EAAgB7rD,EAAS2+D,EAClE,CACA,+BAAAM,CAAgCpT,EAAgB7rD,EAASib,GACrD,MAAMzd,EAASwC,EAAQ6xD,IACjBp3B,EAAYz6B,EAAQ+xD,IAG1B,IAA+C,IAFXjtD,KAAKs1D,mBAAmBn/C,GAE5B1S,KAAKzD,MAyBjC,MAAMA,KAAK+5D,wBAAwBhT,EAAgBjQ,GAAUoE,oCAAqChgD,EAAQ8+D,SAzBzD,CACjDthE,EAAO+K,KAAKzD,MAGZ,MAAMo6D,EAAyB,IACpBp6D,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAI3mB,GAGzC,MAAoD,IAA7C31B,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAI3mB,IAGjC31B,KAAKq6D,QAAQ1kC,GAEbj9B,EAAO+K,KAAKzD,MAGhBA,KAAK2mD,4BAA4B3mD,KAAKs6D,4BAA6B,CAC/DvT,EACApxB,EACAykC,EACA1hE,EACA4/C,IACD8hB,EAAwBtS,GAAsBf,EAAgBzO,GACrE,CAIJ,CACA,YAAAiiB,CAAaxT,EAAgB0S,GACzB,MAAMI,EAAQ75D,KAAKknD,4BXlRH,IWkRyCH,GACzD,OAAO/mD,KAAKw6D,kBAAkBzT,EAAgB0S,EAAmBI,EACrE,CACA,iBAAAW,CAAkBzT,EAAgB0S,EAAmBtjD,GACjD,IACIzd,EADA+hE,EAAoBz6D,KAAKs1D,mBAAmBn/C,GAEhD,GAAiC,mBAAtBsjD,EAAkC,CACzC/gE,EAAS+gE,EAAkB1M,IAC3B,MAAMj3C,EAAY2jD,EAAkBxd,KAEpC,QAAkB1mD,IAAdugB,EAAyB,CACzB,MAAM6jD,EAAuBc,EAC7BA,EAAoB,IACT3kD,EAAUrS,KAAKzD,OAAS25D,EAAqBl2D,KAAKzD,KAEjE,CACJ,MAEItH,EAAS+gE,EAEb,IAAIxS,GAAW,EACf,MAAwC,IAAjCwT,EAAkBh3D,KAAKzD,QAA+B,IAAbinD,GAC5CA,EAAWjnD,KAAKi6D,mBAAmBvhE,GAGvCsH,KAAK2mD,4BAA4B3mD,KAAKu6D,aAAc,CAACxT,EAAgB0S,GAAoBgB,EX3SzE,IW2SsG1T,EAAgB/O,GAMtIiP,EACJ,CACA,oBAAAyT,CAAqB3T,EAAgB7rD,GACjC,MAAM2+D,EAAQ75D,KAAKknD,4BAA4BW,GAAcd,GAC7D/mD,KAAK26D,0BAA0B5T,EAAgB7rD,EAAS2+D,EAC5D,CACA,yBAAAc,CAA0B5T,EAAgB7rD,EAASib,GAC/C,MAAMzd,EAASwC,EAAQ6xD,IACjBp3B,EAAYz6B,EAAQ+xD,IAG1B,IAAwC,IAFXjtD,KAAKs1D,mBAAmBn/C,GAE5B1S,KAAKzD,MAAgB,CAC1CtH,EAAO+K,KAAKzD,MACZ,MAAMo6D,EAAyB,IACpBp6D,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAI3mB,GAGzC,MAAoD,IAA7C31B,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAI3mB,IAGjC31B,KAAKq6D,QAAQ1kC,GAEbj9B,EAAO+K,KAAKzD,MAGhBA,KAAK2mD,4BAA4B3mD,KAAKs6D,4BAA6B,CAC/DvT,EACApxB,EACAykC,EACA1hE,EACAw/C,IACDkiB,EAAwBvS,GAAcd,EAAgB7O,GAC7D,CACJ,CACA,2BAAAoiB,CAA4BvT,EAAgBpxB,EAAWykC,EAAwB1hE,EAAQkiE,GACnF,KAAOR,KAGHp6D,KAAKq6D,QAAQ1kC,GACbj9B,EAAO+K,KAAKzD,MAQhBA,KAAK2mD,4BAA4B3mD,KAAKs6D,4BAA6B,CAC/DvT,EACApxB,EACAykC,EACA1hE,EACAkiE,GACDR,EAAwBtS,GAAsBf,EAAgB6T,EACrE,CACA,kBAAAX,CAAmBvhE,GACf,MAAMmiE,EAAkB76D,KAAKi4D,mBAK7B,OAJAv/D,EAAO+K,KAAKzD,MACWA,KAAKi4D,mBAGJ4C,CAC5B,CACA,UAAAC,CAAWC,EAAY9lB,GACnB,MAAM4kB,EAAQ75D,KAAKknD,4BXnXL,IWmXyCjS,GACjD0G,GAAO,EAAA1sC,EAAA,GAAQ8rD,GAAcA,EAAaA,EAAWhO,IAErDiO,EADSh7D,KAAKs1D,mBAAmBuE,GACXp2D,KAAKzD,KAAM27C,GACvC,QAAqBpmD,IAAjBylE,EAEA,OAD0Brf,EAAKqf,GACNxN,IAAI/pD,KAAKzD,MAEtCA,KAAKi7D,oBAAoBhmB,EAAY8lB,EAAWf,QACpD,CACA,sBAAAf,GAKI,GAJAj5D,KAAKynD,WAAWljD,MAChBvE,KAAKs0D,sBAAsB/vD,MAE3BvE,KAAKm2D,wBAC0B,IAA3Bn2D,KAAKynD,WAAWnyD,SAA0C,IAA1B0K,KAAKk7D,iBAA4B,CACjE,MAAMC,EAAoBn7D,KAAKs8C,GAAG,GAC5B9U,EAASxnC,KAAK8qC,qBAAqBoI,8BAA8B,CACnEC,eAAgBgoB,EAChBloB,SAAUjzC,KAAKqnD,wBAEnBrnD,KAAK8xD,WAAW,IAAIxL,GAA2B9e,EAAQ2zB,GAC3D,CACJ,CACA,eAAAC,CAAgBC,EAAY5mC,EAAKv5B,GAC7B,IAAI67D,EACJ,IACI,MAAMxzD,OAAmBhO,IAAZ2F,EAAwBA,EAAQogE,UAAO/lE,EAMpD,OALAyK,KAAKo4D,WAAa3jC,EAClBsiC,EAAasE,EAAWv1D,MAAM9F,KAAMuD,GACpCvD,KAAKq2D,mBAAmBU,OAAwBxhE,IAAZ2F,QAA2C3F,IAAlB2F,EAAQg5B,MAC/Dh5B,EAAQg5B,MACRmnC,EAAWpoB,UACV8jB,CACX,CACA,MAAO3jE,GACH,MAAM4M,KAAKu7D,qBAAqBnoE,EAAG8H,EAASmgE,EAAWpoB,SAC3D,CACJ,CACA,oBAAAsoB,CAAqBnoE,EAAG8H,EAAS+3C,GAO7B,MANI6S,GAAuB1yD,SAA6BmC,IAAvBnC,EAAEkmE,mBAC/Bt5D,KAAKq2D,mBAAmBjjE,EAAEkmE,sBAA8B/jE,IAAZ2F,QAA2C3F,IAAlB2F,EAAQg5B,MACvEh5B,EAAQg5B,MACR+e,UACC7/C,EAAEkmE,kBAEPlmE,CACV,CACA,eAAAooE,CAAgBxnC,EAASS,EAAKv5B,GAC1B,IAAIw7D,EACJ,IACI,MAAMra,EAAYr8C,KAAKs8C,GAAG,IACoB,IAA1Ct8C,KAAK4yC,aAAayJ,EAAWroB,IAC7Bh0B,KAAK6yD,eACL6D,EAAgBra,GAGhBr8C,KAAKy7D,qBAAqBznC,EAASqoB,EAAWnhD,EAEtD,CACA,MAAOwgE,GACHhF,EAAgB12D,KAAK27D,wBAAwB3nC,EAASS,EAAKinC,EAC/D,CAIA,OAHA17D,KAAKo2D,qBAA4B7gE,IAAZ2F,QAA2C3F,IAAlB2F,EAAQg5B,MAChDh5B,EAAQg5B,MACRF,EAAQjgC,KAAM2iE,GACbA,CACX,CACA,oBAAA+E,CAAqBznC,EAASqoB,EAAWnhD,GACrC,IAAIy/B,EACJ,MAAMyrB,EAAgBpmD,KAAKs8C,GAAG,GAY9B,MAVI3hB,OADYplC,IAAZ2F,GAAyBA,EAAQ8+D,QAC3B9+D,EAAQ8+D,QAGRh6D,KAAK8qC,qBAAqBgI,0BAA0B,CACtD5tC,SAAU8uB,EACV+e,OAAQsJ,EACRrJ,SAAUoT,EACVnT,SAAUjzC,KAAKqnD,wBAGjBrnD,KAAK8xD,WAAW,IAAI3L,GAAyBxrB,EAAK0hB,EAAW+J,GACvE,CACA,uBAAAuV,CAAwB3nC,EAASS,EAAKinC,GAGlC,IAAI17D,KAAKirC,iBAEqB,6BAA1BywB,EAAiB3nE,MAChBiM,KAAKkyD,iBAiBN,MAAMwJ,EAjBkB,CACxB,MAAM/hC,EAAU35B,KAAKoyD,4BAA4Bp+B,EAASS,GAC1D,IACI,OAAOz0B,KAAKyyD,kBAAkBz+B,EAAS2F,EAC3C,CACA,MAAOiiC,GACH,MAAIA,EAAoB7nE,OAAS0yD,GAGvBiV,EAGAE,CAEd,CACJ,CAIJ,CACA,cAAAC,GAEI,MAAMC,EAAc97D,KAAK+iC,OACnBg5B,GAAiB,EAAA/yB,EAAA,GAAMhpC,KAAKynD,YAClC,MAAO,CACH1kB,OAAQ+4B,EACRE,WAAYh8D,KAAK0xD,mBACjBjK,WAAYsU,EACZxG,UAAWv1D,KAAKu1D,UAExB,CACA,gBAAA0G,CAAiBh3D,GACbjF,KAAK+iC,OAAS99B,EAAS89B,OACvB/iC,KAAKiyD,iBAAiBhtD,EAAS+2D,YAC/Bh8D,KAAKynD,WAAaxiD,EAASwiD,UAC/B,CACA,yBAAAqR,CAA0BF,EAAWsD,EAAUjI,GAC3Cj0D,KAAKs0D,sBAAsB19D,KAAKq9D,GAChCj0D,KAAKynD,WAAW7wD,KAAKgiE,GAErB54D,KAAKk2D,yBAAyBgG,EAClC,CACA,cAAAhK,GACI,OAA2C,IAApClyD,KAAKq4D,oBAAoB/iE,MACpC,CACA,mBAAA+xD,GACI,MAAMuR,EAAY54D,KAAK2zD,+BACvB,OAAO3zD,KAAKk4D,oBAAoBU,EACpC,CACA,uBAAA5E,CAAwB4E,GACpB,OAAO54D,KAAKk4D,oBAAoBU,EACpC,CACA,cAAAsC,GACI,OAAOl7D,KAAK4yC,aAAa5yC,KAAKs8C,GAAG,GAAIv2C,GACzC,CACA,KAAA8jD,GACI7pD,KAAK+3D,kBACL/3D,KAAKo4D,WAAa,EAClBp4D,KAAKq4D,oBAAsB,GAC3Br4D,KAAK+iC,OAAS,GACd/iC,KAAKynD,WAAa,GAElBznD,KAAKu1D,UAAY,GACjBv1D,KAAKs0D,sBAAwB,EACjC,GC7gBG,MACH,MAAA6H,CAAOxD,GACH,OAAOA,EAAKl1D,KAAKzD,KACrB,CACA,OAAAo8D,CAAQ3nC,EAAKT,EAAS94B,GAClB,OAAO8E,KAAKw7D,gBAAgBxnC,EAASS,EAAKv5B,EAC9C,CACA,OAAAsnD,CAAQ/tB,EAAK4mC,EAAYngE,GACrB,OAAO8E,KAAKo7D,gBAAgBC,EAAY5mC,EAAKv5B,EACjD,CACA,MAAAunD,CAAOhuB,EAAKglC,GACR,OAAOz5D,KAAKw5D,eAAeC,EAAmBhlC,EAClD,CACA,EAAAquB,CAAGruB,EAAKsmC,GACJ,OAAO/6D,KAAK86D,WAAWC,EAAYtmC,EACvC,CACA,IAAAouB,CAAKpuB,EAAKglC,GACN,OAAOz5D,KAAKu6D,aAAa9lC,EAAKglC,EAClC,CACA,UAAA9W,CAAWluB,EAAKglC,GACZ,OAAOz5D,KAAK45D,mBAAmBnlC,EAAKglC,EACxC,CACA,OAAAY,CAAQrmC,EAAS94B,GACb,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAmhE,CAASroC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAohE,CAAStoC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAqhE,CAASvoC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAshE,CAASxoC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAuhE,CAASzoC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAwhE,CAAS1oC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAAyhE,CAAS3oC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAA0hE,CAAS5oC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,QAAA2hE,CAAS7oC,EAAS94B,GACd,OAAO8E,KAAKw7D,gBAAgBxnC,EAAS,EAAG94B,EAC5C,CACA,OAAA4hE,CAAQzB,EAAYngE,GAChB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAA6hE,CAAS1B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAA8hE,CAAS3B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAA+hE,CAAS5B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAgiE,CAAS7B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAiiE,CAAS9B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAkiE,CAAS/B,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAmiE,CAAShC,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAoiE,CAASjC,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,QAAAqiE,CAASlC,EAAYngE,GACjB,OAAO8E,KAAKo7D,gBAAgBC,EAAY,EAAGngE,EAC/C,CACA,MAAA6/C,CAAO0e,GACH,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAA+D,CAAQ/D,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAgE,CAAQhE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAiE,CAAQjE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAkE,CAAQlE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAmE,CAAQnE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAoE,CAAQpE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAqE,CAAQrE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAsE,CAAQtE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,OAAAuE,CAAQvE,GACJ,OAAOz5D,KAAKw5D,eAAeC,EAAmB,EAClD,CACA,EAAAwE,CAAGlD,GACC,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAmD,CAAInD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAoD,CAAIpD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAqD,CAAIrD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAsD,CAAItD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAuD,CAAIvD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAwD,CAAIxD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAAyD,CAAIzD,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAA0D,CAAI1D,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,GAAA2D,CAAI3D,GACA,OAAO/6D,KAAK86D,WAAWC,EAAY,EACvC,CACA,IAAA4D,CAAKlF,GACDz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAmF,CAAMnF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAoF,CAAMpF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAqF,CAAMrF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAsF,CAAMtF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAuF,CAAMvF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAwF,CAAMxF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAAyF,CAAMzF,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAA0F,CAAM1F,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,KAAA2F,CAAM3F,GACFz5D,KAAKu6D,aAAa,EAAGd,EACzB,CACA,QAAA4F,CAASnkE,GACL8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAokE,CAAUpkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAqkE,CAAUrkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAskE,CAAUtkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAukE,CAAUvkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAwkE,CAAUxkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAAykE,CAAUzkE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAA0kE,CAAU1kE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAA2kE,CAAU3kE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,SAAA4kE,CAAU5kE,GACN8E,KAAK06D,qBAAqB,EAAGx/D,EACjC,CACA,YAAA6kE,CAAatG,GACTz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAAuG,CAAcvG,GACV,OAAOz5D,KAAK45D,mBAAmB,EAAGH,EACtC,CACA,aAAAwG,CAAcxG,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAAyG,CAAczG,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA0G,CAAc1G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA2G,CAAc3G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA4G,CAAc5G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA6G,CAAc7G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA8G,CAAc9G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,aAAA+G,CAAc/G,GACVz5D,KAAK45D,mBAAmB,EAAGH,EAC/B,CACA,gBAAAgH,CAAiBvlE,GACb8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAAwlE,CAAkBxlE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAAylE,CAAkBzlE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA0lE,CAAkB1lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA2lE,CAAkB3lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA4lE,CAAkB5lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA6lE,CAAkB7lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA8lE,CAAkB9lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAA+lE,CAAkB/lE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,iBAAAgmE,CAAkBhmE,GACd8E,KAAKk6D,2BAA2B,EAAGh/D,EACvC,CACA,IAAAimE,CAAKptE,EAAMqtE,EAAgBtxD,EAASi+C,IAChC,GAAI,GAAS/tD,KAAKyuD,kBAAmB16D,GAAO,CACxC,MAIM+O,EAAQ,CACV64B,QALW0Y,GAAqC4B,4BAA4B,CAC5E9B,aAAcpgD,EACdmiD,YAAal2C,KAAKoN,YAIlB3Y,KAAM+hD,GAA0B8L,oBAChCrP,SAAUl/C,GAEdiM,KAAKgvD,iBAAiBp4D,KAAKkM,EAC/B,CACA9C,KAAKyuD,kBAAkB73D,KAAK7C,GAC5B,MAAMstE,EAAqBrhE,KAAK04D,WAAW3kE,EAAMqtE,EAAgBtxD,GAEjE,OADA9P,KAAKjM,GAAQstE,EACNA,CACX,CACA,aAAAC,CAAcvtE,EAAM4kE,EAAM7oD,EAASi+C,IAC/B,MAAMwT,EhBnLP,SAAkCtuB,EAAUwb,EAAmBrhD,GAClE,MAAM21B,EAAS,GACf,IAAIyE,EAWJ,OAVK,GAASinB,EAAmBxb,KAC7BzL,EACI,kCAAkCyL,8CAAqD7lC,wDAE3F21B,EAAOnsC,KAAK,CACR+kC,QAAS6L,EACT/yC,KAAM+hD,GAA0BgrB,sBAChCvuB,SAAUA,KAGXlQ,CACX,CgBqK2B0+B,CAAyB1tE,EAAMiM,KAAKyuD,kBAAmBzuD,KAAKoN,WAC/EpN,KAAKgvD,iBAAmBhvD,KAAKgvD,iBAAiBx7D,OAAO+tE,GACrD,MAAMF,EAAqBrhE,KAAK04D,WAAW3kE,EAAM4kE,EAAM7oD,GAEvD,OADA9P,KAAKjM,GAAQstE,EACNA,CACX,CACA,SAAAK,CAAUvQ,EAAa5tD,GACnB,OAAO,WAEHvD,KAAKq4D,oBAAoBzhE,KAAK,GAC9B,MAAM+qE,EAAW3hE,KAAK67D,iBACtB,IAGI,OAFA1K,EAAYrrD,MAAM9F,KAAMuD,IAEjB,CACX,CACA,MAAOnQ,GACH,GAAI0yD,GAAuB1yD,GACvB,OAAO,EAGP,MAAMA,CAEd,CACA,QACI4M,KAAKi8D,iBAAiB0F,GACtB3hE,KAAKq4D,oBAAoB9zD,KAC7B,CACJ,CACJ,CAEA,kBAAA+iD,GACI,OAAOtnD,KAAK6uD,oBAChB,CACA,4BAAA+S,GACI,OvD9MyBC,GuD8MD,OAAO7hE,KAAK6uD,uBvD7MjC,OAAIgT,EAAUtsC,GADlB,IAA0BssC,CuD+M7B,GCpUG,MACH,gBAAAxR,CAAiBvgD,GACb9P,KAAK8hE,QAAU,GACf9hE,KAAK8qC,sBAAuB,EAAAh3C,EAAA,GAAIgc,EAAQ,wBAClCA,EAAOg7B,qBACPmd,GAAsBnd,oBAChC,CACA,UAAAgnB,CAAWhvD,GACP,GAAIgjD,GAAuBhjD,GAMvB,OALAA,EAAMkwB,QAAU,CACZokB,UAAWp3C,KAAK00D,4BAChBqN,qBAAqB,EAAA/4B,EAAA,GAAMhpC,KAAKs0D,wBAEpCt0D,KAAK8hE,QAAQlrE,KAAKkM,GACXA,EAGP,MAAMlK,MAAM,8DAEpB,CACA,UAAImqC,GACA,OAAO,EAAAiG,EAAA,GAAMhpC,KAAK8hE,QACtB,CACA,UAAI/+B,CAAOi/B,GACPhiE,KAAK8hE,QAAUE,CACnB,CAEA,uBAAAjI,CAAwB9kB,EAAYqG,EAAU2mB,GAC1C,MAAMhvB,EAAWjzC,KAAKqnD,sBAGhB6a,EAD+BzmB,GAAiCxG,EADlDj1C,KAAKsnD,qBAAqBrU,GACiDqI,EAAUt7C,KAAKu7C,cACzD,GAC/C4mB,EAAe,GACrB,IAAK,IAAIjpE,EAAI,EAAGA,GAAK8G,KAAKu7C,aAAcriD,IACpCipE,EAAavrE,KAAKoJ,KAAKs8C,GAAGpjD,IAE9B,MAAMyhC,EAAM36B,KAAK8qC,qBAAqBiJ,sBAAsB,CACxDC,uBAAwBkuB,EACxBnvB,OAAQovB,EACRnvB,SAAUhzC,KAAKs8C,GAAG,GAClBhJ,sBAAuB2uB,EACvBhvB,SAAUA,IAEd,MAAMjzC,KAAK8xD,WAAW,IAAIvL,GAAmB5rB,EAAK36B,KAAKs8C,GAAG,GAAIt8C,KAAKs8C,GAAG,IAC1E,CAEA,mBAAA2e,CAAoBhmB,EAAYmtB,GAC5B,MAAMnvB,EAAWjzC,KAAKqnD,sBAGhBgb,EAA+B7mB,GAAuBvG,EAFxCj1C,KAAKsnD,qBAAqBrU,GAEuCjzC,KAAKu7C,cACpF4mB,EAAe,GACrB,IAAK,IAAIjpE,EAAI,EAAGA,GAAK8G,KAAKu7C,aAAcriD,IACpCipE,EAAavrE,KAAKoJ,KAAKs8C,GAAGpjD,IAE9B,MAAMktD,EAAgBpmD,KAAKs8C,GAAG,GACxB9U,EAASxnC,KAAK8qC,qBAAqBsI,wBAAwB,CAC7DC,oBAAqBgvB,EACrBtvB,OAAQovB,EACRnvB,SAAUoT,EACV9S,sBAAuB8uB,EACvBnvB,SAAUjzC,KAAKqnD,wBAEnB,MAAMrnD,KAAK8xD,WAAW,IAAIzL,GAAqB7e,EAAQxnC,KAAKs8C,GAAG,GAAI8J,GACvE,GCrEG,MACH,iBAAAuK,GAAsB,CACtB,oBAAA2R,CAAqBC,EAAeC,GAChC,MAAMC,EAAgBziE,KAAK6uD,qBAAqB0T,GAChD,IAAI,EAAAphC,GAAA,GAAYshC,GACZ,MAAM7pE,MAAM,UAAU2pE,uCAE1B,OAAOtpB,GAAwB,CAACwpB,GAAgBD,EAAgBxiE,KAAK4yC,aAAc5yC,KAAKu7C,aAC5F,CAGA,yBAAAiX,CAA0BF,GACtB,MAAMoQ,EAAc,GAAMpQ,EAAYlb,WAEhCurB,EADkB3iE,KAAKsnD,qBACSob,GAEtC,OAD+B,IAAInrB,GAAqBorB,EAAerQ,GAAa14B,cAExF,GRWG,MACH,gBAAAg3B,CAAiB9gD,GACb9P,KAAK6sD,mBAAqB,GAC1B7sD,KAAK4iE,iBAAkB,CAC3B,CACA,eAAApU,GACIxuD,KAAK4iE,iBAAkB,EACvB5iE,KAAKwrC,WAAW,oBAAoB,KAUhC,IAAK,IAAItyC,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMu7B,EAAMv7B,EAAI,EAAIA,EAAI,GACxB8G,KAAK,UAAUy0B,KAAS,SAAUouC,EAAMC,GACpC,OAAO9iE,KAAK+iE,sBAAsBF,EAAM3pE,EAAG4pE,EAC/C,EACA9iE,KAAK,UAAUy0B,KAAS,SAAUouC,EAAMC,GACpC,OAAO9iE,KAAKgjE,sBAAsBH,EAAM3pE,EAAG4pE,EAC/C,EACA9iE,KAAK,SAASy0B,KAAS,SAAUouC,GAC7B,OAAO7iE,KAAKijE,qBAAqBJ,EAAM3pE,EAC3C,EACA8G,KAAK,KAAKy0B,KAAS,SAAUouC,GACzB,OAAO7iE,KAAKkjE,iBAAiBL,EAAM3pE,EACvC,EACA8G,KAAK,OAAOy0B,KAAS,SAAUouC,GAC3B7iE,KAAKmjE,mBAAmBjqE,EAAG2pE,EAC/B,EACA7iE,KAAK,WAAWy0B,KAAS,SAAUouC,GAC/B7iE,KAAKojE,2BAA2BlqE,EAAG2pE,EACvC,EACA7iE,KAAK,eAAey0B,KAAS,SAAUouC,GACnC7iE,KAAKqjE,yBAAyBnqE,EAAG2pE,EACrC,EACA7iE,KAAK,mBAAmBy0B,KAAS,SAAUouC,GACvC7iE,KAAKsjE,iCAAiCpqE,EAAG2pE,EAC7C,CACJ,CAEA7iE,KAAc,QAAI,SAAUy0B,EAAKouC,EAAMC,GACnC,OAAO9iE,KAAK+iE,sBAAsBF,EAAMpuC,EAAKquC,EACjD,EACA9iE,KAAc,QAAI,SAAUy0B,EAAKouC,EAAMC,GACnC,OAAO9iE,KAAKgjE,sBAAsBH,EAAMpuC,EAAKquC,EACjD,EACA9iE,KAAa,OAAI,SAAUy0B,EAAKouC,GAC5B,OAAO7iE,KAAKijE,qBAAqBJ,EAAMpuC,EAC3C,EACAz0B,KAAS,GAAI,SAAUy0B,EAAKouC,GACxB,OAAO7iE,KAAKkjE,iBAAiBL,EAAMpuC,EACvC,EACAz0B,KAAW,KAAI,SAAUy0B,EAAKouC,GAC1B7iE,KAAKmjE,mBAAmB1uC,EAAKouC,EACjC,EACA7iE,KAAiB,WAAI,SAAUy0B,EAAKouC,GAChC7iE,KAAKqjE,yBAAyB5uC,EAAKouC,EACvC,EACA7iE,KAAKm8D,OAASn8D,KAAKujE,cACnBvjE,KAAK0hE,UAAY1hE,KAAKwjE,iBACtBxjE,KAAKs8C,GAAKt8C,KAAKyjE,SAAS,GAEhC,CACA,gBAAA3U,GACI9uD,KAAK4iE,iBAAkB,EAKvB5iE,KAAKwrC,WAAW,8BAA8B,KAC1C,MAAM4kB,EAAOpwD,KACb,IAAK,IAAI9G,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMu7B,EAAMv7B,EAAI,EAAIA,EAAI,UACjBk3D,EAAK,UAAU37B,YACf27B,EAAK,UAAU37B,YACf27B,EAAK,SAAS37B,YACd27B,EAAK,KAAK37B,YACV27B,EAAK,OAAO37B,YACZ27B,EAAK,WAAW37B,YAChB27B,EAAK,eAAe37B,YACpB27B,EAAK,mBAAmB37B,IACnC,QACO27B,EAAc,eACdA,EAAc,eACdA,EAAa,cACbA,EAAS,UACTA,EAAW,YACXA,EAAiB,kBACjBA,EAAK+L,cACL/L,EAAKsR,iBACLtR,EAAK9T,EAAE,GAEtB,CAIA,aAAAinB,CAAc5K,GAEd,CAEA,gBAAA6K,CAAiBrS,EAAa5tD,GAC1B,MAAO,KAAM,CACjB,CAGA,SAAAkgE,CAAU5L,GAGN,OAAOlK,EACX,CACA,kBAAAiB,CAAmB76D,EAAM6lD,GACrB,IACI,MAAM8pB,EAAkB,IAAI/uC,EAAK,CAAEx8B,WAAY,GAAIpE,KAAMA,IAKzD,OAJA2vE,EAAgB3vE,KAAOA,EACvBiM,KAAK6sD,mBAAmBj2D,KAAK8sE,GAC7B9pB,EAAIn2C,KAAKzD,MACTA,KAAK6sD,mBAAmBtoD,MACjBm/D,CACX,CACA,MAAOC,GACH,IAA2C,IAAvCA,EAAcjW,qBACd,IACIiW,EAAchoC,QACVgoC,EAAchoC,QAAdgoC,yJAGR,CACA,MAAOC,GAEH,MAAMD,CACV,CAEJ,MAAMA,CACV,CACJ,CAEA,oBAAAV,CAAqBxJ,EAAmBxkB,GACpC,OAAOsX,GAAW9oD,KAAKzD,KAAM+0B,EAAQ0kC,EAAmBxkB,EAC5D,CACA,wBAAAouB,CAAyBpuB,EAAYwkB,GACjClN,GAAW9oD,KAAKzD,KAAMg1B,EAAqBykC,EAAmBxkB,EAClE,CACA,gCAAAquB,CAAiCruB,EAAY/5C,GACzCqxD,GAAW9oD,KAAKzD,KAAMi1B,EAAkC/5B,EAAS+5C,EAAYgX,GACjF,CACA,kBAAAkX,CAAmBluB,EAAYwkB,GAC3BlN,GAAW9oD,KAAKzD,KAAMk1B,EAAYukC,EAAmBxkB,EACzD,CACA,0BAAAmuB,CAA2BnuB,EAAY/5C,GACnCqxD,GAAW9oD,KAAKzD,KAAMm1B,EAAyBj6B,EAAS+5C,EAAYgX,GACxE,CACA,gBAAAiX,CAAiBnI,EAAY9lB,GACzB,OAAOkY,GAAa1pD,KAAKzD,KAAM+6D,EAAY9lB,EAC/C,CACA,qBAAA+tB,CAAsB3H,EAAYpmB,EAAY/5C,GAE1C,GADAyxD,GAAuB1X,IAClBomB,IAA8C,KAAhC,EAAAvnE,EAAA,GAAIunE,EAAY,YAAuB,CACtD,MAAMv4D,EAAQ,IAAIlK,MAAM,WAAW60D,GAAaxY,yEACMzmC,KAAKC,UAAU4sD,iCACnCr7D,KAAK6sD,mBAAmB,GAAG94D,SAE7D,MADA+O,EAAM4qD,sBAAuB,EACvB5qD,CACV,CACA,MAAM8pD,GAAW,QAAK5sD,KAAK6sD,oBACrB5Z,EAAWooB,EAAWpoB,SACtB4wB,EAAkB,IAAI,EAAY,CACpCpvC,IAAKwgB,EACLvf,gBAAiBud,EACjB3lC,MAAOpS,aAAyC,EAASA,EAAQg5B,MAEjEQ,oBAAgBn/B,IAGpB,OADAq3D,EAASz0D,WAAWvB,KAAKitE,GAClB7jE,KAAK6tD,UACNvB,GACAP,EACV,CACA,qBAAAgX,CAAsB/uC,EAASihB,EAAY/5C,GAEvC,GADAyxD,GAAuB1X,IAClB3L,GAAoBtV,GAAU,CAC/B,MAAMlxB,EAAQ,IAAIlK,MAAM,WAAW60D,GAAaxY,qEACEzmC,KAAKC,UAAUulB,iCAC/Bh0B,KAAK6sD,mBAAmB,GAAG94D,SAE7D,MADA+O,EAAM4qD,sBAAuB,EACvB5qD,CACV,CACA,MAAM8pD,GAAW,QAAK5sD,KAAK6sD,oBACrBgX,EAAkB,IAAIvuC,EAAS,CACjCb,IAAKwgB,EACLrf,aAAc5B,EACd1mB,MAAOpS,aAAyC,EAASA,EAAQg5B,QAGrE,OADA04B,EAASz0D,WAAWvB,KAAKitE,GAClBxX,EACX,GS/NG,MACH,qBAAAwE,CAAsB/gD,GAClB,IAAI,EAAAhc,EAAA,GAAIgc,EAAQ,iBAAkB,CAC9B,MAAMg0D,EAAoBh0D,EAAOi7B,cAC3Bg5B,EAA6C,iBAAtBD,EAC7B9jE,KAAK6rC,kBAAoBk4B,EACnBD,EACA93B,IACNhsC,KAAK+qC,cAAgBg5B,EACfD,EAAoB,EACpBA,CACV,MAEI9jE,KAAK6rC,kBAAoB,EACzB7rC,KAAK+qC,cAAgBkd,GAAsBld,cAE/C/qC,KAAK2rC,iBAAmB,CAC5B,CACA,UAAAH,CAAWC,EAAWC,GAGlB,IAA2B,IAAvB1rC,KAAK+qC,cAAwB,CAC7B/qC,KAAK2rC,kBACL,MAAMC,EAAS,IAAIpnC,MAAMxE,KAAK2rC,gBAAkB,GAAGjyC,KAAK,MACpDsG,KAAK2rC,gBAAkB3rC,KAAK6rC,mBAC5B1vB,QAAQC,IAAI,GAAGwvB,YAAcH,MAEjC,MAAM,KAAErc,EAAI,MAAEz8B,GAAUu1C,GAAMwD,GAExBI,EAAc1c,EAAO,GAAKjT,QAAQ0e,KAAO1e,QAAQC,IAKvD,OAJIpc,KAAK2rC,gBAAkB3rC,KAAK6rC,mBAC5BC,EAAY,GAAGF,SAAcH,YAAoBrc,OAErDpvB,KAAK2rC,kBACEh5C,CACX,CAEI,OAAO+4C,GAEf,IP5CUx3C,SAAS8vE,IACf,MAAMC,EAAYD,EAASjgE,UAC3BxK,OAAO2qE,oBAAoBD,GAAW/vE,SAASiwE,IAC3C,GAAiB,gBAAbA,EACA,OAEJ,MAAMC,EAAqB7qE,OAAO8qE,yBAAyBJ,EAAWE,GAElEC,IACCA,EAAmBxsE,KAAOwsE,EAAmBzsE,KAC9C4B,OAAO8wD,eAAe6D,GAAYnqD,UAAWogE,EAAUC,GAGvDlW,GAAYnqD,UAAUogE,GAAYH,EAASjgE,UAAUogE,EACzD,GACF,IDiLH,MAAMG,WAA8B97D,GACvC,WAAAI,CAAYunD,EAAiBrgD,EAASm4C,IAClC,MAAMsc,GAAc,EAAAv7B,EAAA,GAAMl5B,GAC1By0D,EAAY1W,WAAY,EACxBl7B,MAAMw9B,EAAiBoU,EAC3B,E,yKS7KJ,GAJY,QAAS,SAASC,GAC5B,OAAO,QAAS,OAAYA,EAAQ,EAAGhqC,EAAA,GAAmB,GAC5D,I,oBCpBIiqC,EAAa,KAsBV,MAAMC,EACX,WAAA97D,CAAYumB,EAAO,CAAC,GAClBnvB,KAAK2kE,aAAcprE,OAAOwK,UAAUC,eAAeP,KAAK0rB,EAAM,aAC1DA,EAAK/Q,SAETpe,KAAK4kE,gBAAgBrrE,OAAOwK,UAAUC,eAAeP,KAAK0rB,EAAM,eAC5DA,EAAKpU,WAET/a,KAAK6kE,cAActrE,OAAOwK,UAAUC,eAAeP,KAAK0rB,EAAM,aAC1DA,EAAK3L,SAITxjB,KAAK8kE,YAASvvE,EAGdyK,KAAK+kE,oBAAsB,SAAWxvE,GAGtCyK,KAAKglE,oBAAsB,SAAWzvE,GAGtCyK,KAAKilE,OAAS,CAAC,EAEXjlE,KAAK6kE,cAEP7kE,KAAKklE,QAAU,CAAC,EAGhBllE,KAAKmlE,UAAY,CAAC,EAClBnlE,KAAKmlE,UAAUV,GAAc,CAAC,GAIhCzkE,KAAKolE,IAAM,CAAC,EAGZplE,KAAKqlE,OAAS,CAAC,EAGfrlE,KAAKslE,KAAO,CAAC,EAGbtlE,KAAKulE,MAAQ,CAAC,EAGdvlE,KAAKwlE,UAAY,CAAC,EAGlBxlE,KAAKylE,YAAc,CAAC,CACtB,CAEA,UAAAlmD,GACE,OAAOvf,KAAK2kE,WACd,CACA,YAAA3pD,GACE,OAAOhb,KAAK4kE,aACd,CACA,UAAAc,GACE,OAAO1lE,KAAK6kE,WACd,CACA,QAAA5pD,CAAS3N,GAEP,OADAtN,KAAK8kE,OAASx3D,EACPtN,IACT,CACA,KAAA4Y,GACE,OAAO5Y,KAAK8kE,MACd,CAEA,mBAAArhD,CAAoBkiD,GAKlB,OAJK,IAAaA,KAChBA,EAAa,IAAWA,IAE1B3lE,KAAK+kE,oBAAsBY,EACpB3lE,IACT,CACA,SAAA6X,GACE,OAAO7X,KAAK4lE,UACd,CACA,KAAAvwE,GACE,OAAO,IAAO2K,KAAKilE,OACrB,CACA,OAAAlsD,GACE,IAAI9V,EAAOjD,KACX,OAAO,IAASA,KAAK3K,SAAS,SAAUiG,GACtC,OAAO,IAAU2H,EAAKmiE,IAAI9pE,GAC5B,GACF,CACA,KAAA0d,GACE,IAAI/V,EAAOjD,KACX,OAAO,IAASA,KAAK3K,SAAS,SAAUiG,GACtC,OAAO,IAAU2H,EAAKqiE,KAAKhqE,GAC7B,GACF,CACA,QAAAuqE,CAASxmD,EAAI1sB,GACX,IAAI4Q,EAAOG,UACPT,EAAOjD,KAQX,OAPA,IAAOqf,GAAI,SAAU/jB,GACfiI,EAAKjO,OAAS,EAChB2N,EAAKgV,QAAQ3c,EAAG3I,GAEhBsQ,EAAKgV,QAAQ3c,EAEjB,IACO0E,IACT,CACA,OAAAiY,CAAQ3c,EAAG3I,GACT,OAAI4G,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKilE,OAAQ3pE,IAChDoI,UAAUpO,OAAS,IACrB0K,KAAKilE,OAAO3pE,GAAK3I,GAEZqN,OAITA,KAAKilE,OAAO3pE,GAAKoI,UAAUpO,OAAS,EAAI3C,EAAQqN,KAAK+kE,oBAAoBzpE,GACrE0E,KAAK6kE,cACP7kE,KAAKklE,QAAQ5pE,GAAKmpE,EAClBzkE,KAAKmlE,UAAU7pE,GAAK,CAAC,EACrB0E,KAAKmlE,UAAUV,GAAYnpE,IAAK,GAElC0E,KAAKolE,IAAI9pE,GAAK,CAAC,EACf0E,KAAKqlE,OAAO/pE,GAAK,CAAC,EAClB0E,KAAKslE,KAAKhqE,GAAK,CAAC,EAChB0E,KAAKulE,MAAMjqE,GAAK,CAAC,IACf0E,KAAK4lE,WACA5lE,KACT,CACA,IAAA7L,CAAKmH,GACH,OAAO0E,KAAKilE,OAAO3pE,EACrB,CACA,OAAAqf,CAAQrf,GACN,OAAO/B,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKilE,OAAQ3pE,EAC3D,CACA,UAAA2d,CAAW3d,GACT,GAAI/B,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKilE,OAAQ3pE,GAAI,CACxD,IAAIue,EAAczmB,GAAM4M,KAAK6Z,WAAW7Z,KAAKwlE,UAAUpyE,WAChD4M,KAAKilE,OAAO3pE,GACf0E,KAAK6kE,cACP7kE,KAAK8lE,4BAA4BxqE,UAC1B0E,KAAKklE,QAAQ5pE,GACpB,IAAO0E,KAAKkR,SAAS5V,IAAK+kB,IACxBrgB,KAAK2c,UAAU0D,EAAM,WAEhBrgB,KAAKmlE,UAAU7pE,IAExB,IAAO,IAAO0E,KAAKolE,IAAI9pE,IAAKue,UACrB7Z,KAAKolE,IAAI9pE,UACT0E,KAAKqlE,OAAO/pE,GACnB,IAAO,IAAO0E,KAAKslE,KAAKhqE,IAAKue,UACtB7Z,KAAKslE,KAAKhqE,UACV0E,KAAKulE,MAAMjqE,KAChB0E,KAAK4lE,UACT,CACA,OAAO5lE,IACT,CACA,SAAA2c,CAAUrhB,EAAGgW,GACX,IAAKtR,KAAK6kE,YACR,MAAM,IAAIjsE,MAAM,6CAGlB,GAAI,IAAc0Y,GAChBA,EAASmzD,MACJ,CAGL,IAAK,IAAIsB,EADTz0D,GAAU,IACmB,IAAcy0D,GAAWA,EAAW/lE,KAAKsR,OAAOy0D,GAC3E,GAAIA,IAAazqE,EACf,MAAM,IAAI1C,MAAM,WAAa0Y,EAAS,iBAAmBhW,EAAI,yBAIjE0E,KAAKiY,QAAQ3G,EACf,CAMA,OAJAtR,KAAKiY,QAAQ3c,GACb0E,KAAK8lE,4BAA4BxqE,GACjC0E,KAAKklE,QAAQ5pE,GAAKgW,EAClBtR,KAAKmlE,UAAU7zD,GAAQhW,IAAK,EACrB0E,IACT,CACA,2BAAA8lE,CAA4BxqE,UACnB0E,KAAKmlE,UAAUnlE,KAAKklE,QAAQ5pE,IAAIA,EACzC,CACA,MAAAgW,CAAOhW,GACL,GAAI0E,KAAK6kE,YAAa,CACpB,IAAIvzD,EAAStR,KAAKklE,QAAQ5pE,GAC1B,GAAIgW,IAAWmzD,EACb,OAAOnzD,CAEX,CACF,CACA,QAAAJ,CAAS5V,GAKP,GAJI,IAAcA,KAChBA,EAAImpE,GAGFzkE,KAAK6kE,YAAa,CACpB,IAAI3zD,EAAWlR,KAAKmlE,UAAU7pE,GAC9B,GAAI4V,EACF,OAAO,IAAOA,EAElB,KAAO,IAAI5V,IAAMmpE,EACf,OAAOzkE,KAAK3K,QACP,GAAI2K,KAAK2a,QAAQrf,GACtB,MAAO,EACT,CACF,CACA,YAAA4sB,CAAa5sB,GACX,IAAI0qE,EAAShmE,KAAKqlE,OAAO/pE,GACzB,GAAI0qE,EACF,OAAO,IAAOA,EAElB,CACA,UAAAxmD,CAAWlkB,GACT,IAAI2qE,EAAQjmE,KAAKulE,MAAMjqE,GACvB,GAAI2qE,EACF,OAAO,IAAOA,EAElB,CACA,SAAAxmD,CAAUnkB,GACR,IAAI4qE,EAAQlmE,KAAKkoB,aAAa5sB,GAC9B,GAAI4qE,EACF,OAAO,EAAQA,EAAOlmE,KAAKwf,WAAWlkB,GAE1C,CACA,MAAA6qE,CAAO7qE,GAOL,OAA4B,KALxB0E,KAAKuf,aACKvf,KAAKwf,WAAWlkB,GAEhB0E,KAAKyf,UAAUnkB,IAEZhG,MACnB,CACA,WAAA8wE,CAAY3yE,GAEV,IAAI4yE,EAAO,IAAIrmE,KAAK4I,YAAY,CAC9BwV,SAAUpe,KAAK2kE,YACf5pD,WAAY/a,KAAK4kE,cACjBphD,SAAUxjB,KAAK6kE,cAGjBwB,EAAKprD,SAASjb,KAAK4Y,SAEnB,IAAI3V,EAAOjD,KACX,IAAOA,KAAKilE,QAAQ,SAAUtyE,EAAO2I,GAC/B7H,EAAO6H,IACT+qE,EAAKpuD,QAAQ3c,EAAG3I,EAEpB,IAEA,IAAOqN,KAAKwlE,WAAW,SAAUpyE,GAE3BizE,EAAK1rD,QAAQvnB,EAAEkI,IAAM+qE,EAAK1rD,QAAQvnB,EAAEilB,IACtCguD,EAAK7tD,QAAQplB,EAAG6P,EAAKyP,KAAKtf,GAE9B,IAEA,IAAIkzE,EAAU,CAAC,EACf,SAASC,EAAWjrE,GAClB,IAAIgW,EAASrO,EAAKqO,OAAOhW,GACzB,YAAe/F,IAAX+b,GAAwB+0D,EAAK1rD,QAAQrJ,IACvCg1D,EAAQhrE,GAAKgW,EACNA,GACEA,KAAUg1D,EACZA,EAAQh1D,GAERi1D,EAAWj1D,EAEtB,CAQA,OANItR,KAAK6kE,aACP,IAAOwB,EAAKhxE,SAAS,SAAUiG,GAC7B+qE,EAAK1pD,UAAUrhB,EAAGirE,EAAWjrE,GAC/B,IAGK+qE,CACT,CAEA,mBAAAG,CAAoBb,GAKlB,OAJK,IAAaA,KAChBA,EAAa,IAAWA,IAE1B3lE,KAAKglE,oBAAsBW,EACpB3lE,IACT,CACA,SAAAymE,GACE,OAAOzmE,KAAK0mE,UACd,CACA,KAAA/0D,GACE,OAAO,IAAS3R,KAAKwlE,UACvB,CACA,OAAAmB,CAAQtnD,EAAI1sB,GACV,IAAIsQ,EAAOjD,KACPuD,EAAOG,UASX,OARA,IAAS2b,GAAI,SAAU/jB,EAAG+c,GAMxB,OALI9U,EAAKjO,OAAS,EAChB2N,EAAKuV,QAAQld,EAAG+c,EAAG1lB,GAEnBsQ,EAAKuV,QAAQld,EAAG+c,GAEXA,CACT,IACOrY,IACT,CAKA,OAAAwY,GACE,IAAIld,EAAG+c,EAAGtkB,EAAMpB,EACZi0E,GAAiB,EACjBC,EAAOnjE,UAAU,GAED,iBAATmjE,GAA8B,OAATA,GAAiB,MAAOA,GACtDvrE,EAAIurE,EAAKvrE,EACT+c,EAAIwuD,EAAKxuD,EACTtkB,EAAO8yE,EAAK9yE,KACa,IAArB2P,UAAUpO,SACZ3C,EAAQ+Q,UAAU,GAClBkjE,GAAiB,KAGnBtrE,EAAIurE,EACJxuD,EAAI3U,UAAU,GACd3P,EAAO2P,UAAU,GACbA,UAAUpO,OAAS,IACrB3C,EAAQ+Q,UAAU,GAClBkjE,GAAiB,IAIrBtrE,EAAI,GAAKA,EACT+c,EAAI,GAAKA,EACJ,IAActkB,KACjBA,EAAO,GAAKA,GAGd,IAAIX,EAAI0zE,EAAa9mE,KAAK2kE,YAAarpE,EAAG+c,EAAGtkB,GAC7C,GAAIwF,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKylE,YAAaryE,GAIzD,OAHIwzE,IACF5mE,KAAKylE,YAAYryE,GAAKT,GAEjBqN,KAGT,IAAK,IAAcjM,KAAUiM,KAAK4kE,cAChC,MAAM,IAAIhsE,MAAM,qDAKlBoH,KAAKiY,QAAQ3c,GACb0E,KAAKiY,QAAQI,GAGbrY,KAAKylE,YAAYryE,GAAKwzE,EAAiBj0E,EAAQqN,KAAKglE,oBAAoB1pE,EAAG+c,EAAGtkB,GAE9E,IAAI2pB,EA8GR,SAAuB6B,EAAYwnD,EAAIC,EAAIjzE,GACzC,IAAIuH,EAAI,GAAKyrE,EACT1uD,EAAI,GAAK2uD,EACb,IAAKznD,GAAcjkB,EAAI+c,EAAG,CACxB,IAAI4N,EAAM3qB,EACVA,EAAI+c,EACJA,EAAI4N,CACN,CACA,IAAIvI,EAAU,CAAEpiB,EAAGA,EAAG+c,EAAGA,GACrBtkB,IACF2pB,EAAQ3pB,KAAOA,GAEjB,OAAO2pB,CACT,CA3HkBupD,CAAcjnE,KAAK2kE,YAAarpE,EAAG+c,EAAGtkB,GAYpD,OAVAuH,EAAIoiB,EAAQpiB,EACZ+c,EAAIqF,EAAQrF,EAEZ9e,OAAO2xC,OAAOxtB,GACd1d,KAAKwlE,UAAUpyE,GAAKsqB,EACpBwpD,EAAqBlnE,KAAKqlE,OAAOhtD,GAAI/c,GACrC4rE,EAAqBlnE,KAAKulE,MAAMjqE,GAAI+c,GACpCrY,KAAKolE,IAAI/sD,GAAGjlB,GAAKsqB,EACjB1d,KAAKslE,KAAKhqE,GAAGlI,GAAKsqB,EAClB1d,KAAK0mE,aACE1mE,IACT,CACA,IAAA0S,CAAKpX,EAAG+c,EAAGtkB,GACT,IAAIX,EACmB,IAArBsQ,UAAUpO,OACN6xE,EAAYnnE,KAAK2kE,YAAajhE,UAAU,IACxCojE,EAAa9mE,KAAK2kE,YAAarpE,EAAG+c,EAAGtkB,GAC3C,OAAOiM,KAAKylE,YAAYryE,EAC1B,CACA,OAAA4tB,CAAQ1lB,EAAG+c,EAAGtkB,GACZ,IAAIX,EACmB,IAArBsQ,UAAUpO,OACN6xE,EAAYnnE,KAAK2kE,YAAajhE,UAAU,IACxCojE,EAAa9mE,KAAK2kE,YAAarpE,EAAG+c,EAAGtkB,GAC3C,OAAOwF,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKylE,YAAaryE,EAChE,CACA,UAAAymB,CAAWve,EAAG+c,EAAGtkB,GACf,IAAIX,EACmB,IAArBsQ,UAAUpO,OACN6xE,EAAYnnE,KAAK2kE,YAAajhE,UAAU,IACxCojE,EAAa9mE,KAAK2kE,YAAarpE,EAAG+c,EAAGtkB,GACvC2e,EAAO1S,KAAKwlE,UAAUpyE,GAY1B,OAXIsf,IACFpX,EAAIoX,EAAKpX,EACT+c,EAAI3F,EAAK2F,SACFrY,KAAKylE,YAAYryE,UACjB4M,KAAKwlE,UAAUpyE,GACtBg0E,EAAuBpnE,KAAKqlE,OAAOhtD,GAAI/c,GACvC8rE,EAAuBpnE,KAAKulE,MAAMjqE,GAAI+c,UAC/BrY,KAAKolE,IAAI/sD,GAAGjlB,UACZ4M,KAAKslE,KAAKhqE,GAAGlI,GACpB4M,KAAK0mE,cAEA1mE,IACT,CACA,OAAAqZ,CAAQ/d,EAAGnC,GACT,IAAI2uB,EAAM9nB,KAAKolE,IAAI9pE,GACnB,GAAIwsB,EAAK,CACP,IAAInW,EAAQ,IAASmW,GACrB,OAAK3uB,EAGE,IAASwY,GAAO,SAAUe,GAC/B,OAAOA,EAAKpX,IAAMnC,CACpB,IAJSwY,CAKX,CACF,CACA,QAAAwH,CAAS7d,EAAG+c,GACV,IAAIgvD,EAAOrnE,KAAKslE,KAAKhqE,GACrB,GAAI+rE,EAAM,CACR,IAAI11D,EAAQ,IAAS01D,GACrB,OAAKhvD,EAGE,IAAS1G,GAAO,SAAUe,GAC/B,OAAOA,EAAK2F,IAAMA,CACpB,IAJS1G,CAKX,CACF,CACA,SAAA8M,CAAUnjB,EAAG+c,GACX,IAAIgB,EAAUrZ,KAAKqZ,QAAQ/d,EAAG+c,GAC9B,GAAIgB,EACF,OAAOA,EAAQ7lB,OAAOwM,KAAKmZ,SAAS7d,EAAG+c,GAE3C,EASF,SAAS6uD,EAAqBztE,EAAK4B,GAC7B5B,EAAI4B,GACN5B,EAAI4B,KAEJ5B,EAAI4B,GAAK,CAEb,CAEA,SAAS+rE,EAAuB3tE,EAAK4B,KAC5B5B,EAAI4B,WACF5B,EAAI4B,EAEf,CAEA,SAASyrE,EAAavnD,EAAYwnD,EAAIC,EAAIjzE,GACxC,IAAIuH,EAAI,GAAKyrE,EACT1uD,EAAI,GAAK2uD,EACb,IAAKznD,GAAcjkB,EAAI+c,EAAG,CACxB,IAAI4N,EAAM3qB,EACVA,EAAI+c,EACJA,EAAI4N,CACN,CACA,OAAO3qB,EAxeY,IAweS+c,EAxeT,KAwe+B,IAActkB,GA1e1C,KA0esEA,EAC9F,CAiBA,SAASozE,EAAY5nD,EAAY7B,GAC/B,OAAOopD,EAAavnD,EAAY7B,EAAQpiB,EAAGoiB,EAAQrF,EAAGqF,EAAQ3pB,KAChE,CA/CA2wE,EAAM3gE,UAAU6hE,WAAa,EAG7BlB,EAAM3gE,UAAU2iE,WAAa,C,8EC/ctB,MAAMY,UAA0B1uE,MACnC,WAAAgQ,CAAYzU,EAAMwnC,GACdhJ,MAAMx+B,EAAO,GAAGwnC,QAAcxnC,EAAKgG,MAAMwY,MAAMnN,QAAQrR,EAAKgG,MAAMwY,MAAM40D,YAAc5rC,EAC1F,EAEG,SAAS6rC,EAAkBC,GAC9B,MAAM,IAAI7uE,MAAM,0CACpB,C,gLCFO,MAAM8uE,EACT,WAAA9+D,CAAY++D,EAASC,GACjB5nE,KAAK2nE,QAAUA,EACf3nE,KAAK4nE,OAASA,CAClB,CACA,QAAAtxE,GACI,MAAMA,EAAW,CACbuO,MAAO7E,KAAK2nE,UACZlxE,KAAM,IAAMuJ,KAAK4nE,OAAOtxE,EAASuO,OACjC,CAACgjE,OAAOvxE,UAAW,IAAMA,GAE7B,OAAOA,CACX,CACA,CAACuxE,OAAOvxE,YACJ,OAAO0J,KAAK1J,UAChB,CACA,OAAA+oC,GACI,MAAM/oC,EAAW0J,KAAK1J,WACtB,OAAO4B,QAAQ5B,EAASG,OAAOC,KACnC,CACA,KAAAoxE,GACI,MAAMxxE,EAAW0J,KAAK1J,WACtB,IAAIwxE,EAAQ,EACRrxE,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MACToxE,IACArxE,EAAOH,EAASG,OAEpB,OAAOqxE,CACX,CACA,OAAAC,GACI,MAAMxxE,EAAS,GACTD,EAAW0J,KAAK1J,WACtB,IAAIG,EACJ,GACIA,EAAOH,EAASG,YACGlB,IAAfkB,EAAK9D,OACL4D,EAAOK,KAAKH,EAAK9D,cAEf8D,EAAKC,MACf,OAAOH,CACX,CACA,KAAAyxE,GACI,OAAO,IAAIh1E,IAAIgN,KACnB,CACA,KAAAioE,CAAMC,EAAOC,GACT,MAAMC,EAAcpoE,KAAKvG,KAAI9D,GAAW,CACpCuyE,EAAQA,EAAMvyE,GAAWA,EACzBwyE,EAAUA,EAAQxyE,GAAWA,KAEjC,OAAO,IAAI2B,IAAI8wE,EACnB,CACA,QAAA/wD,GACI,OAAOrX,KAAKtG,MAChB,CACA,MAAAlG,CAAOkgB,GACH,OAAO,IAAIg0D,GAAW,KAAM,CAAG9xE,MAAOoK,KAAK2nE,UAAWU,WAAW,EAAO/xE,SAAUod,EAAMm0D,OAAOvxE,gBAAgBuO,IAC3G,IAAItO,EACJ,IAAKsO,EAAMwjE,UAAW,CAClB,GAEI,GADA9xE,EAASyJ,KAAK4nE,OAAO/iE,EAAMjP,QACtBW,EAAOG,KACR,OAAOH,SAELA,EAAOG,MACjBmO,EAAMwjE,WAAY,CACtB,CACA,GAEI,GADA9xE,EAASsO,EAAMvO,SAASG,QACnBF,EAAOG,KACR,OAAOH,SAELA,EAAOG,MACjB,OAAO4xE,CAAW,GAE1B,CACA,IAAA5uE,CAAKi8B,EAAY,KACb,MAAMr/B,EAAW0J,KAAK1J,WACtB,IACIC,EADA5D,EAAQ,GAER41E,GAAe,EACnB,GACIhyE,EAASD,EAASG,OACbF,EAAOG,OACJ6xE,IACA51E,GAASgjC,GAEbhjC,GAAS0kB,EAAS9gB,EAAO5D,QAE7B41E,GAAe,SACThyE,EAAOG,MACjB,OAAO/D,CACX,CACA,OAAA0a,CAAQm7D,EAAezyD,EAAY,GAC/B,MAAMzf,EAAW0J,KAAK1J,WACtB,IAAIlB,EAAQ,EACRqB,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,GAAItB,GAAS2gB,GAAatf,EAAK9D,QAAU61E,EACrC,OAAOpzE,EAEXqB,EAAOH,EAASG,OAChBrB,GACJ,CACA,OAAQ,CACZ,CACA,KAAAqzE,CAAM3yD,GACF,MAAMxf,EAAW0J,KAAK1J,WACtB,IAAIG,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,IAAKof,EAAUrf,EAAK9D,OAChB,OAAO,EAEX8D,EAAOH,EAASG,MACpB,CACA,OAAO,CACX,CACA,IAAAiyE,CAAK5yD,GACD,MAAMxf,EAAW0J,KAAK1J,WACtB,IAAIG,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,GAAIof,EAAUrf,EAAK9D,OACf,OAAO,EAEX8D,EAAOH,EAASG,MACpB,CACA,OAAO,CACX,CACA,OAAAvC,CAAQy0E,GACJ,MAAMryE,EAAW0J,KAAK1J,WACtB,IAAIlB,EAAQ,EACRqB,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MACTiyE,EAAWlyE,EAAK9D,MAAOyC,GACvBqB,EAAOH,EAASG,OAChBrB,GAER,CACA,GAAAqE,CAAIkvE,GACA,OAAO,IAAIjB,EAAW1nE,KAAK2nE,SAAU9iE,IACjC,MAAM,KAAEnO,EAAI,MAAE/D,GAAUqN,KAAK4nE,OAAO/iE,GACpC,OAAInO,EACO4xE,EAGA,CAAE5xE,MAAM,EAAO/D,MAAOg2E,EAAWh2E,GAC5C,GAER,CACA,MAAAc,CAAOqiB,GACH,OAAO,IAAI4xD,EAAW1nE,KAAK2nE,SAAS9iE,IAChC,IAAItO,EACJ,GAEI,GADAA,EAASyJ,KAAK4nE,OAAO/iE,IAChBtO,EAAOG,MAAQof,EAAUvf,EAAO5D,OACjC,OAAO4D,SAELA,EAAOG,MACjB,OAAO4xE,CAAW,GAE1B,CACA,WAAAM,GACI,OAAO5oE,KAAKvM,QAAOL,GAAKA,SAC5B,CACA,MAAAk5B,CAAOq8C,EAAYE,GACf,MAAMvyE,EAAW0J,KAAK1J,WACtB,IAAIwyE,EAAgBD,EAChBpyE,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAELoyE,OADkBvzE,IAAlBuzE,EACgBryE,EAAK9D,MAGLg2E,EAAWG,EAAeryE,EAAK9D,OAEnD8D,EAAOH,EAASG,OAEpB,OAAOqyE,CACX,CACA,WAAAC,CAAYJ,EAAYE,GACpB,OAAO7oE,KAAKgpE,gBAAgBhpE,KAAK1J,WAAYqyE,EAAYE,EAC7D,CACA,eAAAG,CAAgB1yE,EAAUqyE,EAAYE,GAClC,MAAMpyE,EAAOH,EAASG,OACtB,GAAIA,EAAKC,KACL,OAAOmyE,EAEX,MAAMC,EAAgB9oE,KAAKgpE,gBAAgB1yE,EAAUqyE,EAAYE,GACjE,YAAsBtzE,IAAlBuzE,EACOryE,EAAK9D,MAETg2E,EAAWG,EAAeryE,EAAK9D,MAC1C,CACA,IAAAQ,CAAK2iB,GACD,MAAMxf,EAAW0J,KAAK1J,WACtB,IAAIG,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,GAAIof,EAAUrf,EAAK9D,OACf,OAAO8D,EAAK9D,MAEhB8D,EAAOH,EAASG,MACpB,CAEJ,CACA,SAAAwyE,CAAUnzD,GACN,MAAMxf,EAAW0J,KAAK1J,WACtB,IAAIlB,EAAQ,EACRqB,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,GAAIof,EAAUrf,EAAK9D,OACf,OAAOyC,EAEXqB,EAAOH,EAASG,OAChBrB,GACJ,CACA,OAAQ,CACZ,CACA,QAAA4F,CAASwtE,GACL,MAAMlyE,EAAW0J,KAAK1J,WACtB,IAAIG,EAAOH,EAASG,OACpB,MAAQA,EAAKC,MAAM,CACf,GAAID,EAAK9D,QAAU61E,EACf,OAAO,EAEX/xE,EAAOH,EAASG,MACpB,CACA,OAAO,CACX,CACA,OAAAR,CAAQ0yE,GACJ,OAAO,IAAIjB,GAAW,KAAM,CAAG1nE,KAAMA,KAAK2nE,cAAe9iE,IACrD,EAAG,CACC,GAAIA,EAAMvO,SAAU,CAChB,MAAMG,EAAOoO,EAAMvO,SAASG,OAC5B,IAAIA,EAAKC,KAIL,OAAOD,EAHPoO,EAAMvO,cAAWf,CAKzB,CACA,MAAM,KAAEmB,EAAI,MAAE/D,GAAUqN,KAAK4nE,OAAO/iE,EAAM7E,MAC1C,IAAKtJ,EAAM,CACP,MAAMwyE,EAASP,EAAWh2E,GAC1B,IAAIw2E,EAAWD,GAIX,MAAO,CAAExyE,MAAM,EAAO/D,MAAOu2E,GAH7BrkE,EAAMvO,SAAW4yE,EAAOrB,OAAOvxE,WAKvC,CACJ,OAASuO,EAAMvO,UACf,OAAOgyE,CAAW,GAE1B,CACA,IAAAc,CAAK7mD,GAID,QAHchtB,IAAVgtB,IACAA,EAAQ,GAERA,GAAS,EACT,OAAOviB,KAEX,MAAMqpE,EAAS9mD,EAAQ,EAAIviB,KAAKopE,KAAK7mD,EAAQ,GAAKviB,KAClD,OAAO,IAAI0nE,GAAW,KAAM,CAAG1nE,KAAMqpE,EAAO1B,cAAe9iE,IACvD,EAAG,CACC,GAAIA,EAAMvO,SAAU,CAChB,MAAMG,EAAOoO,EAAMvO,SAASG,OAC5B,IAAIA,EAAKC,KAIL,OAAOD,EAHPoO,EAAMvO,cAAWf,CAKzB,CACA,MAAM,KAAEmB,EAAI,MAAE/D,GAAU02E,EAAOzB,OAAO/iE,EAAM7E,MAC5C,IAAKtJ,EAAM,CACP,IAAIyyE,EAAWx2E,GAIX,MAAO,CAAE+D,MAAM,EAAO/D,MAAOA,GAH7BkS,EAAMvO,SAAW3D,EAAMk1E,OAAOvxE,WAKtC,CACJ,OAASuO,EAAMvO,UACf,OAAOgyE,CAAW,GAE1B,CACA,IAAAgB,GACI,MACM/yE,EADWyJ,KAAK1J,WACEG,OACxB,IAAIF,EAAOG,KAGX,OAAOH,EAAO5D,KAClB,CACA,IAAA42E,CAAKC,EAAY,GACb,OAAO,IAAI9B,GAAW,KAClB,MAAM7iE,EAAQ7E,KAAK2nE,UACnB,IAAK,IAAIzuE,EAAI,EAAGA,EAAIswE,EAAWtwE,IAAK,CAEhC,GADa8G,KAAK4nE,OAAO/iE,GAChBnO,KACL,OAAOmO,CAEf,CACA,OAAOA,CAAK,GACb7E,KAAK4nE,OACZ,CACA,KAAA6B,CAAMC,GACF,OAAO,IAAIhC,GAAW,KAAM,CAAGrpD,KAAM,EAAGxZ,MAAO7E,KAAK2nE,cAAc9iE,IAC9DA,EAAMwZ,OACFxZ,EAAMwZ,KAAOqrD,EACNpB,EAEJtoE,KAAK4nE,OAAO/iE,EAAMA,SAEjC,CACA,QAAA8kE,CAASC,GACL,OAAO,IAAIlC,GAAW,KAAM,CAAG/vE,IAAK,IAAI3E,IAAO62E,cAAe7pE,KAAK2nE,cAAc9iE,IAC7E,IAAItO,EACJ,GAEI,GADAA,EAASyJ,KAAK4nE,OAAO/iE,EAAMglE,gBACtBtzE,EAAOG,KAAM,CACd,MAAM/D,EAAQi3E,EAAKA,EAAGrzE,EAAO5D,OAAS4D,EAAO5D,MAC7C,IAAKkS,EAAMlN,IAAI7D,IAAInB,GAEf,OADAkS,EAAMlN,IAAI3D,IAAIrB,GACP4D,CAEf,SACMA,EAAOG,MACjB,OAAO4xE,CAAW,GAE1B,CACA,OAAAwB,CAAQp2D,EAAOyC,GACX,MAAM4zD,EAAc,IAAI/2E,IACxB,IAAK,MAAM0d,KAAQgD,EAAO,CACtB,MAAM/gB,EAAQwjB,EAAMA,EAAIzF,GAAQA,EAChCq5D,EAAY/1E,IAAIrB,EACpB,CACA,OAAOqN,KAAKvM,QAAOL,IACf,MAAM42E,EAAS7zD,EAAMA,EAAI/iB,GAAKA,EAC9B,OAAQ22E,EAAYj2E,IAAIk2E,EAAO,GAEvC,EAEJ,SAAS3yD,EAAS3G,GACd,MAAoB,iBAATA,EACAA,OAES,IAATA,EACA,YAGkB,mBAAlBA,EAAK2G,SAEL3G,EAAK2G,WAET9d,OAAOwK,UAAUsT,SAAS5T,KAAKiN,EAC1C,CACA,SAASy4D,EAAW32C,GAChB,QAASA,GAAuC,mBAAzBA,EAAIq1C,OAAOvxE,SACtC,CAKO,MAAM2zE,EAAe,IAAIvC,GAAW,KAAe,IAAE,IAAMY,IAIrDA,EAAc/uE,OAAO2xC,OAAO,CAAEx0C,MAAM,EAAM/D,WAAO4C,IAIvD,SAAS8zE,KAAUa,GACtB,GAA2B,IAAvBA,EAAY50E,OAAc,CAC1B,MAAMugB,EAAaq0D,EAAY,GAC/B,GAAIr0D,aAAsB6xD,EACtB,OAAO7xD,EAEX,GAAIszD,EAAWtzD,GACX,OAAO,IAAI6xD,GAAW,IAAM7xD,EAAWgyD,OAAOvxE,cAAcA,GAAaA,EAASG,SAEtF,GAAiC,iBAAtBof,EAAWvgB,OAClB,OAAO,IAAIoyE,GAAW,KAAM,CAAGtyE,MAAO,MAAOyP,GACrCA,EAAMzP,MAAQygB,EAAWvgB,OAClB,CAAEoB,MAAM,EAAO/D,MAAOkjB,EAAWhR,EAAMzP,UAGvCkzE,GAIvB,CACA,OAAI4B,EAAY50E,OAAS,EACd,IAAIoyE,GAAW,KAAM,CAAGyC,UAAW,EAAGC,SAAU,MAAOvlE,IAC1D,EAAG,CACC,GAAIA,EAAMvO,SAAU,CAChB,MAAMG,EAAOoO,EAAMvO,SAASG,OAC5B,IAAKA,EAAKC,KACN,OAAOD,EAEXoO,EAAMvO,cAAWf,CACrB,CACA,GAAIsP,EAAMwR,MAAO,CACb,GAAIxR,EAAMulE,SAAWvlE,EAAMwR,MAAM/gB,OAC7B,MAAO,CAAEoB,MAAM,EAAO/D,MAAOkS,EAAMwR,MAAMxR,EAAMulE,aAEnDvlE,EAAMwR,WAAQ9gB,EACdsP,EAAMulE,SAAW,CACrB,CACA,GAAIvlE,EAAMslE,UAAYD,EAAY50E,OAAQ,CACtC,MAAMugB,EAAaq0D,EAAYrlE,EAAMslE,aACjChB,EAAWtzD,GACXhR,EAAMvO,SAAWuf,EAAWgyD,OAAOvxE,YAE9Buf,GAA2C,iBAAtBA,EAAWvgB,SACrCuP,EAAMwR,MAAQR,EAEtB,CACJ,OAAShR,EAAMvO,UAAYuO,EAAMwR,OAASxR,EAAMslE,UAAYD,EAAY50E,QACxE,OAAOgzE,CAAW,IAGnB2B,CACX,CAMO,MAAMI,UAAuB3C,EAChC,WAAA9+D,CAAYuY,EAAMjQ,EAAUhW,GACxBy3B,OAAM,KAAM,CACR23C,WAAYpvE,aAAyC,EAASA,EAAQqvE,aAAe,CAAC,CAACppD,GAAM0mD,OAAOvxE,aAAe,CAAC4a,EAASiQ,GAAM0mD,OAAOvxE,aAC1Ik0E,QAAQ,MACR3lE,IAKA,IAJIA,EAAM2lE,SACN3lE,EAAMylE,UAAU/lE,MAChBM,EAAM2lE,QAAS,GAEZ3lE,EAAMylE,UAAUh1E,OAAS,GAAG,CAC/B,MACMmB,EADWoO,EAAMylE,UAAUzlE,EAAMylE,UAAUh1E,OAAS,GACpCmB,OACtB,IAAIA,EAAKC,KAKL,OADAmO,EAAMylE,UAAU1zE,KAAKsa,EAASza,EAAK9D,OAAOk1E,OAAOvxE,aAC1CG,EAJPoO,EAAMylE,UAAU/lE,KAMxB,CACA,OAAO+jE,CAAW,GAE1B,CACA,QAAAhyE,GACI,MAAMA,EAAW,CACbuO,MAAO7E,KAAK2nE,UACZlxE,KAAM,IAAMuJ,KAAK4nE,OAAOtxE,EAASuO,OACjChO,MAAO,KACHP,EAASuO,MAAM2lE,QAAS,CAAI,EAEhC,CAAC3C,OAAOvxE,UAAW,IAAMA,GAE7B,OAAOA,CACX,EAKG,IAAIm0E,GACX,SAAWA,GAOPA,EAAU/jD,IAHV,SAAa2iD,GACT,OAAOA,EAAO/8C,QAAO,CAACo+C,EAAG15C,IAAM05C,EAAI15C,GAAG,EAC1C,EAQAy5C,EAAUE,QAHV,SAAiBtB,GACb,OAAOA,EAAO/8C,QAAO,CAACo+C,EAAG15C,IAAM05C,EAAI15C,GAAG,EAC1C,EAQAy5C,EAAU/0E,IAHV,SAAa2zE,GACT,OAAOA,EAAO/8C,QAAO,CAACo+C,EAAG15C,IAAMx7B,KAAKE,IAAIg1E,EAAG15C,IAC/C,EAQAy5C,EAAUh1E,IAHV,SAAa4zE,GACT,OAAOA,EAAO/8C,QAAO,CAACo+C,EAAG15C,IAAMx7B,KAAKC,IAAIi1E,EAAG15C,IAC/C,CAEH,CA7BD,CA6BGy5C,IAAcA,EAAY,CAAC,G,qHCjfvB,MAAMG,EACT,WAAAhiE,GAII5I,KAAK6qE,YAAc,EACvB,CACA,WAAAC,CAAYj4E,EAASqI,GACjB,MAAM6vE,GAAiB,SAAO,QAAqBl4E,GAAS,IACtDm4E,EAAiBhrE,KAAKirE,oBAAoBF,GAC1Cn5B,EAAS5xC,KAAKkrE,mBAAmBH,EAAgBC,EAAgB9vE,GAYvE,OAXA8vE,EAAe92E,SAAQi3E,IACnB,MAAMj4D,EAAUi4D,EAAcp1C,QACP,iBAAZ7iB,GAAwBA,GAAW,SAAUA,IAAW,QAAaA,GAC5E0+B,EAAOlxC,QAAQyqE,GAGfv5B,EAAOh7C,KAAKu0E,EAChB,IAIGv5B,CACX,CAEA,iBAAAw5B,CAAkB9lE,GACd,MAAO,CAAEulE,YAAa7qE,KAAKqrE,iBAC/B,CACA,cAAAA,GACI,MAAMR,EAAc,IAAI7qE,KAAK6qE,aAE7B,OADA7qE,KAAK6qE,YAAc,GACZA,CACX,CACA,mBAAAI,CAAoB/3E,GAChB,OAAOA,EAAMO,OAAO,MAAgBA,QAAOL,IAAMA,EAAEk4E,WAC9C7xE,KAAIjF,GAAYwL,KAAKurE,mBAAmB/2E,KAAWuzE,SAC5D,CACA,kBAAAwD,CAAmB/2E,GACf,MAAMoG,GAAQ,OAAcpG,GACtB0e,EAAUlT,KAAKwrE,sBAAsB5wE,GAASoF,KAAKyrE,qBAAqB7wE,GAASA,EACjFqnC,EAAY,CACdluC,KAAMS,EAAST,KACfgiC,QAAS7iB,GASb,MAPuB,mBAAZA,IACP+uB,EAAUR,aAAc,GAExBjtC,EAASd,SAETuuC,EAAUhB,OAAQ,QAAarmC,GAAS,KAAMsmC,QAAU,UAErDe,CACX,CACA,qBAAAupC,CAAsB5wE,GAClB,SAAIA,EAAM5B,MAAMgC,SAAS,OAAQJ,EAAM5B,MAAMgC,SAAS,UAI7CJ,EAAMxB,OAAO4B,SAAS,SAAUJ,EAAMxB,OAAO4B,SAAS,OAOnE,CACA,oBAAAywE,CAAqB7wE,GACjB,MAAM8wE,EAAc,IAAI/xE,OAAOiB,EAAOA,EAAM5B,MAAQ,KACpD,MAAO,CAACsM,EAAMe,KACVqlE,EAAY5jC,UAAYzhC,EAExB,OADmBqlE,EAAYjiE,KAAKnE,EACnB,CAEzB,CACA,kBAAA4lE,CAAmBh4E,EAAO83E,EAAgB9vE,GACtC,OAAOhI,EAEFO,OAAO,MACPwC,SAAQrC,IAAQ,QAAkBA,GAAMH,OAAO,QAC/Ck2E,UAASv2E,GAAKA,EAAET,QAAOo1E,UAEvB5jD,MAAK,CAACumD,EAAG15C,IAAMA,EAAEr+B,MAAM2C,OAASo1E,EAAE/3E,MAAM2C,SACxCmE,KAAItD,GAAW6J,KAAK2rE,kBAAkBx1E,EAAS60E,EAAgB9yE,QAAQgD,aAAyC,EAASA,EAAQ0wE,mBAC1I,CACA,iBAAAD,CAAkBx1E,EAAS60E,EAAgBY,GACvC,MAAMC,EAAiB7rE,KAAK8rE,oBAAoB31E,EAASy1E,GACnD3pC,EAAY,CACdluC,KAAMoC,EAAQxD,MACdojC,QAAS81C,EACTxqC,WAAYrhC,KAAK+rE,cAAc51E,EAAS60E,IAK5C,MAH8B,mBAAnBa,IACP5pC,EAAUR,aAAc,GAErBQ,CACX,CACA,mBAAA6pC,CAAoB31E,EAASy1E,GACzB,OAAOA,EACH,IAAIjyE,QAAO,QAA0BxD,EAAQxD,QAC7CwD,EAAQxD,KAChB,CACA,aAAAo5E,CAAc51E,EAAS60E,GACnB,OAAOA,EAAe1+C,QAAO,CAAC0/C,EAAY1nE,KACtC,MAAM4O,EAAU5O,aAAqC,EAASA,EAAMyxB,QAIpE,OAHK7iB,aAAyC,EAASA,EAAQ9Z,UAAW,QAAe,IAAM8Z,EAAQ9Z,OAAS,IAAKjD,EAAQxD,QACzHq5E,EAAWp1E,KAAK0N,GAEb0nE,CAAU,GAClB,GACP,E,6KC9FA7wE,EAAS,WACX,IAAIC,GAAoB,SAAO,SAASC,EAAGC,EAAGC,EAAIC,GAChD,IAAKD,EAAKA,GAAM,CAAC,EAAGC,EAAIH,EAAE/F,OAAQkG,IAAKD,EAAGF,EAAEG,IAAMF,GAClD,OAAOC,CACT,GAAG,KAAME,EAAM,CAAC,EAAG,GAAIC,EAAM,CAAC,EAAG,GAAIC,EAAM,CAAC,EAAG,GAAIC,EAAM,CAAC,EAAG,GAAIC,EAAM,CAAC,EAAG,GAAIC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,IAAKC,EAAM,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAKC,EAAM,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAKC,EAAM,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAChtB4B,EAAU,CACZC,OAAuB,SAAO,WAC9B,GAAG,SACHC,GAAI,CAAC,EACLC,SAAU,CAAE,MAAS,EAAG,MAAS,EAAG,MAAS,EAAG,GAAM,EAAG,GAAM,EAAG,SAAY,EAAG,KAAQ,EAAG,UAAa,EAAG,kBAAqB,GAAI,eAAkB,GAAI,kBAAqB,GAAI,YAAe,GAAI,MAAS,GAAI,SAAO,GAAI,WAAc,GAAI,MAAS,GAAI,MAAS,GAAI,eAAkB,GAAI,aAAgB,GAAI,YAAe,GAAI,YAAe,GAAI,GAAM,GAAI,GAAM,GAAI,KAAQ,GAAI,KAAQ,GAAI,OAAU,GAAI,WAAc,GAAI,KAAQ,GAAI,aAAgB,GAAI,UAAa,GAAI,UAAa,GAAI,UAAa,GAAI,gBAAmB,GAAI,UAAa,GAAI,gBAAmB,GAAI,0BAA6B,GAAI,SAAY,GAAI,YAAe,GAAI,mBAAsB,GAAI,QAAW,GAAI,MAAS,GAAI,UAAa,GAAI,mBAAsB,GAAI,MAAS,GAAI,gBAAmB,GAAI,WAAc,GAAI,aAAgB,GAAI,aAAgB,GAAI,aAAgB,GAAI,aAAgB,GAAI,IAAO,GAAI,IAAK,GAAI,WAAc,GAAI,gBAAmB,GAAI,QAAW,GAAI,SAAY,GAAI,QAAW,EAAG,KAAQ,GACt9BC,WAAY,CAAE,EAAG,QAAS,EAAG,QAAS,EAAG,KAAM,EAAG,KAAM,GAAI,QAAS,GAAI,SAAO,GAAI,aAAc,GAAI,QAAS,GAAI,QAAS,GAAI,iBAAkB,GAAI,eAAgB,GAAI,cAAe,GAAI,cAAe,GAAI,KAAM,GAAI,KAAM,GAAI,OAAQ,GAAI,OAAQ,GAAI,SAAU,GAAI,aAAc,GAAI,OAAQ,GAAI,YAAa,GAAI,YAAa,GAAI,kBAAmB,GAAI,YAAa,GAAI,kBAAmB,GAAI,4BAA6B,GAAI,WAAY,GAAI,cAAe,GAAI,qBAAsB,GAAI,UAAW,GAAI,QAAS,GAAI,YAAa,GAAI,qBAAsB,GAAI,QAAS,GAAI,kBAAmB,GAAI,aAAc,GAAI,eAAgB,GAAI,eAAgB,GAAI,eAAgB,GAAI,eAAgB,GAAI,IAAK,GAAI,aAAc,GAAI,kBAAmB,GAAI,UAAW,GAAI,YACrvBC,aAAc,CAAC,EAAG,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,IACtZC,eAA+B,SAAO,SAAmBC,EAAQC,EAAQC,EAAUP,EAAIQ,EAASC,EAAIC,GAClG,IAAIC,EAAKF,EAAGvK,OAAS,EACrB,OAAQsK,GACN,KAAK,EAEH,OADAR,EAAG6sE,WAAWpsE,EAAGE,IACVF,EAAGE,GAEZ,KAAK,EACHC,KAAKC,EAAI,GACT,MACF,KAAK,EACW,MAAVJ,EAAGE,KACLF,EAAGE,EAAK,GAAGnJ,KAAKiJ,EAAGE,IACnBC,KAAKC,EAAIJ,EAAGE,EAAK,IAEnB,MACF,KAAK,EACL,KAAK,EAML,KAAK,GACHC,KAAKC,EAAIJ,EAAGE,GACZ,MALF,KAAK,EACHC,KAAKC,EAAI,KACT,MAIF,KAAK,GACH,MAAMisE,EAAYrsE,EAAGE,EAAK,GAC1BmsE,EAAUlgB,YAAc5sD,EAAG+sE,UAAUtsE,EAAGE,IACxCC,KAAKC,EAAIisE,EACT,MACF,KAAK,GACHlsE,KAAKC,EAAI,CAAEsU,KAAM,WAAY63D,OAAQvsE,EAAGE,EAAK,GAAIssE,OAAQxsE,EAAGE,IAC5D,MACF,KAAK,GACH,MAAMusE,EAAiBltE,EAAG+sE,UAAUtsE,EAAGE,IACvCC,KAAKC,EAAI,CAAEsU,KAAM,WAAY63D,OAAQvsE,EAAGE,EAAK,GAAIssE,OAAQxsE,EAAGE,EAAK,GAAIisD,YAAasgB,GAClF,MACF,KAAK,GACHtsE,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,EAAK,GAAItL,KAAM,UAAWu3D,YAAa,GAAI33C,IAAKxU,EAAGE,EAAK,IACzF,MACF,KAAK,GACH,IAAIqJ,EAAKvJ,EAAGE,GACRisD,EAAcnsD,EAAGE,EAAK,GAAGM,OAC7B,GAAIR,EAAGE,GAAIwF,MAAM,KAAM,CACrB,IAAIyhB,EAAQnnB,EAAGE,GAAI0G,MAAM,KACzB2C,EAAK4d,EAAM,GACXglC,EAAc,CAACA,EAAahlC,EAAM,GACpC,CACAhnB,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,KAAI3U,KAAM,UAAWu3D,eAC/C,MACF,KAAK,GACHhsD,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,EAAK,GAAItL,KAAM,UAAWu3D,YAAansD,EAAGE,EAAK,GAAIsU,IAAKxU,EAAGE,EAAK,IACjG,MACF,KAAK,GACHC,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,GAAKtL,KAAM,QAC5C,MACF,KAAK,GACHuL,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,GAAKtL,KAAM,QAC5C,MACF,KAAK,GACHuL,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,GAAKtL,KAAM,UAC5C,MACF,KAAK,GACHuL,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIhK,EAAGmtE,eAAgB93E,KAAM,WACvD,MACF,KAAK,GACHuL,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,EAAK,GAAGM,OAAQ8O,KAAM,CAAE0f,SAAUhvB,EAAGE,EAAK,GAAGM,OAAQiF,KAAMzF,EAAGE,GAAIM,SACnG,MACF,KAAK,GACHL,KAAKC,EAAIJ,EAAGE,GAAIM,OAChBjB,EAAGkB,YAAYN,KAAKC,GACpB,MACF,KAAK,GACL,KAAK,GACHD,KAAKC,EAAIJ,EAAGE,GAAIM,OAChBjB,EAAGmB,kBAAkBP,KAAKC,GAC1B,MACF,KAAK,GACL,KAAK,GACHD,KAAKC,EAAI,CAAEsU,KAAM,WAAYnL,GAAIvJ,EAAGE,EAAK,GAAGM,OAAQkK,QAAS1K,EAAGE,GAAIM,QACpE,MACF,KAAK,GACHL,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,EAAK,GAAGM,OAAQiP,WAAYzP,EAAGE,GAAIM,QACpE,MACF,KAAK,GACHL,KAAKC,EAAI,CAAEsU,KAAM,aAAcnL,GAAIvJ,EAAGE,EAAK,GAAGM,OAAQiP,WAAYzP,EAAGE,GAAIM,QACzE,MACF,KAAK,GACHjB,EAAGoC,aAAa,MAChBxB,KAAKC,EAAI,CAAEsU,KAAM,MAAO5hB,MAAO,MAC/B,MACF,KAAK,GACHyM,EAAGoC,aAAa,MAChBxB,KAAKC,EAAI,CAAEsU,KAAM,MAAO5hB,MAAO,MAC/B,MACF,KAAK,GACHyM,EAAGoC,aAAa,MAChBxB,KAAKC,EAAI,CAAEsU,KAAM,MAAO5hB,MAAO,MAC/B,MACF,KAAK,GACHyM,EAAGoC,aAAa,MAChBxB,KAAKC,EAAI,CAAEsU,KAAM,MAAO5hB,MAAO,MAC/B,MACF,KAAK,GACL,KAAK,GACHqN,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,GAAIM,OAAQ5L,KAAM,UAAWu3D,YAAa,IAC3E,MACF,KAAK,GAGL,KAAK,GACHhsD,KAAKC,EAAI,CAAEsU,KAAM,QAASnL,GAAIvJ,EAAGE,EAAK,GAAGM,OAAQkK,QAAS,CAAC1K,EAAGE,GAAIM,QAAS5L,KAAM,UAAWu3D,YAAa,IAG/G,GAAG,aACHxpD,MAAO,CAAC,CAAE,EAAG,EAAG,EAAG/G,EAAK,EAAGC,EAAK,EAAGC,GAAO,CAAE,EAAG,CAAC,IAAM,CAAE,EAAG,EAAG,EAAGF,EAAK,EAAGC,EAAK,EAAGC,GAAO,CAAE,EAAG,EAAG,EAAGF,EAAK,EAAGC,EAAK,EAAGC,GAAOP,EAAE,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAKQ,EAAK,CAAE,EAAG,IAAM,CAAE,EAAG,CAAC,EAAG,IAAM,CAAE,EAAG,CAAC,EAAG,IAAM,CAAE,EAAG,CAAC,EAAG,GAAI,EAAGC,EAAK,EAAGC,EAAK,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAO/B,EAAEgC,EAAK,CAAC,EAAG,IAAK,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIrB,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAO/B,EAAEgC,EAAK,CAAC,EAAG,IAAKhC,EAAEgC,EAAK,CAAC,EAAG,IAAKhC,EAAEgC,EAAK,CAAC,EAAG,IAAKhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,MAAQhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEiC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQjC,EAAEiC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQjC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,IAAKhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,GAAI,GAAIjB,EAAK,GAAIgB,GAAO/B,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEkC,EAAK1B,EAAK,CAAE,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAOR,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,EAAGvB,EAAK,EAAGC,EAAK,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,CAAC,EAAG,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAO/B,EAAEgC,EAAK,CAAC,EAAG,IAAK,CAAE,GAAI,CAAC,EAAG,MAAQ,CAAE,GAAI,CAAC,EAAG,KAAO,CAAE,GAAI,CAAC,EAAG,KAAOhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEiC,EAAK,CAAC,EAAG,KAAMjC,EAAEiC,EAAK,CAAC,EAAG,KAAMjC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEkC,EAAK1B,EAAK,CAAE,EAAG,KAAOR,EAAEgC,EAAK,CAAC,EAAG,KAAMhC,EAAEgC,EAAK,CAAC,EAAG,KAAM,CAAE,EAAGvB,EAAK,EAAGC,EAAK,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,CAAC,EAAG,IAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAI,GAAI,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,GAAO/B,EAAEgC,EAAK,CAAC,EAAG,MACjhFqF,eAAgB,CAAE,EAAG,CAAC,EAAG,GAAI,EAAG,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,IAAK,GAAI,CAAC,EAAG,KAC7DC,YAA4B,SAAO,SAAoBC,EAAKC,GAC1D,IAAIA,EAAKC,YAEF,CACL,IAAIC,EAAQ,IAAIlK,MAAM+J,GAEtB,MADAG,EAAMF,KAAOA,EACPE,CACR,CALE9C,KAAKb,MAAMwD,EAMf,GAAG,cACHI,OAAuB,SAAO,SAAeC,GAC3C,IAAIC,EAAOjD,KAAMkD,EAAQ,CAAC,GAAIC,EAAS,GAAIC,EAAS,CAAC,MAAOC,EAAS,GAAIb,EAAQxC,KAAKwC,MAAO/C,EAAS,GAAIE,EAAW,EAAGD,EAAS,EAAG4D,EAAa,EAC7IC,EAAOF,EAAOG,MAAMC,KAAKC,UAAW,GACpCC,EAASpK,OAAOqK,OAAO5D,KAAK6D,OAC5BC,EAAc,CAAE1E,GAAI,CAAC,GACzB,IAAK,IAAI/D,KAAK2E,KAAKZ,GACb7F,OAAOwK,UAAUC,eAAeP,KAAKzD,KAAKZ,GAAI/D,KAChDyI,EAAY1E,GAAG/D,GAAK2E,KAAKZ,GAAG/D,IAGhCsI,EAAOM,SAASjB,EAAOc,EAAY1E,IACnC0E,EAAY1E,GAAGyE,MAAQF,EACvBG,EAAY1E,GAAGjE,OAAS6E,UACI,IAAjB2D,EAAOO,SAChBP,EAAOO,OAAS,CAAC,GAEnB,IAAIC,EAAQR,EAAOO,OACnBb,EAAOzM,KAAKuN,GACZ,IAAIC,EAAST,EAAOzI,SAAWyI,EAAOzI,QAAQkJ,OAY9C,SAASC,IACP,IAAIC,EASJ,MAPqB,iBADrBA,EAAQnB,EAAOoB,OAASZ,EAAOU,OA/BqI,KAiC9JC,aAAiBE,QAEnBF,GADAnB,EAASmB,GACMC,OAEjBD,EAAQrB,EAAK5D,SAASiF,IAAUA,GAE3BA,CACT,CAtByC,mBAA9BR,EAAY1E,GAAGsD,WACxB1C,KAAK0C,WAAaoB,EAAY1E,GAAGsD,WAEjC1C,KAAK0C,WAAanJ,OAAOkL,eAAezE,MAAM0C,YAOhD,SALA,SAAkBgC,GAChBxB,EAAM5N,OAAS4N,EAAM5N,OAAS,EAAIoP,EAClCtB,EAAO9N,OAAS8N,EAAO9N,OAASoP,EAChCrB,EAAO/N,OAAS+N,EAAO/N,OAASoP,CAClC,GACiB,aAajB,QAAOL,EAAK,OAEZ,IADA,IAAIM,EAAQC,EAAgBC,EAAOnM,EAAWoM,EAAeC,EAAGC,EAAKC,EAAUC,EAA9BC,EAAQ,CAAC,IAC7C,CAUX,GATAN,EAAQ3B,EAAMA,EAAM5N,OAAS,GACzB0K,KAAKyC,eAAeoC,GACtBnM,EAASsH,KAAKyC,eAAeoC,IAEzBF,UACFA,EAASN,KAEX3L,EAAS8J,EAAMqC,IAAUrC,EAAMqC,GAAOF,SAElB,IAAXjM,IAA2BA,EAAOpD,SAAWoD,EAAO,GAAI,CACjE,IAAI0M,EAAS,GAEb,IAAKL,KADLG,EAAW,GACD1C,EAAMqC,GACV7E,KAAKV,WAAWyF,IAAMA,EAzD6H,GA0DrJG,EAAStO,KAAK,IAAMoJ,KAAKV,WAAWyF,GAAK,KAI3CK,EADEzB,EAAO0B,aACA,wBAA0B1F,EAAW,GAAK,MAAQgE,EAAO0B,eAAiB,eAAiBH,EAASxL,KAAK,MAAQ,WAAasG,KAAKV,WAAWqF,IAAWA,GAAU,IAEnK,wBAA0BhF,EAAW,GAAK,iBAhE6G,GAgE1FgF,EAAgB,eAAiB,KAAO3E,KAAKV,WAAWqF,IAAWA,GAAU,KAErJ3E,KAAK0C,WAAW0C,EAAQ,CACtBE,KAAM3B,EAAO4B,MACbjB,MAAOtE,KAAKV,WAAWqF,IAAWA,EAClCa,KAAM7B,EAAOhE,SACb8F,IAAKtB,EACLe,YAEJ,CACA,GAAIxM,EAAO,aAAc8L,OAAS9L,EAAOpD,OAAS,EAChD,MAAM,IAAIsD,MAAM,oDAAsDiM,EAAQ,YAAcF,GAE9F,OAAQjM,EAAO,IACb,KAAK,EACHwK,EAAMtM,KAAK+N,GACXvB,EAAOxM,KAAK+M,EAAOlE,QACnB4D,EAAOzM,KAAK+M,EAAOO,QACnBhB,EAAMtM,KAAK8B,EAAO,IAClBiM,EAAS,KACJC,GASHD,EAASC,EACTA,EAAiB,OATjBlF,EAASiE,EAAOjE,OAChBD,EAASkE,EAAOlE,OAChBE,EAAWgE,EAAOhE,SAClBwE,EAAQR,EAAOO,OACXZ,EAAa,GACfA,KAMJ,MACF,KAAK,EAwBH,GAvBA0B,EAAMhF,KAAKT,aAAa7G,EAAO,IAAI,GACnCyM,EAAMlF,EAAImD,EAAOA,EAAO9N,OAAS0P,GACjCG,EAAMrF,GAAK,CACT4F,WAAYrC,EAAOA,EAAO/N,QAAU0P,GAAO,IAAIU,WAC/CC,UAAWtC,EAAOA,EAAO/N,OAAS,GAAGqQ,UACrCC,aAAcvC,EAAOA,EAAO/N,QAAU0P,GAAO,IAAIY,aACjDC,YAAaxC,EAAOA,EAAO/N,OAAS,GAAGuQ,aAErCzB,IACFe,EAAMrF,GAAG3F,MAAQ,CACfkJ,EAAOA,EAAO/N,QAAU0P,GAAO,IAAI7K,MAAM,GACzCkJ,EAAOA,EAAO/N,OAAS,GAAG6E,MAAM,UAYnB,KATjB2K,EAAI9E,KAAKR,cAAcsG,MAAMX,EAAO,CAClC1F,EACAC,EACAC,EACAmE,EAAY1E,GACZ1G,EAAO,GACP0K,EACAC,GACA7P,OAAO+P,KAEP,OAAOuB,EAELE,IACF9B,EAAQA,EAAMM,MAAM,GAAI,EAAIwB,EAAM,GAClC5B,EAASA,EAAOI,MAAM,GAAI,EAAIwB,GAC9B3B,EAASA,EAAOG,MAAM,GAAI,EAAIwB,IAEhC9B,EAAMtM,KAAKoJ,KAAKT,aAAa7G,EAAO,IAAI,IACxC0K,EAAOxM,KAAKuO,EAAMlF,GAClBoD,EAAOzM,KAAKuO,EAAMrF,IAClBmF,EAAWzC,EAAMU,EAAMA,EAAM5N,OAAS,IAAI4N,EAAMA,EAAM5N,OAAS,IAC/D4N,EAAMtM,KAAKqO,GACX,MACF,KAAK,EACH,OAAO,EAEb,CACA,OAAO,CACT,GAAG,UAEDpB,EAAwB,WA2jB1B,MA1jBa,CACXkC,IAAK,EACLrD,YAA4B,SAAO,SAAoBC,EAAKC,GAC1D,IAAI5C,KAAKZ,GAAGjE,OAGV,MAAM,IAAIvC,MAAM+J,GAFhB3C,KAAKZ,GAAGjE,OAAOuH,WAAWC,EAAKC,EAInC,GAAG,cAEHqB,UAA0B,SAAO,SAASjB,EAAO5D,GAiB/C,OAhBAY,KAAKZ,GAAKA,GAAMY,KAAKZ,IAAM,CAAC,EAC5BY,KAAKgG,OAAShD,EACdhD,KAAKiG,MAAQjG,KAAKkG,WAAalG,KAAKtJ,MAAO,EAC3CsJ,KAAKL,SAAWK,KAAKN,OAAS,EAC9BM,KAAKP,OAASO,KAAKmG,QAAUnG,KAAKuF,MAAQ,GAC1CvF,KAAKoG,eAAiB,CAAC,WACvBpG,KAAKkE,OAAS,CACZwB,WAAY,EACZE,aAAc,EACdD,UAAW,EACXE,YAAa,GAEX7F,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC,EAAG,IAE1B6F,KAAKqG,OAAS,EACPrG,IACT,GAAG,YAEHgD,OAAuB,SAAO,WAC5B,IAAIsD,EAAKtG,KAAKgG,OAAO,GAiBrB,OAhBAhG,KAAKP,QAAU6G,EACftG,KAAKN,SACLM,KAAKqG,SACLrG,KAAKuF,OAASe,EACdtG,KAAKmG,SAAWG,EACJA,EAAGf,MAAM,oBAEnBvF,KAAKL,WACLK,KAAKkE,OAAOyB,aAEZ3F,KAAKkE,OAAO2B,cAEV7F,KAAK9E,QAAQkJ,QACfpE,KAAKkE,OAAO/J,MAAM,KAEpB6F,KAAKgG,OAAShG,KAAKgG,OAAOxC,MAAM,GACzB8C,CACT,GAAG,SAEHC,OAAuB,SAAO,SAASD,GACrC,IAAItB,EAAMsB,EAAGhR,OACTkR,EAAQF,EAAGG,MAAM,iBACrBzG,KAAKgG,OAASM,EAAKtG,KAAKgG,OACxBhG,KAAKP,OAASO,KAAKP,OAAOiH,OAAO,EAAG1G,KAAKP,OAAOnK,OAAS0P,GACzDhF,KAAKqG,QAAUrB,EACf,IAAI2B,EAAW3G,KAAKuF,MAAMkB,MAAM,iBAChCzG,KAAKuF,MAAQvF,KAAKuF,MAAMmB,OAAO,EAAG1G,KAAKuF,MAAMjQ,OAAS,GACtD0K,KAAKmG,QAAUnG,KAAKmG,QAAQO,OAAO,EAAG1G,KAAKmG,QAAQ7Q,OAAS,GACxDkR,EAAMlR,OAAS,IACjB0K,KAAKL,UAAY6G,EAAMlR,OAAS,GAElC,IAAIwP,EAAI9E,KAAKkE,OAAO/J,MAWpB,OAVA6F,KAAKkE,OAAS,CACZwB,WAAY1F,KAAKkE,OAAOwB,WACxBC,UAAW3F,KAAKL,SAAW,EAC3BiG,aAAc5F,KAAKkE,OAAO0B,aAC1BC,YAAaW,GAASA,EAAMlR,SAAWqR,EAASrR,OAAS0K,KAAKkE,OAAO0B,aAAe,GAAKe,EAASA,EAASrR,OAASkR,EAAMlR,QAAQA,OAASkR,EAAM,GAAGlR,OAAS0K,KAAKkE,OAAO0B,aAAeZ,GAEtLhF,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC2K,EAAE,GAAIA,EAAE,GAAK9E,KAAKN,OAASsF,IAElDhF,KAAKN,OAASM,KAAKP,OAAOnK,OACnB0K,IACT,GAAG,SAEH4G,MAAsB,SAAO,WAE3B,OADA5G,KAAKiG,OAAQ,EACNjG,IACT,GAAG,QAEH6G,QAAwB,SAAO,WAC7B,OAAI7G,KAAK9E,QAAQ4L,iBACf9G,KAAKkG,YAAa,EAQblG,MANEA,KAAK0C,WAAW,0BAA4B1C,KAAKL,SAAW,GAAK,mIAAqIK,KAAKqF,eAAgB,CAChOC,KAAM,GACNhB,MAAO,KACPkB,KAAMxF,KAAKL,UAIjB,GAAG,UAEHoH,MAAsB,SAAO,SAASrC,GACpC1E,KAAKuG,MAAMvG,KAAKuF,MAAM/B,MAAMkB,GAC9B,GAAG,QAEHsC,WAA2B,SAAO,WAChC,IAAIC,EAAOjH,KAAKmG,QAAQO,OAAO,EAAG1G,KAAKmG,QAAQ7Q,OAAS0K,KAAKuF,MAAMjQ,QACnE,OAAQ2R,EAAK3R,OAAS,GAAK,MAAQ,IAAM2R,EAAKP,QAAQ,IAAIQ,QAAQ,MAAO,GAC3E,GAAG,aAEHC,eAA+B,SAAO,WACpC,IAAI1Q,EAAOuJ,KAAKuF,MAIhB,OAHI9O,EAAKnB,OAAS,KAChBmB,GAAQuJ,KAAKgG,OAAOU,OAAO,EAAG,GAAKjQ,EAAKnB,UAElCmB,EAAKiQ,OAAO,EAAG,KAAOjQ,EAAKnB,OAAS,GAAK,MAAQ,KAAK4R,QAAQ,MAAO,GAC/E,GAAG,iBAEH7B,cAA8B,SAAO,WACnC,IAAI+B,EAAMpH,KAAKgH,YACXK,EAAI,IAAI7C,MAAM4C,EAAI9R,OAAS,GAAGoE,KAAK,KACvC,OAAO0N,EAAMpH,KAAKmH,gBAAkB,KAAOE,EAAI,GACjD,GAAG,gBAEHC,YAA4B,SAAO,SAAS/B,EAAOgC,GACjD,IAAIjD,EAAOkC,EAAOgB,EAmDlB,GAlDIxH,KAAK9E,QAAQ4L,kBACfU,EAAS,CACP7H,SAAUK,KAAKL,SACfuE,OAAQ,CACNwB,WAAY1F,KAAKkE,OAAOwB,WACxBC,UAAW3F,KAAK2F,UAChBC,aAAc5F,KAAKkE,OAAO0B,aAC1BC,YAAa7F,KAAKkE,OAAO2B,aAE3BpG,OAAQO,KAAKP,OACb8F,MAAOvF,KAAKuF,MACZkC,QAASzH,KAAKyH,QACdtB,QAASnG,KAAKmG,QACdzG,OAAQM,KAAKN,OACb2G,OAAQrG,KAAKqG,OACbJ,MAAOjG,KAAKiG,MACZD,OAAQhG,KAAKgG,OACb5G,GAAIY,KAAKZ,GACTgH,eAAgBpG,KAAKoG,eAAe5C,MAAM,GAC1C9M,KAAMsJ,KAAKtJ,MAETsJ,KAAK9E,QAAQkJ,SACfoD,EAAOtD,OAAO/J,MAAQ6F,KAAKkE,OAAO/J,MAAMqJ,MAAM,MAGlDgD,EAAQjB,EAAM,GAAGA,MAAM,sBAErBvF,KAAKL,UAAY6G,EAAMlR,QAEzB0K,KAAKkE,OAAS,CACZwB,WAAY1F,KAAKkE,OAAOyB,UACxBA,UAAW3F,KAAKL,SAAW,EAC3BiG,aAAc5F,KAAKkE,OAAO2B,YAC1BA,YAAaW,EAAQA,EAAMA,EAAMlR,OAAS,GAAGA,OAASkR,EAAMA,EAAMlR,OAAS,GAAGiQ,MAAM,UAAU,GAAGjQ,OAAS0K,KAAKkE,OAAO2B,YAAcN,EAAM,GAAGjQ,QAE/I0K,KAAKP,QAAU8F,EAAM,GACrBvF,KAAKuF,OAASA,EAAM,GACpBvF,KAAKyH,QAAUlC,EACfvF,KAAKN,OAASM,KAAKP,OAAOnK,OACtB0K,KAAK9E,QAAQkJ,SACfpE,KAAKkE,OAAO/J,MAAQ,CAAC6F,KAAKqG,OAAQrG,KAAKqG,QAAUrG,KAAKN,SAExDM,KAAKiG,OAAQ,EACbjG,KAAKkG,YAAa,EAClBlG,KAAKgG,OAAShG,KAAKgG,OAAOxC,MAAM+B,EAAM,GAAGjQ,QACzC0K,KAAKmG,SAAWZ,EAAM,GACtBjB,EAAQtE,KAAKR,cAAciE,KAAKzD,KAAMA,KAAKZ,GAAIY,KAAMuH,EAAcvH,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,IAChH0K,KAAKtJ,MAAQsJ,KAAKgG,SACpBhG,KAAKtJ,MAAO,GAEV4N,EACF,OAAOA,EACF,GAAItE,KAAKkG,WAAY,CAC1B,IAAK,IAAI7K,KAAKmM,EACZxH,KAAK3E,GAAKmM,EAAOnM,GAEnB,OAAO,CACT,CACA,OAAO,CACT,GAAG,cAEH5E,MAAsB,SAAO,WAC3B,GAAIuJ,KAAKtJ,KACP,OAAOsJ,KAAK+F,IAKd,IAAIzB,EAAOiB,EAAOmC,EAAWtS,EAHxB4K,KAAKgG,SACRhG,KAAKtJ,MAAO,GAGTsJ,KAAKiG,QACRjG,KAAKP,OAAS,GACdO,KAAKuF,MAAQ,IAGf,IADA,IAAIrS,EAAQ8M,KAAK2H,gBACRzO,EAAI,EAAGA,EAAIhG,EAAMoC,OAAQ4D,IAEhC,IADAwO,EAAY1H,KAAKgG,OAAOT,MAAMvF,KAAK9M,MAAMA,EAAMgG,SAC5BqM,GAASmC,EAAU,GAAGpS,OAASiQ,EAAM,GAAGjQ,QAAS,CAGlE,GAFAiQ,EAAQmC,EACRtS,EAAQ8D,EACJ8G,KAAK9E,QAAQ4L,gBAAiB,CAEhC,IAAc,KADdxC,EAAQtE,KAAKsH,WAAWI,EAAWxU,EAAMgG,KAEvC,OAAOoL,EACF,GAAItE,KAAKkG,WAAY,CAC1BX,GAAQ,EACR,QACF,CACE,OAAO,CAEX,CAAO,IAAKvF,KAAK9E,QAAQ0M,KACvB,KAEJ,CAEF,OAAIrC,GAEY,KADdjB,EAAQtE,KAAKsH,WAAW/B,EAAOrS,EAAMkC,MAE5BkP,EAIS,KAAhBtE,KAAKgG,OACAhG,KAAK+F,IAEL/F,KAAK0C,WAAW,0BAA4B1C,KAAKL,SAAW,GAAK,yBAA2BK,KAAKqF,eAAgB,CACtHC,KAAM,GACNhB,MAAO,KACPkB,KAAMxF,KAAKL,UAGjB,GAAG,QAEH0E,KAAqB,SAAO,WAC1B,IAAIS,EAAI9E,KAAKvJ,OACb,OAAIqO,GAGK9E,KAAKqE,KAEhB,GAAG,OAEHwD,OAAuB,SAAO,SAAeC,GAC3C9H,KAAKoG,eAAexP,KAAKkR,EAC3B,GAAG,SAEHC,UAA0B,SAAO,WAE/B,OADQ/H,KAAKoG,eAAe9Q,OAAS,EAC7B,EACC0K,KAAKoG,eAAe7B,MAEpBvE,KAAKoG,eAAe,EAE/B,GAAG,YAEHuB,eAA+B,SAAO,WACpC,OAAI3H,KAAKoG,eAAe9Q,QAAU0K,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,GAC1E0K,KAAKgI,WAAWhI,KAAKoG,eAAepG,KAAKoG,eAAe9Q,OAAS,IAAIpC,MAErE8M,KAAKgI,WAAoB,QAAE9U,KAEtC,GAAG,iBAEH+U,UAA0B,SAAO,SAAkBvD,GAEjD,OADAA,EAAI1E,KAAKoG,eAAe9Q,OAAS,EAAIE,KAAK0S,IAAIxD,GAAK,KAC1C,EACA1E,KAAKoG,eAAe1B,GAEpB,SAEX,GAAG,YAEHyD,WAA2B,SAAO,SAAmBL,GACnD9H,KAAK6H,MAAMC,EACb,GAAG,aAEHM,gBAAgC,SAAO,WACrC,OAAOpI,KAAKoG,eAAe9Q,MAC7B,GAAG,kBACH4F,QAAS,CAAE,oBAAoB,GAC/BsE,eAA+B,SAAO,SAAmBJ,EAAIiJ,EAAKC,EAA2BC,GAE3F,OAAQD,GACN,KAAK,EACH,OAAO,GAET,KAAK,EAuJL,KAAK,GACH,OAAO,GArJT,KAAK,EAuJL,KAAK,GACH,OAAO,GArJT,KAAK,EAuJL,KAAK,GACH,OAAO,GArJT,KAAK,EAuJL,KAAK,GACH,OAAO,GArJT,KAAK,EAEL,KAAK,EAOL,KAAK,EAEL,KAAK,EAEL,KAAK,GAEL,KAAK,GAoKL,KAAK,GAML,KAAK,GAyBL,KAAK,GACH,MA7MF,KAAK,EAgQL,KAAK,GACH,OAAO,EAtPT,KAAK,GA+EL,KAAK,GAEH,OADAtI,KAAKmI,UAAU,SACR,GA7ET,KAAK,GA+EL,KAAK,GACH,OAAO,GA7ET,KAAK,GAsBL,KAAK,GAyDL,KAAK,GA2DL,KAAK,GASL,KAAK,GACHnI,KAAK+H,WACL,MAlJF,KAAK,GAEH,OADA/H,KAAK6H,MAAM,aACJ,GAET,KAAK,GAEH,OADA7H,KAAK+H,WACE,kBAET,KAAK,GAEH,OADA/H,KAAK6H,MAAM,aACJ,GAET,KAAK,GAEH,OADA7H,KAAK+H,WACE,kBAET,KAAK,GACH/H,KAAK6H,MAAM,uBACX,MAIF,KAAK,GACH,MAAO,4BAET,KAAK,GAEH,OADA7H,KAAKmI,UAAU,YACR,GAET,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,cACR,sBAET,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,cACR,GAET,KAAK,GAEH,OADAnI,KAAK+H,WACE,GAET,KAAK,GAEH,OADA/H,KAAKmI,UAAU,SACR,GAET,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,eACR,GAET,KAAK,GAEH,OADAnI,KAAK+H,WACE,GAET,KAAK,GAEH,OADA/H,KAAKmI,UAAU,SACR,GAET,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,mBACR,GAET,KAAK,GAEH,OADAnI,KAAK+H,WACE,GAYT,KAAK,GACH/H,KAAKmI,UAAU,SACf,MACF,KAAK,GAeL,KAAK,GAGH,OAFAnI,KAAK+H,WACLM,EAAI5I,OAAS4I,EAAI5I,OAAO+D,MAAM,GAAI,GAAGnD,OAC9B,GAbT,KAAK,GAeL,KAAK,GAGH,OAFAL,KAAK+H,WACLM,EAAI5I,OAAS4I,EAAI5I,OAAO+D,MAAM,GAAI,GAAGnD,OAC9B,GAbT,KAAK,GAeL,KAAK,GAGH,OAFAL,KAAK+H,WACLM,EAAI5I,OAAS4I,EAAI5I,OAAO+D,MAAM,GAAI,IAAInD,OAC/B,GAcT,KAAK,GACHL,KAAKmI,UAAU,gBACf,MACF,KAAK,GAEH,OADAnI,KAAKmI,UAAU,YACR,KAET,KAAK,GAyDL,KAAK,GAEH,OADAnI,KAAK+H,WACE,KApDT,KAAK,GACH,MAAO,cAET,KAAK,GACH,OAAO,GAKT,KAAK,GAGH,OAFA/H,KAAK+H,WACL/H,KAAKmI,UAAU,UACR,GAIT,KAAK,GAEH,OADAnI,KAAK+H,WACE,GAIT,KAAK,GAEH,OADA/H,KAAK6H,MAAM,QACJ,GAET,KAAK,GAGH,OAFA7H,KAAK+H,WACL/H,KAAKmI,UAAU,WACR,GAET,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,WACR,GAET,KAAK,GACHnI,KAAK+H,WACL/H,KAAKmI,UAAU,iBACf,MACF,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,oBACR,KAIT,KAAK,GACH,MAAO,YAMT,KAAK,GAGH,OAFAnI,KAAK+H,WACL/H,KAAKmI,UAAU,aACR,GAET,KAAK,GAGH,OAFAnI,KAAK+H,WACLM,EAAI5I,OAAS4I,EAAI5I,OAAOiH,OAAO,GAAGrG,OAC3B,GAET,KAAK,GAGH,OAFAL,KAAK+H,WACLM,EAAI5I,OAAS4I,EAAI5I,OAAO+D,MAAM,GAAI,GAAGnD,OAC9B,GAET,KAAK,GAGL,KAAK,GACH,OAAO,EAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GAEH,OADAgI,EAAI5I,OAAS4I,EAAI5I,OAAOY,OACjB,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAET,KAAK,GACH,OAAO,GAKT,KAAK,GACH,MAAO,UAGb,GAAG,aACHnN,MAAO,CAAC,kBAAmB,+BAAgC,+BAAgC,+BAAgC,+BAAgC,uBAAwB,sBAAuB,cAAe,cAAe,oBAAqB,gBAAiB,gBAAiB,iBAAkB,YAAa,mBAAoB,wBAAyB,wBAAyB,wBAAyB,wBAAyB,yBAA0B,aAAc,eAAgB,oBAAqB,mBAAoB,eAAgB,eAAgB,iBAAkB,2BAA4B,eAAgB,iBAAkB,kBAAmB,eAAgB,iBAAkB,YAAa,mBAAoB,iBAAkB,mBAAoB,mBAAoB,qBAAsB,uBAAwB,uBAAwB,yBAA0B,+BAAgC,+BAAgC,+BAAgC,+BAAgC,YAAa,iBAAkB,iBAAkB,YAAa,cAAe,mBAAoB,WAAY,WAAY,uBAAwB,WAAY,aAAc,gBAAiB,kBAAmB,mBAAoB,UAAW,iBAAkB,YAAa,cAAe,eAAgB,uBAAwB,qBAAsB,2BAA4B,wBAAyB,2BAA4B,iCAAkC,eAAgB,sBAAuB,qBAAsB,YAAa,WAAY,YAAa,UAAW,WACljD8U,WAAY,CAAE,KAAQ,CAAE,MAAS,CAAC,EAAG,IAAK,WAAa,GAAS,OAAU,CAAE,MAAS,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,iBAAoB,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,cAAiB,CAAE,MAAS,CAAC,GAAI,GAAI,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,GAAI,IAAK,WAAa,GAAS,QAAW,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,KAAQ,CAAE,MAAS,CAAC,GAAI,GAAI,IAAK,WAAa,GAAS,mBAAsB,CAAE,MAAS,GAAI,WAAa,GAAS,gBAAmB,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,GAAI,WAAa,GAAS,MAAS,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,YAAe,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,MAAS,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,WAAc,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,SAAY,CAAE,MAAS,CAAC,GAAI,IAAK,WAAa,GAAS,oBAAuB,CAAE,MAAS,CAAC,GAAI,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,UAAa,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,MAAS,CAAE,MAAS,CAAC,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,MAAS,CAAE,MAAS,GAAI,WAAa,GAAS,SAAY,CAAE,MAAS,CAAC,IAAK,WAAa,GAAS,aAAgB,CAAE,MAAS,CAAC,GAAI,IAAK,WAAa,GAAS,WAAc,CAAE,MAAS,GAAI,WAAa,GAAS,MAAS,CAAE,MAAS,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,GAAS,GAAM,CAAE,MAAS,CAAC,EAAG,IAAK,WAAa,GAAS,QAAW,CAAE,MAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,WAAa,IAGjmD,CA5jB4B,GA8jB5B,SAASQ,IACPxI,KAAKZ,GAAK,CAAC,CACb,CAIA,OAPAF,EAAQ2E,MAAQA,GAIhB,QAAO2E,EAAQ,UACfA,EAAOzE,UAAY7E,EACnBA,EAAQsJ,OAASA,EACV,IAAIA,CACb,CA/1Ba,GAg2BbrN,EAAOA,OAASA,EAChB,IAAIqxE,EAAuBrxE,EAMvBsxE,EAAa,QACbC,EAAgB,WAIhBC,EAAqB,UACrBC,EAAe,UACfC,EAAe,YACfC,EAAwB,aAExBC,EAAmB,OACnBC,EAAmB,SACnBC,EAAc,OACdC,EAAwB,gBAGxBC,EAAgB,UAChBC,EAAc,mBAGdC,EAAc,eAEdC,EAAoB,GAAGD,UACvBE,EAAW,aAGXC,EAAqB,GAAGD,cACxBE,EAAmB,GAAGJ,SAEtBK,EAAsB,GAAGL,YAEzBM,EAA0B,GAAGN,gBAC7B76B,EAAS,SACTo7B,EAAO,OAEPC,EAAoB,OACpBC,EAAU,GAAGD,IAAoBD,IACjCG,EAAY,GAAGF,IAAoBr7B,IAGnCt+B,GAAyB,SAAO,CAACC,EAAYC,EA1CpB,QA2C3B,IAAKD,EAAWE,IACd,OAAOD,EAET,IAAInD,EAAMmD,EACV,IAAK,MAAME,KAAiBH,EAAWE,IACV,QAAvBC,EAAcC,OAChBtD,EAAMqD,EAAc3hB,OAGxB,OAAOse,CAAG,GACT,UA2BC+8D,EAAmC,CACrC7/D,YA3B+B,SAAO,SAAS7I,EAAMmP,GACrD,OAAOA,EAAWC,GAAGvG,YACvB,GAAG,cA0BDwG,MAzByB,SAAOC,eAAetP,EAAM8D,EAAIyL,EAAUC,GACnE,KAAIC,KAAK,SACT,KAAIA,KAAK,6BAA8B3L,GACvC,MAAM,cAAE6G,EAAepL,MAAOmQ,EAAI,OAAEC,IAAW,UAC/CH,EAAKJ,GAAGu5D,QAAQn5D,EAAKJ,GAAGw5D,gBACxB,MAAMh5D,EAAcJ,EAAKJ,GAAGhD,UACtByD,GAAM,OAAkB/L,EAAI6G,GAClCiF,EAAYzgB,KAAOqgB,EAAKrgB,KACxBygB,EAAYE,gBAAkBH,EAC9BC,EAAYG,YAAcL,GAAMK,aAAe,GAC/CH,EAAYI,YAAcN,GAAMM,aAAe,GAC/CJ,EAAYK,QAAU,CAAC,QACvBL,EAAYM,UAAYpM,QAClB,QAAO8L,EAAaC,GAE1B,KAAcM,YACZN,EACA,wBACAH,GAAMU,gBAAkB,GACxBZ,EAAKJ,GAAG/H,oBAEV,OAAoBwI,EAPJ,EAOkBk4D,EAAar4D,GAAMW,cAAe,EACtE,GAAG,QAIDzB,UAIEi6D,EAAyB,IAAI72E,IAC7B82E,EAAiB,EACrB,SAASC,EAAWC,EAAS,GAAIh7D,EAAU,EAAG7e,EAAO,GAAI85E,EAAaV,GAEpE,MAAO,SAAkBS,IADA,OAAT75E,GAAiBA,EAAKa,OAAS,EAAI,GAAGi5E,IAAa95E,IAAS,MAC/B6e,GAC/C,EACA,QAAO+6D,EAAY,cACnB,IAAIG,GAA2B,SAAO,CAACC,EAAkBp6D,EAAKq6D,EAAer5E,EAAOsc,EAAOg9D,EAAS18D,EAAM1H,KACxG,KAAIpL,MAAM,QAASkV,GACnBA,EAAIngB,SAASwc,IACX,OAAQA,EAAK6D,MACX,KAAKk4D,EAGL,KAAKE,EACHiC,EAAYH,EAAkB/9D,EAAMg+D,EAAer5E,EAAOsc,EAAOg9D,EAAS18D,EAAM1H,GAChF,MACF,KAAKmiE,EACH,CACEkC,EACEH,EACA/9D,EAAK07D,OACLsC,EACAr5E,EACAsc,EACAg9D,EACA18D,EACA1H,GAEFqkE,EACEH,EACA/9D,EAAK27D,OACLqC,EACAr5E,EACAsc,EACAg9D,EACA18D,EACA1H,GAEF,MAAMskE,EAAW,CACfzlE,GAAI,OAASglE,EACbz7D,MAAOjC,EAAK07D,OAAOhjE,GACnBwJ,IAAKlC,EAAK27D,OAAOjjE,GACjB0lE,UAAW,SACX/7D,aAAc,aACd5H,MAAO0hE,EACP55D,WAAY,GACZ3F,MAAO,KAAelD,aAAasG,EAAKs7C,aAAa,WACrDh5C,eAAgB85D,EAChBv5D,SA7HU,IA8HVw7D,UAAWhC,EACXl6D,UAAWm6D,EACXziE,QAASgjE,EACTt7D,QAEFN,EAAM/a,KAAKi4E,GACXT,GACF,EAEJ,GACA,GACD,YACCY,GAA0B,SAAO,CAAC76D,EAAYC,EArJrB,QAsJ3B,IAAInD,EAAMmD,EACV,GAAID,EAAWE,IACb,IAAK,MAAMC,KAAiBH,EAAWE,IACV,QAAvBC,EAAcC,OAChBtD,EAAMqD,EAAc3hB,OAI1B,OAAOse,CAAG,GACT,UACH,SAASg+D,EAAmB55E,EAAO65E,EAAU3kE,GAC3C,IAAK2kE,EAAS9lE,IAAsB,mBAAhB8lE,EAAS9lE,IAA2C,cAAhB8lE,EAAS9lE,GAC/D,OAEE8lE,EAAS1hE,aACNhJ,MAAMyK,QAAQigE,EAASC,qBAC1BD,EAASC,kBAAoB,IAE/BD,EAAS1hE,WAAW/G,MAAM,KAAKvS,SAASk7E,IACtC,GAAI7kE,EAAQ3S,IAAIw3E,GAAW,CACzB,MAAMC,EAAW9kE,EAAQ3S,IAAIw3E,GAC7BF,EAASC,kBAAoB,IAAID,EAASC,qBAAsBE,EAASzhE,OAC3E,MAGJ,MAAM0hE,EAAmBj6E,EAAMlC,MAAMgB,GAASA,EAAKiV,KAAO8lE,EAAS9lE,KAC/DkmE,EACF/1E,OAAOg2D,OAAO+f,EAAkBJ,GAEhC75E,EAAMuB,KAAKs4E,EAEf,CAEA,SAASK,EAAqBC,GAC5B,OAAOA,GAAYjlE,SAAS7Q,KAAK,MAAQ,EAC3C,CAEA,SAAS+1E,EAAoBD,GAC3B,OAAOA,GAAY5hE,QAAU,EAC/B,EAPA,QAAOqhE,EAAoB,uBAI3B,QAAOM,EAAsB,yBAI7B,QAAOE,EAAqB,uBAC5B,IAAIb,GAA8B,SAAO,CAACt9D,EAAQ6C,EAAYu6D,EAAer5E,EAAOsc,EAAOg9D,EAAS18D,EAAM1H,KACxG,MAAM+jE,EAASn6D,EAAW/K,GACpBsmE,EAAUhB,EAAc92E,IAAI02E,GAC5BqB,EAAWJ,EAAqBG,GAChCvkE,EAAQskE,EAAoBC,GAElC,GADA,KAAI36D,KAAK,yBAA0BZ,EAAYu7D,EAASvkE,GACzC,SAAXmjE,EAAmB,CACrB,IAAI/gE,EAAQ0/D,GACa,IAArB94D,EAAWxB,MACbpF,EAxLY,cAyLkB,IAArB4G,EAAWxB,QACpBpF,EAzLU,YA2LR4G,EAAW1f,OAASk4E,IACtBp/D,EAAQ4G,EAAW1f,MAEhB05E,EAAOv2E,IAAI02E,IACdH,EAAOx2E,IAAI22E,EAAQ,CACjBllE,GAAIklE,EACJ/gE,QACAy+C,YAAa,KAAe5hD,aAAakkE,GAAQ,WACjD9gE,WAAY,GAAGmiE,KAAYrC,IAC3Bt7D,UAAW7G,IAGf,MAAMykE,EAAUzB,EAAOv2E,IAAI02E,GACvBn6D,EAAW63C,cACTxnD,MAAMyK,QAAQ2gE,EAAQ5jB,cACxB4jB,EAAQriE,MAAQ2/D,EAChB0C,EAAQ5jB,YAAYp1D,KAAKud,EAAW63C,cAEhC4jB,EAAQ5jB,aAAa12D,OAAS,GAChCs6E,EAAQriE,MAAQ2/D,EACZ0C,EAAQ5jB,cAAgBsiB,EAC1BsB,EAAQ5jB,YAAc,CAAC73C,EAAW63C,aAElC4jB,EAAQ5jB,YAAc,CAAC4jB,EAAQ5jB,YAAa73C,EAAW63C,eAGzD4jB,EAAQriE,MAAQ0/D,EAChB2C,EAAQ5jB,YAAc73C,EAAW63C,aAGrC4jB,EAAQ5jB,YAAc,KAAe6jB,oBAAoBD,EAAQ5jB,aAAa,YAE5C,IAAhC4jB,EAAQ5jB,aAAa12D,QAAgBs6E,EAAQriE,QAAU2/D,IACpC,UAAjB0C,EAAQn7E,KACVm7E,EAAQriE,MAAQ6/D,EAEhBwC,EAAQriE,MAAQ0/D,IAGf2C,EAAQn7E,MAAQ0f,EAAWE,MAC9B,KAAIU,KAAK,0BAA2Bu5D,EAAQU,EAAQ76D,IACpDy7D,EAAQn7E,KAAO,QACfm7E,EAAQ99D,SAAU,EAClB89D,EAAQ3+D,IAAM+9D,EAAQ76D,GACtBy7D,EAAQriE,MAAQ4G,EAAW1f,OAASm4E,EAAeO,EAAgBC,EACnEwC,EAAQpiE,WAAa,GAAGoiE,EAAQpiE,cAAckgE,KAAuBiB,EAAUhB,EAA0B,MAE3G,MAAMuB,EAAW,CACfj8D,WAAY,GACZ1F,MAAOqiE,EAAQriE,MACfD,MAAOsiE,EAAQ5jB,YACfx+C,WAAYoiE,EAAQpiE,WACpB2hE,kBAAmB,GACnBn9D,UAAW49D,EAAQ59D,UACnB5I,GAAIklE,EACJr9D,IAAK2+D,EAAQ3+D,IACbpD,MAAOwgE,EAAWC,EAAQF,GAC1B35E,KAAMm7E,EAAQn7E,KACdqd,QAA0B,UAAjB89D,EAAQn7E,KACjBsd,QAAS,EACT+9D,GAAI,GACJC,GAAI,GACJ99D,QAUF,GARIi9D,EAAS3hE,QAAU4/D,IACrB+B,EAAS5hE,MAAQ,IAEfgE,GAAwB,SAAdA,EAAOlI,KACnB,KAAIjK,MAAM,gBAAiBmvE,EAAQ,8BAA+Bh9D,EAAOlI,IACzE8lE,EAAS/8D,SAAWb,EAAOlI,IAE7B8lE,EAASc,aAAc,EACnB77D,EAAWhF,KAAM,CACnB,MAAM8gE,EAAW,CACfh9D,WAAY,GACZ1F,MAnQS,OAoQTD,MAAO6G,EAAWhF,KAAK7J,KACvBkI,WAAYigE,EAEZz7D,UAAW,GACXk+D,kBAAmB,GACnB9mE,GAAIklE,EAASR,EAAU,IAAMM,EAC7BvgE,MAAOwgE,EAAWC,EAAQF,EAAgBR,GAC1Cn5E,KAAMm7E,EAAQn7E,KACdqd,QAA0B,UAAjB89D,EAAQn7E,KACjBsd,SAAS,UAAYo+D,UAAUp+D,QAC/BE,OACA4c,SAAU1a,EAAWhF,KAAK0f,UAEtBuhD,EAAe9B,EAASP,EACxBsC,EAAY,CAChBp9D,WAAY,GACZ1F,MAnRc,YAoRdD,MAAO6G,EAAWhF,KAAK7J,KACvBkI,WAAYoiE,EAAQpiE,WACpBwE,UAAW,GACX5I,GAAIklE,EAASP,EACblgE,MAAOwgE,EAAWC,EAAQF,EAAgB57B,GAC1C/9C,KAAM,QACNqd,SAAS,EACTC,QAAS,GAETE,OACA4c,SAAU1a,EAAWhF,KAAK0f,UAE5Bu/C,IACAiC,EAAUjnE,GAAKgnE,EACfH,EAAS99D,SAAWi+D,EACpBnB,EAAmB55E,EAAOg7E,EAAW9lE,GACrC0kE,EAAmB55E,EAAO46E,EAAU1lE,GACpC0kE,EAAmB55E,EAAO65E,EAAU3kE,GACpC,IAAI6xB,EAAOkyC,EACPjyC,EAAK4zC,EAAS7mE,GACe,YAA7B+K,EAAWhF,KAAK0f,WAClBuN,EAAO6zC,EAAS7mE,GAChBizB,EAAKiyC,GAEP38D,EAAM/a,KAAK,CACTwS,GAAIgzB,EAAO,IAAMC,EACjB1pB,MAAOypB,EACPxpB,IAAKypB,EACLyyC,UAAW,OACX/7D,aAAc,GACd5H,MAAO0hE,EACP55D,WAAY,GACZ1I,QAASijE,EACTx6D,eAAgB85D,EAChBv5D,SAhUc,IAiUdw7D,UAAWhC,EACXl6D,UAAWm6D,EACX/6D,QAEJ,MACEg9D,EAAmB55E,EAAO65E,EAAU3kE,EAExC,CACI4J,EAAWE,MACb,KAAIlV,MAAM,0BACVqvE,EAASr6D,EAAYA,EAAWE,IAAKq6D,EAAer5E,EAAOsc,GAAQg9D,EAAS18D,EAAM1H,GACpF,GACC,eACCs/C,GAAwB,SAAO,KACjCskB,EAAOphE,QACPqhE,EAAiB,CAAC,GACjB,SAGCkC,EAAa,MACbC,EAAa,QACbC,EAAWF,EAEXG,EAAgB,QAChBC,EAAe,OAGnB,SAASC,IACP,OAAuB,IAAIr5E,GAC7B,EACA,QAAOq5E,EAAgB,kBACvB,IAAIC,GAAyB,SAAO,KAC3B,CAELtmE,UAAW,GACXumE,OAAwB,IAAIv5E,IAC5Bw5E,UAAW,CAAC,KAEb,UACC9nC,GAAwB,SAAQ5tC,GAAMoT,KAAKzL,MAAMyL,KAAKC,UAAUrT,KAAK,SACrE21E,EAAU,cAEV,QAAO/wE,KAAM,UACf,CAIA,WAAA4I,CAAYooE,GACVhxE,KAAK+M,QACL/M,KAAKgxE,QAAUA,EACfhxE,KAAKisE,WAAajsE,KAAKisE,WAAWn/D,KAAK9M,MACvCA,KAAKusE,aAAevsE,KAAKusE,aAAaz/D,KAAK9M,MAC3CA,KAAKwB,aAAexB,KAAKwB,aAAasL,KAAK9M,MAC3CA,KAAKmsE,UAAYnsE,KAAKmsE,UAAUr/D,KAAK9M,KACvC,CAKAgxE,QAKA37E,MAAQ,GAKRsc,MAAQ,GAKRs/D,QAAU,GAKV1mE,QAAUomE,IAMVG,UAAY,CACV3vD,KAAMyvD,KAMRM,gBAAkBlxE,KAAK8wE,UAAU3vD,KAKjCgwD,cAAgB,EAKhBC,WAAa,EACbC,oBAAsB,CACpBxvE,YAAa,EACbC,UAAW,EACXC,YAAa,EACbC,WAAY,GAEd,UAAAiqE,CAAW7wE,GACT,KAAI2Z,KAAK,mBAAoB3Z,GAC7B4E,KAAKixE,QAAU71E,EACM,IAAjB4E,KAAKgxE,QACPhxE,KAAKiuE,QAAQ7yE,GAEb4E,KAAKiuE,QAAQjuE,KAAKkuE,eAEtB,CACA,UAAAoD,GACE,OAAOtxE,KAAKixE,OACd,CAOA,aAAAM,CAAcjgE,EAAQnd,EAAMyB,GAC1B,GAAIzB,EAAKogB,OAASm4D,EAChB1sE,KAAKuxE,cAAcjgE,EAAQnd,EAAKi4E,QAAQ,GACxCpsE,KAAKuxE,cAAcjgE,EAAQnd,EAAKk4E,QAAQ,QAUxC,GARIl4E,EAAKogB,OAASk4D,IACA,QAAZt4E,EAAKiV,IACPjV,EAAKiV,GAAKxT,EAAQ0b,EAAOlI,GAAK,SAAWkI,EAAOlI,GAAK,OACrDjV,EAAKwe,MAAQ/c,GAEbzB,EAAKiV,GAAKjV,EAAKiV,GAAG/I,QAGlBlM,EAAKkgB,IAAK,CACZ,MAAMA,EAAM,GACZ,IACInb,EADAs4E,EAAa,GAEjB,IAAKt4E,EAAI,EAAGA,EAAI/E,EAAKkgB,IAAI/e,OAAQ4D,IAC/B,GAAI/E,EAAKkgB,IAAInb,GAAGzE,OAASm4E,EAAc,CACrC,MAAMgD,EAAU5mC,EAAM70C,EAAKkgB,IAAInb,IAC/B02E,EAAQv7D,IAAM20B,EAAMwoC,GACpBn9D,EAAIzd,KAAKg5E,GACT4B,EAAa,EACf,MACEA,EAAW56E,KAAKzC,EAAKkgB,IAAInb,IAG7B,GAAImb,EAAI/e,OAAS,GAAKk8E,EAAWl8E,OAAS,EAAG,CAC3C,MAAMs6E,EAAU,CACdr7D,KAAMk4D,EACNrjE,IAAI,UACJ3U,KAAM,UACN4f,IAAK20B,EAAMwoC,IAEbn9D,EAAIzd,KAAKoyC,EAAM4mC,IACfz7E,EAAKkgB,IAAMA,CACb,CACAlgB,EAAKkgB,IAAIngB,SAASu9E,GAAYzxE,KAAKuxE,cAAcp9E,EAAMs9E,GAAS,IAClE,CAEJ,CAIA,YAAAvD,GAEE,OADAluE,KAAKuxE,cAAc,CAAEnoE,GAAI,QAAU,CAAEA,GAAI,OAAQiL,IAAKrU,KAAKixE,UAAW,GAC/D,CAAE7nE,GAAI,OAAQiL,IAAKrU,KAAKixE,QACjC,CAYA,OAAAhD,CAAQyD,GACN,IAAIr9D,EAEFA,EADEq9D,EAAKr9D,IACDq9D,EAAKr9D,IAELq9D,EAER,KAAI38D,KAAKV,GACTrU,KAAK+M,OAAM,GACX,KAAIgI,KAAK,4BAA6BV,GACtCA,EAAIngB,SAASwc,IAEX,OADA,KAAImqB,KAAK,YAAanqB,EAAK6D,MACnB7D,EAAK6D,MACX,KAAKk4D,EACHzsE,KAAK2xE,SACHjhE,EAAKtH,GAAG/I,OACRqQ,EAAKjc,KACLic,EAAK2D,IACL3D,EAAKs7C,YACLt7C,EAAKvB,KACLuB,EAAKnG,QACLmG,EAAK9C,OACL8C,EAAKnB,YAEP,MACF,KAAKm9D,EACH1sE,KAAKE,YAAYwQ,EAAK07D,OAAQ17D,EAAK27D,OAAQ37D,EAAKs7C,aAChD,MACF,IA9hBY,WA+hBVhsD,KAAK4xE,cAAclhE,EAAKtH,GAAG/I,OAAQqQ,EAAKnG,SACxC,MACF,IAhiBY,QAiiBV,CACE,MAAM6E,EAAMsB,EAAKtH,GAAG/I,OAAOoG,MAAM,KAC3BmH,EAAS8C,EAAKpB,WAAW7I,MAAM,KACrC2I,EAAIlb,SAASkV,IACX,IAAIyoE,EAAa7xE,KAAK8xE,SAAS1oE,GAC/B,QAAmB,IAAfyoE,EAAuB,CACzB,MAAME,EAAY3oE,EAAG/I,OACrBL,KAAK2xE,SAASI,GACdF,EAAa7xE,KAAK8xE,SAASC,EAC7B,CACAF,EAAWjkE,OAASA,EAAOnU,KAAKR,GAAMA,EAAEiO,QAAQ,KAAM,KAAK7G,QAAO,GAEtE,CACA,MACF,IA9iBc,aA+iBZL,KAAKW,YAAY+P,EAAKtH,GAAG/I,OAAQqQ,EAAKpB,YAE1C,IAEF,MAAMo/D,EAAgB1uE,KAAKgyE,YAErB//D,GADS,UACKA,KACpB43C,IACA+kB,OACE,EACA5uE,KAAKkuE,eACLQ,EACA1uE,KAAK3K,MACL2K,KAAK2R,OACL,EACAM,EACAjS,KAAKuK,SAEPvK,KAAK3K,MAAMnB,SAASC,IAClB,GAAIqQ,MAAMyK,QAAQ9a,EAAKmZ,OAAQ,CAE7B,GADAnZ,EAAK63D,YAAc73D,EAAKmZ,MAAM9J,MAAM,GAChCrP,EAAK2d,SAAW3d,EAAK63D,YAAY12D,OAAS,EAC5C,MAAM,IAAIsD,MACR,gFAAkFzE,EAAKiV,GAAK,KAGhGjV,EAAKmZ,MAAQnZ,EAAKmZ,MAAM,EAC1B,IAEJ,CAaA,QAAAqkE,CAASvoE,EAAI3U,EAAOk4E,EAAoBt4D,EAAM,KAAM49D,EAAQ,KAAM9iE,EAAO,KAAM5E,EAAU,KAAMqD,EAAS,KAAM2B,EAAa,MACzH,MAAMwiE,EAAY3oE,GAAI/I,OA8BtB,GA7BKL,KAAKkxE,gBAAgBL,OAAO/8E,IAAIi+E,IAa9B/xE,KAAKkxE,gBAAgBL,OAAOj5E,IAAIm6E,GAAW19D,MAC9CrU,KAAKkxE,gBAAgBL,OAAOj5E,IAAIm6E,GAAW19D,IAAMA,GAE9CrU,KAAKkxE,gBAAgBL,OAAOj5E,IAAIm6E,GAAWt9E,OAC9CuL,KAAKkxE,gBAAgBL,OAAOj5E,IAAIm6E,GAAWt9E,KAAOA,KAhBpD,KAAIsgB,KAAK,gBAAiBg9D,EAAWE,GACrCjyE,KAAKkxE,gBAAgBL,OAAOl5E,IAAIo6E,EAAW,CACzC3oE,GAAI2oE,EACJG,aAAc,GACdz9E,OACA4f,MACAlF,OACA5E,QAAS,GACTqD,OAAQ,GACR2B,WAAY,MAUZ0iE,IACF,KAAIl9D,KAAK,4BAA6Bg9D,EAAWE,GAC5B,iBAAVA,GACTjyE,KAAKmyE,eAAeJ,EAAWE,EAAM5xE,QAElB,iBAAV4xE,GACTA,EAAM/9E,SAASk+E,GAAQpyE,KAAKmyE,eAAeJ,EAAWK,EAAI/xE,WAG1D8O,EAAM,CACR,MAAMkjE,EAAOryE,KAAKkxE,gBAAgBL,OAAOj5E,IAAIm6E,GAC7CM,EAAKljE,KAAOA,EACZkjE,EAAKljE,KAAK7J,KAAO,KAAe8E,aAAaioE,EAAKljE,KAAK7J,MAAM,UAC/D,CACA,GAAIiF,EAAS,CACX,KAAIwK,KAAK,wBAAyBg9D,EAAWxnE,IACN,iBAAZA,EAAuB,CAACA,GAAWA,GAClDrW,SAASk7E,GAAapvE,KAAKW,YAAYoxE,EAAW3C,EAAS/uE,SACzE,CACA,GAAIuN,EAAQ,CACV,KAAImH,KAAK,uBAAwBg9D,EAAWnkE,IACP,iBAAXA,EAAsB,CAACA,GAAUA,GAChD1Z,SAASiX,GAAUnL,KAAKsyE,SAASP,EAAW5mE,EAAM9K,SAC/D,CACA,GAAIkP,EAAY,CACd,KAAIwF,KAAK,uBAAwBg9D,EAAWnkE,IACC,iBAAf2B,EAA0B,CAACA,GAAcA,GACxDrb,SAASq+E,GAAcvyE,KAAKwyE,aAAaT,EAAWQ,EAAUlyE,SAC/E,CACF,CACA,KAAA0M,CAAM0lE,GACJzyE,KAAK3K,MAAQ,GACb2K,KAAK2R,MAAQ,GACb3R,KAAK8wE,UAAY,CACf3vD,KAAMyvD,KAER5wE,KAAKkxE,gBAAkBlxE,KAAK8wE,UAAU3vD,KACtCnhB,KAAKmxE,cAAgB,EACrBnxE,KAAKuK,QAAUomE,IACV8B,IACH,SAEJ,CACA,QAAAX,CAAS1oE,GACP,OAAOpJ,KAAKkxE,gBAAgBL,OAAOj5E,IAAIwR,EACzC,CACA,SAAA4oE,GACE,OAAOhyE,KAAKkxE,gBAAgBL,MAC9B,CACA,YAAA6B,GACE,KAAI39D,KAAK,eAAgB/U,KAAK8wE,UAChC,CACA,YAAA1iE,GACE,OAAOpO,KAAKkxE,gBAAgB5mE,SAC9B,CAUA,eAAAqoE,CAAgBvpE,EAAK,IACnB,IAAIwpE,EAAUxpE,EAKd,OAJIA,IAAOknE,IACTtwE,KAAKmxE,gBACLyB,EAAU,GAAGrC,IAAavwE,KAAKmxE,iBAE1ByB,CACT,CAUA,iBAAAC,CAAkBzpE,EAAK,GAAI3U,EAAOk4E,GAChC,OAAOvjE,IAAOknE,EAAaC,EAAa97E,CAC1C,CAUA,aAAAq+E,CAAc1pE,EAAK,IACjB,IAAIwpE,EAAUxpE,EAKd,OAJIA,IAAOonE,IACTxwE,KAAKmxE,gBACLyB,EAAU,MAAc5yE,KAAKmxE,iBAExByB,CACT,CAUA,eAAAG,CAAgB3pE,EAAK,GAAI3U,EAAOk4E,GAC9B,OAAOvjE,IAAOonE,EAlYH,MAkYyB/7E,CACtC,CAOA,eAAAu+E,CAAgBC,EAAOC,EAAOC,GAC5B,IAAI/xE,EAAMpB,KAAK2yE,gBAAgBM,EAAM7pE,GAAG/I,QACpCoB,EAAQzB,KAAK6yE,kBAAkBI,EAAM7pE,GAAG/I,OAAQ4yE,EAAMx+E,MACtD4M,EAAMrB,KAAK2yE,gBAAgBO,EAAM9pE,GAAG/I,QACpCqB,EAAQ1B,KAAK6yE,kBAAkBK,EAAM9pE,GAAG/I,OAAQ6yE,EAAMz+E,MAC1DuL,KAAK2xE,SACHvwE,EACAK,EACAwxE,EAAM5+D,IACN4+D,EAAMjnB,YACNinB,EAAM9jE,KACN8jE,EAAM1oE,QACN0oE,EAAMrlE,OACNqlE,EAAM1jE,YAERvP,KAAK2xE,SACHtwE,EACAK,EACAwxE,EAAM7+D,IACN6+D,EAAMlnB,YACNknB,EAAM/jE,KACN+jE,EAAM3oE,QACN2oE,EAAMtlE,OACNslE,EAAM3jE,YAERvP,KAAKkxE,gBAAgB5mE,UAAU1T,KAAK,CAClCwK,MACAC,MACA8xE,cAAe,KAAe/oE,aAAa+oE,GAAe,YAE9D,CAQA,WAAAjzE,CAAY+yE,EAAOC,EAAO/yE,GACxB,GAAqB,iBAAV8yE,EACTjzE,KAAKgzE,gBAAgBC,EAAOC,EAAO/yE,OAC9B,CACL,MAAMiB,EAAMpB,KAAK2yE,gBAAgBM,EAAM5yE,QACjCoB,EAAQzB,KAAK6yE,kBAAkBI,GAC/B5xE,EAAMrB,KAAK8yE,cAAcI,EAAM7yE,QAC/BqB,EAAQ1B,KAAK+yE,gBAAgBG,GACnClzE,KAAK2xE,SAASvwE,EAAKK,GACnBzB,KAAK2xE,SAAStwE,EAAKK,GACnB1B,KAAKkxE,gBAAgB5mE,UAAU1T,KAAK,CAClCwK,MACAC,MACAlB,MAAO,KAAeiK,aAAajK,GAAO,YAE9C,CACF,CACA,cAAAgyE,CAAe/oE,EAAI6oE,GACjB,MAAMmB,EAAWpzE,KAAKkxE,gBAAgBL,OAAOj5E,IAAIwR,GAC3CiqE,EAASpB,EAAMpoE,WAAW,KAAOooE,EAAM/qE,QAAQ,IAAK,IAAI7G,OAAS4xE,EACvEmB,EAASlB,aAAat7E,KAAK,KAAewT,aAAaipE,GAAQ,WACjE,CACA,YAAAjzE,CAAakN,GACX,MAA8B,MAA1BA,EAAMxS,UAAU,EAAG,GACdwS,EAAM5G,OAAO,GAAGrG,OAEhBiN,EAAMjN,MAEjB,CACA,YAAAksE,GAEE,OADAvsE,KAAKoxE,aACE,cAAgBpxE,KAAKoxE,UAC9B,CAQA,aAAAQ,CAAcxoE,EAAIkqE,EAAkB,IAC7BtzE,KAAKuK,QAAQzW,IAAIsV,IACpBpJ,KAAKuK,QAAQ5S,IAAIyR,EAAI,CAAEA,KAAIwE,OAAQ,GAAI2B,WAAY,KAErD,MAAMgkE,EAAavzE,KAAKuK,QAAQ3S,IAAIwR,GAChCkqE,SACFA,EAAgB7sE,MA1dD,KA0duBvS,SAASs/E,IAC7C,MAAMC,EAAcD,EAAOtsE,QAAQ,WAAY,MAAM7G,OACrD,GAAI1G,OAAO82E,GAAehnE,KAAK+pE,GAAS,CACtC,MACME,EADYD,EAAYvsE,QAAQwpE,EA9dlC,UA+dwBxpE,QAAQupE,EAAeC,GACnD6C,EAAWhkE,WAAW3Y,KAAK88E,EAC7B,CACAH,EAAW3lE,OAAOhX,KAAK68E,EAAY,GAGzC,CAKA,UAAAtlE,GACE,OAAOnO,KAAKuK,OACd,CASA,WAAA5J,CAAYgzE,EAASC,GACnBD,EAAQltE,MAAM,KAAKvS,SAASkV,IAC1B,IAAIyoE,EAAa7xE,KAAK8xE,SAAS1oE,GAC/B,QAAmB,IAAfyoE,EAAuB,CACzB,MAAME,EAAY3oE,EAAG/I,OACrBL,KAAK2xE,SAASI,GACdF,EAAa7xE,KAAK8xE,SAASC,EAC7B,CACAF,EAAWtnE,QAAQ3T,KAAKg9E,EAAa,GAEzC,CAWA,QAAAtB,CAAShE,EAAQuF,GACf,MAAMnjE,EAAO1Q,KAAK8xE,SAASxD,QACd,IAAT59D,GACFA,EAAK9C,OAAOhX,KAAKi9E,EAErB,CAOA,YAAArB,CAAalE,EAAQsF,GACnB,MAAMljE,EAAO1Q,KAAK8xE,SAASxD,QACd,IAAT59D,GACFA,EAAKnB,WAAW3Y,KAAKg9E,EAEzB,CAMA,qBAAAE,GACE,OAAO9zE,KAAKixE,QAAQ99E,MAAMkhB,GAt4BT,QAs4BiBA,EAAIE,MACxC,CACA,YAAAvD,GACE,OAAOhR,KAAK8zE,yBAAyBnhF,OA34BT,IA44B9B,CACA,YAAA6O,CAAayP,GACX,MAAMoD,EAAMrU,KAAK8zE,wBACbz/D,EACFA,EAAI1hB,MAAQse,EAEZjR,KAAKixE,QAAQvwE,QAAQ,CAAE6T,KAh5BR,MAg5B8B5hB,MAAOse,GAExD,CACA,SAAAk7D,CAAUxpE,GACR,OAAOA,GAAkB,MAAXA,EAAI,GAAaA,EAAI+D,OAAO,GAAGrG,OAASsC,EAAItC,MAC5D,CACA,OAAAqR,GACE,MAAM5B,GAAS,UACf,MAAO,CACLza,MAAO2K,KAAK3K,MACZsc,MAAO3R,KAAK2R,MACZ+B,MAAO,CAAC,EACR5D,SACAvD,UAAW2H,EAAOlU,KAAKkuE,gBAE3B,CACA,SAAAthE,GACE,OAAO,UAAY/H,KACrB,CACA2H,YAAc,KACdlM,YAAc,KACdmM,kBAAoB,KACpBlM,kBAAoB,KACpBmM,gBAAkB,KAClBC,gBAAkB,MA2NhBgH,IAvN4B,SAAQzY,GAAY,6CAExCA,EAAQ64E,iCACN74E,EAAQ64E,uDAGZ74E,EAAQ0Y,qFAKR1Y,EAAQ+Y,sHAOR/Y,EAAQ84E,uDAIR94E,EAAQ6Y,uBACN7Y,EAAQ0Y,oDAIR1Y,EAAQ8Y,iEAKR9Y,EAAQ64E,8FAMV74E,EAAQ+4E,8IAUN/4E,EAAQsX,6BACVtX,EAAQqX,wCAGNrX,EAAQg5E,uIASVh5E,EAAQ6Y,qEAKR7Y,EAAQi5E,gFAIIj5E,EAAQk5E,sDAENl5E,EAAQk5E,iFAIRl5E,EAAQk5E,mCACpBl5E,EAAQk5E,0FAKVl5E,EAAQm5E,sBAAwBn5E,EAAQo5E,4DAGvCp5E,EAAQm5E,sBAAwBn5E,EAAQo5E,wDAIzCp5E,EAAQ84E,wGAMR94E,EAAQq5E,iCACNr5E,EAAQq5E,wDAIVr5E,EAAQq5E,iCACNr5E,EAAQq5E,8DAIVr5E,EAAQs5E,kCACNt5E,EAAQ+4E,oEAIV/4E,EAAQu5E,qBAAuBv5E,EAAQ+4E,6BAClC/4E,EAAQ+4E,gEAKb/4E,EAAQw5E,UAAYx5E,EAAQ6Y,uBAC1B7Y,EAAQy5E,aAAez5E,EAAQ0Y,kEAIjC1Y,EAAQ6Y,uBACN7Y,EAAQy5E,aAAez5E,EAAQ0Y,2EAIjC1Y,EAAQ8Y,0DAIR9Y,EAAQ05E,wCACN15E,EAAQy5E,aAAez5E,EAAQ0Y,kFAKhC1Y,EAAQ84E,yJASP94E,EAAQy5E,aAAez5E,EAAQ0Y,iJAQjC1Y,EAAQu5E,qBAAuBv5E,EAAQ+4E,oFAGvC/4E,EAAQ25E,cAAgB35E,EAAQ25E,cAAgB,gNAchD35E,EAAQ25E,cAAgB35E,EAAQ25E,cAAgB,kGAQhD35E,EAAQqX,4BACNrX,EAAQsX,qGAMVtX,EAAQqX,4BACNrX,EAAQsX,uGAOVtX,EAAQg5E,kEAIPh5E,EAAQg5E,mEAGAh5E,EAAQg5E,oEAIjBh5E,EAAQ8Y,yBACN9Y,EAAQ8Y,sHAOV9Y,EAAQ+Y,mBAEf,Y,oyBC7/DI,MASM6gE,EAAe,eAIrB,MAAMC,EAAe,eAIrB,MAAMC,EAAY,YAUlB,MAAMC,EAAiB,iBAIvB,MAAMC,EAAe,eAIrB,MAAMC,EAAkB,kBACxB,SAASC,EAAkB1kE,GAC9B,OAAO2kE,GAAWC,WAAW5kE,EAAMykE,EACvC,CACO,MAAMI,EAAe,eAIrB,MAAMC,EAAY,YAIlB,MAAMC,EAAiB,iBACvB,SAASC,EAAiBhlE,GAC7B,OAAO2kE,GAAWC,WAAW5kE,EAAM+kE,EACvC,CACO,MAAME,EAAc,cACpB,SAASC,EAAcllE,GAC1B,OAAO2kE,GAAWC,WAAW5kE,EAAMilE,EACvC,CACO,MAAME,EAAc,cACpB,SAASC,EAAcplE,GAC1B,OAAO2kE,GAAWC,WAAW5kE,EAAMmlE,EACvC,CACO,MAAME,EAAU,UAIhB,MAAMC,EAAgB,gBAItB,MAAMC,EAAe,eACrB,SAASC,EAAexlE,GAC3B,OAAO2kE,GAAWC,WAAW5kE,EAAMulE,EACvC,CACO,MAAME,EAAY,YAClB,SAASC,EAAY1lE,GACxB,OAAO2kE,GAAWC,WAAW5kE,EAAMylE,EACvC,CACO,MAAME,EAAgB,gBAItB,MAAMC,EAAW,WACjB,SAASC,EAAW7lE,GACvB,OAAO2kE,GAAWC,WAAW5kE,EAAM4lE,EACvC,CACO,MAAME,EAAgB,gBAItB,MAAMC,EAAY,YAIlB,MAAMC,EAAqB,qBAC3B,SAASC,EAAqBjmE,GACjC,OAAO2kE,GAAWC,WAAW5kE,EAAMgmE,EACvC,CACO,MAAME,EAAa,aACnB,SAASC,EAAanmE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAMkmE,EACvC,CACO,MAAME,EAAgB,gBAItB,MAAMC,EAAa,aACnB,SAASC,EAAatmE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAMqmE,EACvC,CACO,MAAME,EAAa,aACnB,SAASC,EAAaxmE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAMumE,EACvC,CACO,MAAME,EAAgB,gBAItB,MAAMC,EAAe,eACrB,SAASC,EAAe3mE,GAC3B,OAAO2kE,GAAWC,WAAW5kE,EAAM0mE,EACvC,CACO,MAAME,EAAO,OACb,SAASC,EAAO7mE,GACnB,OAAO2kE,GAAWC,WAAW5kE,EAAM4mE,EACvC,CACO,MAAME,EAAgB,gBAItB,MAAMC,EAAY,YAIlB,MAAMC,EAAS,SACf,SAASC,EAASjnE,GACrB,OAAO2kE,GAAWC,WAAW5kE,EAAMgnE,EACvC,CACO,MAAME,EAAe,eACrB,SAASC,EAAennE,GAC3B,OAAO2kE,GAAWC,WAAW5kE,EAAMknE,EACvC,CACO,MAAME,EAAa,aACnB,SAASC,EAAarnE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAMonE,EACvC,CACO,MAAME,EAAiB,iBACvB,SAASC,EAAiBvnE,GAC7B,OAAO2kE,GAAWC,WAAW5kE,EAAMsnE,EACvC,CACO,MAAME,GAAiB,iBACvB,SAASC,GAAiBznE,GAC7B,OAAO2kE,GAAWC,WAAW5kE,EAAMwnE,GACvC,CACO,MAAME,GAAY,YAClB,SAASC,GAAY3nE,GACxB,OAAO2kE,GAAWC,WAAW5kE,EAAM0nE,GACvC,CACO,MAAME,GAAQ,QACd,SAASxmE,GAAQpB,GACpB,OAAO2kE,GAAWC,WAAW5kE,EAAM4nE,GACvC,CACO,MAAMC,GAAU,UAChB,SAASC,GAAU9nE,GACtB,OAAO2kE,GAAWC,WAAW5kE,EAAM6nE,GACvC,CACO,MAAME,GAAe,eACrB,SAASC,GAAehoE,GAC3B,OAAO2kE,GAAWC,WAAW5kE,EAAM+nE,GACvC,CACO,MAAME,GAAa,aACnB,SAASC,GAAaloE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAMioE,GACvC,CACO,MAAME,GAAW,WACjB,SAASC,GAAWpoE,GACvB,OAAO2kE,GAAWC,WAAW5kE,EAAMmoE,GACvC,CACO,MAAME,GAAuB,uBAC7B,SAASC,GAAuBtoE,GACnC,OAAO2kE,GAAWC,WAAW5kE,EAAMqoE,GACvC,CACO,MAAME,GAAgB,gBACtB,SAASC,GAAgBxoE,GAC5B,OAAO2kE,GAAWC,WAAW5kE,EAAMuoE,GACvC,CACO,MAAME,GAAmB,mBACzB,SAASC,GAAmB1oE,GAC/B,OAAO2kE,GAAWC,WAAW5kE,EAAMyoE,GACvC,CACO,MAAME,GAAiB,iBACvB,SAASC,GAAiB5oE,GAC7B,OAAO2kE,GAAWC,WAAW5kE,EAAM2oE,GACvC,CACO,MAAME,GAAa,aACnB,SAASC,GAAa9oE,GACzB,OAAO2kE,GAAWC,WAAW5kE,EAAM6oE,GACvC,CACO,MAAME,GAAW,WACjB,SAASC,GAAWhpE,GACvB,OAAO2kE,GAAWC,WAAW5kE,EAAM+oE,GACvC,CACO,MAAME,WAAoC,KAC7C,WAAAC,GACI,MAAO,CAACzE,EAAiBL,EAAcC,EAAc2C,EAAQE,EAAcrC,EAAcC,EAAWsC,EAAYrC,EAAgBuC,EAAgBhD,EAAWW,EAAauC,GAAgBrC,EAAauC,GAAWrC,EAASC,EAAesC,GAAOrC,EAAcE,EAAWoC,GAASlC,EAAeoC,GAAcnC,EAAUE,EAAeC,EAAWC,EAAoBE,EAAYE,EAAe6B,GAAY5B,EAAY8B,GAAU5B,EAAYE,EAAe4B,GAAsBE,GAAe7B,EAAc+B,GAAkB7B,EAAME,EAAevC,EAAgBwC,EAAW4B,GAAgBE,GAAYrE,EAAcuE,GACjmB,CACA,gBAAAI,CAAiBC,EAASC,GACtB,OAAQD,GACJ,KAAKpC,EACL,KAAKE,EACL,KAAKE,EACL,KAAKE,EACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKC,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACL,KAAKE,GACD,OAAOz5E,KAAKg6E,UAAU7E,EAAiB4E,GAE3C,KAAKxE,EACL,KAAKiB,EACL,KAAKW,EACD,OAAOn3E,KAAKg6E,UAAU9E,EAAc6E,GAExC,KAAKvE,EACL,KAAKsB,EACL,KAAKG,EACL,KAAKQ,EACD,OAAOz3E,KAAKg6E,UAAU/E,EAAgB8E,GAE1C,KAAKtE,EACD,OAAOz1E,KAAKg6E,UAAUhF,EAAW+E,IAAc/5E,KAAKg6E,UAAU9E,EAAc6E,GAEhF,KAAKpE,EACL,KAAKE,EACL,KAAKS,EACL,KAAKI,EACD,OAAO12E,KAAKg6E,UAAUhF,EAAW+E,GAErC,KAAK9D,EACL,KAAKE,EACL,KAAKmB,EACD,OAAOt3E,KAAKg6E,UAAUjF,EAAcgF,GAExC,KAAKnD,EACD,OAAO52E,KAAKg6E,UAAUlF,EAAciF,IAAc/5E,KAAKg6E,UAAUjF,EAAcgF,GAEnF,KAAK3C,EACD,OAAOp3E,KAAKg6E,UAAUlF,EAAciF,GAExC,QACI,OAAO,EAGnB,CACA,gBAAAE,CAAiBC,GACb,MAAMC,EAAc,GAAGD,EAAQjjF,UAAUgE,SAASi/E,EAAQllF,WAC1D,OAAQmlF,GACJ,IAAK,cACL,IAAK,sBACL,IAAK,uBACL,IAAK,wBACL,IAAK,qBACD,OAAOpF,EAEX,IAAK,uBACL,IAAK,0BACL,IAAK,gBACD,OAAOD,EAEX,IAAK,uBACD,OAAOiB,EAEX,IAAK,0BACL,IAAK,+BACD,OAAOU,EAEX,IAAK,wBACD,OAAOW,EAEX,QACI,MAAM,IAAIx+E,MAAM,GAAGuhF,kCAG/B,CACA,eAAAC,CAAgB3lF,GACZ,OAAQA,GACJ,KAAK0gF,EACD,MAAO,CACHphF,KAAMohF,EACNkF,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,eAIpB,KAAKwhF,EACD,MAAO,CACHxhF,KAAMwhF,EACN8E,WAAY,CACR,CAAEtmF,KAAM,WAAYumF,aAAc,MAI9C,KAAK9E,EACD,MAAO,CACHzhF,KAAMyhF,EACN6E,WAAY,CACR,CAAEtmF,KAAM,iBAIpB,KAAK0hF,EACD,MAAO,CACH1hF,KAAM0hF,EACN4E,WAAY,CACR,CAAEtmF,KAAM,OAAQumF,cAAc,KAI1C,KAAK3E,EACD,MAAO,CACH5hF,KAAM4hF,EACN0E,WAAY,CACR,CAAEtmF,KAAM,QACR,CAAEA,KAAM,WAIpB,KAAK8hF,EACD,MAAO,CACH9hF,KAAM8hF,EACNwE,WAAY,CACR,CAAEtmF,KAAM,QACR,CAAEA,KAAM,WAIpB,KAAKgiF,EACD,MAAO,CACHhiF,KAAMgiF,EACNsE,WAAY,CACR,CAAEtmF,KAAM,sBAAuBumF,cAAc,GAC7C,CAAEvmF,KAAM,eAAgBumF,aAAc,IACtC,CAAEvmF,KAAM,UAAWumF,aAAc,IACjC,CAAEvmF,KAAM,aAAcumF,aAAc,IACpC,CAAEvmF,KAAM,aAAcumF,cAAc,GACpC,CAAEvmF,KAAM,QACR,CAAEA,KAAM,QAASumF,aAAc,IAC/B,CAAEvmF,KAAM,QAASumF,aAAc,IAC/B,CAAEvmF,KAAM,eAAgBumF,aAAc,MAIlD,KAAKtE,EACD,MAAO,CACHjiF,KAAMiiF,EACNqE,WAAY,CACR,CAAEtmF,KAAM,UAIpB,KAAKkiF,EACD,MAAO,CACHliF,KAAMkiF,EACNoE,WAAY,CACR,CAAEtmF,KAAM,UAIpB,KAAKoiF,EACD,MAAO,CACHpiF,KAAMoiF,EACNkE,WAAY,CACR,CAAEtmF,KAAM,aAAcumF,aAAc,IACpC,CAAEvmF,KAAM,QACR,CAAEA,KAAM,aAAcumF,aAAc,MAIhD,KAAKjE,EACD,MAAO,CACHtiF,KAAMsiF,EACNgE,WAAY,CACR,CAAEtmF,KAAM,eAAgBumF,cAAc,GACtC,CAAEvmF,KAAM,aACR,CAAEA,KAAM,WAIpB,KAAKuiF,EACD,MAAO,CACHviF,KAAMuiF,EACN+D,WAAY,CACR,CAAEtmF,KAAM,WAIpB,KAAKyiF,EACD,MAAO,CACHziF,KAAMyiF,EACN6D,WAAY,CACR,CAAEtmF,KAAM,WAIpB,KAAK0iF,EACD,MAAO,CACH1iF,KAAM0iF,EACN4D,WAAY,CACR,CAAEtmF,KAAM,UAIpB,KAAK2iF,EACD,MAAO,CACH3iF,KAAM2iF,EACN2D,WAAY,CACR,CAAEtmF,KAAM,eAIpB,KAAK6iF,EACD,MAAO,CACH7iF,KAAM6iF,EACNyD,WAAY,CACR,CAAEtmF,KAAM,YACR,CAAEA,KAAM,sBAAuBumF,cAAc,GAC7C,CAAEvmF,KAAM,cACR,CAAEA,KAAM,QAASumF,cAAc,GAC/B,CAAEvmF,KAAM,WAAYumF,cAAc,GAClC,CAAEvmF,KAAM,eAAgBumF,aAAc,IACtC,CAAEvmF,KAAM,gBACR,CAAEA,KAAM,QACR,CAAEA,KAAM,aAAcumF,aAAc,IACpC,CAAEvmF,KAAM,cACR,CAAEA,KAAM,WAAYumF,cAAc,KAI9C,KAAKxD,EACD,MAAO,CACH/iF,KAAM+iF,EACNuD,WAAY,CACR,CAAEtmF,KAAM,mBAIpB,KAAKgjF,EACD,MAAO,CACHhjF,KAAMgjF,EACNsD,WAAY,CACR,CAAEtmF,KAAM,UAIpB,KAAKkjF,EACD,MAAO,CACHljF,KAAMkjF,EACNoD,WAAY,CACR,CAAEtmF,KAAM,iBACR,CAAEA,KAAM,cACR,CAAEA,KAAM,aAIpB,KAAKojF,EACD,MAAO,CACHpjF,KAAMojF,EACNkD,WAAY,CACR,CAAEtmF,KAAM,WAIpB,KAAKqjF,EACD,MAAO,CACHrjF,KAAMqjF,EACNiD,WAAY,CACR,CAAEtmF,KAAM,cACR,CAAEA,KAAM,WAAYumF,cAAc,GAClC,CAAEvmF,KAAM,SAAUumF,cAAc,GAChC,CAAEvmF,KAAM,QACR,CAAEA,KAAM,UAIpB,KAAKujF,EACD,MAAO,CACHvjF,KAAMujF,EACN+C,WAAY,CACR,CAAEtmF,KAAM,QACR,CAAEA,KAAM,UAIpB,KAAKyjF,EACD,MAAO,CACHzjF,KAAMyjF,EACN6C,WAAY,CACR,CAAEtmF,KAAM,gBACR,CAAEA,KAAM,aAAcumF,cAAc,GACpC,CAAEvmF,KAAM,QACR,CAAEA,KAAM,UAIpB,KAAK0jF,EACD,MAAO,CACH1jF,KAAM0jF,EACN4C,WAAY,CACR,CAAEtmF,KAAM,QAASumF,aAAc,MAI3C,KAAK5C,EACD,MAAO,CACH3jF,KAAM2jF,EACN2C,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WACR,CAAEA,KAAM,gBACR,CAAEA,KAAM,aACR,CAAEA,KAAM,YACR,CAAEA,KAAM,UAIpB,KAAK6jF,EACD,MAAO,CACH7jF,KAAM6jF,EACNyC,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,eAIpB,KAAK+jF,EACD,MAAO,CACH/jF,KAAM+jF,EACNuC,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WACR,CAAEA,KAAM,aACR,CAAEA,KAAM,YACR,CAAEA,KAAM,cAIpB,KAAKikF,EACD,MAAO,CACHjkF,KAAMikF,EACNqC,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,QACR,CAAEA,KAAM,aACR,CAAEA,KAAM,WAIpB,KAAKmkF,GACD,MAAO,CACHnkF,KAAMmkF,GACNmC,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,mBAAoBumF,cAAc,GAC1C,CAAEvmF,KAAM,aACR,CAAEA,KAAM,YACR,CAAEA,KAAM,UAIpB,KAAKqkF,GACD,MAAO,CACHrkF,KAAMqkF,GACNiC,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,eAIpB,KAAKukF,GACD,MAAO,CACHvkF,KAAMukF,GACN+B,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,kBACR,CAAEA,KAAM,eAIpB,KAAKwkF,GACD,MAAO,CACHxkF,KAAMwkF,GACN8B,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,WAIpB,KAAK0kF,GACD,MAAO,CACH1kF,KAAM0kF,GACN4B,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,cAIpB,KAAK4kF,GACD,MAAO,CACH5kF,KAAM4kF,GACN0B,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,WAIpB,KAAK8kF,GACD,MAAO,CACH9kF,KAAM8kF,GACNwB,WAAY,CACR,CAAEtmF,KAAM,YAAaumF,aAAc,IACnC,CAAEvmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,UAIpB,KAAKglF,GACD,MAAO,CACHhlF,KAAMglF,GACNsB,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,eAIpB,KAAKklF,GACD,MAAO,CACHllF,KAAMklF,GACNoB,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,eAIpB,KAAKolF,GACD,MAAO,CACHplF,KAAMolF,GACNkB,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,UAIpB,KAAKslF,GACD,MAAO,CACHtlF,KAAMslF,GACNgB,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,eAIpB,KAAKwlF,GACD,MAAO,CACHxlF,KAAMwlF,GACNc,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,aACR,CAAEA,KAAM,cAIpB,KAAK0lF,GACD,MAAO,CACH1lF,KAAM0lF,GACNY,WAAY,CACR,CAAEtmF,KAAM,eACR,CAAEA,KAAM,eAIpB,QACI,MAAO,CACHA,KAAMU,EACN4lF,WAAY,IAI5B,EAEG,MAAMhF,GAAa,IAAIsE,E,uBClsBvB,SAASY,EAAU/nD,GACtB,MAAsB,iBAARA,GAA4B,OAARA,GAAqC,iBAAdA,EAAIv3B,KACjE,CACO,SAASu/E,EAAYhoD,GACxB,MAAsB,iBAARA,GAA4B,OAARA,GAAwC,iBAAjBA,EAAIioD,QACjE,CACO,SAASC,EAAqBloD,GACjC,MAAsB,iBAARA,GAA4B,OAARA,GACP,iBAAbA,EAAIz+B,MACS,iBAAby+B,EAAI/9B,MACS,iBAAb+9B,EAAItY,IACtB,CACO,SAASygE,EAAenoD,GAC3B,MAAsB,iBAARA,GAA4B,OAARA,GAC3B+nD,EAAU/nD,EAAIv7B,YACdujF,EAAYhoD,EAAIooD,YACO,iBAAhBpoD,EAAImJ,OACtB,C,yMAKO,MAAMk/C,EACT,WAAAjyE,GACI5I,KAAK86E,SAAW,CAAC,EACjB96E,KAAK+6E,YAAc,CAAC,CACxB,CACA,UAAAzF,CAAWnhF,EAAMM,GACb,OAAO8lF,EAAUpmF,IAAS6L,KAAKg6E,UAAU7lF,EAAK8G,MAAOxG,EACzD,CACA,SAAAulF,CAAUF,EAASC,GACf,GAAID,IAAYC,EACZ,OAAO,EAEX,IAAIiB,EAASh7E,KAAK86E,SAAShB,GACtBkB,IACDA,EAASh7E,KAAK86E,SAAShB,GAAW,CAAC,GAEvC,MAAMmB,EAAWD,EAAOjB,GACxB,QAAiBxkF,IAAb0lF,EACA,OAAOA,EAEN,CACD,MAAM1kF,EAASyJ,KAAK65E,iBAAiBC,EAASC,GAE9C,OADAiB,EAAOjB,GAAaxjF,EACbA,CACX,CACJ,CACA,cAAA2kF,CAAezmF,GACX,MAAMwmF,EAAWj7E,KAAK+6E,YAAYtmF,GAClC,GAAIwmF,EACA,OAAOA,EAEN,CACD,MAAME,EAAWn7E,KAAK45E,cAChBwB,EAAQ,GACd,IAAK,MAAMC,KAAmBF,EACtBn7E,KAAKg6E,UAAUqB,EAAiB5mF,IAChC2mF,EAAMxkF,KAAKykF,GAInB,OADAr7E,KAAK+6E,YAAYtmF,GAAQ2mF,EAClBA,CACX,CACJ,EAEG,SAASE,EAAmBnnF,GAC/B,MAAuB,iBAATA,GAA8B,OAATA,GAAiBqQ,MAAMyK,QAAQ9a,EAAK6B,QAC3E,CACO,SAASulF,EAAcpnF,GAC1B,MAAuB,iBAATA,GAA8B,OAATA,GAA2C,iBAAnBA,EAAK8tC,SACpE,CACO,SAASu5C,EAAcrnF,GAC1B,OAAOmnF,EAAmBnnF,IAAkC,iBAAlBA,EAAKo2C,QACnD,C,qCChDA,IAnBA,SAAsBl0B,EAAOH,EAAUgkB,GAIrC,IAHA,IAAI9kC,GAAS,EACTE,EAAS+gB,EAAM/gB,SAEVF,EAAQE,GAAQ,CACvB,IAAI3C,EAAQ0jB,EAAMjhB,GACdqmF,EAAUvlE,EAASvjB,GAEvB,GAAe,MAAX8oF,SAAiClmF,IAAb+kC,EACfmhD,GAAYA,KAAY,OAASA,GAClCvhD,EAAWuhD,EAASnhD,IAE1B,IAAIA,EAAWmhD,EACXllF,EAAS5D,CAEjB,CACA,OAAO4D,CACT,C,+CCRA,IAVA,SAAiBsf,EAAYK,GAC3B,IAAI9gB,GAAS,EACTmB,GAAS,OAAYsf,GAAcrR,MAAMqR,EAAWvgB,QAAU,GAKlE,OAHA,OAASugB,GAAY,SAASljB,EAAOwjB,EAAKN,GACxCtf,IAASnB,GAAS8gB,EAASvjB,EAAOwjB,EAAKN,EACzC,IACOtf,CACT,C,uBCnBO,SAAS6uB,EAAG8X,GACf,OAAOA,EAAKK,WAAW,EAC3B,CACO,SAASm+C,EAAYhrE,EAAM/Y,GAC1B6M,MAAMyK,QAAQyB,GACdA,EAAKxc,SAAQ,SAAUynF,GACnBhkF,EAAIf,KAAK+kF,EACb,IAGAhkF,EAAIf,KAAK8Z,EAEjB,CACO,SAASkrE,EAAQC,EAASC,GAC7B,IAAyB,IAArBD,EAAQC,GACR,KAAM,kBAAoBA,EAEpBD,EAAQC,GAClBD,EAAQC,IAAW,CACvB,CACO,SAASC,EAAcvpD,GAE1B,QAAYj9B,IAARi9B,EACA,MAAM55B,MAAM,2CAEhB,OAAO,CACX,CAEO,SAASojF,IACZ,MAAMpjF,MAAM,0CAChB,CACO,SAASqjF,EAAYzpD,GACxB,MAAuB,cAAhBA,EAAU,IACrB,C,uDChCO,MAAM0pD,EAAkB,GAC/B,IAAK,IAAIhjF,EAAIksB,EAAG,KAAMlsB,GAAKksB,EAAG,KAAMlsB,IAChCgjF,EAAgBtlF,KAAKsC,GAElB,MAAMijF,EAAgB,CAAC/2D,EAAG,MAAM5xB,OAAO0oF,GAC9C,IAAK,IAAIhjF,EAAIksB,EAAG,KAAMlsB,GAAKksB,EAAG,KAAMlsB,IAChCijF,EAAcvlF,KAAKsC,GAEvB,IAAK,IAAIA,EAAIksB,EAAG,KAAMlsB,GAAKksB,EAAG,KAAMlsB,IAChCijF,EAAcvlF,KAAKsC,GAGhB,MAAMkjF,EAAkB,CAC3Bh3D,EAAG,KACHA,EAAG,MACHA,EAAG,MACHA,EAAG,MACHA,EAAG,MACHA,EAAG,MACHA,EAAG,MACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,UACHA,EAAG,UACHA,EAAG,KACHA,EAAG,KACHA,EAAG,KACHA,EAAG,WCpCDi3D,EAAkB,cAClBC,EAAiB,QACjBC,EAAuB,QAGtB,MAAMC,EACT,WAAA5zE,GACI5I,KAAKy0B,IAAM,EACXz0B,KAAKgD,MAAQ,GACbhD,KAAKy8E,SAAW,CACpB,CACA,SAAAC,GACI,MAAO,CACHjoD,IAAKz0B,KAAKy0B,IACVzxB,MAAOhD,KAAKgD,MACZy5E,SAAUz8E,KAAKy8E,SAEvB,CACA,YAAAE,CAAa13E,GACTjF,KAAKy0B,IAAMxvB,EAASwvB,IACpBz0B,KAAKgD,MAAQiC,EAASjC,MACtBhD,KAAKy8E,SAAWx3E,EAASw3E,QAC7B,CACA,OAAAvpE,CAAQlQ,GAEJhD,KAAKy0B,IAAM,EACXz0B,KAAKgD,MAAQA,EACbhD,KAAKy8E,SAAW,EAChBz8E,KAAK48E,YAAY,KACjB,MAAMjqF,EAAQqN,KAAK68E,cACnB78E,KAAK48E,YAAY,KACjB,MAAM5jF,EAAQ,CACVvE,KAAM,QACNgR,IAAK,CAAEoC,MAAO7H,KAAKy0B,IAAK7hB,IAAK5P,EAAM1N,QACnCuvC,QAAQ,EACRnJ,YAAY,EACZohD,WAAW,EACXn6C,SAAS,EACThE,QAAQ,GAEZ,KAAO3+B,KAAK+8E,gBACR,OAAQ/8E,KAAKg9E,WACT,IAAK,IACDpB,EAAQ5iF,EAAO,UACf,MACJ,IAAK,IACD4iF,EAAQ5iF,EAAO,cACf,MACJ,IAAK,IACD4iF,EAAQ5iF,EAAO,aACf,MACJ,IAAK,IACD4iF,EAAQ5iF,EAAO,WACf,MACJ,IAAK,IACD4iF,EAAQ5iF,EAAO,UAI3B,GAAIgH,KAAKy0B,MAAQz0B,KAAKgD,MAAM1N,OACxB,MAAMsD,MAAM,oBAAsBoH,KAAKgD,MAAMlI,UAAUkF,KAAKy0B,MAEhE,MAAO,CACHhgC,KAAM,UACNuE,MAAOA,EACPrG,MAAOA,EACP8S,IAAKzF,KAAKyF,IAAI,GAEtB,CACA,WAAAo3E,GACI,MAAMlhC,EAAO,GACP9zC,EAAQ7H,KAAKy0B,IAEnB,IADAknB,EAAK/kD,KAAKoJ,KAAKu/C,eACY,MAApBv/C,KAAKi9E,YACRj9E,KAAK48E,YAAY,KACjBjhC,EAAK/kD,KAAKoJ,KAAKu/C,eAEnB,MAAO,CAAE9qD,KAAM,cAAe9B,MAAOgpD,EAAMl2C,IAAKzF,KAAKyF,IAAIoC,GAC7D,CACA,WAAA03C,GACI,MAAM1jB,EAAQ,GACRh0B,EAAQ7H,KAAKy0B,IACnB,KAAOz0B,KAAKk9E,UACRrhD,EAAMjlC,KAAKoJ,KAAK87B,QAEpB,MAAO,CAAErnC,KAAM,cAAe9B,MAAOkpC,EAAOp2B,IAAKzF,KAAKyF,IAAIoC,GAC9D,CACA,IAAAi0B,GACI,OAAI97B,KAAKm9E,cACEn9E,KAAKo9E,YAGLp9E,KAAK+7B,MAEpB,CACA,SAAAqhD,GACI,MAAMv1E,EAAQ7H,KAAKy0B,IACnB,OAAQz0B,KAAKg9E,WACT,IAAK,IACD,MAAO,CACHvoF,KAAM,cACNgR,IAAKzF,KAAKyF,IAAIoC,IAEtB,IAAK,IACD,MAAO,CAAEpT,KAAM,YAAagR,IAAKzF,KAAKyF,IAAIoC,IAE9C,IAAK,KACD,OAAQ7H,KAAKg9E,WACT,IAAK,IACD,MAAO,CACHvoF,KAAM,eACNgR,IAAKzF,KAAKyF,IAAIoC,IAEtB,IAAK,IACD,MAAO,CACHpT,KAAM,kBACNgR,IAAKzF,KAAKyF,IAAIoC,IAI1B,MAAMjP,MAAM,4BAEhB,IAAK,IAED,IAAInE,EACJ,OAFAuL,KAAK48E,YAAY,KAET58E,KAAKg9E,WACT,IAAK,IACDvoF,EAAO,YACP,MACJ,IAAK,IACDA,EAAO,oBAGfsnF,EAActnF,GACd,MAAMooF,EAAc78E,KAAK68E,cAEzB,OADA78E,KAAK48E,YAAY,KACV,CACHnoF,KAAMA,EACN9B,MAAOkqF,EACPp3E,IAAKzF,KAAKyF,IAAIoC,IAI1B,OAAOm0E,GACX,CACA,UAAAl/C,CAAWugD,GAAiB,GACxB,IAAIljF,EACJ,MAAM0N,EAAQ7H,KAAKy0B,IACnB,OAAQz0B,KAAKg9E,WACT,IAAK,IACD7iF,EAAQ,CACJ4iC,QAAS,EACTugD,OAAQtxC,KAEZ,MACJ,IAAK,IACD7xC,EAAQ,CACJ4iC,QAAS,EACTugD,OAAQtxC,KAEZ,MACJ,IAAK,IACD7xC,EAAQ,CACJ4iC,QAAS,EACTugD,OAAQ,GAEZ,MACJ,IAAK,IACD,MAAMvgD,EAAU/8B,KAAKu9E,uBACrB,OAAQv9E,KAAKg9E,WACT,IAAK,IACD7iF,EAAQ,CACJ4iC,QAASA,EACTugD,OAAQvgD,GAEZ,MACJ,IAAK,IACD,IAAIugD,EACAt9E,KAAKw9E,WACLF,EAASt9E,KAAKu9E,uBACdpjF,EAAQ,CACJ4iC,QAASA,EACTugD,OAAQA,IAIZnjF,EAAQ,CACJ4iC,QAASA,EACTugD,OAAQtxC,KAGhBhsC,KAAK48E,YAAY,KAKzB,IAAuB,IAAnBS,QAAqC9nF,IAAV4E,EAC3B,OAEJ4hF,EAAc5hF,GAKtB,IAAuB,IAAnBkjF,QAAqC9nF,IAAV4E,EAI/B,OAAI4hF,EAAc5hF,IACW,MAArB6F,KAAKi9E,SAAS,IACdj9E,KAAK48E,YAAY,KACjBziF,EAAMsjF,QAAS,GAGftjF,EAAMsjF,QAAS,EAEnBtjF,EAAM1F,KAAO,aACb0F,EAAMsL,IAAMzF,KAAKyF,IAAIoC,GACd1N,QAVX,CAYJ,CACA,IAAA4hC,GACI,IAAIA,EACJ,MAAMl0B,EAAQ7H,KAAKy0B,IACnB,OAAQz0B,KAAKi9E,YACT,IAAK,IACDlhD,EAAO/7B,KAAK09E,SACZ,MACJ,IAAK,KACD3hD,EAAO/7B,KAAK29E,aACZ,MACJ,IAAK,IACD5hD,EAAO/7B,KAAK49E,iBACZ,MACJ,IAAK,IACD7hD,EAAO/7B,KAAK9F,QAOpB,YAJa3E,IAATwmC,GAAsB/7B,KAAK69E,uBAC3B9hD,EAAO/7B,KAAK89E,oBAGZ/B,EAAchgD,IACdA,EAAKt2B,IAAMzF,KAAKyF,IAAIoC,GAChB7H,KAAK+9E,iBACLhiD,EAAKe,WAAa98B,KAAK88B,cAEpBf,GAGJigD,GACX,CACA,MAAA0B,GAEI,OADA19E,KAAK48E,YAAY,KACV,CACHnoF,KAAM,MACNwnC,YAAY,EACZtpC,MAAO,CAACyyB,EAAG,MAAOA,EAAG,MAAOA,EAAG,UAAWA,EAAG,WAErD,CACA,UAAAu4D,GAEI,OADA39E,KAAK48E,YAAY,MACT58E,KAAKi9E,YACT,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAOj9E,KAAKg+E,oBAChB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAOh+E,KAAKi+E,uBAChB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAOj+E,KAAKk+E,oBAChB,IAAK,IACD,OAAOl+E,KAAKm+E,0BAChB,IAAK,IACD,OAAOn+E,KAAKo+E,mBAChB,IAAK,IACD,OAAOp+E,KAAKq+E,wBAChB,IAAK,IACD,OAAOr+E,KAAKs+E,kCAChB,QACI,OAAOt+E,KAAKu+E,qBAExB,CACA,iBAAAP,GAEI,MAAO,CAAEvpF,KAAM,qBAAsB9B,MADvBqN,KAAKw+E,kBAEvB,CACA,oBAAAP,GACI,IAAItmF,EACAskC,GAAa,EACjB,OAAQj8B,KAAKg9E,WACT,IAAK,IACDrlF,EAAMukF,EACN,MACJ,IAAK,IACDvkF,EAAMukF,EACNjgD,GAAa,EACb,MACJ,IAAK,IACDtkC,EAAMykF,EACN,MACJ,IAAK,IACDzkF,EAAMykF,EACNngD,GAAa,EACb,MACJ,IAAK,IACDtkC,EAAMwkF,EACN,MACJ,IAAK,IACDxkF,EAAMwkF,EACNlgD,GAAa,EAIrB,OAAI8/C,EAAcpkF,GACP,CAAElD,KAAM,MAAO9B,MAAOgF,EAAKskC,WAAYA,GAG3C+/C,GACX,CACA,iBAAAkC,GACI,IAAIO,EACJ,OAAQz+E,KAAKg9E,WACT,IAAK,IACDyB,EAAar5D,EAAG,MAChB,MACJ,IAAK,IACDq5D,EAAar5D,EAAG,MAChB,MACJ,IAAK,IACDq5D,EAAar5D,EAAG,MAChB,MACJ,IAAK,IACDq5D,EAAar5D,EAAG,MAChB,MACJ,IAAK,IACDq5D,EAAar5D,EAAG,MAIxB,OAAI22D,EAAc0C,GACP,CAAEhqF,KAAM,YAAa9B,MAAO8rF,GAGhCzC,GACX,CACA,uBAAAmC,GACIn+E,KAAK48E,YAAY,KACjB,MAAM8B,EAAS1+E,KAAKg9E,UACpB,IAAgC,IAA5B,WAAW94C,KAAKw6C,GAChB,MAAM9lF,MAAM,YAGhB,MAAO,CAAEnE,KAAM,YAAa9B,MADT+rF,EAAOphD,cAAcC,WAAW,GAAK,GAE5D,CACA,gBAAA6gD,GAII,OADAp+E,KAAK48E,YAAY,KACV,CAAEnoF,KAAM,YAAa9B,MAAOyyB,EAAG,MAC1C,CACA,qBAAAi5D,GAEI,OADAr+E,KAAK48E,YAAY,KACV58E,KAAK2+E,eAAe,EAC/B,CACA,+BAAAL,GAEI,OADAt+E,KAAK48E,YAAY,KACV58E,KAAK2+E,eAAe,EAC/B,CACA,kBAAAJ,GAII,MAAO,CAAE9pF,KAAM,YAAa9B,MAAOyyB,EADfplB,KAAKg9E,WAE7B,CACA,yBAAA4B,GACI,OAAQ5+E,KAAKi9E,YAET,IAAK,KAEL,IAAK,KAEL,IAAK,SAEL,IAAK,SAEL,IAAK,KAEL,IAAK,IACD,MAAMrkF,MAAM,OAChB,QAEI,MAAO,CAAEnE,KAAM,YAAa9B,MAAOyyB,EADlBplB,KAAKg9E,YAGlC,CACA,cAAAY,GACI,MAAMjmF,EAAM,GACZ,IAAIskC,GAAa,EAMjB,IALAj8B,KAAK48E,YAAY,KACQ,MAArB58E,KAAKi9E,SAAS,KACdj9E,KAAK48E,YAAY,KACjB3gD,GAAa,GAEVj8B,KAAK6+E,eAAe,CACvB,MAAMziD,EAAOp8B,KAAK8+E,YACO1iD,EAAK3nC,KAC9B,GAAIwnF,EAAY7/C,IAASp8B,KAAK++E,cAAe,CACzC/+E,KAAK48E,YAAY,KACjB,MAAMvgD,EAAKr8B,KAAK8+E,YACOziD,EAAG5nC,KAE1B,GAAIwnF,EAAY5/C,GAAK,CACjB,GAAIA,EAAG1pC,MAAQypC,EAAKzpC,MAChB,MAAMiG,MAAM,yCAEhBjB,EAAIf,KAAK,CAAEwlC,KAAMA,EAAKzpC,MAAO0pC,GAAIA,EAAG1pC,OACxC,MAGI+oF,EAAYt/C,EAAKzpC,MAAOgF,GACxBA,EAAIf,KAAKwuB,EAAG,MACZs2D,EAAYr/C,EAAG1pC,MAAOgF,EAE9B,MAEI+jF,EAAYt/C,EAAKzpC,MAAOgF,EAEhC,CAEA,OADAqI,KAAK48E,YAAY,KACV,CAAEnoF,KAAM,MAAOwnC,WAAYA,EAAYtpC,MAAOgF,EACzD,CACA,SAAAmnF,GACI,OAAQ9+E,KAAKi9E,YAET,IAAK,IAEL,IAAK,KAEL,IAAK,KAEL,IAAK,SAEL,IAAK,SACD,MAAMrkF,MAAM,OAChB,IAAK,KACD,OAAOoH,KAAKg/E,cAChB,QACI,OAAOh/E,KAAK4+E,4BAExB,CACA,WAAAI,GAEI,OADAh/E,KAAK48E,YAAY,MACT58E,KAAKi9E,YAGT,IAAK,IAED,OADAj9E,KAAK48E,YAAY,KACV,CAAEnoF,KAAM,YAAa9B,MAAOyyB,EAAG,OAC1C,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAOplB,KAAKi+E,uBAChB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAOj+E,KAAKk+E,oBAChB,IAAK,IACD,OAAOl+E,KAAKm+E,0BAChB,IAAK,IACD,OAAOn+E,KAAKo+E,mBAChB,IAAK,IACD,OAAOp+E,KAAKq+E,wBAChB,IAAK,IACD,OAAOr+E,KAAKs+E,kCAChB,QACI,OAAOt+E,KAAKu+E,qBAExB,CACA,KAAArkF,GACI,IAAI+kF,GAAY,EAEhB,GADAj/E,KAAK48E,YAAY,KAER,MADD58E,KAAKi9E,SAAS,GAEdj9E,KAAK48E,YAAY,KACjB58E,KAAK48E,YAAY,KACjBqC,GAAY,OAGZj/E,KAAKy8E,WAGb,MAAM9pF,EAAQqN,KAAK68E,cACnB78E,KAAK48E,YAAY,KACjB,MAAMsC,EAAW,CACbzqF,KAAM,QACNwqF,UAAWA,EACXtsF,MAAOA,GAKX,OAHIssF,IACAC,EAAc,IAAIl/E,KAAKy8E,UAEpByC,CACX,CACA,eAAAV,GACI,IAAIW,EAASn/E,KAAKg9E,UAGlB,IAA0C,IAAtCT,EAAqBr4C,KAAKi7C,GAC1B,MAAMvmF,MAAM,gCAEhB,KAAO0jF,EAAep4C,KAAKlkC,KAAKi9E,SAAS,KACrCkC,GAAUn/E,KAAKg9E,UAEnB,OAAOoC,SAASD,EAAQ,GAC5B,CACA,oBAAA5B,GACI,IAAI4B,EAASn/E,KAAKg9E,UAClB,IAAoC,IAAhCV,EAAep4C,KAAKi7C,GACpB,MAAMvmF,MAAM,wBAEhB,KAAO0jF,EAAep4C,KAAKlkC,KAAKi9E,SAAS,KACrCkC,GAAUn/E,KAAKg9E,UAEnB,OAAOoC,SAASD,EAAQ,GAC5B,CACA,gBAAArB,GACI,MAAMuB,EAAWr/E,KAAKg9E,UACtB,OAAQqC,GAEJ,IAAK,KAEL,IAAK,KAEL,IAAK,SAEL,IAAK,SAEL,IAAK,IAEL,IAAK,IAEL,IAAK,KAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAEL,IAAK,IAED,MAAMzmF,MAAM,OAChB,QACI,MAAO,CAAEnE,KAAM,YAAa9B,MAAOyyB,EAAGi6D,IAElD,CACA,YAAAtC,GACI,OAAQ/8E,KAAKi9E,SAAS,IAClB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,OAAO,EACX,QACI,OAAO,EAEnB,CACA,WAAA8B,GACI,MAA2B,MAApB/+E,KAAKi9E,YAAsBj9E,KAAK6+E,YAAY,EACvD,CACA,OAAArB,GACI,OAAOlB,EAAep4C,KAAKlkC,KAAKi9E,SAAS,GAC7C,CACA,WAAA4B,CAAYhnB,EAAU,GAClB,OAAQ73D,KAAKi9E,SAASplB,IAClB,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,SACL,IAAK,SACD,OAAO,EACX,QACI,OAAO,EAEnB,CACA,MAAAqlB,GACI,OAAOl9E,KAAKs/E,UAAYt/E,KAAKm9E,aACjC,CACA,MAAAmC,GACI,GAAIt/E,KAAK69E,qBACL,OAAO,EAEX,OAAQ79E,KAAKi9E,SAAS,IAClB,IAAK,IACL,IAAK,KACL,IAAK,IAEL,IAAK,IACD,OAAO,EACX,QACI,OAAO,EAEnB,CACA,WAAAE,GACI,OAAQn9E,KAAKi9E,SAAS,IAClB,IAAK,IACL,IAAK,IACD,OAAO,EAEX,IAAK,KACD,OAAQj9E,KAAKi9E,SAAS,IAClB,IAAK,IACL,IAAK,IACD,OAAO,EACX,QACI,OAAO,EAGnB,IAAK,IACD,MAA6B,MAArBj9E,KAAKi9E,SAAS,KACI,MAArBj9E,KAAKi9E,SAAS,IAAmC,MAArBj9E,KAAKi9E,SAAS,IACnD,QACI,OAAO,EAEnB,CACA,YAAAc,GACI,MAAMwB,EAAYv/E,KAAK08E,YACvB,IACI,YAAiCnnF,IAA1ByK,KAAK88B,YAAW,EAC3B,CACA,MAAO1pC,GACH,OAAO,CACX,CACA,QACI4M,KAAK28E,aAAa4C,EACtB,CACJ,CACA,kBAAA1B,GACI,OAAQ79E,KAAKi9E,YACT,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,SACL,IAAK,SACD,OAAO,EACX,QACI,OAAO,EAEnB,CACA,cAAA0B,CAAea,GACX,IAAIC,EAAY,GAChB,IAAK,IAAIvmF,EAAI,EAAGA,EAAIsmF,EAAStmF,IAAK,CAC9B,MAAMwmF,EAAU1/E,KAAKg9E,UACrB,IAAsC,IAAlCX,EAAgBn4C,KAAKw7C,GACrB,MAAM9mF,MAAM,iCAEhB6mF,GAAaC,CACjB,CAEA,MAAO,CAAEjrF,KAAM,YAAa9B,MADXysF,SAASK,EAAW,IAEzC,CACA,QAAAxC,CAASplB,EAAU,GACf,OAAO73D,KAAKgD,MAAMhD,KAAKy0B,IAAMojC,EACjC,CACA,OAAAmlB,GACI,MAAMqC,EAAWr/E,KAAKi9E,SAAS,GAE/B,OADAj9E,KAAK48E,iBAAYrnF,GACV8pF,CACX,CACA,WAAAzC,CAAY1/C,GACR,QAAa3nC,IAAT2nC,GAAsBl9B,KAAKgD,MAAMhD,KAAKy0B,OAASyI,EAC/C,MAAMtkC,MAAM,cACRskC,EACA,iBACAl9B,KAAKgD,MAAMhD,KAAKy0B,KAChB,gBACAz0B,KAAKy0B,KAEb,GAAIz0B,KAAKy0B,KAAOz0B,KAAKgD,MAAM1N,OACvB,MAAMsD,MAAM,2BAEhBoH,KAAKy0B,KACT,CACA,GAAAhvB,CAAIoC,GACA,MAAO,CAAEA,MAAOA,EAAO+K,IAAK5S,KAAKy0B,IACrC,ECxtBG,MAAMkrD,EACT,aAAA3hD,CAAc7pC,GACV,IAAK,MAAMgiB,KAAOhiB,EAAM,CACpB,MAAMksB,EAAQlsB,EAAKgiB,GAEfhiB,EAAK6P,eAAemS,UACD5gB,IAAf8qB,EAAM5rB,KACNuL,KAAKu0B,MAAMlU,GAEN7b,MAAMyK,QAAQoR,IACnBA,EAAMnsB,SAAS0rF,IACX5/E,KAAKu0B,MAAMqrD,EAAS,GACrB5/E,MAGf,CACJ,CACA,KAAAu0B,CAAMpgC,GACF,OAAQA,EAAKM,MACT,IAAK,UACDuL,KAAK6/E,aAAa1rF,GAClB,MACJ,IAAK,QACD6L,KAAK8/E,WAAW3rF,GAChB,MACJ,IAAK,cACD6L,KAAK+/E,iBAAiB5rF,GACtB,MACJ,IAAK,cACD6L,KAAKk2B,iBAAiB/hC,GACtB,MACJ,IAAK,cACD6L,KAAKskC,iBAAiBnwC,GACtB,MACJ,IAAK,YACD6L,KAAK6jC,eAAe1vC,GACpB,MACJ,IAAK,eACD6L,KAAKggF,kBAAkB7rF,GACvB,MACJ,IAAK,kBACD6L,KAAKigF,qBAAqB9rF,GAC1B,MACJ,IAAK,YACD6L,KAAKi+B,eAAe9pC,GACpB,MACJ,IAAK,oBACD6L,KAAKk+B,uBAAuB/pC,GAC5B,MACJ,IAAK,YACD6L,KAAKm+B,eAAehqC,GACpB,MACJ,IAAK,MACD6L,KAAKo+B,SAASjqC,GACd,MACJ,IAAK,QACD6L,KAAKkgF,WAAW/rF,GAChB,MACJ,IAAK,qBACD6L,KAAKmgF,wBAAwBhsF,GAC7B,MACJ,IAAK,aACD6L,KAAKogF,gBAAgBjsF,GAG7B6L,KAAKg+B,cAAc7pC,EACvB,CACA,YAAA0rF,CAAa1rF,GAAQ,CACrB,UAAA2rF,CAAW3rF,GAAQ,CACnB,gBAAA4rF,CAAiB5rF,GAAQ,CACzB,gBAAA+hC,CAAiB/hC,GAAQ,CAEzB,gBAAAmwC,CAAiBnwC,GAAQ,CACzB,cAAA0vC,CAAe1vC,GAAQ,CACvB,iBAAA6rF,CAAkB7rF,GAAQ,CAC1B,oBAAA8rF,CAAqB9rF,GAAQ,CAC7B,cAAA8pC,CAAe9pC,GAAQ,CACvB,sBAAA+pC,CAAuB/pC,GAAQ,CAE/B,cAAAgqC,CAAehqC,GAAQ,CACvB,QAAAiqC,CAASjqC,GAAQ,CACjB,UAAA+rF,CAAW/rF,GAAQ,CACnB,uBAAAgsF,CAAwBhsF,GAAQ,CAChC,eAAAisF,CAAgBjsF,GAAQ,E,uBC9E5BoF,OAAO8wD,eAAeg2B,EAAS,aAAc,CAAE1tF,OAAO,IACtD0tF,EAAQC,QAAUD,EAAQE,WAAQ,EAClC,MAAMC,EAAQ,EAAQ,MACtB,IAAID,GACJ,SAAWA,GACP,MAAME,EAAc,CAAE,OAAAC,GAAY,GAClCH,EAAMI,KAAO,WAAc,OAAOF,CAAa,CAClD,CAHD,CAGGF,IAAUF,EAAQE,MAAQA,EAAQ,CAAC,IACtC,MAAMK,EACF,GAAA5sF,CAAI6sF,EAAU7tD,EAAU,KAAM8tD,GACrB9gF,KAAK+gF,aACN/gF,KAAK+gF,WAAa,GAClB/gF,KAAKghF,UAAY,IAErBhhF,KAAK+gF,WAAWnqF,KAAKiqF,GACrB7gF,KAAKghF,UAAUpqF,KAAKo8B,GAChBxuB,MAAMyK,QAAQ6xE,IACdA,EAAOlqF,KAAK,CAAE8pF,QAAS,IAAM1gF,KAAKihF,OAAOJ,EAAU7tD,IAE3D,CACA,MAAAiuD,CAAOJ,EAAU7tD,EAAU,MACvB,IAAKhzB,KAAK+gF,WACN,OAEJ,IAAIG,GAAoC,EACxC,IAAK,IAAIhoF,EAAI,EAAG8L,EAAMhF,KAAK+gF,WAAWzrF,OAAQ4D,EAAI8L,EAAK9L,IACnD,GAAI8G,KAAK+gF,WAAW7nF,KAAO2nF,EAAU,CACjC,GAAI7gF,KAAKghF,UAAU9nF,KAAO85B,EAItB,OAFAhzB,KAAK+gF,WAAWI,OAAOjoF,EAAG,QAC1B8G,KAAKghF,UAAUG,OAAOjoF,EAAG,GAIzBgoF,GAAoC,CAE5C,CAEJ,GAAIA,EACA,MAAM,IAAItoF,MAAM,oFAExB,CACA,MAAAwoF,IAAU79E,GACN,IAAKvD,KAAK+gF,WACN,MAAO,GAEX,MAAMM,EAAM,GAAIC,EAAYthF,KAAK+gF,WAAWv9E,MAAM,GAAI+9E,EAAWvhF,KAAKghF,UAAUx9E,MAAM,GACtF,IAAK,IAAItK,EAAI,EAAG8L,EAAMs8E,EAAUhsF,OAAQ4D,EAAI8L,EAAK9L,IAC7C,IACImoF,EAAIzqF,KAAK0qF,EAAUpoF,GAAG4M,MAAMy7E,EAASroF,GAAIqK,GAC7C,CACA,MAAOnQ,IAEH,EAAIotF,EAAMgB,WAAWrlE,QAAQrZ,MAAM1P,EACvC,CAEJ,OAAOiuF,CACX,CACA,OAAAhiD,GACI,OAAQr/B,KAAK+gF,YAAyC,IAA3B/gF,KAAK+gF,WAAWzrF,MAC/C,CACA,OAAAorF,GACI1gF,KAAK+gF,gBAAaxrF,EAClByK,KAAKghF,eAAYzrF,CACrB,EAEJ,MAAM+qF,EACF,WAAA13E,CAAY64E,GACRzhF,KAAKyhF,SAAWA,CACpB,CAKA,SAAIl2E,GA6BA,OA5BKvL,KAAK0hF,SACN1hF,KAAK0hF,OAAS,CAACC,EAAUC,EAAUC,KAC1B7hF,KAAK+gF,aACN/gF,KAAK+gF,WAAa,IAAIH,GAEtB5gF,KAAKyhF,UAAYzhF,KAAKyhF,SAASK,oBAAsB9hF,KAAK+gF,WAAW1hD,WACrEr/B,KAAKyhF,SAASK,mBAAmB9hF,MAErCA,KAAK+gF,WAAW/sF,IAAI2tF,EAAUC,GAC9B,MAAMrrF,EAAS,CACXmqF,QAAS,KACA1gF,KAAK+gF,aAIV/gF,KAAK+gF,WAAWE,OAAOU,EAAUC,GACjCrrF,EAAOmqF,QAAUJ,EAAQyB,MACrB/hF,KAAKyhF,UAAYzhF,KAAKyhF,SAASO,sBAAwBhiF,KAAK+gF,WAAW1hD,WACvEr/B,KAAKyhF,SAASO,qBAAqBhiF,MACvC,GAMR,OAHIwE,MAAMyK,QAAQ4yE,IACdA,EAAYjrF,KAAKL,GAEdA,CAAM,GAGdyJ,KAAK0hF,MAChB,CAKA,IAAAO,CAAK12E,GACGvL,KAAK+gF,YACL/gF,KAAK+gF,WAAWK,OAAO39E,KAAKzD,KAAK+gF,WAAYx1E,EAErD,CACA,OAAAm1E,GACQ1gF,KAAK+gF,aACL/gF,KAAK+gF,WAAWL,UAChB1gF,KAAK+gF,gBAAaxrF,EAE1B,EAEJ8qF,EAAQC,QAAUA,EAClBA,EAAQyB,MAAQ,WAAc,C,8LCzHvB,MAAMG,EAAiB,UACxBC,EAAe,IAAI,IAczB,MAAMC,UAA8B,IAChC,WAAAx5E,GACI+pB,SAASjvB,WACT1D,KAAKqiF,YAAa,EAClBriF,KAAKsiF,eAAiB,GACtBtiF,KAAK4kC,WAAY,CACrB,CACA,YAAI29C,GACA,OAAOviF,KAAKsiF,eAAe5oF,KAAK,GACpC,CACA,KAAAmwD,CAAMjvD,GACFoF,KAAK4kC,WAAY,EACjB5kC,KAAKpF,MAAQA,EACboF,KAAKwiF,YAAc,GACnBxiF,KAAKqiF,YAAa,EAClBriF,KAAKsiF,eAAiB,EAC1B,CACA,UAAApC,CAAW/rF,GACHA,EAAK2oC,aACL98B,KAAKqiF,YAAa,EAClBriF,KAAKsiF,eAAiB,GAE9B,CACA,cAAAnkD,CAAehqC,GACX,MAAM+oC,EAAOC,OAAOC,aAAajpC,EAAKxB,OAItC,GAHKqN,KAAK4kC,WAAsB,OAAT1H,IACnBl9B,KAAK4kC,WAAY,GAEjBzwC,EAAK2oC,WACL98B,KAAKqiF,YAAa,EAClBriF,KAAKsiF,eAAiB,OAErB,CACD,MAAMG,EAAcC,EAAaxlD,GACjCl9B,KAAKsiF,eAAe1rF,KAAK6rF,GACrBziF,KAAKqiF,aACLriF,KAAKwiF,aAAeC,EAE5B,CACJ,CACA,QAAArkD,CAASjqC,GACL,IAAK6L,KAAK4kC,UAAW,CACjB,MAAMjtC,EAAMqI,KAAKpF,MAAME,UAAU3G,EAAKsR,IAAIoC,MAAO1T,EAAKsR,IAAImN,KACpDhY,EAAQ,IAAIjB,OAAOhC,GACzBqI,KAAK4kC,UAAY1sC,QAAQ,KAAKqN,MAAM3K,GACxC,CACA,GAAIzG,EAAK2oC,WACL98B,KAAKqiF,YAAa,EAClBriF,KAAKsiF,eAAiB,OAErB,CACD,MAAM3qF,EAAMqI,KAAKpF,MAAME,UAAU3G,EAAKsR,IAAIoC,MAAO1T,EAAKsR,IAAImN,KAC1D5S,KAAKsiF,eAAe1rF,KAAKe,GACrBqI,KAAKqiF,aACLriF,KAAKwiF,aAAe7qF,EAE5B,CACJ,CACA,aAAAqmC,CAAc7pC,GACV,GAAkB,UAAdA,EAAKM,KAAkB,CAIvB,GADcN,EACJ2oC,WACN,MAER,CACAnK,MAAMqL,cAAc7pC,EACxB,EAEJ,MAAMmgC,EAAU,IAAI8tD,EAuBb,SAASO,EAAmBC,GAC/B,IAQI,MAPsB,iBAAXA,IACPA,EAAS,IAAIjpF,OAAOipF,IAExBA,EAASA,EAAOvrE,WAChBid,EAAQu1B,MAAM+4B,GAEdtuD,EAAQC,MAAM4tD,EAAajvE,QAAQ0vE,IAC5BtuD,EAAQsQ,SACnB,CACA,MAAO5tC,GACH,OAAO,CACX,CACJ,CAKO,MAAM6rF,EAAuB,gDAC0Bp8E,MAAM,IAC7D,SAASq8E,EAAanwF,GACzB,MAAMiwF,EAA0B,iBAAVjwF,EAAqB,IAAIgH,OAAOhH,GAASA,EAC/D,OAAOkwF,EAAqBna,MAAMh7C,GAAOk1D,EAAO1+C,KAAKxW,IACzD,CACO,SAASg1D,EAAa/vF,GACzB,OAAOA,EAAMuU,QAAQ,sBAAuB,OAChD,CACO,SAAS67E,EAA0B5sF,GACtC,OAAOqO,MAAMT,UAAUtK,IAAIgK,KAAKtN,GAASuoF,GAAU,KAAKx6C,KAAKw6C,GAAU,IAAIA,EAAO7mF,gBAAgB6mF,EAAOphD,iBAAmBolD,EAAahE,KAAShlF,KAAK,GAC3J,CAOO,SAASspF,EAAepoF,EAAOoI,GAClC,MAAMigF,EAUH,SAAuBroF,GACL,iBAAVA,IACPA,EAAQ,IAAIjB,OAAOiB,IAEvB,MAAMsoF,EAAKtoF,EAAOxB,EAASwB,EAAMxB,OACjC,IAAIF,EAAI,EACR,SAASiqF,IACL,IAAiBl9D,EAAb1vB,EAAS,GACb,SAAS6sF,EAAUC,GACf9sF,GAAU6C,EAAOsN,OAAOxN,EAAGmqF,GAC3BnqF,GAAKmqF,CACT,CACA,SAASC,EAAeD,GACpB9sF,GAAU,MAAQ6C,EAAOsN,OAAOxN,EAAGmqF,GAAW,MAC9CnqF,GAAKmqF,CACT,CACA,KAAOnqF,EAAIE,EAAO9D,QACd,OAAQ8D,EAAOF,IACX,IAAK,KACD,OAAQE,EAAOF,EAAI,IACf,IAAK,IACDoqF,EAAe,GACf,MACJ,IAAK,IACDA,EAAe,GACf,MACJ,IAAK,IACGJ,EAAGvgD,QACmB,MAAlBvpC,EAAOF,EAAI,GACXoqF,EAAelqF,EAAOiU,QAAQ,IAAKnU,GAAKA,EAAI,GAG5CoqF,EAAe,GAInBA,EAAe,GAEnB,MACJ,IAAK,IACL,IAAK,IACGJ,EAAGvgD,QACH2gD,EAAelqF,EAAOiU,QAAQ,IAAKnU,GAAKA,EAAI,GAG5CoqF,EAAe,GAEnB,MACJ,IAAK,IACDA,EAAelqF,EAAOiU,QAAQ,IAAKnU,GAAKA,EAAI,GAC5C,MACJ,QACIoqF,EAAe,GAGvB,MACJ,IAAK,IACDr9D,EAAM,mBACNA,EAAI6hB,UAAY5uC,EAChB+sB,EAAMA,EAAIxc,KAAKrQ,IAAW,GAC1BkqF,EAAer9D,EAAI,GAAG3wB,QACtB,MACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD8tF,EAAU,GACV,MACJ,IAAK,IACDn9D,EAAM,gBACNA,EAAI6hB,UAAY5uC,EAChB+sB,EAAMA,EAAIxc,KAAKrQ,GACX6sB,EACAm9D,EAAUn9D,EAAI,GAAG3wB,QAGjBguF,EAAe,GAEnB,MACJ,IAAK,IACD,GAAsB,MAAlBlqF,EAAOF,EAAI,GACX,OAAQE,EAAOF,EAAI,IACf,IAAK,IACD3C,GAAU,MACV2C,GAAK,EACL3C,GAAU4sF,IAAY,MACtB,MACJ,IAAK,IACD5sF,GAAU,MACV2C,GAAK,EACL3C,GAAU4sF,IAAY,IACtB,MACJ,IAAK,IACDl9D,EAAM/sB,EACNA,GAAK,EACLiqF,IACA5sF,GAAU6C,EAAOsN,OAAOuf,EAAK/sB,EAAI+sB,GACjC,MACJ,IAAK,IACD,OAAQ7sB,EAAOF,EAAI,IACf,IAAK,IACL,IAAK,IACD+sB,EAAM/sB,EACNA,GAAK,EACLiqF,IACA5sF,GAAU6C,EAAOsN,OAAOuf,EAAK/sB,EAAI+sB,GACjC,MACJ,QACIm9D,EAAUhqF,EAAOiU,QAAQ,IAAKnU,GAAKA,EAAI,GACvC3C,GAAU4sF,IAAY,YAOtCC,EAAU,GACV7sF,GAAU4sF,IAAY,MAE1B,MACJ,IAAK,IAED,QADEjqF,EACK3C,EACX,QACI+sF,EAAe,GAI3B,OAAO/sF,CACX,CACA,OAAO,IAAIoD,OAAOwpF,IAAWvoF,EAAM5B,MACvC,CA/IoBuqF,CAAc3oF,GACxB2K,EAAQvC,EAAMuC,MAAM09E,GAC1B,QAAS19E,GAASA,EAAM,GAAGjQ,OAAS,CACxC,C,mECrJIkuF,EAAcjqF,OAAOwK,UAGrBC,EAAiBw/E,EAAYx/E,eAuB7B+6B,GAAW,QAAS,SAAS/kB,EAAQjB,GACvCiB,EAASzgB,OAAOygB,GAEhB,IAAI5kB,GAAS,EACTE,EAASyjB,EAAQzjB,OACjBq+B,EAAQr+B,EAAS,EAAIyjB,EAAQ,QAAKxjB,EAMtC,IAJIo+B,IAAS,OAAe5a,EAAQ,GAAIA,EAAQ,GAAI4a,KAClDr+B,EAAS,KAGFF,EAAQE,GAMf,IALA,IAAI8D,EAAS2f,EAAQ3jB,GACjB0uB,GAAQ,OAAO1qB,GACfqqF,GAAc,EACdC,EAAc5/D,EAAMxuB,SAEfmuF,EAAaC,GAAa,CACjC,IAAIvtE,EAAM2N,EAAM2/D,GACZ9wF,EAAQqnB,EAAO7D,SAEL5gB,IAAV5C,IACC,OAAGA,EAAO6wF,EAAYrtE,MAAUnS,EAAeP,KAAKuW,EAAQ7D,MAC/D6D,EAAO7D,GAAO/c,EAAO+c,GAEzB,CAGF,OAAO6D,CACT,IAEA,K,sGCvDI2pE,GAAoC,SAAO,CAACv6E,EAAI6G,KAClD,IAAI2zE,EACkB,YAAlB3zE,IACF2zE,GAAiB,SAAO,KAAOx6E,IAIjC,OAF+B,YAAlB6G,GAA8B,SAAO2zE,EAAevuF,QAAQ,GAAGwuF,gBAAgB13E,OAAQ,SAAO,SAC1Ff,OAAO,QAAQhC,MACtB,GACT,qBAGC06E,GAAsC,SAAO,CAAC3uE,EAAKpD,EAASgyE,EAAYpuE,KAC1ER,EAAIjK,KAAK,QAAS64E,GAClB,MAAM,MAAEroE,EAAK,OAAEE,EAAM,EAAEN,EAAC,EAAEC,GAAMyoE,EAA+B7uE,EAAKpD,IACpE,QAAiBoD,EAAKyG,EAAQF,EAAO/F,GACrC,MAAMsuE,EAAUC,EAAc5oE,EAAGC,EAAGG,EAAOE,EAAQ7J,GACnDoD,EAAIjK,KAAK,UAAW+4E,GACpB,KAAI11E,MAAM,uBAAuB01E,mBAAyBlyE,IAAU,GACnE,uBACCiyE,GAAiD,SAAO,CAAC7uE,EAAKpD,KAChE,MAAMoyE,EAAShvE,EAAIhhB,QAAQiwF,WAAa,CAAE1oE,MAAO,EAAGE,OAAQ,EAAGN,EAAG,EAAGC,EAAG,GACxE,MAAO,CACLG,MAAOyoE,EAAOzoE,MAAkB,EAAV3J,EACtB6J,OAAQuoE,EAAOvoE,OAAmB,EAAV7J,EACxBuJ,EAAG6oE,EAAO7oE,EACVC,EAAG4oE,EAAO5oE,EACX,GACA,kCACC2oE,GAAgC,SAAO,CAAC5oE,EAAGC,EAAGG,EAAOE,EAAQ7J,IACxD,GAAGuJ,EAAIvJ,KAAWwJ,EAAIxJ,KAAW2J,KAASE,KAChD,gB,uDCrCH,IAAIyoE,EAAe,KAiBnB,MAPA,SAAyBC,GAGvB,IAFA,IAAIlvF,EAAQkvF,EAAOhvF,OAEZF,KAAWivF,EAAangD,KAAKogD,EAAO55C,OAAOt1C,MAClD,OAAOA,CACT,ECbImvF,EAAc,OAelB,MANA,SAAkBD,GAChB,OAAOA,EACHA,EAAO9gF,MAAM,EAAG,EAAgB8gF,GAAU,GAAGp9E,QAAQq9E,EAAa,IAClED,CACN,E,oBCRIE,EAAa,qBAGbC,EAAa,aAGbC,EAAY,cAGZC,EAAevF,SA8CnB,MArBA,SAAkBzsF,GAChB,GAAoB,iBAATA,EACT,OAAOA,EAET,IAAI,EAAA6xB,EAAA,GAAS7xB,GACX,OA1CM,IA4CR,IAAI,EAAA4lE,EAAA,GAAS5lE,GAAQ,CACnB,IAAI+gB,EAAgC,mBAAjB/gB,EAAMiyF,QAAwBjyF,EAAMiyF,UAAYjyF,EACnEA,GAAQ,EAAA4lE,EAAA,GAAS7kD,GAAUA,EAAQ,GAAMA,CAC3C,CACA,GAAoB,iBAAT/gB,EACT,OAAiB,IAAVA,EAAcA,GAASA,EAEhCA,EAAQ,EAASA,GACjB,IAAIkyF,EAAWJ,EAAWvgD,KAAKvxC,GAC/B,OAAQkyF,GAAYH,EAAUxgD,KAAKvxC,GAC/BgyF,EAAahyF,EAAM6Q,MAAM,GAAIqhF,EAAW,EAAI,GAC3CL,EAAWtgD,KAAKvxC,GAvDb,KAuD6BA,CACvC,EC1DImyF,EAAW,IAsCf,MAZA,SAAkBnyF,GAChB,OAAKA,GAGLA,EAAQ,EAASA,MACHmyF,GAAYnyF,KAAU,IA9BpB,uBA+BFA,EAAQ,GAAK,EAAI,GAGxBA,GAAUA,EAAQA,EAAQ,EAPd,IAAVA,EAAcA,EAAQ,CAQjC,C,qCClBA,IALA,SAAiB0jB,GAEf,OADsB,MAATA,EAAgB,EAAIA,EAAM/gB,SACvB,OAAY+gB,EAAO,GAAK,EAC1C,C,uDCdO,MAAM0uE,EACT,QAAAC,GACI,MAAM,IAAIpsF,MAAM,+BACpB,CACA,mBAAMqsF,GACF,MAAO,EACX,EAEG,MAAMC,EAAkB,CAC3BC,mBAAoB,IAAM,IAAIJ,E,mECsClC,IALA,SAAalvE,EAAYK,GAEvB,QADW,OAAQL,GAAc,IAAW,KAChCA,GAAY,OAAaK,EAAU,GACjD,C,kXCxCA,MAAMkvE,EAAuB,CACzBrP,QAAS,KAAe,EACxBsP,iBAAkB,KAAM,CACpBzZ,iBAAiB,EACjB0Z,eAAgB,CAAC,YACjBC,WAAY,aAGdC,EAA6B,CAC/BC,cAAe,IAAM,IAAIjqD,EAAA,IAYtB,SAASkqD,EAAoBC,GAChC,IAAI3uF,EACJ,MAAM4uF,EAZV,WACI,MAAM3yD,GAAS,SAAO,OAA8B,KAAkBuyD,GAChE3yF,GAAU,SAAO,OAAwB,CAAEogC,WAAWmyD,GAE5D,OADAnyD,EAAOE,gBAAgBC,SAASvgC,GACzBA,CACX,CAOqBgzF,GACX3wF,EAAU0wF,EAASE,WAAWC,eAAeC,YAAYL,GAE/D,OADAC,EAAS3yD,OAAOgzD,UAAUC,uBAAuBC,UAAUjxF,EAAS,IAAI6N,MAAM,YAAoC,QAAvB/L,EAAK9B,EAAQnB,YAAyB,IAAPiD,EAAgBA,EAAK,sBACxI9B,CACX,C,wBCrCIkxF,EAAY7sF,OAAO8wD,eACnBg8B,EAAS,CAACx2E,EAAQld,IAAUyzF,EAAUv2E,EAAQ,OAAQ,CAAEld,QAAO43D,cAAc,IAI7E+7B,EAAY,YACZC,EAAe,eAInBF,GAHA,SAAwB31E,GACtB,OAAO2kE,EAAWC,WAAW5kE,EAAM61E,EACrC,GACuB,kBACvB,IAAIC,EAAO,OACPC,EAAS,SAIbJ,GAHA,SAAkB31E,GAChB,OAAO2kE,EAAWC,WAAW5kE,EAAM+1E,EACrC,GACiB,YACjB,IAAIC,EAAW,WACXC,EAAgB,gBAChBC,EAAS,SAIbP,GAHA,SAAkB31E,GAChB,OAAO2kE,EAAWC,WAAW5kE,EAAMk2E,EACrC,GACiB,YACjB,IAAIC,EAAS,SAIbR,GAHA,SAAkB31E,GAChB,OAAO2kE,EAAWC,WAAW5kE,EAAMm2E,EACrC,GACiB,YACjB,IAAIC,EAAQ,QACRC,EAAO,OACPC,EAAQ,QACRC,EAAW,WAIfZ,GAHA,SAAoB31E,GAClB,OAAO2kE,EAAWC,WAAW5kE,EAAMu2E,EACrC,GACmB,cACnB,IAAI3O,EAAQ,QACR4O,EAAO,OAIXb,GAHA,SAAgB31E,GACd,OAAO2kE,EAAWC,WAAW5kE,EAAMw2E,EACrC,GACe,UACf,IAAIC,EAAW,WACXC,EAAQ,QAIZf,GAHA,SAAiB31E,GACf,OAAO2kE,EAAWC,WAAW5kE,EAAM02E,EACrC,GACgB,WAChB,IAAIryD,EAAS,SACTsyD,EAAS,SAIbhB,GAHA,SAAkB31E,GAChB,OAAO2kE,EAAWC,WAAW5kE,EAAM22E,EACrC,GACiB,YACjB,IAAIC,EAAc,cAIlBjB,GAHA,SAAuB31E,GACrB,OAAO2kE,EAAWC,WAAW5kE,EAAM42E,EACrC,GACsB,iBACtB,IAAIC,EAAM,MAIVlB,GAHA,SAAe31E,GACb,OAAO2kE,EAAWC,WAAW5kE,EAAM62E,EACrC,GACc,SACd,IAAIC,EAAa,aAIjBnB,GAHA,SAAsB31E,GACpB,OAAO2kE,EAAWC,WAAW5kE,EAAM82E,EACrC,GACqB,gBACrB,IA2SIC,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EArTA50D,EAAQ,QACR60D,EAAU,UACVC,EAAY,YACZC,EAAuB,cAAc,YAErC5B,EAAOrmF,KAAM,uBACf,CACA,WAAA45E,GACE,MAAO,CAAC2M,EAAcC,EAAMC,EAAQC,EAAUC,EAAeC,EAAQC,EAAQC,EAAOkB,EAAWjB,EAAMC,EAAOC,EAAU3O,EAAO4O,EAAMC,EAAUC,EAAOryD,EAAQsyD,EAAQC,EAAaC,EAAKC,EAAYt0D,EAAO60D,EAASzB,EACpN,CACA,gBAAAzM,CAAiBC,EAASC,GACxB,OAAQD,GACN,KAAK2M,EACL,KAAKC,EACL,KAAKC,EACL,KAAKC,EACL,KAAKQ,EACH,OAAOpnF,KAAKg6E,UAAUsM,EAAWvM,GAEnC,KAAKiO,EACH,OAAOhoF,KAAKg6E,UAAUiN,EAAUlN,GAElC,QACE,OAAO,EAGb,CACA,gBAAAE,CAAiBC,GACf,MAAMC,EAAc,GAAGD,EAAQjjF,UAAUgE,SAASi/E,EAAQllF,WAC1D,GACO,eADCmlF,EAEJ,OAAOqM,EAGP,MAAM,IAAI5tF,MAAM,GAAGuhF,iCAGzB,CACA,eAAAC,CAAgB3lF,GACd,OAAQA,GACN,KAAK8xF,EACH,MAAO,CACLxyF,KAAMwyF,EACNlM,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,QAASumF,aAAc,IAC/B,CAAEvmF,KAAM,SAAUumF,aAAc,IAChC,CAAEvmF,KAAM,YAAaumF,aAAc,IACnC,CAAEvmF,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,WAId,KAAKyyF,EACH,MAAO,CACLzyF,KAAMyyF,EACNnM,WAAY,CACV,CAAEtmF,KAAM,SACR,CAAEA,KAAM,UAId,KAAK0yF,EACH,MAAO,CACL1yF,KAAM0yF,EACNpM,WAAY,CACV,CAAEtmF,KAAM,QACR,CAAEA,KAAM,WAId,KAAK2yF,EACH,MAAO,CACL3yF,KAAM2yF,EACNrM,WAAY,CACV,CAAEtmF,KAAM,YAId,KAAK4yF,EACH,MAAO,CACL5yF,KAAM4yF,EACNtM,WAAY,CACV,CAAEtmF,KAAM,MACR,CAAEA,KAAM,UACR,CAAEA,KAAM,OAAQumF,aAAc,MAIpC,KAAKsM,EACH,MAAO,CACL7yF,KAAM6yF,EACNvM,WAAY,CACV,CAAEtmF,KAAM,MACR,CAAEA,KAAM,WACR,CAAEA,KAAM,OAAQumF,aAAc,IAC9B,CAAEvmF,KAAM,UAId,KAAK8yF,EACH,MAAO,CACL9yF,KAAM8yF,EACNxM,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,WAId,KAAK+yF,EACH,MAAO,CACL/yF,KAAM+yF,EACNzM,WAAY,CACV,CAAEtmF,KAAM,UAAWumF,aAAc,IACjC,CAAEvmF,KAAM,SACR,CAAEA,KAAM,UAId,KAAKgzF,EACH,MAAO,CACLhzF,KAAMgzF,EACN1M,WAAY,CACV,CAAEtmF,KAAM,UACR,CAAEA,KAAM,WAAYumF,cAAc,GAClC,CAAEvmF,KAAM,SACR,CAAEA,KAAM,UAAWumF,cAAc,GACjC,CAAEvmF,KAAM,UACR,CAAEA,KAAM,WAAYumF,cAAc,GAClC,CAAEvmF,KAAM,SACR,CAAEA,KAAM,UAAWumF,cAAc,GACjC,CAAEvmF,KAAM,WAId,KAAKizF,EACH,MAAO,CACLjzF,KAAMizF,EACN3M,WAAY,CACV,CAAEtmF,KAAM,QACR,CAAEA,KAAM,WAId,KAAKkzF,EACH,MAAO,CACLlzF,KAAMkzF,EACN5M,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,aAAcumF,aAAc,IACpC,CAAEvmF,KAAM,WAId,KAAKukF,EACH,MAAO,CACLvkF,KAAMukF,EACN+B,WAAY,CACV,CAAEtmF,KAAM,QACR,CAAEA,KAAM,MACR,CAAEA,KAAM,MACR,CAAEA,KAAM,WAId,KAAKmzF,EACH,MAAO,CACLnzF,KAAMmzF,EACN7M,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,WAId,KAAKozF,EACH,MAAO,CACLpzF,KAAMozF,EACN9M,WAAY,CACV,CAAEtmF,KAAM,MACR,CAAEA,KAAM,QAId,KAAKqzF,EACH,MAAO,CACLrzF,KAAMqzF,EACN/M,WAAY,CACV,CAAEtmF,KAAM,UACR,CAAEA,KAAM,MACR,CAAEA,KAAM,OAAQumF,aAAc,IAC9B,CAAEvmF,KAAM,UAId,KAAKghC,EACH,MAAO,CACLhhC,KAAMghC,EACNslD,WAAY,CACV,CAAEtmF,KAAM,QACR,CAAEA,KAAM,QAASumF,cAAc,KAIrC,KAAK+M,EACH,MAAO,CACLtzF,KAAMszF,EACNhN,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,SAAUumF,aAAc,IAChC,CAAEvmF,KAAM,WAId,KAAKuzF,EACH,MAAO,CACLvzF,KAAMuzF,EACNjN,WAAY,CACV,CAAEtmF,KAAM,OACR,CAAEA,KAAM,SACR,CAAEA,KAAM,WAId,KAAKwzF,EACH,MAAO,CACLxzF,KAAMwzF,EACNlN,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,WAAYumF,aAAc,IAClC,CAAEvmF,KAAM,WAAYumF,cAAc,GAClC,CAAEvmF,KAAM,WAId,KAAKyzF,EACH,MAAO,CACLzzF,KAAMyzF,EACNnN,WAAY,CACV,CAAEtmF,KAAM,SACR,CAAEA,KAAM,WAId,KAAKm/B,EACH,MAAO,CACLn/B,KAAMm/B,EACNmnD,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,OAAQumF,aAAc,IAC9B,CAAEvmF,KAAM,SAAUumF,aAAc,IAChC,CAAEvmF,KAAM,UAAWumF,aAAc,IACjC,CAAEvmF,KAAM,WAId,KAAKg0F,EACH,MAAO,CACLh0F,KAAMg0F,EACN1N,WAAY,CACV,CAAEtmF,KAAM,QACR,CAAEA,KAAM,YACR,CAAEA,KAAM,MACR,CAAEA,KAAM,MACR,CAAEA,KAAM,WAId,KAAKi0F,EACH,MAAO,CACLj0F,KAAMi0F,EACN3N,WAAY,CACV,CAAEtmF,KAAM,YACR,CAAEA,KAAM,YACR,CAAEA,KAAM,OACR,CAAEA,KAAM,aAAcumF,aAAc,IACpC,CAAEvmF,KAAM,WAId,QACE,MAAO,CACLA,KAAMU,EACN4lF,WAAY,IAIpB,GAEEhF,EAAa,IAAI4S,EAKjBC,EAA8B7B,GAAO,IAAMoB,IAAsBA,EAAoB/B,EAAoB,2lHAA2lH,eAEpsHyC,EAAgC9B,GAAO,IAAMqB,IAAwBA,EAAsBhC,EAAoB,kiKAA+hK,iBAE9oK0C,EAA6B/B,GAAO,IAAMsB,IAAqBA,EAAmBjC,EAAoB,m+JAAm+J,cAEzkK2C,EAAsChC,GAAO,IAAMuB,IAA8BA,EAA4BlC,EAAoB,45VAA45V,uBAE7hW4C,EAAkCjC,GAAO,IAAMwB,IAA0BA,EAAwBnC,EAAoB,otUAAitU,mBAEt0U6C,EAA+BlC,GAAO,IAAMyB,IAAuBA,EAAqBpC,EAAoB,ijXAA8iX,gBAG1pX8C,GAAuB,CACzBjD,WAAY,OACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJC,GAAyB,CAC3BnD,WAAY,SACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJE,GAAsB,CACxBpD,WAAY,MACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJG,GAA+B,CACjCrD,WAAY,eACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJI,GAA2B,CAC7BtD,WAAY,WACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJK,GAAwB,CAC1BvD,WAAY,QACZD,eAAgB,CAAC,OAAQ,YACzB1Z,iBAAiB,EACjB6c,KAAM,cAEJM,GAA+B,CACjCtD,cAA+BY,GAAO,IAAM,IAAI4B,GAAwB,kBAEtEe,GAAsB,CACxBjT,QAAyBsQ,GAAO,IAAM6B,KAAe,WACrD7C,iBAAkCgB,GAAO,IAAMmC,IAAsB,oBACrErtF,OAAQ,CAAC,GAEP8tF,GAAwB,CAC1BlT,QAAyBsQ,GAAO,IAAM8B,KAAiB,WACvD9C,iBAAkCgB,GAAO,IAAMqC,IAAwB,oBACvEvtF,OAAQ,CAAC,GAEP+tF,GAAqB,CACvBnT,QAAyBsQ,GAAO,IAAM+B,KAAc,WACpD/C,iBAAkCgB,GAAO,IAAMsC,IAAqB,oBACpExtF,OAAQ,CAAC,GAEPguF,GAA8B,CAChCpT,QAAyBsQ,GAAO,IAAMgC,KAAuB,WAC7DhD,iBAAkCgB,GAAO,IAAMuC,IAA8B,oBAC7EztF,OAAQ,CAAC,GAEPiuF,GAA0B,CAC5BrT,QAAyBsQ,GAAO,IAAMiC,KAAmB,WACzDjD,iBAAkCgB,GAAO,IAAMwC,IAA0B,oBACzE1tF,OAAQ,CAAC,GAEPkuF,GAAuB,CACzBtT,QAAyBsQ,GAAO,IAAMkC,KAAgB,WACtDlD,iBAAkCgB,GAAO,IAAMyC,IAAuB,oBACtE3tF,OAAQ,CAAC,GAYPmuF,GAAe,CACjBC,UAN4B,6CAO5BC,UAN4B,4BAO5BC,MANe,yBAQbC,GAAgC,cAAc,WAE9CrD,EAAOrmF,KAAM,gCACf,CACA,YAAA2pF,CAAa/1F,EAAMoP,EAAOjM,GACxB,IAAIpE,EAAQqN,KAAK4pF,mBAAmBh2F,EAAMoP,EAAOjM,GAIjD,YAHc,IAAVpE,IACFA,EAAQqN,KAAK6pF,mBAAmBj2F,EAAMoP,EAAOjM,SAEjC,IAAVpE,EACKggC,MAAMg3D,aAAa/1F,EAAMoP,EAAOjM,GAElCpE,CACT,CACA,kBAAAi3F,CAAmBh2F,EAAMoP,EAAO8mF,GAC9B,MAAMlvF,EAAQ0uF,GAAa11F,EAAKG,MAChC,QAAc,IAAV6G,EACF,OAEF,MAAM2K,EAAQ3K,EAAM6O,KAAKzG,GACzB,OAAc,OAAVuC,OAGa,IAAbA,EAAM,GACDA,EAAM,GAAGlF,OAAO6G,QAAQ,cAAe,UAE/B,IAAb3B,EAAM,GACDA,EAAM,GAAG2B,QAAQ,SAAU,IAAIA,QAAQ,SAAU,IAAIA,QAAQ,cAAe,KAAKA,QAAQ,eAAgB,WADlH,OANA,CAUF,GAEE6iF,GAAuB,cAAcL,UAErCrD,EAAOrmF,KAAM,uBACf,CACA,kBAAA6pF,CAAmBG,EAAOhkF,EAAQ8jF,GAElC,GAKEG,GAA8B,cAAc,WAE5C5D,EAAOrmF,KAAM,8BACf,CACA,WAAA4I,CAAYshF,GACVv3D,QACA3yB,KAAKkqF,SAAW,IAAIl3F,IAAIk3F,EAC1B,CACA,kBAAAhf,CAAmBh4E,EAAO83E,EAAgB9vE,GACxC,MAAM2jC,EAAalM,MAAMu4C,mBAAmBh4E,EAAO83E,EAAgB9vE,GAMnE,OALA2jC,EAAW3qC,SAAS+tC,IACdjiC,KAAKkqF,SAASp2F,IAAImuC,EAAUluC,YAA+B,IAAtBkuC,EAAUlM,UACjDkM,EAAUlM,QAAU,IAAIp8B,OAAOsoC,EAAUlM,QAAQ1e,WAAa,sBAChE,IAEKwnB,CACT,IAEuB,cAAcorD,UAEnC5D,EAAOrmF,KAAM,qBACf,G,2DC5eS8yB,E,mBAhCJ,MAAMq3D,EACT,OAAAC,CAAQpnF,EAAOjM,GACX,IAAIhB,EAAUgB,EAAQjB,cAItB,IAHI,QAAiBC,KACjBA,GAAU,QAA0BA,KAEpC,QAAWA,GAAU,CACrB,MAAMnC,EAAOmC,EAAQnC,KAAKS,IAC1B,IAAKT,EACD,MAAM,IAAIgF,MAAM,2CAEpB,OAAOoH,KAAK2pF,aAAa/1F,EAAMoP,EAAOjM,EAC1C,CACA,OAAOiM,CACX,CAEA,YAAA2mF,CAAa/1F,EAAMoP,EAAOjM,GACtB,IAAIC,EACJ,OAAQpD,EAAKG,KAAKupC,eACd,IAAK,MAAO,OAAOxK,EAAeu3D,WAAWrnF,GAC7C,IAAK,SAAU,OAAO8vB,EAAew3D,cAActnF,GACnD,IAAK,KAAM,OAAO8vB,EAAey3D,UAAUvnF,GAE/C,OAAqC,QAA5BhM,GAAK,QAAYpD,UAA0B,IAAPoD,OAAgB,EAASA,EAAGa,eACrE,IAAK,SAAU,OAAOi7B,EAAe03D,cAAcxnF,GACnD,IAAK,UAAW,OAAO8vB,EAAe23D,eAAeznF,GACrD,IAAK,SAAU,OAAO8vB,EAAe43D,cAAc1nF,GACnD,IAAK,OAAQ,OAAO8vB,EAAe63D,YAAY3nF,GAC/C,QAAS,OAAOA,EAExB,GAGJ,SAAW8vB,GAgBP,SAAS83D,EAAuB1tD,GAC5B,OAAQA,GACJ,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,IAAK,IAAK,MAAO,KACjB,QAAS,OAAOA,EAExB,CAZApK,EAAew3D,cAdf,SAAuBtnF,GACnB,IAAIzM,EAAS,GACb,IAAK,IAAI2C,EAAI,EAAGA,EAAI8J,EAAM1N,OAAS,EAAG4D,IAAK,CACvC,MAAMmO,EAAIrE,EAAM0nC,OAAOxxC,GACvB,GAAU,OAANmO,EAAY,CAEZ9Q,GAAUq0F,EADC5nF,EAAM0nC,SAASxxC,GAE9B,MAEI3C,GAAU8Q,CAElB,CACA,OAAO9Q,CACX,EAsBAu8B,EAAey3D,UARf,SAAmBvnF,GACf,MAAwB,MAApBA,EAAM0nC,OAAO,GACN1nC,EAAMlI,UAAU,GAGhBkI,CAEf,EAKA8vB,EAAeu3D,WAHf,SAAoBrnF,GAChB,OAAOo8E,SAASp8E,EACpB,EAKA8vB,EAAe43D,cAHf,SAAuB1nF,GACnB,OAAO6nF,OAAO7nF,EAClB,EAKA8vB,EAAe63D,YAHf,SAAqB3nF,GACjB,OAAO,IAAIuX,KAAKvX,EACpB,EAKA8vB,EAAe03D,cAHf,SAAuBxnF,GACnB,OAAO8a,OAAO9a,EAClB,EAKA8vB,EAAe23D,eAHf,SAAwBznF,GACpB,MAA+B,SAAxBA,EAAMnL,aACjB,CAEH,CAzDD,CAyDGi7B,IAAmBA,EAAiB,CAAC,G,sHC/CxC,MAlCA,SAAiB9Y,EAAQE,EAAMvnB,EAAOm4F,GACpC,KAAK,EAAAvyB,EAAA,GAASv+C,GACZ,OAAOA,EAST,IALA,IAAI5kB,GAAS,EACTE,GAHJ4kB,GAAO,OAASA,EAAMF,IAGJ1kB,OACdwyC,EAAYxyC,EAAS,EACrB0lF,EAAShhE,EAEI,MAAVghE,KAAoB5lF,EAAQE,GAAQ,CACzC,IAAI6gB,GAAM,OAAM+D,EAAK9kB,IACjB21F,EAAWp4F,EAEf,GAAY,cAARwjB,GAA+B,gBAARA,GAAiC,cAARA,EAClD,OAAO6D,EAGT,GAAI5kB,GAAS0yC,EAAW,CACtB,IAAIkjD,EAAWhQ,EAAO7kE,QAEL5gB,KADjBw1F,EAAWD,EAAaA,EAAWE,EAAU70E,EAAK6kE,QAAUzlF,KAE1Dw1F,GAAW,EAAAxyB,EAAA,GAASyyB,GAChBA,GACC,OAAQ9wE,EAAK9kB,EAAQ,IAAM,GAAK,CAAC,EAE1C,EACA,OAAY4lF,EAAQ7kE,EAAK40E,GACzB/P,EAASA,EAAO7kE,EAClB,CACA,OAAO6D,CACT,ECnBA,MAhBA,SAAoBA,EAAQC,EAAOnE,GAKjC,IAJA,IAAI1gB,GAAS,EACTE,EAAS2kB,EAAM3kB,OACfiB,EAAS,CAAC,IAELnB,EAAQE,GAAQ,CACvB,IAAI4kB,EAAOD,EAAM7kB,GACbzC,GAAQ,OAAQqnB,EAAQE,GAExBpE,EAAUnjB,EAAOunB,IACnB,EAAQ3jB,GAAQ,OAAS2jB,EAAMF,GAASrnB,EAE5C,CACA,OAAO4D,CACT,C,qBCdA,IAJA,SAAgB5D,EAAO+gB,GACrB,OAAO/gB,EAAQ+gB,CACjB,C,2MCsDWu3E,E,oBAtDJ,SAASC,EAAU/2F,GACtB,OAAO,IAAI,KAAeA,GAAMwB,IACxB,QAAmBA,GACZA,EAAQK,QAGR,IAEZ,CAAEu0E,aAAa,GACtB,CAUO,SAAS4gB,EAAY9qE,EAAO/O,GAC/B,KAAO+O,EAAMppB,WAET,IADAopB,EAAQA,EAAMppB,aACAqa,EACV,OAAO,EAGf,OAAO,CACX,CACO,SAAS85E,EAAa9mF,GAGzB,MAAO,CACHqO,MAAO,CACH40D,UAAWjjE,EAAMmsC,YAAc,EAC/BjrC,KAAMlB,EAAMksC,UAAY,GAE5B59B,IAAK,CACD20D,UAAWjjE,EAAM6tC,UACjB3sC,KAAMlB,EAAM4tC,QAAU,GAGlC,CACO,SAASm5C,EAAkBl3F,GAC9B,IAAKA,EACD,OAEJ,MAAM,OAAEkS,EAAM,IAAEuM,EAAG,MAAEzY,GAAUhG,EAC/B,MAAO,CACHgG,QACAkM,SACAuM,MACAtd,OAAQsd,EAAMvM,EAEtB,CAgCO,SAASilF,EAAQnxF,EAAOkiC,GAC3B,MAAMkvD,EAvBH,SAAsBpxF,EAAOkiC,GAChC,GAAIliC,EAAMyY,IAAIpN,KAAO62B,EAAG1pB,MAAMnN,MAASrL,EAAMyY,IAAIpN,OAAS62B,EAAG1pB,MAAMnN,MAAQrL,EAAMyY,IAAI20D,WAAalrC,EAAG1pB,MAAM40D,UACvG,OAAO0jB,EAAgBO,OAEtB,GAAIrxF,EAAMwY,MAAMnN,KAAO62B,EAAGzpB,IAAIpN,MAASrL,EAAMwY,MAAMnN,OAAS62B,EAAGzpB,IAAIpN,MAAQrL,EAAMwY,MAAM40D,WAAalrC,EAAGzpB,IAAI20D,UAC5G,OAAO0jB,EAAgBQ,MAE3B,MAAMC,EAAcvxF,EAAMwY,MAAMnN,KAAO62B,EAAG1pB,MAAMnN,MAASrL,EAAMwY,MAAMnN,OAAS62B,EAAG1pB,MAAMnN,MAAQrL,EAAMwY,MAAM40D,WAAalrC,EAAG1pB,MAAM40D,UAC3HokB,EAAYxxF,EAAMyY,IAAIpN,KAAO62B,EAAGzpB,IAAIpN,MAASrL,EAAMyY,IAAIpN,OAAS62B,EAAGzpB,IAAIpN,MAAQrL,EAAMyY,IAAI20D,WAAalrC,EAAGzpB,IAAI20D,UACnH,OAAImkB,GAAeC,EACRV,EAAgBW,OAElBF,EACET,EAAgBY,YAElBF,EACEV,EAAgBa,aAGhBb,EAAgBc,OAE/B,CAEuBC,CAAa7xF,EAAOkiC,GACvC,OAAOkvD,EAAaN,EAAgBQ,KACxC,EAjCA,SAAWR,GACPA,EAAgBA,EAAwB,OAAI,GAAK,SACjDA,EAAgBA,EAAuB,MAAI,GAAK,QAChDA,EAAgBA,EAA8B,aAAI,GAAK,eACvDA,EAAgBA,EAA6B,YAAI,GAAK,cACtDA,EAAgBA,EAAwB,OAAI,GAAK,SACjDA,EAAgBA,EAAyB,QAAI,GAAK,SACrD,CAPD,CAOGA,IAAoBA,EAAkB,CAAC,IA6BnC,MAAMgB,EAAoB,eAoB1B,SAASC,EAAgBn1F,EAASo1F,GACrC,GAAIp1F,EAAS,CACT,MAAMi8C,EAwFP,SAAyB7+C,EAAMT,GAAS,GAC3C,KAAOS,EAAK8C,WAAW,CACnB,MAAMqa,EAASnd,EAAK8C,UACpB,IAAI7B,EAAQkc,EAAOtb,QAAQqX,QAAQlZ,GACnC,KAAOiB,EAAQ,GAAG,CACdA,IACA,MAAM49C,EAAW1hC,EAAOtb,QAAQZ,GAChC,GAAI1B,IAAWs/C,EAASt/C,OACpB,OAAOs/C,CAEf,CACA7+C,EAAOmd,CACX,CACA,MACJ,CAtGyB86E,CAAgBr1F,GAAS,GAC1C,GAAIi8C,GAAYq5C,EAAcr5C,EAAUm5C,GACpC,OAAOn5C,EAEX,IAAI,QAAcj8C,GAAU,CAIxB,IAAK,IAAImC,EADQnC,EAAQf,QAAQizE,WAAU71E,IAAMA,EAAEM,SAC3B,EAAGwF,GAAK,EAAGA,IAAK,CACpC,MAAMmnB,EAAQtpB,EAAQf,QAAQkD,GAC9B,GAAImzF,EAAchsE,EAAO8rE,GACrB,OAAO9rE,CAEf,CACJ,CACJ,CAEJ,CACO,SAASgsE,EAAct1F,EAASo1F,GACnC,OAAO,QAAcp1F,IAAYo1F,EAAanxF,SAASjE,EAAQkrC,UAAUluC,KAC7E,C,yDCpHA,IANA,SAAasiB,GACX,OAAQA,GAASA,EAAM/gB,QACnB,OAAa+gB,EAAO,IAAU,UAC9B9gB,CACN,C,qBCPA,IALA,SAAc8gB,GACZ,IAAI/gB,EAAkB,MAAT+gB,EAAgB,EAAIA,EAAM/gB,OACvC,OAAOA,EAAS+gB,EAAM/gB,EAAS,QAAKC,CACtC,C,mGCAI+2F,EAAuB,cAAc,aAErC,QAAOtsF,KAAM,uBACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,YACT,GAIE45D,EAAiB,CACnBpxF,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAIy5D,GAAwB,gBACvEx5D,gBAAgC,SAAO,IAAM,IAAI,MAAwB,oBAG7E,SAAS05D,EAAuBx5D,EAAU,KACxC,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIi0D,GAAW,SACf,OAAwB,CAAEh0D,WAC1B,KACAs5D,GAGF,OADAt5D,EAAOE,gBAAgBC,SAAS6zD,GACzB,CAAEh0D,SAAQg0D,WACnB,EACA,QAAOuF,EAAwB,yB,mGC7B3BC,EAAkB,cAAc,aAEhC,QAAOzsF,KAAM,kBACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,MAAO,YAChB,GAIE+5D,EAAoB,cAAc,aAElC,QAAO1sF,KAAM,oBACf,CACA,kBAAA6pF,CAAmBj2F,EAAMoP,EAAO8mF,GAC9B,GAAkB,sBAAdl2F,EAAKG,KAGT,OAAOiP,EAAMkE,QAAQ,KAAM,IAAI7G,MACjC,GAIEssF,EAAY,CACdxxF,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAI45D,GAAmB,gBAClE35D,gBAAgC,SAAO,IAAM,IAAI45D,GAAqB,oBAG1E,SAASE,EAAkB55D,EAAU,KACnC,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIu0D,GAAM,SACV,OAAwB,CAAEt0D,WAC1B,KACA05D,GAGF,OADA15D,EAAOE,gBAAgBC,SAASm0D,GACzB,CAAEt0D,SAAQs0D,MACnB,EACA,QAAOqF,EAAmB,oB,uBC3D1B,IAAIC,E,uDAAI,MAAmB,IAAI1uE,EAAE,CAAC,IAAIA,IAAI,SAAS/qB,EAAE+qB,GAAG,GAAG,iBAAiBA,EAAE,MAAM,IAAI8b,UAAU,mCAAmCzrB,KAAKC,UAAU0P,GAAG,CAAC,SAASrZ,EAAEqZ,EAAE/qB,GAAG,IAAI,IAAI0R,EAAEJ,EAAE,GAAGxL,EAAE,EAAEkC,GAAG,EAAEnC,EAAE,EAAE0iB,EAAE,EAAEA,GAAGwC,EAAE7oB,SAASqmB,EAAE,CAAC,GAAGA,EAAEwC,EAAE7oB,OAAOwP,EAAEqZ,EAAEof,WAAW5hB,OAAO,CAAC,GAAG,KAAK7W,EAAE,MAAMA,EAAE,EAAE,CAAC,GAAG,KAAKA,EAAE,CAAC,GAAG1J,IAAIugB,EAAE,GAAG,IAAI1iB,QAAQ,GAAGmC,IAAIugB,EAAE,GAAG,IAAI1iB,EAAE,CAAC,GAAGyL,EAAEpP,OAAO,GAAG,IAAI4D,GAAG,KAAKwL,EAAE64B,WAAW74B,EAAEpP,OAAO,IAAI,KAAKoP,EAAE64B,WAAW74B,EAAEpP,OAAO,GAAG,GAAGoP,EAAEpP,OAAO,EAAE,CAAC,IAAIo1E,EAAEhmE,EAAE7J,YAAY,KAAK,GAAG6vE,IAAIhmE,EAAEpP,OAAO,EAAE,EAAE,IAAIo1E,GAAGhmE,EAAE,GAAGxL,EAAE,GAAGA,GAAGwL,EAAEA,EAAElB,MAAM,EAAEknE,IAAIp1E,OAAO,EAAEoP,EAAE7J,YAAY,KAAKO,EAAEugB,EAAE1iB,EAAE,EAAE,QAAQ,CAAC,MAAM,GAAG,IAAIyL,EAAEpP,QAAQ,IAAIoP,EAAEpP,OAAO,CAACoP,EAAE,GAAGxL,EAAE,EAAEkC,EAAEugB,EAAE1iB,EAAE,EAAE,QAAQ,CAAC7F,IAAIsR,EAAEpP,OAAO,EAAEoP,GAAG,MAAMA,EAAE,KAAKxL,EAAE,EAAE,MAAMwL,EAAEpP,OAAO,EAAEoP,GAAG,IAAIyZ,EAAE3a,MAAMpI,EAAE,EAAEugB,GAAGjX,EAAEyZ,EAAE3a,MAAMpI,EAAE,EAAEugB,GAAGziB,EAAEyiB,EAAEvgB,EAAE,EAAEA,EAAEugB,EAAE1iB,EAAE,CAAC,MAAM,KAAK6L,IAAI,IAAI7L,IAAIA,EAAEA,GAAG,CAAC,CAAC,OAAOyL,CAAC,CAAC,IAAIA,EAAE,CAACooF,QAAQ,WAAW,IAAI,IAAI3uE,EAAEzZ,EAAE,GAAGxL,GAAE,EAAGkC,EAAEsI,UAAUpO,OAAO,EAAE8F,IAAI,IAAIlC,EAAEkC,IAAI,CAAC,IAAInC,EAAEmC,GAAG,EAAEnC,EAAEyK,UAAUtI,SAAI,IAAS+iB,IAAIA,EAAEglE,QAAQ4J,OAAO9zF,EAAEklB,GAAG/qB,EAAE6F,GAAG,IAAIA,EAAE3D,SAASoP,EAAEzL,EAAE,IAAIyL,EAAExL,EAAE,KAAKD,EAAEskC,WAAW,GAAG,CAAC,OAAO74B,EAAEI,EAAEJ,GAAGxL,GAAGA,EAAEwL,EAAEpP,OAAO,EAAE,IAAIoP,EAAE,IAAIA,EAAEpP,OAAO,EAAEoP,EAAE,GAAG,EAAEsoF,UAAU,SAAS7uE,GAAG,GAAG/qB,EAAE+qB,GAAG,IAAIA,EAAE7oB,OAAO,MAAM,IAAI,IAAIoP,EAAE,KAAKyZ,EAAEof,WAAW,GAAGrkC,EAAE,KAAKilB,EAAEof,WAAWpf,EAAE7oB,OAAO,GAAG,OAAO,KAAK6oB,EAAErZ,EAAEqZ,GAAGzZ,IAAIpP,QAAQoP,IAAIyZ,EAAE,KAAKA,EAAE7oB,OAAO,GAAG4D,IAAIilB,GAAG,KAAKzZ,EAAE,IAAIyZ,EAAEA,CAAC,EAAE8uE,WAAW,SAAS9uE,GAAG,OAAO/qB,EAAE+qB,GAAGA,EAAE7oB,OAAO,GAAG,KAAK6oB,EAAEof,WAAW,EAAE,EAAE7jC,KAAK,WAAW,GAAG,IAAIgK,UAAUpO,OAAO,MAAM,IAAI,IAAI,IAAI6oB,EAAErZ,EAAE,EAAEA,EAAEpB,UAAUpO,SAASwP,EAAE,CAAC,IAAI5L,EAAEwK,UAAUoB,GAAG1R,EAAE8F,GAAGA,EAAE5D,OAAO,SAAI,IAAS6oB,EAAEA,EAAEjlB,EAAEilB,GAAG,IAAIjlB,EAAE,CAAC,YAAO,IAASilB,EAAE,IAAIzZ,EAAEsoF,UAAU7uE,EAAE,EAAE+uE,SAAS,SAAS/uE,EAAErZ,GAAG,GAAG1R,EAAE+qB,GAAG/qB,EAAE0R,GAAGqZ,IAAIrZ,EAAE,MAAM,GAAG,IAAIqZ,EAAEzZ,EAAEooF,QAAQ3uE,OAAOrZ,EAAEJ,EAAEooF,QAAQhoF,IAAI,MAAM,GAAG,IAAI,IAAI5L,EAAE,EAAEA,EAAEilB,EAAE7oB,QAAQ,KAAK6oB,EAAEof,WAAWrkC,KAAKA,GAAG,IAAI,IAAIkC,EAAE+iB,EAAE7oB,OAAO2D,EAAEmC,EAAElC,EAAEyiB,EAAE,EAAEA,EAAE7W,EAAExP,QAAQ,KAAKwP,EAAEy4B,WAAW5hB,KAAKA,GAAG,IAAI,IAAI+uD,EAAE5lE,EAAExP,OAAOqmB,EAAEtU,EAAEpO,EAAEyxE,EAAEzxE,EAAEyxE,EAAE5oD,GAAG,EAAE3oB,EAAE,EAAEA,GAAGkO,IAAIlO,EAAE,CAAC,GAAGA,IAAIkO,EAAE,CAAC,GAAGqjE,EAAErjE,EAAE,CAAC,GAAG,KAAKvC,EAAEy4B,WAAW5hB,EAAExiB,GAAG,OAAO2L,EAAEtB,MAAMmY,EAAExiB,EAAE,GAAG,GAAG,IAAIA,EAAE,OAAO2L,EAAEtB,MAAMmY,EAAExiB,EAAE,MAAMF,EAAEoO,IAAI,KAAK8W,EAAEof,WAAWrkC,EAAEC,GAAG2oB,EAAE3oB,EAAE,IAAIA,IAAI2oB,EAAE,IAAI,KAAK,CAAC,IAAItmB,EAAE2iB,EAAEof,WAAWrkC,EAAEC,GAAG,GAAGqC,IAAIsJ,EAAEy4B,WAAW5hB,EAAExiB,GAAG,MAAM,KAAKqC,IAAIsmB,EAAE3oB,EAAE,CAAC,IAAIwe,EAAE,GAAG,IAAIxe,EAAED,EAAE4oB,EAAE,EAAE3oB,GAAGiC,IAAIjC,EAAEA,IAAIiC,GAAG,KAAK+iB,EAAEof,WAAWpkC,KAAK,IAAIwe,EAAEriB,OAAOqiB,GAAG,KAAKA,GAAG,OAAO,OAAOA,EAAEriB,OAAO,EAAEqiB,EAAE7S,EAAEtB,MAAMmY,EAAEmG,IAAInG,GAAGmG,EAAE,KAAKhd,EAAEy4B,WAAW5hB,MAAMA,EAAE7W,EAAEtB,MAAMmY,GAAG,EAAEwxE,UAAU,SAAShvE,GAAG,OAAOA,CAAC,EAAEivE,QAAQ,SAASjvE,GAAG,GAAG/qB,EAAE+qB,GAAG,IAAIA,EAAE7oB,OAAO,MAAM,IAAI,IAAI,IAAIwP,EAAEqZ,EAAEof,WAAW,GAAG74B,EAAE,KAAKI,EAAE5L,GAAG,EAAEkC,GAAE,EAAGnC,EAAEklB,EAAE7oB,OAAO,EAAE2D,GAAG,IAAIA,EAAE,GAAG,MAAM6L,EAAEqZ,EAAEof,WAAWtkC,KAAK,IAAImC,EAAE,CAAClC,EAAED,EAAE,KAAK,OAAOmC,GAAE,EAAG,OAAO,IAAIlC,EAAEwL,EAAE,IAAI,IAAIA,GAAG,IAAIxL,EAAE,KAAKilB,EAAE3a,MAAM,EAAEtK,EAAE,EAAEm0F,SAAS,SAASlvE,EAAErZ,GAAG,QAAG,IAASA,GAAG,iBAAiBA,EAAE,MAAM,IAAIm1B,UAAU,mCAAmC7mC,EAAE+qB,GAAG,IAAIzZ,EAAExL,EAAE,EAAEkC,GAAG,EAAEnC,GAAE,EAAG,QAAG,IAAS6L,GAAGA,EAAExP,OAAO,GAAGwP,EAAExP,QAAQ6oB,EAAE7oB,OAAO,CAAC,GAAGwP,EAAExP,SAAS6oB,EAAE7oB,QAAQwP,IAAIqZ,EAAE,MAAM,GAAG,IAAIxC,EAAE7W,EAAExP,OAAO,EAAEo1E,GAAG,EAAE,IAAIhmE,EAAEyZ,EAAE7oB,OAAO,EAAEoP,GAAG,IAAIA,EAAE,CAAC,IAAI2C,EAAE8W,EAAEof,WAAW74B,GAAG,GAAG,KAAK2C,GAAG,IAAIpO,EAAE,CAACC,EAAEwL,EAAE,EAAE,KAAK,OAAO,IAAIgmE,IAAIzxE,GAAE,EAAGyxE,EAAEhmE,EAAE,GAAGiX,GAAG,IAAItU,IAAIvC,EAAEy4B,WAAW5hB,IAAI,KAAKA,IAAIvgB,EAAEsJ,IAAIiX,GAAG,EAAEvgB,EAAEsvE,GAAG,CAAC,OAAOxxE,IAAIkC,EAAEA,EAAEsvE,GAAG,IAAItvE,IAAIA,EAAE+iB,EAAE7oB,QAAQ6oB,EAAE3a,MAAMtK,EAAEkC,EAAE,CAAC,IAAIsJ,EAAEyZ,EAAE7oB,OAAO,EAAEoP,GAAG,IAAIA,EAAE,GAAG,KAAKyZ,EAAEof,WAAW74B,IAAI,IAAIzL,EAAE,CAACC,EAAEwL,EAAE,EAAE,KAAK,OAAO,IAAItJ,IAAInC,GAAE,EAAGmC,EAAEsJ,EAAE,GAAG,OAAO,IAAItJ,EAAE,GAAG+iB,EAAE3a,MAAMtK,EAAEkC,EAAE,EAAEkyF,QAAQ,SAASnvE,GAAG/qB,EAAE+qB,GAAG,IAAI,IAAIrZ,GAAG,EAAEJ,EAAE,EAAExL,GAAG,EAAEkC,GAAE,EAAGnC,EAAE,EAAE0iB,EAAEwC,EAAE7oB,OAAO,EAAEqmB,GAAG,IAAIA,EAAE,CAAC,IAAI+uD,EAAEvsD,EAAEof,WAAW5hB,GAAG,GAAG,KAAK+uD,GAAG,IAAIxxE,IAAIkC,GAAE,EAAGlC,EAAEyiB,EAAE,GAAG,KAAK+uD,GAAG,IAAI5lE,EAAEA,EAAE6W,EAAE,IAAI1iB,IAAIA,EAAE,IAAI,IAAI6L,IAAI7L,GAAG,QAAQ,IAAImC,EAAE,CAACsJ,EAAEiX,EAAE,EAAE,KAAK,CAAC,CAAC,OAAO,IAAI7W,IAAI,IAAI5L,GAAG,IAAID,GAAG,IAAIA,GAAG6L,IAAI5L,EAAE,GAAG4L,IAAIJ,EAAE,EAAE,GAAGyZ,EAAE3a,MAAMsB,EAAE5L,EAAE,EAAEq0F,OAAO,SAASpvE,GAAG,GAAG,OAAOA,GAAG,iBAAiBA,EAAE,MAAM,IAAI8b,UAAU,0EAA0E9b,GAAG,OAAO,SAASA,EAAE/qB,GAAG,IAAI0R,EAAE1R,EAAE6d,KAAK7d,EAAE+tB,KAAKzc,EAAEtR,EAAEo6F,OAAOp6F,EAAEW,MAAM,KAAKX,EAAEq6F,KAAK,IAAI,OAAO3oF,EAAEA,IAAI1R,EAAE+tB,KAAKrc,EAAEJ,EAAEI,EAAE,IAAIJ,EAAEA,CAAC,CAAtG,CAAwG,EAAEyZ,EAAE,EAAEpb,MAAM,SAASob,GAAG/qB,EAAE+qB,GAAG,IAAIrZ,EAAE,CAACqc,KAAK,GAAGlQ,IAAI,GAAGu8E,KAAK,GAAGC,IAAI,GAAG15F,KAAK,IAAI,GAAG,IAAIoqB,EAAE7oB,OAAO,OAAOwP,EAAE,IAAIJ,EAAExL,EAAEilB,EAAEof,WAAW,GAAGniC,EAAE,KAAKlC,EAAEkC,GAAG0J,EAAEqc,KAAK,IAAIzc,EAAE,GAAGA,EAAE,EAAE,IAAI,IAAIzL,GAAG,EAAE0iB,EAAE,EAAE+uD,GAAG,EAAErjE,GAAE,EAAGya,EAAE3D,EAAE7oB,OAAO,EAAE6D,EAAE,EAAE2oB,GAAGpd,IAAIod,EAAE,GAAG,MAAM5oB,EAAEilB,EAAEof,WAAWzb,KAAK,IAAI4oD,IAAIrjE,GAAE,EAAGqjE,EAAE5oD,EAAE,GAAG,KAAK5oB,GAAG,IAAID,EAAEA,EAAE6oB,EAAE,IAAI3oB,IAAIA,EAAE,IAAI,IAAIF,IAAIE,GAAG,QAAQ,IAAIkO,EAAE,CAACsU,EAAEmG,EAAE,EAAE,KAAK,CAAC,OAAO,IAAI7oB,IAAI,IAAIyxE,GAAG,IAAIvxE,GAAG,IAAIA,GAAGF,IAAIyxE,EAAE,GAAGzxE,IAAI0iB,EAAE,GAAG,IAAI+uD,IAAI5lE,EAAE0oF,KAAK1oF,EAAE/Q,KAAK,IAAI4nB,GAAGvgB,EAAE+iB,EAAE3a,MAAM,EAAEknE,GAAGvsD,EAAE3a,MAAMmY,EAAE+uD,KAAK,IAAI/uD,GAAGvgB,GAAG0J,EAAE/Q,KAAKoqB,EAAE3a,MAAM,EAAEvK,GAAG6L,EAAE0oF,KAAKrvE,EAAE3a,MAAM,EAAEknE,KAAK5lE,EAAE/Q,KAAKoqB,EAAE3a,MAAMmY,EAAE1iB,GAAG6L,EAAE0oF,KAAKrvE,EAAE3a,MAAMmY,EAAE+uD,IAAI5lE,EAAE2oF,IAAItvE,EAAE3a,MAAMvK,EAAEyxE,IAAI/uD,EAAE,EAAE7W,EAAEmM,IAAIkN,EAAE3a,MAAM,EAAEmY,EAAE,GAAGvgB,IAAI0J,EAAEmM,IAAI,KAAKnM,CAAC,EAAE8mB,IAAI,IAAI8hE,UAAU,IAAIC,MAAM,KAAKC,MAAM,MAAMlpF,EAAEkpF,MAAMlpF,EAAEyZ,EAAEkiE,QAAQ37E,IAAItR,EAAE,CAAC,EAAE,SAAS0R,EAAEJ,GAAG,IAAIxL,EAAE9F,EAAEsR,GAAG,QAAG,IAASxL,EAAE,OAAOA,EAAEmnF,QAAQ,IAAIjlF,EAAEhI,EAAEsR,GAAG,CAAC27E,QAAQ,CAAC,GAAG,OAAOliE,EAAEzZ,GAAGtJ,EAAEA,EAAEilF,QAAQv7E,GAAG1J,EAAEilF,OAAO,CAACv7E,EAAE+oF,EAAE,CAAC1vE,EAAE/qB,KAAK,IAAI,IAAIsR,KAAKtR,EAAE0R,EAAE1J,EAAEhI,EAAEsR,KAAKI,EAAE1J,EAAE+iB,EAAEzZ,IAAInL,OAAO8wD,eAAelsC,EAAEzZ,EAAE,CAAC4lD,YAAW,EAAG1yD,IAAIxE,EAAEsR,IAAG,EAAGI,EAAE1J,EAAE,CAAC+iB,EAAE/qB,IAAImG,OAAOwK,UAAUC,eAAeP,KAAK0a,EAAE/qB,GAAG0R,EAAEA,EAAEqZ,IAAI,oBAAoB0pD,QAAQA,OAAOimB,aAAav0F,OAAO8wD,eAAelsC,EAAE0pD,OAAOimB,YAAY,CAACn7F,MAAM,WAAW4G,OAAO8wD,eAAelsC,EAAE,aAAa,CAACxrB,OAAM,GAAG,EAAG,IAAI+R,EAAE,CAAC,EAAE,MAAM,IAAIyZ,EAAE,GAAGrZ,EAAEA,EAAEJ,GAAGI,EAAE+oF,EAAEnpF,EAAE,CAACqpF,IAAI,IAAIjsE,EAAEksE,MAAM,IAAIC,IAAI,iBAAiB9K,QAAQhlE,EAAE,UAAUglE,QAAQ+K,cAAc,GAAG,iBAAiBC,UAAU,CAAC,IAAI/6F,EAAE+6F,UAAUC,UAAUjwE,EAAE/qB,EAAEia,QAAQ,YAAY,CAAC,CAAC,MAAMja,EAAE,iBAAiB8F,EAAE,MAAMkC,EAAE,QAAQ,SAASnC,EAAEklB,EAAErZ,GAAG,IAAIqZ,EAAEkwE,QAAQvpF,EAAE,MAAM,IAAIlM,MAAM,2DAA2DulB,EAAEmwE,sBAAsBnwE,EAAEjE,kBAAkBiE,EAAEowE,sBAAsBpwE,EAAEmtD,cAAc,GAAGntD,EAAEkwE,SAASj7F,EAAE8wC,KAAK/lB,EAAEkwE,QAAQ,MAAM,IAAIz1F,MAAM,mDAAmD,GAAGulB,EAAEjE,KAAK,GAAGiE,EAAEmwE,WAAW,IAAIp1F,EAAEgrC,KAAK/lB,EAAEjE,MAAM,MAAM,IAAIthB,MAAM,iJAAiJ,GAAGwC,EAAE8oC,KAAK/lB,EAAEjE,MAAM,MAAM,IAAIthB,MAAM,4HAA4H,CAAC,MAAM+iB,EAAE,GAAG+uD,EAAE,IAAIrjE,EAAE,+DAA+D,MAAMya,EAAE,YAAO0sE,CAAMrwE,GAAG,OAAOA,aAAa2D,KAAK3D,GAAG,iBAAiBA,EAAEmwE,WAAW,iBAAiBnwE,EAAEmtD,UAAU,iBAAiBntD,EAAEjE,MAAM,iBAAiBiE,EAAEowE,OAAO,iBAAiBpwE,EAAEkwE,QAAQ,iBAAiBlwE,EAAEswE,QAAQ,mBAAmBtwE,EAAEuwE,MAAM,mBAAmBvwE,EAAE9G,QAAQ,CAACg3E,OAAOC,UAAUp0E,KAAKq0E,MAAMjjB,SAAS,WAAA1iE,CAAYuV,EAAE/qB,EAAE0R,EAAEJ,EAAExL,EAAEkC,GAAE,GAAI,iBAAiB+iB,GAAGne,KAAKquF,OAAOlwE,EAAEkwE,QAAQ1yE,EAAE3b,KAAKsuF,UAAUnwE,EAAEmwE,WAAW3yE,EAAE3b,KAAKka,KAAKiE,EAAEjE,MAAMyB,EAAE3b,KAAKuuF,MAAMpwE,EAAEowE,OAAO5yE,EAAE3b,KAAKsrE,SAASntD,EAAEmtD,UAAU3vD,IAAI3b,KAAKquF,OAAO,SAASlwE,EAAE/qB,GAAG,OAAO+qB,GAAG/qB,EAAE+qB,EAAE,MAAM,CAAlC,CAAoCA,EAAE/iB,GAAG4E,KAAKsuF,UAAUl7F,GAAGuoB,EAAE3b,KAAKka,KAAK,SAASiE,EAAE/qB,GAAG,OAAO+qB,GAAG,IAAI,QAAQ,IAAI,OAAO,IAAI,OAAO/qB,EAAEA,EAAE,KAAKs3E,IAAIt3E,EAAEs3E,EAAEt3E,GAAGA,EAAEs3E,EAAE,OAAOt3E,CAAC,CAA1F,CAA4F4M,KAAKquF,OAAOvpF,GAAG6W,GAAG3b,KAAKuuF,MAAM7pF,GAAGiX,EAAE3b,KAAKsrE,SAASpyE,GAAGyiB,EAAE1iB,EAAE+G,KAAK5E,GAAG,CAAC,UAAIqzF,GAAS,OAAOE,EAAE3uF,MAAK,EAAG,CAAC,KAAKme,GAAG,IAAIA,EAAE,OAAOne,KAAK,IAAIquF,OAAOj7F,EAAEk7F,UAAUxpF,EAAEoV,KAAKxV,EAAE6pF,MAAMr1F,EAAEoyE,SAASlwE,GAAG+iB,EAAE,YAAO,IAAS/qB,EAAEA,EAAE4M,KAAKquF,OAAO,OAAOj7F,IAAIA,EAAEuoB,QAAG,IAAS7W,EAAEA,EAAE9E,KAAKsuF,UAAU,OAAOxpF,IAAIA,EAAE6W,QAAG,IAASjX,EAAEA,EAAE1E,KAAKka,KAAK,OAAOxV,IAAIA,EAAEiX,QAAG,IAASziB,EAAEA,EAAE8G,KAAKuuF,MAAM,OAAOr1F,IAAIA,EAAEyiB,QAAG,IAASvgB,EAAEA,EAAE4E,KAAKsrE,SAAS,OAAOlwE,IAAIA,EAAEugB,GAAGvoB,IAAI4M,KAAKquF,QAAQvpF,IAAI9E,KAAKsuF,WAAW5pF,IAAI1E,KAAKka,MAAMhhB,IAAI8G,KAAKuuF,OAAOnzF,IAAI4E,KAAKsrE,SAAStrE,KAAK,IAAIxE,EAAEpI,EAAE0R,EAAEJ,EAAExL,EAAEkC,EAAE,CAAC,YAAO2H,CAAMob,EAAE/qB,GAAE,GAAI,MAAM0R,EAAEuC,EAAEoC,KAAK0U,GAAG,OAAOrZ,EAAE,IAAItJ,EAAEsJ,EAAE,IAAI6W,EAAEizE,EAAE9pF,EAAE,IAAI6W,GAAGizE,EAAE9pF,EAAE,IAAI6W,GAAGizE,EAAE9pF,EAAE,IAAI6W,GAAGizE,EAAE9pF,EAAE,IAAI6W,GAAGvoB,GAAG,IAAIoI,EAAEmgB,EAAEA,EAAEA,EAAEA,EAAEA,EAAE,CAAC,WAAOkzE,CAAKz7F,GAAG,IAAI0R,EAAE6W,EAAE,GAAGwC,IAAI/qB,EAAEA,EAAE8T,QAAQ,MAAMwjE,IAAIt3E,EAAE,KAAKs3E,GAAGt3E,EAAE,KAAKs3E,EAAE,CAAC,MAAMvsD,EAAE/qB,EAAEia,QAAQq9D,EAAE,IAAI,IAAIvsD,GAAGrZ,EAAE1R,EAAE0H,UAAU,GAAG1H,EAAEs3E,IAAI5lE,EAAE1R,EAAE0H,UAAU,EAAEqjB,GAAG/qB,EAAEA,EAAE0H,UAAUqjB,IAAIusD,EAAE,CAAC,OAAO,IAAIlvE,EAAE,OAAOsJ,EAAE1R,EAAEuoB,EAAEA,EAAE,CAAC,WAAOygB,CAAKje,GAAG,MAAM/qB,EAAE,IAAIoI,EAAE2iB,EAAEkwE,OAAOlwE,EAAEmwE,UAAUnwE,EAAEjE,KAAKiE,EAAEowE,MAAMpwE,EAAEmtD,UAAU,OAAOryE,EAAE7F,GAAE,GAAIA,CAAC,CAAC,QAAAikB,CAAS8G,GAAE,GAAI,OAAO5C,EAAEvb,KAAKme,EAAE,CAAC,MAAA2wE,GAAS,OAAO9uF,IAAI,CAAC,aAAO+uF,CAAO5wE,GAAG,GAAGA,EAAE,CAAC,GAAGA,aAAa2D,EAAE,OAAO3D,EAAE,CAAC,MAAM/qB,EAAE,IAAIoI,EAAE2iB,GAAG,OAAO/qB,EAAE47F,WAAW7wE,EAAE8wE,SAAS77F,EAAE87F,QAAQ/wE,EAAEgxE,OAAOh2F,EAAEglB,EAAEswE,OAAO,KAAKr7F,CAAC,CAAC,CAAC,OAAO+qB,CAAC,EAAE,MAAMhlB,EAAEglB,EAAE,OAAE,EAAO,MAAM3iB,UAAUsmB,EAAEktE,WAAW,KAAKE,QAAQ,KAAK,UAAIT,GAAS,OAAOzuF,KAAKkvF,UAAUlvF,KAAKkvF,QAAQP,EAAE3uF,MAAK,IAAKA,KAAKkvF,OAAO,CAAC,QAAA73E,CAAS8G,GAAE,GAAI,OAAOA,EAAE5C,EAAEvb,MAAK,IAAKA,KAAKgvF,aAAahvF,KAAKgvF,WAAWzzE,EAAEvb,MAAK,IAAKA,KAAKgvF,WAAW,CAAC,MAAAF,GAAS,MAAM3wE,EAAE,CAACixE,KAAK,GAAG,OAAOpvF,KAAKkvF,UAAU/wE,EAAEswE,OAAOzuF,KAAKkvF,QAAQ/wE,EAAEgxE,KAAKh2F,GAAG6G,KAAKgvF,aAAa7wE,EAAE8wE,SAASjvF,KAAKgvF,YAAYhvF,KAAKka,OAAOiE,EAAEjE,KAAKla,KAAKka,MAAMla,KAAKquF,SAASlwE,EAAEkwE,OAAOruF,KAAKquF,QAAQruF,KAAKsuF,YAAYnwE,EAAEmwE,UAAUtuF,KAAKsuF,WAAWtuF,KAAKuuF,QAAQpwE,EAAEowE,MAAMvuF,KAAKuuF,OAAOvuF,KAAKsrE,WAAWntD,EAAEmtD,SAAStrE,KAAKsrE,UAAUntD,CAAC,EAAE,MAAMxG,EAAE,CAAC,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,SAASk2E,EAAE1vE,EAAE/qB,EAAE0R,GAAG,IAAIJ,EAAExL,GAAG,EAAE,IAAI,IAAIkC,EAAE,EAAEA,EAAE+iB,EAAE7oB,OAAO8F,IAAI,CAAC,MAAMnC,EAAEklB,EAAEof,WAAWniC,GAAG,GAAGnC,GAAG,IAAIA,GAAG,KAAKA,GAAG,IAAIA,GAAG,IAAIA,GAAG,IAAIA,GAAG,IAAI,KAAKA,GAAG,KAAKA,GAAG,KAAKA,GAAG,MAAMA,GAAG7F,GAAG,KAAK6F,GAAG6L,GAAG,KAAK7L,GAAG6L,GAAG,KAAK7L,GAAG6L,GAAG,KAAK7L,GAAG,IAAIC,IAAIwL,GAAG2qF,mBAAmBlxE,EAAErjB,UAAU5B,EAAEkC,IAAIlC,GAAG,QAAG,IAASwL,IAAIA,GAAGyZ,EAAEusB,OAAOtvC,QAAQ,MAAC,IAASsJ,IAAIA,EAAEyZ,EAAEzX,OAAO,EAAEtL,IAAI,MAAMhI,EAAEukB,EAAE1e,QAAG,IAAS7F,IAAI,IAAI8F,IAAIwL,GAAG2qF,mBAAmBlxE,EAAErjB,UAAU5B,EAAEkC,IAAIlC,GAAG,GAAGwL,GAAGtR,IAAI,IAAI8F,IAAIA,EAAEkC,EAAE,CAAC,CAAC,OAAO,IAAIlC,IAAIwL,GAAG2qF,mBAAmBlxE,EAAErjB,UAAU5B,UAAK,IAASwL,EAAEA,EAAEyZ,CAAC,CAAC,SAASpZ,EAAEoZ,GAAG,IAAI/qB,EAAE,IAAI,IAAI0R,EAAE,EAAEA,EAAEqZ,EAAE7oB,OAAOwP,IAAI,CAAC,MAAMJ,EAAEyZ,EAAEof,WAAWz4B,GAAG,KAAKJ,GAAG,KAAKA,QAAG,IAAStR,IAAIA,EAAE+qB,EAAEzX,OAAO,EAAE5B,IAAI1R,GAAGukB,EAAEjT,SAAI,IAAStR,IAAIA,GAAG+qB,EAAErZ,GAAG,CAAC,YAAO,IAAS1R,EAAEA,EAAE+qB,CAAC,CAAC,SAASwwE,EAAEv7F,EAAE0R,GAAG,IAAIJ,EAAE,OAAOA,EAAEtR,EAAEk7F,WAAWl7F,EAAE8mB,KAAK5kB,OAAO,GAAG,SAASlC,EAAEi7F,OAAO,KAAKj7F,EAAEk7F,YAAYl7F,EAAE8mB,OAAO,KAAK9mB,EAAE8mB,KAAKqjB,WAAW,KAAKnqC,EAAE8mB,KAAKqjB,WAAW,IAAI,IAAInqC,EAAE8mB,KAAKqjB,WAAW,IAAI,IAAInqC,EAAE8mB,KAAKqjB,WAAW,IAAI,IAAInqC,EAAE8mB,KAAKqjB,WAAW,IAAI,MAAM,KAAKnqC,EAAE8mB,KAAKqjB,WAAW,GAAGz4B,EAAE1R,EAAE8mB,KAAKxT,OAAO,GAAGtT,EAAE8mB,KAAK,GAAGriB,cAAczE,EAAE8mB,KAAKxT,OAAO,GAAGtT,EAAE8mB,KAAKiE,IAAIzZ,EAAEA,EAAEwC,QAAQ,MAAM,OAAOxC,CAAC,CAAC,SAAS6W,EAAE4C,EAAE/qB,GAAG,MAAM0R,EAAE1R,EAAE2R,EAAE8oF,EAAE,IAAInpF,EAAE,IAAI2pF,OAAOn1F,EAAEo1F,UAAUlzF,EAAE8e,KAAKjhB,EAAEs1F,MAAM5yE,EAAE2vD,SAASjkE,GAAG8W,EAAE,GAAGjlB,IAAIwL,GAAGxL,EAAEwL,GAAG,MAAMtJ,GAAG,SAASlC,KAAKwL,GAAGgmE,EAAEhmE,GAAGgmE,GAAGtvE,EAAE,CAAC,IAAI+iB,EAAE/iB,EAAEiS,QAAQ,KAAK,IAAI,IAAI8Q,EAAE,CAAC,MAAM/qB,EAAEgI,EAAEsL,OAAO,EAAEyX,GAAG/iB,EAAEA,EAAEsL,OAAOyX,EAAE,GAAGA,EAAE/qB,EAAEyH,YAAY,MAAM,IAAIsjB,EAAEzZ,GAAGI,EAAE1R,GAAE,GAAG,IAAKsR,GAAGI,EAAE1R,EAAEsT,OAAO,EAAEyX,IAAG,GAAG,GAAIzZ,GAAG,IAAIA,GAAGI,EAAE1R,EAAEsT,OAAOyX,EAAE,IAAG,GAAG,IAAKzZ,GAAG,GAAG,CAACtJ,EAAEA,EAAEvD,cAAcsmB,EAAE/iB,EAAEP,YAAY,MAAM,IAAIsjB,EAAEzZ,GAAGI,EAAE1J,GAAE,GAAG,IAAKsJ,GAAGI,EAAE1J,EAAEsL,OAAO,EAAEyX,IAAG,GAAG,GAAIzZ,GAAGtJ,EAAEsL,OAAOyX,GAAG,CAAC,GAAGllB,EAAE,CAAC,GAAGA,EAAE3D,QAAQ,GAAG,KAAK2D,EAAEskC,WAAW,IAAI,KAAKtkC,EAAEskC,WAAW,GAAG,CAAC,MAAMpf,EAAEllB,EAAEskC,WAAW,GAAGpf,GAAG,IAAIA,GAAG,KAAKllB,EAAE,IAAIkkC,OAAOC,aAAajf,EAAE,OAAOllB,EAAEyN,OAAO,KAAK,MAAM,GAAGzN,EAAE3D,QAAQ,GAAG,KAAK2D,EAAEskC,WAAW,GAAG,CAAC,MAAMpf,EAAEllB,EAAEskC,WAAW,GAAGpf,GAAG,IAAIA,GAAG,KAAKllB,EAAE,GAAGkkC,OAAOC,aAAajf,EAAE,OAAOllB,EAAEyN,OAAO,KAAK,CAAChC,GAAGI,EAAE7L,GAAE,GAAG,EAAG,CAAC,OAAO0iB,IAAIjX,GAAG,IAAIA,GAAGI,EAAE6W,GAAE,GAAG,IAAKtU,IAAI3C,GAAG,IAAIA,GAAGtR,EAAEiU,EAAEwmF,EAAExmF,GAAE,GAAG,IAAK3C,CAAC,CAAC,SAASpJ,EAAE6iB,GAAG,IAAI,OAAOmxE,mBAAmBnxE,EAAE,CAAC,MAAM,OAAOA,EAAE7oB,OAAO,EAAE6oB,EAAEzX,OAAO,EAAE,GAAGpL,EAAE6iB,EAAEzX,OAAO,IAAIyX,CAAC,CAAC,CAAC,MAAM6S,EAAE,8BAA8B,SAAS49D,EAAEzwE,GAAG,OAAOA,EAAE5Y,MAAMyrB,GAAG7S,EAAEjX,QAAQ8pB,GAAG7S,GAAG7iB,EAAE6iB,KAAKA,CAAC,CAAC,IAAIoxE,EAAEzqF,EAAE,KAAK,MAAMuT,EAAEk3E,EAAE3B,OAAO2B,EAAEj0E,EAAE,IAAI,IAAI2yE,GAAG,SAAS9vE,GAAGA,EAAEqxE,SAAS,SAASrxE,KAAK/qB,GAAG,OAAO+qB,EAAEuwE,KAAK,CAACx0E,KAAK7B,EAAE3e,KAAKykB,EAAEjE,QAAQ9mB,IAAI,EAAE+qB,EAAEsxE,YAAY,SAAStxE,KAAK/qB,GAAG,IAAI0R,EAAEqZ,EAAEjE,KAAKxV,GAAE,EAAGI,EAAE,KAAKwW,IAAIxW,EAAEwW,EAAExW,EAAEJ,GAAE,GAAI,IAAIxL,EAAEmf,EAAEy0E,QAAQhoF,KAAK1R,GAAG,OAAOsR,GAAGxL,EAAE,KAAKoiB,IAAI6C,EAAEmwE,YAAYp1F,EAAEA,EAAE4B,UAAU,IAAIqjB,EAAEuwE,KAAK,CAACx0E,KAAKhhB,GAAG,EAAEilB,EAAEivE,QAAQ,SAASjvE,GAAG,GAAG,IAAIA,EAAEjE,KAAK5kB,QAAQ6oB,EAAEjE,OAAOoB,EAAE,OAAO6C,EAAE,IAAI/qB,EAAEilB,EAAE+0E,QAAQjvE,EAAEjE,MAAM,OAAO,IAAI9mB,EAAEkC,QAAQ,KAAKlC,EAAEmqC,WAAW,KAAKnqC,EAAE,IAAI+qB,EAAEuwE,KAAK,CAACx0E,KAAK9mB,GAAG,EAAE+qB,EAAEkvE,SAAS,SAASlvE,GAAG,OAAO9F,EAAEg1E,SAASlvE,EAAEjE,KAAK,EAAEiE,EAAEmvE,QAAQ,SAASnvE,GAAG,OAAO9F,EAAEi1E,QAAQnvE,EAAEjE,KAAK,CAAC,CAAvf,CAAyf+zE,IAAIA,EAAE,CAAC,GAAI,EAAx6L,GAA46LpB,EAAInoF,CAAE,EAA36U,GAAs7U,MAAK,IAACqpF,EAAG,MAACC,GAAOnB,C,+CC4B/8U,IAJA,SAAiBh3E,EAAYK,GAC3B,OAAO,QAAY,OAAIL,EAAYK,GAAW,EAChD,C,mGCTIw5E,EAAmB,cAAc,aAEjC,QAAO1vF,KAAM,mBACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,OAAQ,YACjB,GAIEg9D,EAAa,CACfx0F,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAI68D,GAAoB,gBACnE58D,gBAAgC,SAAO,IAAM,IAAI,MAAwB,oBAG7E,SAAS88D,EAAmB58D,EAAU,KACpC,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIk0D,GAAO,SACX,OAAwB,CAAEj0D,WAC1B,KACA08D,GAGF,OADA18D,EAAOE,gBAAgBC,SAAS8zD,GACzB,CAAEj0D,SAAQi0D,OACnB,EACA,QAAO0I,EAAoB,qB,qBCnC3B,SAAStL,EAAO3xF,GACZ,MAAwB,iBAAVA,GAAsBA,aAAiBwqC,MACzD,CAcA,SAAS9mB,EAAM1jB,GACX,OAAO6R,MAAMyK,QAAQtc,EACzB,CAxBA4G,OAAO8wD,eAAeg2B,EAAS,aAAc,CAAE1tF,OAAO,IACtD0tF,EAAQwP,YAAcxP,EAAQhqE,MAAQgqE,EAAQjmE,KAAOimE,EAAQv9E,MAAQu9E,EAAQlB,OAASkB,EAAQiE,OAASjE,EAAQyP,aAAU,EAIzHzP,EAAQyP,QAHR,SAAiBn9F,GACb,OAAiB,IAAVA,IAA4B,IAAVA,CAC7B,EAKA0tF,EAAQiE,OAASA,EAIjBjE,EAAQlB,OAHR,SAAgBxsF,GACZ,MAAwB,iBAAVA,GAAsBA,aAAiBmrB,MACzD,EAKAuiE,EAAQv9E,MAHR,SAAenQ,GACX,OAAOA,aAAiBiG,KAC5B,EAKAynF,EAAQjmE,KAHR,SAAcznB,GACV,MAAwB,mBAAVA,CAClB,EAKA0tF,EAAQhqE,MAAQA,EAIhBgqE,EAAQwP,YAHR,SAAqBl9F,GACjB,OAAO0jB,EAAM1jB,IAAUA,EAAM81E,OAAM93D,GAAQ2zE,EAAO3zE,IACtD,C,qCCEA,IAPA,SAAmBhe,GACjB,IAAI4D,GAAS,OAAS5D,GAClBo9F,EAAYx5F,EAAS,EAEzB,OAAOA,GAAWA,EAAUw5F,EAAYx5F,EAASw5F,EAAYx5F,EAAU,CACzE,C,qHC8BIy5F,EAAU,CAAC,EACXC,EAAe,CACjBl7E,MAAsB,SAAOH,UAC3B,MAAQg7E,mBAAoBM,SAA8B,+BACpD/0F,EAAS+0F,IAAsBhJ,KAAK/rF,OAAOg1F,cACjDH,EAAQj7E,KAAO5Z,CAAM,GACpB,QACHi1F,QAAwB,SAAOx7E,UAC7B,MAAQy7E,qBAAsBC,SAAgC,8BACxDn1F,EAASm1F,IAAwBjJ,OAAOlsF,OAAOg1F,cACrDH,EAAQI,OAASj1F,CAAM,GACtB,UACHo1F,KAAqB,SAAO37E,UAC1B,MAAQg4E,kBAAmB4D,SAA6B,+BAClDr1F,EAASq1F,IAAqBjJ,IAAIpsF,OAAOg1F,cAC/CH,EAAQO,IAAMp1F,CAAM,GACnB,OACHs1F,cAA8B,SAAO77E,UACnC,MAAQ87E,2BAA4BC,SAAsC,+BACpEx1F,EAASw1F,IAA8BpK,aAAaprF,OAAOg1F,cACjEH,EAAQS,aAAet1F,CAAM,GAC5B,gBACHy1F,UAA0B,SAAOh8E,UAC/B,MAAQ43E,uBAAwBqE,SAAkC,+BAC5D11F,EAAS01F,IAA0B5J,SAAS9rF,OAAOg1F,cACzDH,EAAQY,SAAWz1F,CAAM,GACxB,YACH21F,OAAuB,SAAOl8E,UAC5B,MAAQme,oBAAqBg+D,SAA+B,+BACtD51F,EAAS41F,IAAuB79D,MAAM/3B,OAAOg1F,cACnDH,EAAQc,MAAQ31F,CAAM,GACrB,UAELyZ,eAAe7R,EAAMiuF,EAAa1rF,GAChC,MAAMuxC,EAAco5C,EAAae,GACjC,IAAKn6C,EACH,MAAM,IAAIj+C,MAAM,yBAAyBo4F,KAEtChB,EAAQgB,UACLn6C,IAER,MACMtgD,EADSy5F,EAAQgB,GACDjuF,MAAMuC,GAC5B,GAAI/O,EAAO06F,YAAY37F,OAAS,GAAKiB,EAAO26F,aAAa57F,OAAS,EAChE,MAAM,IAAI67F,EAAkB56F,GAE9B,OAAOA,EAAO5D,KAChB,EACA,QAAOoQ,EAAO,SACd,IAAIouF,EAAoB,cAAcv4F,MACpC,WAAAgQ,CAAYrS,GAGVo8B,MAAM,mBAFcp8B,EAAO06F,YAAYx3F,KAAK23F,GAAQA,EAAIz1D,UAASjiC,KAAK,SACjDnD,EAAO26F,aAAaz3F,KAAK23F,GAAQA,EAAIz1D,UAASjiC,KAAK,SAExEsG,KAAKzJ,OAASA,CAChB,SAEE,QAAOyJ,KAAM,oBACf,E,mGCxGEqxF,EAA2B,cAAc,aAEzC,QAAOrxF,KAAM,2BACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,gBACT,GAIE2+D,EAA6B,cAAc,aAE3C,QAAOtxF,KAAM,6BACf,CACA,kBAAA6pF,CAAmBj2F,EAAMoP,EAAO8mF,GAC9B,MAAkB,cAAdl2F,EAAKG,KACAiP,EAAMkE,QAAQ,QAAS,IAAI7G,OACX,mBAAdzM,EAAKG,KACPiP,EAAMkE,QAAQ,SAAU,IACR,eAAdtT,EAAKG,KACPiP,EAAMkE,QAAQ,SAAU,IAAI7G,YAD9B,CAIT,GAIEkxF,EAAqB,CACvBp2F,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAIw+D,GAA4B,gBAC3Ev+D,gBAAgC,SAAO,IAAM,IAAIw+D,GAA8B,oBAGnF,SAASZ,EAA2B19D,EAAU,KAC5C,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIuzD,GAAe,SACnB,OAAwB,CAAEtzD,WAC1B,KACAs+D,GAGF,OADAt+D,EAAOE,gBAAgBC,SAASmzD,GACzB,CAAEtzD,SAAQszD,eACnB,EACA,QAAOmK,EAA4B,6B,4JCvD5B,SAASc,EAAY59F,EAAMa,EAAMwgD,GACpC,MAAO,GAAGrhD,EAAKG,QAAQU,KAAQwgD,GACnC,CAcO,MAAMw8C,EACT,WAAA7oF,CAAYiH,GACR7P,KAAK6P,OAASA,CAClB,CACA,SAAA6hF,GACI,OAAO,CACX,EAEG,MAAMC,UAAuBF,EAChC,WAAA7oF,CAAYiH,EAAQoyB,GAChBtP,MAAM9iB,GACN7P,KAAKiiC,UAAYA,CACrB,EAEG,MAAM2vD,UAA0BH,EACnC,WAAA7oF,CAAYiH,GACR8iB,MAAM9iB,EACV,CACA,SAAA6hF,GACI,OAAO,CACX,EAEG,MAAMG,UAAuBJ,EAChC,WAAA7oF,CAAYkpF,EAAWl+F,EAAMm+F,GACzBp/D,MAAMm/D,GACN9xF,KAAKpM,KAAOA,EACZoM,KAAK+xF,YAAcA,CACvB,CACA,SAAAL,GACI,OAAO,CACX,EAEG,SAASM,EAAU9+F,GACtB,MAAM++F,EAAM,CACRC,YAAa,CAAC,EACdC,eAAgB,GAChBC,iBAAkB,IAAI96F,IACtB+6F,gBAAiB,IAAI/6F,IACrBu5E,OAAQ,KAchB,SAAyCohB,EAAK/+F,GAC1C,MAAMo/F,EAAap/F,EAAMoC,OACzB,IAAK,IAAI4D,EAAI,EAAGA,EAAIo5F,EAAYp5F,IAAK,CACjC,MAAMtF,EAAOV,EAAMgG,GACbyZ,EAAQ1N,EAASgtF,EAAKr+F,OAAM2B,EAAW,CACzCd,KApEkB,IAsEhB89F,EAAOttF,EAASgtF,EAAKr+F,OAAM2B,EAAW,CACxCd,KAlEiB,IAoErBke,EAAM4/E,KAAOA,EACbN,EAAIG,iBAAiBz6F,IAAI/D,EAAM+e,GAC/Bs/E,EAAII,gBAAgB16F,IAAI/D,EAAM2+F,EAClC,CACJ,CA1BIC,CAAgCP,EAAK/+F,GACrC,MAAMo/F,EAAap/F,EAAMoC,OACzB,IAAK,IAAI4D,EAAI,EAAGA,EAAIo5F,EAAYp5F,IAAK,CACjC,MAAMtF,EAAOV,EAAMgG,GACbu5F,EAAYC,EAAMT,EAAKr+F,EAAMA,QACjB2B,IAAdk9F,GAGJE,EAAgBV,EAAKr+F,EAAM6+F,EAC/B,CACA,OAAOR,CACX,CAgBA,SAASl2D,EAAKk2D,EAAKr+F,EAAMg/F,GACrB,OAAIA,aAAsB,KACfC,EAASZ,EAAKr+F,EAAMg/F,EAAWh9D,aAAcg9D,GAE/CA,aAAsB,KAoQnC,SAAiBX,EAAKa,EAAaC,GAC/B,MAAMn/F,EAAOm/F,EAAYr+D,eACnB/hB,EAAQs/E,EAAIG,iBAAiBx6F,IAAIhE,GACjC0G,EAAO2K,EAASgtF,EAAKa,EAAaC,EAAa,CACjDt+F,KA3ViB,IA6Vf2F,EAAQ6K,EAASgtF,EAAKa,EAAaC,EAAa,CAClDt+F,KA9ViB,IAgWfgP,EAAO,IAAIouF,EAAel/E,EAAO/e,EAAMwG,GAE7C,OADA44F,EAAc14F,EAAMmJ,GACb,CACHnJ,OACAF,QAER,CAlRe64F,CAAQhB,EAAKr+F,EAAMg/F,GAErBA,aAAsB,KAwDnC,SAAqBX,EAAKr+F,EAAMshD,GAC5B,MAAMviC,EAAQ1N,EAASgtF,EAAKr+F,EAAMshD,EAAa,CAC3CzgD,KAhJiB,IAkJrBy+F,EAAoBjB,EAAKt/E,GACzB,MAAMgpC,GAAO,EAAAliD,EAAA,GAAIy7C,EAAY/8C,YAAa/E,GAAM2oC,EAAKk2D,EAAKr+F,EAAMR,KAC1D+/F,EAASC,EAASnB,EAAKr+F,EAAM+e,EAAOuiC,KAAgByG,GAC1D,OAAOw3C,CACX,CA/Dej+C,CAAY+8C,EAAKr+F,EAAMg/F,GAEzBA,aAAsB,KA8DnC,SAAgBX,EAAKr+F,EAAM6uD,GACvB,MAAM9vC,EAAQ1N,EAASgtF,EAAKr+F,EAAM6uD,EAAQ,CACtChuD,KAzJiB,IA2JrBy+F,EAAoBjB,EAAKt/E,GACzB,MAAMwgF,EAASC,EAASnB,EAAKr+F,EAAM+e,EAAO8vC,EAAQiwC,EAAMT,EAAKr+F,EAAM6uD,IACnE,OA8EJ,SAAkBwvC,EAAKr+F,EAAMy/F,EAAUF,GACnC,MAAMxgF,EAAQwgF,EAAO74F,KACfsY,EAAMugF,EAAO/4F,MAGnB,OAFAk5F,EAAQ3gF,EAAOC,GACfq/E,EAAIC,YAAYV,EAAY59F,EAAM,SAAUy/F,EAAS5+D,MAAQ9hB,EACtDwgF,CACX,CApFWE,CAASpB,EAAKr+F,EAAM6uD,EAAQ0wC,EACvC,CApEe,CAAOlB,EAAKr+F,EAAMg/F,GAEpBA,aAAsB,KAgBnC,SAAoBX,EAAKr+F,EAAM4hD,GAC3B,MAAM+9C,EAAYtuF,EAASgtF,EAAKr+F,EAAM4hD,EAAY,CAC9C/gD,KA3G4B,IA6GhCy+F,EAAoBjB,EAAKsB,GACzB,MAAMJ,EAASC,EAASnB,EAAKr+F,EAAM2/F,EAAW/9C,EAAYk9C,EAAMT,EAAKr+F,EAAM4hD,IAC3E,OAAOg+C,EAAKvB,EAAKr+F,EAAM4hD,EAAY29C,EACvC,CAtBe39C,CAAWy8C,EAAKr+F,EAAMg/F,GAExBA,aAAsB,KAqBnC,SAAuBX,EAAKr+F,EAAM4hD,GAC9B,MAAM+9C,EAAYtuF,EAASgtF,EAAKr+F,EAAM4hD,EAAY,CAC9C/gD,KAnH4B,IAqHhCy+F,EAAoBjB,EAAKsB,GACzB,MAAMJ,EAASC,EAASnB,EAAKr+F,EAAM2/F,EAAW/9C,EAAYk9C,EAAMT,EAAKr+F,EAAM4hD,IACrE5pB,EAAMinE,EAASZ,EAAKr+F,EAAM4hD,EAAW7f,UAAW6f,GACtD,OAAOg+C,EAAKvB,EAAKr+F,EAAM4hD,EAAY29C,EAAQvnE,EAC/C,CA5Be6nE,CAAcxB,EAAKr+F,EAAMg/F,GAE3BA,aAAsB,KA2BnC,SAA6BX,EAAKr+F,EAAM4hD,GACpC,MAAMk+C,EAAYzuF,EAASgtF,EAAKr+F,EAAM4hD,EAAY,CAC9C/gD,KA7H4B,IA+HhCy+F,EAAoBjB,EAAKyB,GACzB,MAAMP,EAASC,EAASnB,EAAKr+F,EAAM8/F,EAAWl+C,EAAYk9C,EAAMT,EAAKr+F,EAAM4hD,IAC3E,OAAOm+C,EAAK1B,EAAKr+F,EAAM4hD,EAAY29C,EACvC,CAjCexpC,CAAoBsoC,EAAKr+F,EAAMg/F,GAEjCA,aAAsB,KAgCnC,SAAgCX,EAAKr+F,EAAM4hD,GACvC,MAAMk+C,EAAYzuF,EAASgtF,EAAKr+F,EAAM4hD,EAAY,CAC9C/gD,KArI4B,IAuIhCy+F,EAAoBjB,EAAKyB,GACzB,MAAMP,EAASC,EAASnB,EAAKr+F,EAAM8/F,EAAWl+C,EAAYk9C,EAAMT,EAAKr+F,EAAM4hD,IACrE5pB,EAAMinE,EAASZ,EAAKr+F,EAAM4hD,EAAW7f,UAAW6f,GACtD,OAAOm+C,EAAK1B,EAAKr+F,EAAM4hD,EAAY29C,EAAQvnE,EAC/C,CAvCegoE,CAAuB3B,EAAKr+F,EAAMg/F,GAGlCF,EAAMT,EAAKr+F,EAAMg/F,EAEhC,CAoDA,SAASF,EAAMT,EAAKr+F,EAAM8+F,GACtB,MAAMmB,GAAU,EAAApgG,EAAA,IAAO,EAAAgG,EAAA,GAAIi5F,EAAMv6F,YAAa/E,GAAM2oC,EAAKk2D,EAAKr+F,EAAMR,MAAMA,QAAYmC,IAANnC,IAChF,OAAuB,IAAnBygG,EAAQv+F,OACDu+F,EAAQ,GAES,IAAnBA,EAAQv+F,YACb,EAgIR,SAAmB28F,EAAKt2C,GACpB,MAAMm4C,EAAan4C,EAAKrmD,OACxB,IAAK,IAAI4D,EAAI,EAAGA,EAAI46F,EAAa,EAAG56F,IAAK,CACrC,MAAMi6F,EAASx3C,EAAKziD,GACpB,IAAI0S,EACmC,IAAnCunF,EAAO74F,KAAKy5F,YAAYz+F,SACxBsW,EAAaunF,EAAO74F,KAAKy5F,YAAY,IAEzC,MAAMC,EAAmBpoF,aAAsBimF,EACzCoC,EAAiBroF,EACjBnV,EAAOklD,EAAKziD,EAAI,GAAGoB,KA/SR,IAgTb64F,EAAO74F,KAAK7F,MAhTC,IAiTb0+F,EAAO/4F,MAAM3F,WACEc,IAAfqW,IACEooF,GAAoBC,EAAelC,cAAgBoB,EAAO/4F,OACxDwR,EAAWiE,SAAWsjF,EAAO/4F,QAE7B45F,EACAC,EAAelC,YAAct7F,EAG7BmV,EAAWiE,OAASpZ,EAExBy9F,EAAYjC,EAAKkB,EAAO/4F,QAIxBk5F,EAAQH,EAAO/4F,MAAO3D,EAE9B,CACA,MAAMb,EAAQ+lD,EAAK,GACbp0B,EAAOo0B,EAAKm4C,EAAa,GAC/B,MAAO,CACHx5F,KAAM1E,EAAM0E,KACZF,MAAOmtB,EAAKntB,MAEpB,CAjKe+5F,CAAUlC,EAAK4B,EAE9B,CACA,SAASF,EAAK1B,EAAKr+F,EAAM+/F,EAAMR,EAAQvnE,GACnC,MAAMwoE,EAAWjB,EAAO74F,KAClB+5F,EAASlB,EAAO/4F,MAChBk6F,EAAOrvF,EAASgtF,EAAKr+F,EAAM+/F,EAAM,CACnCl/F,KArK0B,KAuK9By+F,EAAoBjB,EAAKqC,GACzB,MAAM1hF,EAAM3N,EAASgtF,EAAKr+F,EAAM+/F,EAAM,CAClCl/F,KAxKoB,KA0LxB,OAhBA2/F,EAASG,SAAWD,EACpB1hF,EAAI2hF,SAAWD,EACfrC,EAAIC,YAAYV,EAAY59F,EAAMg4B,EAAM,mCAAqC,sBAAuB+nE,EAAKl/D,MAAQ6/D,EACjHhB,EAAQe,EAAQC,QAGJ/+F,IAARq2B,GACA0nE,EAAQgB,EAAMF,GACdd,EAAQgB,EAAM1hF,KAGd0gF,EAAQgB,EAAM1hF,GAEd0gF,EAAQgB,EAAM1oE,EAAItxB,MAClBg5F,EAAQ1nE,EAAIxxB,MAAOg6F,IAEhB,CACH95F,KAAM85F,EACNh6F,MAAOwY,EAEf,CACA,SAAS4gF,EAAKvB,EAAKr+F,EAAM4/F,EAAML,EAAQvnE,GACnC,MAAMjZ,EAAQwgF,EAAO74F,KACfsY,EAAMugF,EAAO/4F,MACb/G,EAAQ4R,EAASgtF,EAAKr+F,EAAM4/F,EAAM,CACpC/+F,KArM2B,KAuM/By+F,EAAoBjB,EAAK5+F,GACzB,MAAMmhG,EAAUvvF,EAASgtF,EAAKr+F,EAAM4/F,EAAM,CACtC/+F,KAvMoB,KAyMlB6/F,EAAOrvF,EAASgtF,EAAKr+F,EAAM4/F,EAAM,CACnC/+F,KA7M0B,IA8N9B,OAfApB,EAAMkhG,SAAWD,EACjBE,EAAQD,SAAWD,EACnBhB,EAAQjgG,EAAOsf,GACf2gF,EAAQjgG,EAAOmhG,GACflB,EAAQ1gF,EAAK0hF,QACD/+F,IAARq2B,GACA0nE,EAAQgB,EAAME,GAEdlB,EAAQgB,EAAM1oE,EAAItxB,MAClBg5F,EAAQ1nE,EAAIxxB,MAAOuY,IAGnB2gF,EAAQgB,EAAMjhG,GAElB4+F,EAAIC,YAAYV,EAAY59F,EAAMg4B,EAAM,0BAA4B,aAAc4nE,EAAK/+D,MAAQphC,EACxF,CACHiH,KAAMjH,EACN+G,MAAOo6F,EAEf,CAQA,SAAStB,EAAoBjB,EAAKptF,GAG9B,OAFAotF,EAAIE,eAAev7F,KAAKiO,GACxBA,EAAM4vF,SAAWxC,EAAIE,eAAe78F,OAAS,EACtCuP,EAAM4vF,QACjB,CACA,SAASrB,EAASnB,EAAKr+F,EAAM+e,EAAOigF,KAAej3C,GAC/C,MAAM/oC,EAAM3N,EAASgtF,EAAKr+F,EAAMg/F,EAAY,CACxCn+F,KAlPqB,EAmPrBke,UAEJA,EAAMC,IAAMA,EACZ,IAAK,MAAM8lB,KAAOijB,OACFpmD,IAARmjC,GAEA46D,EAAQ3gF,EAAO+lB,EAAIp+B,MACnBg5F,EAAQ56D,EAAIt+B,MAAOwY,IAGnB0gF,EAAQ3gF,EAAOC,GAGvB,MAAMugF,EAAS,CACX74F,KAAMqY,EACNvY,MAAOwY,GAGX,OADAq/E,EAAIC,YAAYV,EAAY59F,EAGhC,SAAqBg/F,GACjB,GAAIA,aAAsB,KACtB,MAAO,cAEN,GAAIA,aAAsB,KAC3B,MAAO,SAEN,GAAIA,aAAsB,KAC3B,MAAO,aAEN,GAAIA,aAAsB,KAC3B,MAAO,0BAEN,GAAIA,aAAsB,KAC3B,MAAO,sBAEN,GAAIA,aAAsB,KAC3B,MAAO,mCAGP,MAAM,IAAIh6F,MAAM,sCAExB,CAzBsCkiD,CAAY83C,GAAaA,EAAWn+D,MAAQ9hB,EACvEwgF,CACX,CA6DA,SAASN,EAASZ,EAAKr+F,EAAMquC,EAAW2wD,GACpC,MAAMt4F,EAAO2K,EAASgtF,EAAKr+F,EAAMg/F,EAAY,CACzCn+F,KA5UiB,IA8Uf2F,EAAQ6K,EAASgtF,EAAKr+F,EAAMg/F,EAAY,CAC1Cn+F,KA/UiB,IAkVrB,OADAu+F,EAAc14F,EAAM,IAAIq3F,EAAev3F,EAAO6nC,IACvC,CACH3nC,OACAF,QAER,CAiBA,SAASu4F,EAAgBV,EAAKr+F,EAAM8+F,GAChC,MAAM//E,EAAQs/E,EAAIG,iBAAiBx6F,IAAIhE,GACvC0/F,EAAQ3gF,EAAO+/E,EAAMp4F,MACrB,MAAMi4F,EAAON,EAAII,gBAAgBz6F,IAAIhE,GACrC0/F,EAAQZ,EAAMt4F,MAAOm4F,GAKrB,MAJe,CACXj4F,KAAMqY,EACNvY,MAAOm4F,EAGf,CACA,SAASe,EAAQ5oB,EAAG15C,GAEhBgiE,EAActoB,EADK,IAAIknB,EAAkB5gE,GAE7C,CACA,SAAS/rB,EAASgtF,EAAKr+F,EAAMg/F,EAAY3P,GACrC,MAAM9kE,EAAI5kB,OAAOg2D,OAAO,CAAE0iC,MACtBW,aAAY8B,wBAAwB,EAAO9gG,OAAMmgG,YAAa,GAAIY,oBAAqB,GAAIC,YAAa3C,EAAIphB,OAAOv7E,QAAU2tF,GAEjI,OADAgP,EAAIphB,OAAOj6E,KAAKunB,GACTA,CACX,CACA,SAAS60E,EAAcnuF,EAAO+G,GAGO,IAA7B/G,EAAMkvF,YAAYz+F,SAClBuP,EAAM6vF,uBAAyB9oF,EAAW8lF,aAE9C7sF,EAAMkvF,YAAYn9F,KAAKgV,EAC3B,CACA,SAASsoF,EAAYjC,EAAKptF,GACtBotF,EAAIphB,OAAOsQ,OAAO8Q,EAAIphB,OAAOxjE,QAAQxI,GAAQ,EACjD,CC5YO,MAAMgwF,EAAY,CAAC,EACnB,MAAMC,EACT,WAAAlsF,GACI5I,KAAKvG,IAAM,CAAC,EACZuG,KAAK+0F,QAAU,EACnB,CACA,QAAI12E,GACA,OAAOre,KAAK+0F,QAAQz/F,MACxB,CACA,QAAA0/F,GAEIh1F,KAAKvG,IAAM,CAAC,CAChB,CACA,GAAAzF,CAAI8b,GACA,MAAMqG,EAAM8+E,EAAgBnlF,GAGtBqG,KAAOnW,KAAKvG,MACduG,KAAKvG,IAAI0c,GAAOnW,KAAK+0F,QAAQz/F,OAC7B0K,KAAK+0F,QAAQn+F,KAAKkZ,GAE1B,CACA,YAAI/V,GACA,OAAOiG,KAAK+0F,OAChB,CACA,QAAIp5C,GACA,OAAO,EAAAliD,EAAA,GAAIuG,KAAK+0F,SAAU3hG,GAAMA,EAAEslC,KACtC,CACA,OAAIviB,GACA,IAAIxjB,EAAQ,GACZ,IAAK,MAAM0I,KAAK2E,KAAKvG,IACjB9G,GAAS0I,EAAI,IAEjB,OAAO1I,CACX,EAEG,SAASsiG,EAAgBnlF,EAAQ4oB,GAAM,GAC1C,MAAO,GAAGA,EAAM,IAAI5oB,EAAO4oB,MAAQ,MAAM5oB,EAAOjL,MAAM+vF,eAAe9kF,EAAO5M,MAAMzJ,KAAKrG,GAAMA,EAAEwhG,YAAYv9E,aAAY3d,KAAK,MAChI,C,4CCdA,MAJA,SAAgB2c,EAAOH,GACrB,OAAQG,GAASA,EAAM/gB,QAAU,OAAS+gB,GAAO,OAAaH,EAAU,IAAM,EAChF,E,wCCZA,SAASg/E,EAAeC,EAAYV,GAChC,MAAMh7F,EAAM,CAAC,EACb,OAAQ27F,IACJ,MAAMj/E,EAAMi/E,EAAa/9E,WACzB,IAAI4jE,EAAWxhF,EAAI0c,GACnB,YAAiB5gB,IAAb0lF,IAIAA,EAAW,CACPoa,cAAeF,EACfV,WACA5jB,OAAQ,CAAC,GAEbp3E,EAAI0c,GAAO8kE,GARJA,CAUX,CAER,CACA,MAAMqa,EACF,WAAA1sF,GACI5I,KAAKg8C,WAAa,EACtB,CACA,EAAAu5C,CAAGngG,GACC,OAAOA,GAAS4K,KAAKg8C,WAAW1mD,QAAU0K,KAAKg8C,WAAW5mD,EAC9D,CACA,GAAAuC,CAAIvC,EAAOzC,GACPqN,KAAKg8C,WAAW5mD,GAASzC,CAC7B,CACA,QAAA0kB,GACI,IAAI1kB,EAAQ,GACZ,MAAM0rB,EAAOre,KAAKg8C,WAAW1mD,OAC7B,IAAK,IAAI4D,EAAI,EAAGA,EAAImlB,EAAMnlB,IACtBvG,IAAgC,IAAvBqN,KAAKg8C,WAAW9iD,GAAc,IAAM,IAEjD,OAAOvG,CACX,EAEJ,MAAM6iG,EAAmB,IAAIF,EACtB,MAAMG,UAAgC,KACzC,WAAA7sF,CAAY1N,GACR,IAAIlE,EACJ27B,QACA3yB,KAAK01F,QAAuF,QAA5E1+F,EAAKkE,aAAyC,EAASA,EAAQw6F,eAA4B,IAAP1+F,EAAgBA,EAAO2kC,GAAYxf,QAAQC,IAAIuf,EACvJ,CACA,UAAAq0B,CAAW90D,GACP8E,KAAKiyF,IAAMD,EAAU92F,EAAQhI,OAC7B8M,KAAK21F,KAuJb,SAA0B1D,GACtB,MAAM2D,EAAiB3D,EAAIE,eAAe78F,OACpCugG,EAAgBrxF,MAAMoxF,GAC5B,IAAK,IAAI18F,EAAI,EAAGA,EAAI08F,EAAgB18F,IAChC28F,EAAc38F,GAAKg8F,EAAejD,EAAIE,eAAej5F,GAAIA,GAE7D,OAAO28F,CACX,CA9JoBC,CAAiB91F,KAAKiyF,IACtC,CACA,wCAAAvuC,GACI,MAAO,EACX,CACA,2BAAA2E,GACI,MAAO,EACX,CACA,4BAAAc,CAA6BjuD,GACzB,MAAM,eAAE6rD,EAAc,KAAEnzD,EAAI,cAAEyhC,EAAa,qBAAEumB,GAAyB1gD,EAChEy6F,EAAO31F,KAAK21F,KACZD,EAAU11F,KAAK01F,QACfv/E,EAAMq7E,EAAY59F,EAAM,cAAemzD,GAEvCgvC,EADgB/1F,KAAKiyF,IAAIC,YAAY/7E,GACPs+E,SAC9Br2C,GAAc,EAAA3kD,EAAA,IAAI,QAAkB,CACtC8hD,aAAc,EACdtG,WAAY8R,EACZzL,SAAU,cACV1nD,KAAMA,KACLklD,IAAY,EAAAr/C,EAAA,GAAIq/C,GAAU5+B,GAASA,EAAK,OAC7C,GAAI87E,EAAc53C,GAAa,KAAWxC,EAAsB,CAC5D,MAAMY,GAAc,EAAAlwB,EAAA,GAAO8xB,GAAa,CAAC7nD,EAAQuiD,EAASrkB,MACtD,EAAAvgC,EAAA,GAAQ4kD,GAAU1W,IACVA,IACA7rC,EAAO6rC,EAAYtB,cAAgBrM,GACnC,EAAAvgC,EAAA,GAAQkuC,EAAYoH,iBAAkBiT,IAClClmD,EAAOkmD,GAAqBhoB,CAAG,IAEvC,IAEGl+B,IACR,CAAC,GACJ,OAAI8+B,EACO,SAAU0mB,GACb,IAAI/kD,EACJ,MAAMqlD,EAAYr8C,KAAKs8C,GAAG,GACpB25C,EAAaz5C,EAAYH,EAAUvb,cACzC,QAAevrC,IAAXwmD,QAAuCxmD,IAAf0gG,EAA0B,CAClD,MAAMC,EAAqC,QAA7Bl/F,EAAK+kD,EAAOk6C,UAAgC,IAAPj/F,OAAgB,EAASA,EAAGilD,KAC/E,QAAa1mD,IAAT2gG,IAA0C,IAApBA,EAAKzyF,KAAKzD,MAChC,MAER,CACA,OAAOi2F,CACX,EAGO,WACH,MAAM55C,EAAYr8C,KAAKs8C,GAAG,GAC1B,OAAOE,EAAYH,EAAUvb,aACjC,CAER,CACK,OAAIzL,EACE,SAAU0mB,GACb,MAAMC,EAAa,IAAIs5C,EACjBhgG,OAAoBC,IAAXwmD,EAAuB,EAAIA,EAAOzmD,OACjD,IAAK,IAAI4D,EAAI,EAAGA,EAAI5D,EAAQ4D,IAAK,CAC7B,MAAMg9F,EAAOn6C,aAAuC,EAASA,EAAO7iD,GAAG+iD,KACvED,EAAWrkD,IAAIuB,OAAY3D,IAAT2gG,GAAsBA,EAAKzyF,KAAKzD,MACtD,CACA,MAAMzJ,EAAS4/F,EAAgB1yF,KAAKzD,KAAM21F,EAAMI,EAAe/5C,EAAY05C,GAC3E,MAAyB,iBAAXn/F,EAAsBA,OAAShB,CACjD,EAGO,WACH,MAAMgB,EAAS4/F,EAAgB1yF,KAAKzD,KAAM21F,EAAMI,EAAeP,EAAkBE,GACjF,MAAyB,iBAAXn/F,EAAsBA,OAAShB,CACjD,CAER,CACA,yBAAA+zD,CAA0BpuD,GACtB,MAAM,eAAE6rD,EAAc,KAAEnzD,EAAI,SAAE0nD,EAAQ,qBAAEM,GAAyB1gD,EAC3Dy6F,EAAO31F,KAAK21F,KACZD,EAAU11F,KAAK01F,QACfv/E,EAAMq7E,EAAY59F,EAAM0nD,EAAUyL,GAElCgvC,EADgB/1F,KAAKiyF,IAAIC,YAAY/7E,GACPs+E,SAC9B94C,GAAO,EAAAliD,EAAA,IAAI,QAAkB,CAC/B8hD,aAAc,EACdtG,WAAY8R,EACZzL,WACA1nD,UACCR,IACM,EAAAqG,EAAA,GAAIrG,GAAIukB,GAAMA,EAAE,OAE3B,GAAIq+E,EAAcr6C,IAASA,EAAK,GAAG,KAAOC,EAAsB,CAC5D,MAAMljB,EAAMijB,EAAK,GACXiB,GAAoB,EAAAviC,EAAA,GAAQqe,GAClC,GAAiC,IAA7BkkB,EAAkBtnD,SAClB,EAAA+pC,EAAA,GAAQud,EAAkB,GAAGpT,iBAAkB,CAC/C,MACMqT,EADoBD,EAAkB,GACK9b,aACjD,OAAO,WACH,OAAO9gC,KAAKs8C,GAAG,GAAGxb,eAAiB+b,CACvC,CACJ,CACK,CACD,MAAML,GAAc,EAAAlwB,EAAA,GAAOswB,GAAmB,CAACrmD,EAAQ6rC,UAC/B7sC,IAAhB6sC,IACA7rC,EAAO6rC,EAAYtB,eAAgB,GACnC,EAAA5sC,EAAA,GAAQkuC,EAAYoH,iBAAkBiT,IAClClmD,EAAOkmD,IAAqB,CAAI,KAGjClmD,IACR,CAAC,GACJ,OAAO,WACH,MAAM8lD,EAAYr8C,KAAKs8C,GAAG,GAC1B,OAA+C,IAAxCE,EAAYH,EAAUvb,aACjC,CACJ,CACJ,CACA,OAAO,WACH,MAAMvqC,EAAS4/F,EAAgB1yF,KAAKzD,KAAM21F,EAAMI,EAAeP,EAAkBE,GACjF,MAAyB,iBAAXn/F,GAAyC,IAAXA,CAChD,CACJ,EAEJ,SAASy/F,EAAcI,EAAWC,GAAa,GAC3C,MAAMC,EAAU,IAAItjG,IACpB,IAAK,MAAM0lC,KAAO09D,EAAW,CACzB,MAAMG,EAAS,IAAIvjG,IACnB,IAAK,MAAMghC,KAAW0E,EAAK,CACvB,QAAgBnjC,IAAZy+B,EAAuB,CACvB,GAAIqiE,EAEA,MAGA,OAAO,CAEf,CACA,MAAMG,EAAU,CAACxiE,EAAQ8M,cAActtC,OAAOwgC,EAAQwV,iBACtD,IAAK,MAAMp0C,KAASohG,EAChB,GAAIF,EAAQxiG,IAAIsB,IACZ,IAAKmhG,EAAOziG,IAAIsB,GACZ,OAAO,OAIXkhG,EAAQtiG,IAAIoB,GACZmhG,EAAOviG,IAAIoB,EAGvB,CACJ,CACA,OAAO,CACX,CASA,SAAS+gG,EAAgBM,EAAWhC,EAAUW,EAAcM,GACxD,MAAMgB,EAAMD,EAAUhC,GAAUW,GAChC,IAAIziF,EAAQ+jF,EAAI/jF,MAChB,QAAcpd,IAAVod,EAAqB,CAErBA,EAAQgkF,EAAYD,EAAKE,EADTC,GAAkBH,EAAIrB,iBAEtCqB,EAAI/jF,MAAQA,CAChB,CAEA,OADYmkF,EAAiBhxF,MAAM9F,KAAM,CAAC02F,EAAK/jF,EAAOyiF,EAAcM,GAExE,CACA,SAASoB,EAAiBJ,EAAKK,EAAI3B,EAAcM,GAC7C,IAAIsB,EAAYD,EACZ79F,EAAI,EACR,MAAMghB,EAAO,GACb,IAAIiE,EAAIne,KAAKs8C,GAAGpjD,KAChB,OAAa,CACT,IAAI20F,GA0G2BvpF,EA1GW6Z,EAAX64E,EA2GtBrlF,MAAMrN,EAAMw8B,eAvGrB,QAHUvrC,IAANs4F,IACAA,EAAIoJ,EAAuBnxF,MAAM9F,KAAM,CAAC02F,EAAKM,EAAW74E,EAAGjlB,EAAGk8F,EAAcM,KAE5E7H,IAAMgH,EACN,OAAOqC,EAA0Bh9E,EAAM88E,EAAW74E,GAEtD,IAAwB,IAApB0vE,EAAEsJ,cACF,OAAOtJ,EAAEoI,WAEbe,EAAYnJ,EACZ3zE,EAAKtjB,KAAKunB,GACVA,EAAIne,KAAKs8C,GAAGpjD,IAChB,CA6FJ,IAAuCoL,CA5FvC,CACA,SAAS2yF,EAAuBP,EAAKM,EAAW1yF,EAAOrK,EAAWm7F,EAAcM,GAC5E,MAAM0B,EA6FV,SAAyBrC,EAASzwF,EAAO8wF,GACrC,MAAMiC,EAAe,IAAIvC,EACnBwC,EAAoB,GAC1B,IAAK,MAAMjwF,KAAK0tF,EAAQh7F,SAAU,CAC9B,IAA+B,IAA3Bq7F,EAAaG,GAAGluF,EAAEqxB,KAClB,SAEJ,GHjVqB,IGiVjBrxB,EAAExC,MAAMpQ,KAAwB,CAChC6iG,EAAkB1gG,KAAKyQ,GACvB,QACJ,CACA,MAAMkwF,EAAmBlwF,EAAExC,MAAMkvF,YAAYz+F,OAC7C,IAAK,IAAI4D,EAAI,EAAGA,EAAIq+F,EAAkBr+F,IAAK,CACvC,MACM2W,EAAS2nF,EADInwF,EAAExC,MAAMkvF,YAAY76F,GACOoL,QAC/B/O,IAAXsa,GACAwnF,EAAarjG,IAAI,CACb6Q,MAAOgL,EACP6oB,IAAKrxB,EAAEqxB,IACPx1B,MAAOmE,EAAEnE,OAGrB,CACJ,CACA,IAAIk0F,EAC6B,IAA7BE,EAAkBhiG,QAAsC,IAAtB+hG,EAAah5E,OAC/C+4E,EAAQC,GAEZ,QAAc9hG,IAAV6hG,EAAqB,CACrBA,EAAQ,IAAItC,EACZ,IAAK,MAAMztF,KAAKgwF,EAAat9F,SACzB09F,GAAQpwF,EAAG+vF,EAEnB,CACA,GAAIE,EAAkBhiG,OAAS,IAwHnC,SAAkCy/F,GAC9B,IAAK,MAAM1tF,KAAK0tF,EAAQh7F,SACpB,GHteqB,IGsejBsN,EAAExC,MAAMpQ,KACR,OAAO,EAGf,OAAO,CACX,CA/HyCijG,CAAyBN,GAC1D,IAAK,MAAM/vF,KAAKiwF,EACZF,EAAMpjG,IAAIqT,GAGlB,OAAO+vF,CACX,CArIkBO,CAAgBX,EAAUjC,QAASzwF,EAAO8wF,GACxD,GAAmB,IAAfgC,EAAM/4E,KAEN,OADAu5E,EAAWlB,EAAKM,EAAW1yF,EAAOuwF,GAC3BA,EAEX,IAAI5vF,EAAW2xF,EAAYQ,GAC3B,MAAMS,EAuIV,SAAsB9C,EAASK,GAC3B,IAAI18D,EACJ,IAAK,MAAMrxB,KAAK0tF,EAAQh7F,SACpB,IAA+B,IAA3Bq7F,EAAaG,GAAGluF,EAAEqxB,KAClB,QAAYnjC,IAARmjC,EACAA,EAAMrxB,EAAEqxB,SAEP,GAAIA,IAAQrxB,EAAEqxB,IACf,OAIZ,OAAOA,CACX,CApJyBo/D,CAAaV,EAAOhC,GACzC,QAAqB7/F,IAAjBsiG,EACA5yF,EAASkyF,eAAgB,EACzBlyF,EAASgxF,WAAa4B,EACtB5yF,EAAS8vF,QAAQgD,UAAYF,OAE5B,GA2PT,SAA0C9C,GACtC,GATJ,SAAoCA,GAChC,IAAK,MAAM1tF,KAAK0tF,EAAQh7F,SACpB,GH9eqB,IG8ejBsN,EAAExC,MAAMpQ,KACR,OAAO,EAGf,OAAO,CACX,CAEQujG,CAA2BjD,GAC3B,OAAO,EAEX,MAAMkD,EAIV,SAA+BlD,GAC3B,MAAMmD,EAAe,IAAI5gG,IACzB,IAAK,MAAM+P,KAAK0tF,EAAS,CACrB,MAAM5+E,EAAM8+E,EAAgB5tF,GAAG,GAC/B,IAAIs0C,EAAOu8C,EAAatgG,IAAIue,QACf5gB,IAATomD,IACAA,EAAO,CAAC,EACRu8C,EAAavgG,IAAIwe,EAAKwlC,IAE1BA,EAAKt0C,EAAEqxB,MAAO,CAClB,CACA,OAAOw/D,CACX,CAhBoBC,CAAsBpD,EAAQh7F,UAE9C,OAeJ,SAA8Bk+F,GAC1B,IAAK,MAAMtlG,KAAS6R,MAAM43B,KAAK67D,EAAQl0E,UACnC,GAAIxqB,OAAOsY,KAAKlf,GAAO2C,OAAS,EAC5B,OAAO,EAGf,OAAO,CACX,CAvBsB8iG,CAAqBH,KAwB3C,SAAsCA,GAClC,IAAK,MAAMtlG,KAAS6R,MAAM43B,KAAK67D,EAAQl0E,UACnC,GAAkC,IAA9BxqB,OAAOsY,KAAKlf,GAAO2C,OACnB,OAAO,EAGf,OAAO,CACX,CA/BwD+iG,CAA6BJ,EAErF,CAlQaK,CAAiClB,GAAQ,CAC9C,MAAMnB,GAAa,EAAAvgG,EAAA,GAAI0hG,EAAMz7C,MAC7B12C,EAASkyF,eAAgB,EACzBlyF,EAASgxF,WAAaA,EACtBhxF,EAAS8vF,QAAQgD,UAAY9B,EAC7BsC,EAAyBzyF,MAAM9F,KAAM,CAAC02F,EAAKz8F,EAAWm9F,EAAMz7C,KAAM+5C,GACtE,CAEA,OADAzwF,EAAW2yF,EAAWlB,EAAKM,EAAW1yF,EAAOW,GACtCA,CACX,CACA,SAASszF,EAAyB7B,EAAKz8F,EAAWk7C,EAAkBugD,GAChE,MAAM3gD,EAAa,GACnB,IAAK,IAAI77C,EAAI,EAAGA,GAAKe,EAAWf,IAC5B67C,EAAWn+C,KAAKoJ,KAAKs8C,GAAGpjD,GAAG+oC,WAE/B,MAAMu2D,EAAW9B,EAAIrB,cASrBK,EAEJ,SAA6Bx6F,GACzB,MAAM45C,GAAU,EAAAr7C,EAAA,GAAIyB,EAAQ65C,YAAaM,IAAY,QAAWA,KAAU37C,KAAK,MACzEu7C,EAAwC,IAA3B/5C,EAAQ03F,WAAWn+D,IAAY,GAAKv5B,EAAQ03F,WAAWn+D,IAC1E,IAAI6gB,EAAc,qCAAqCp6C,EAAQi6C,iBAAiBz7C,KAAK,cASzF,SAA8B86B,GAC1B,GAAIA,aAAgB,KAChB,MAAO,UAEN,GAAIA,aAAgB,KACrB,MAAO,SAEN,GAAIA,aAAgB,KACrB,MAAO,KAEN,GAAIA,aAAgB,KACrB,MAAO,eAEN,GAAIA,aAAgB,KACrB,MAAO,mBAEN,GAAIA,aAAgB,KACrB,MAAO,WAEN,GAAIA,aAAgB,KACrB,MAAO,OAEN,GAAIA,aAAgB,KACrB,MAAO,UAGP,MAAM57B,MAAM,uBAEpB,CArCuGk+B,CAAqB57B,EAAQ03F,cAAc39C,cAC9H/5C,EAAQi5C,aAAapgD,iBAC7B+gD,+DAKR,OAJAQ,GACIA,mHAGGA,CACX,CAnBoBmjD,CAAoB,CAChCtkD,aAHiBqkD,EAAS5kG,KAI1BuhD,mBACAy9C,WAJe4F,EAAS5F,WAKxB79C,eAGR,CA0CA,SAASmiD,EAA0Bh9E,EAAM84B,EAAUyoC,GAC/C,MAAMid,GAAkB,EAAAziG,EAAA,GAAQ+8C,EAAS+hD,QAAQh7F,UAAW3G,GAAMA,EAAEyR,MAAMkvF,cAI1E,MAAO,CACH4E,YAAald,EACbmd,mBALmB,EAAOF,EACzBjlG,QAAQL,GAAMA,aAAau+F,IAC3Bl4F,KAAKrG,GAAMA,EAAE6uC,aAAa7uC,GAAMA,EAAE0tC,eAInC+3D,UAAW3+E,EAEnB,CA6CA,SAASs9E,EAAmB5rF,EAAYtH,GACpC,GAAIsH,aAAsB+lF,IACtB,OAAartF,EAAOsH,EAAWq2B,WAC/B,OAAOr2B,EAAWiE,MAG1B,CAeA,SAAS+mF,EAAYa,GACjB,MAAO,CACH1C,QAAS0C,EACT9lF,MAAO,CAAC,EACRwlF,eAAe,EACflB,YAAa,EAErB,CACA,SAAS2B,EAAWlB,EAAKt6D,EAAM93B,EAAO+3B,GAGlC,OAFAA,EAAKs6D,EAAYD,EAAKr6D,GACtBD,EAAKzqB,MAAMrN,EAAMw8B,cAAgBzE,EAC1BA,CACX,CACA,SAASs6D,EAAYD,EAAK7xF,GACtB,GAAIA,IAAUgwF,EACV,OAAOhwF,EAIX,MAAMi0F,EAASj0F,EAAMkwF,QAAQ5+E,IACvB8kE,EAAWyb,EAAI7lB,OAAOioB,GAC5B,YAAiBvjG,IAAb0lF,EACOA,GAEXp2E,EAAMkwF,QAAQC,WACd0B,EAAI7lB,OAAOioB,GAAUj0F,EACdA,EACX,CACA,SAASgyF,GAAkB2B,GACvB,MAAMzD,EAAU,IAAID,EACdiE,EAAsBP,EAASzE,YAAYz+F,OACjD,IAAK,IAAI4D,EAAI,EAAGA,EAAI6/F,EAAqB7/F,IAAK,CAO1Cu+F,GALe,CACX5yF,MAFW2zF,EAASzE,YAAY76F,GAAG2W,OAGnC6oB,IAAKx/B,EACLgK,MAAO,IAEK6xF,EACpB,CACA,OAAOA,CACX,CACA,SAAS0C,GAAQ3nF,EAAQilF,GACrB,MAAMhwF,EAAI+K,EAAOjL,MACjB,GHpbyB,IGobrBE,EAAEtQ,KAAwB,CAC1B,GAAIqb,EAAO5M,MAAM5N,OAAS,EAAG,CACzB,MAAM0jG,EAAW,IAAIlpF,EAAO5M,OAO5Bu0F,GALqB,CACjB5yF,MAFgBm0F,EAASz0F,MAGzBm0B,IAAK5oB,EAAO4oB,IACZx1B,MAAO81F,GAEWjE,EAC1B,MAIIA,EAAQ/gG,IAAI8b,GAEhB,MACJ,CACK/K,EAAE2vF,wBACHK,EAAQ/gG,IAAI8b,GAEhB,MAAMynF,EAAmBxyF,EAAEgvF,YAAYz+F,OACvC,IAAK,IAAI4D,EAAI,EAAGA,EAAIq+F,EAAkBr+F,IAAK,CACvC,MACMmO,EAAI4xF,GAAiBnpF,EADR/K,EAAEgvF,YAAY76F,SAEvB3D,IAAN8R,GACAowF,GAAQpwF,EAAG0tF,EAEnB,CACJ,CACA,SAASkE,GAAiBnpF,EAAQlE,GAC9B,GAAIA,aAAsBgmF,EACtB,MAAO,CACH/sF,MAAO+G,EAAWiE,OAClB6oB,IAAK5oB,EAAO4oB,IACZx1B,MAAO4M,EAAO5M,OAGjB,GAAI0I,aAAsBimF,EAAgB,CAC3C,MAAM3uF,EAAQ,IAAI4M,EAAO5M,MAAO0I,EAAWmmF,aAC3C,MAAO,CACHltF,MAAO+G,EAAWiE,OAClB6oB,IAAK5oB,EAAO4oB,IACZx1B,QAER,CAEJ,C,IChfWg2F,GAOAnL,GAOAoL,GASAC,GAaAC,GA8BAC,GA2BAC,GAwBAC,GA4BAC,GA8BAC,GAyBAC,GA2BAC,GAmBAC,GAyCAC,GAwBAC,GAwBAC,GAqBAC,GAYAC,GA2CAC,GA0BAC,GAoCAC,GAqBAC,GAQAC,GA4CAC,GAiBAC,GAuBAC,GAwBAC,GAuBAC,GAuTAC,GAuBAC,GAwBAC,GAwBAC,GA6BAC,GAmBAC,GAcAC,GAgCAC,GAwBAC,GAYAC,GAwBAC,GAqBAC,GAaAC,GAeAC,GAaAC,GAoBAC,GAiBAC,GAiBAC,GAoBAC,GAmBAC,GAmBAC,GAkCAC,GAOAC,GAwBAC,GAkBAC,GA4CAC,GA2EAC,GAkBAC,GA2BAC,GAqCAC,GA0BAC,GAsBAC,GAsBAC,GAwBAC,GAwCAC,GAgBAC,GAcAC,GAoBAC,GAqBAC,GAsBAC,GAuBAC,GAeAC,GAeAC,GAsBAC,GAOAC,GAOAC,GAaAC,GAWAC,GAOAC,GAOAC,G,YA57DX,SAAW5E,GAIPA,EAAY3D,GAHZ,SAAY5iG,GACR,MAAwB,iBAAVA,CAClB,CAEH,CALD,CAKGumG,KAAgBA,GAAc,CAAC,IAElC,SAAWnL,GAIPA,EAAIwH,GAHJ,SAAY5iG,GACR,MAAwB,iBAAVA,CAClB,CAEH,CALD,CAKGo7F,KAAQA,GAAM,CAAC,IAElB,SAAWoL,GACPA,EAAQ4E,WAAa,WACrB5E,EAAQ6E,UAAY,WAIpB7E,EAAQ5D,GAHR,SAAY5iG,GACR,MAAwB,iBAAVA,GAAsBwmG,EAAQ4E,WAAaprG,GAASA,GAASwmG,EAAQ6E,SACvF,CAEH,CAPD,CAOG7E,KAAYA,GAAU,CAAC,IAE1B,SAAWC,GACPA,EAAS2E,UAAY,EACrB3E,EAAS4E,UAAY,WAIrB5E,EAAS7D,GAHT,SAAY5iG,GACR,MAAwB,iBAAVA,GAAsBymG,EAAS2E,WAAaprG,GAASA,GAASymG,EAAS4E,SACzF,CAEH,CAPD,CAOG5E,KAAaA,GAAW,CAAC,IAM5B,SAAWC,GAePA,EAASz1F,OATT,SAAgB4B,EAAM+hE,GAOlB,OANI/hE,IAASsY,OAAOkgF,YAChBx4F,EAAO4zF,GAAS4E,WAEhBz2B,IAAczpD,OAAOkgF,YACrBz2B,EAAY6xB,GAAS4E,WAElB,CAAEx4F,OAAM+hE,YACnB,EASA8xB,EAAS9D,GAJT,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAG9E,SAAS6E,EAAUz4F,OAAS04F,GAAG9E,SAAS6E,EAAU12B,UAC/F,CAEH,CAxBD,CAwBG8xB,KAAaA,GAAW,CAAC,IAM5B,SAAWC,GAYPA,EAAM11F,OAXN,SAAgBw6F,EAAKC,EAAKC,EAAOC,GAC7B,GAAIL,GAAG9E,SAASgF,IAAQF,GAAG9E,SAASiF,IAAQH,GAAG9E,SAASkF,IAAUJ,GAAG9E,SAASmF,GAC1E,MAAO,CAAE5rF,MAAO0mF,GAASz1F,OAAOw6F,EAAKC,GAAMzrF,IAAKymF,GAASz1F,OAAO06F,EAAOC,IAEtE,GAAIlF,GAAS9D,GAAG6I,IAAQ/E,GAAS9D,GAAG8I,GACrC,MAAO,CAAE1rF,MAAOyrF,EAAKxrF,IAAKyrF,GAG1B,MAAM,IAAIzlG,MAAM,8CAA8CwlG,MAAQC,MAAQC,MAAUC,KAEhG,EASAjF,EAAM/D,GAJN,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAGC,cAAcF,IAAc5E,GAAS9D,GAAG0I,EAAUtrF,QAAU0mF,GAAS9D,GAAG0I,EAAUrrF,IAChG,CAEH,CArBD,CAqBG0mF,KAAUA,GAAQ,CAAC,IAMtB,SAAWC,GASPA,EAAS31F,OAHT,SAAgB46F,EAAKrkG,GACjB,MAAO,CAAEqkG,MAAKrkG,QAClB,EASAo/F,EAAShE,GAJT,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAGC,cAAcF,IAAc3E,GAAM/D,GAAG0I,EAAU9jG,SAAW+jG,GAAG5Z,OAAO2Z,EAAUO,MAAQN,GAAG3oG,UAAU0oG,EAAUO,KAC3H,CAEH,CAlBD,CAkBGjF,KAAaA,GAAW,CAAC,IAM5B,SAAWC,GAWPA,EAAa51F,OAHb,SAAgB66F,EAAWC,EAAaC,EAAsBC,GAC1D,MAAO,CAAEH,YAAWC,cAAaC,uBAAsBC,uBAC3D,EAWApF,EAAajE,GANb,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAGC,cAAcF,IAAc3E,GAAM/D,GAAG0I,EAAUS,cAAgBR,GAAG5Z,OAAO2Z,EAAUQ,YACtFnF,GAAM/D,GAAG0I,EAAUU,wBAClBrF,GAAM/D,GAAG0I,EAAUW,uBAAyBV,GAAG3oG,UAAU0oG,EAAUW,sBAC/E,CAEH,CAtBD,CAsBGpF,KAAiBA,GAAe,CAAC,IAMpC,SAAWC,GAYPA,EAAM71F,OARN,SAAgBi7F,EAAKC,EAAOC,EAAMC,GAC9B,MAAO,CACHH,MACAC,QACAC,OACAC,QAER,EAYAvF,EAAMlE,GAPN,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAGe,YAAYhB,EAAUY,IAAK,EAAG,IAChEX,GAAGe,YAAYhB,EAAUa,MAAO,EAAG,IACnCZ,GAAGe,YAAYhB,EAAUc,KAAM,EAAG,IAClCb,GAAGe,YAAYhB,EAAUe,MAAO,EAAG,EAC9C,CAEH,CAxBD,CAwBGvF,KAAUA,GAAQ,CAAC,IAMtB,SAAWC,GAUPA,EAAiB91F,OANjB,SAAgBzJ,EAAO+kG,GACnB,MAAO,CACH/kG,QACA+kG,QAER,EASAxF,EAAiBnE,GAJjB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAc3E,GAAM/D,GAAG0I,EAAU9jG,QAAUs/F,GAAMlE,GAAG0I,EAAUiB,MAC1F,CAEH,CAnBD,CAmBGxF,KAAqBA,GAAmB,CAAC,IAM5C,SAAWC,GAWPA,EAAkB/1F,OAPlB,SAAgB0J,EAAO6xF,EAAUC,GAC7B,MAAO,CACH9xF,QACA6xF,WACAC,sBAER,EAWAzF,EAAkBpE,GANlB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAG5Z,OAAO2Z,EAAU3wF,SAClD4wF,GAAG3oG,UAAU0oG,EAAUkB,WAAa/E,GAAS7E,GAAG0I,MAChDC,GAAG3oG,UAAU0oG,EAAUmB,sBAAwBlB,GAAGmB,WAAWpB,EAAUmB,oBAAqBhF,GAAS7E,IACjH,CAEH,CAtBD,CAsBGoE,KAAsBA,GAAoB,CAAC,IAK9C,SAAWC,GAIPA,EAAiB0F,QAAU,UAI3B1F,EAAiB2F,QAAU,UAI3B3F,EAAiB4F,OAAS,QAC7B,CAbD,CAaG5F,KAAqBA,GAAmB,CAAC,IAM5C,SAAWC,GAuBPA,EAAaj2F,OAnBb,SAAgB4sC,EAAW0B,EAASutD,EAAgBC,EAAcC,EAAMC,GACpE,MAAMrpG,EAAS,CACXi6C,YACA0B,WAcJ,OAZIgsD,GAAG2B,QAAQJ,KACXlpG,EAAOkpG,eAAiBA,GAExBvB,GAAG2B,QAAQH,KACXnpG,EAAOmpG,aAAeA,GAEtBxB,GAAG2B,QAAQF,KACXppG,EAAOopG,KAAOA,GAEdzB,GAAG2B,QAAQD,KACXrpG,EAAOqpG,cAAgBA,GAEpBrpG,CACX,EAYAsjG,EAAatE,GAPb,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAG9E,SAAS6E,EAAUztD,YAAc0tD,GAAG9E,SAAS6E,EAAUztD,aACxF0tD,GAAG3oG,UAAU0oG,EAAUwB,iBAAmBvB,GAAG9E,SAAS6E,EAAUwB,mBAChEvB,GAAG3oG,UAAU0oG,EAAUyB,eAAiBxB,GAAG9E,SAAS6E,EAAUyB,iBAC9DxB,GAAG3oG,UAAU0oG,EAAU0B,OAASzB,GAAG5Z,OAAO2Z,EAAU0B,MAChE,CAEH,CAnCD,CAmCG9F,KAAiBA,GAAe,CAAC,IAMpC,SAAWC,GAUPA,EAA6Bl2F,OAN7B,SAAgB0yD,EAAU36B,GACtB,MAAO,CACH26B,WACA36B,UAER,EASAm+D,EAA6BvE,GAJ7B,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAc1E,GAAShE,GAAG0I,EAAU3nC,WAAa4nC,GAAG5Z,OAAO2Z,EAAUtiE,QAC3F,CAEH,CAnBD,CAmBGm+D,KAAiCA,GAA+B,CAAC,IAKpE,SAAWC,GAIPA,EAAmBnhG,MAAQ,EAI3BmhG,EAAmB+F,QAAU,EAI7B/F,EAAmBgG,YAAc,EAIjChG,EAAmBiG,KAAO,CAC7B,CAjBD,CAiBGjG,KAAuBA,GAAqB,CAAC,IAOhD,SAAWC,GAOPA,EAAciG,YAAc,EAM5BjG,EAAckG,WAAa,CAC9B,CAdD,CAcGlG,KAAkBA,GAAgB,CAAC,IAOtC,SAAWC,GAKPA,EAAgB1E,GAJhB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAG5Z,OAAO2Z,EAAUkC,KAC9D,CAEH,CAND,CAMGlG,KAAoBA,GAAkB,CAAC,IAM1C,SAAWC,GAoBPA,EAAWt2F,OAhBX,SAAgBzJ,EAAOwhC,EAASykE,EAAUlkE,EAAM9iC,EAAQinG,GACpD,IAAI9pG,EAAS,CAAE4D,QAAOwhC,WAatB,OAZIuiE,GAAG2B,QAAQO,KACX7pG,EAAO6pG,SAAWA,GAElBlC,GAAG2B,QAAQ3jE,KACX3lC,EAAO2lC,KAAOA,GAEdgiE,GAAG2B,QAAQzmG,KACX7C,EAAO6C,OAASA,GAEhB8kG,GAAG2B,QAAQQ,KACX9pG,EAAO8pG,mBAAqBA,GAEzB9pG,CACX,EAiBA2jG,EAAW3E,GAZX,SAAY5iG,GACR,IAAIqE,EACJ,IAAIinG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IACX3E,GAAM/D,GAAG0I,EAAU9jG,QACnB+jG,GAAG5Z,OAAO2Z,EAAUtiE,WACnBuiE,GAAG/e,OAAO8e,EAAUmC,WAAalC,GAAG3oG,UAAU0oG,EAAUmC,aACxDlC,GAAG/E,QAAQ8E,EAAU/hE,OAASgiE,GAAG5Z,OAAO2Z,EAAU/hE,OAASgiE,GAAG3oG,UAAU0oG,EAAU/hE,SAClFgiE,GAAG3oG,UAAU0oG,EAAUqC,kBAAqBpC,GAAG5Z,OAA4C,QAApCttF,EAAKinG,EAAUqC,uBAAoC,IAAPtpG,OAAgB,EAASA,EAAGmpG,SAC/HjC,GAAG5Z,OAAO2Z,EAAU7kG,SAAW8kG,GAAG3oG,UAAU0oG,EAAU7kG,WACtD8kG,GAAG3oG,UAAU0oG,EAAUoC,qBAAuBnC,GAAGmB,WAAWpB,EAAUoC,mBAAoBvG,GAA6BvE,IACnI,CAEH,CArCD,CAqCG2E,KAAeA,GAAa,CAAC,IAMhC,SAAWC,GAWPA,EAAQv2F,OAPR,SAAgBzD,EAAOogG,KAAYh9F,GAC/B,IAAIhN,EAAS,CAAE4J,QAAOogG,WAItB,OAHIrC,GAAG2B,QAAQt8F,IAASA,EAAKjO,OAAS,IAClCiB,EAAOmN,UAAYH,GAEhBhN,CACX,EASA4jG,EAAQ5E,GAJR,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAU99F,QAAU+9F,GAAG5Z,OAAO2Z,EAAUsC,QACtF,CAEH,CApBD,CAoBGpG,KAAYA,GAAU,CAAC,IAM1B,SAAWC,GASPA,EAASlzF,QAHT,SAAiB/M,EAAOqmG,GACpB,MAAO,CAAErmG,QAAOqmG,UACpB,EAUApG,EAASqG,OAHT,SAAgB5xE,EAAU2xE,GACtB,MAAO,CAAErmG,MAAO,CAAEwY,MAAOkc,EAAUjc,IAAKic,GAAY2xE,UACxD,EASApG,EAASsG,IAHT,SAAavmG,GACT,MAAO,CAAEA,QAAOqmG,QAAS,GAC7B,EAQApG,EAAS7E,GANT,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IACjBC,GAAG5Z,OAAO2Z,EAAUuC,UACpBlH,GAAM/D,GAAG0I,EAAU9jG,MAC9B,CAEH,CAlCD,CAkCGigG,KAAaA,GAAW,CAAC,IAE5B,SAAWC,GAWPA,EAAiBz2F,OAVjB,SAAgB0J,EAAOqzF,EAAmB30C,GACtC,MAAMz1D,EAAS,CAAE+W,SAOjB,YAN0B/X,IAAtBorG,IACApqG,EAAOoqG,kBAAoBA,QAEXprG,IAAhBy2D,IACAz1D,EAAOy1D,YAAcA,GAElBz1D,CACX,EAQA8jG,EAAiB9E,GANjB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAcC,GAAG5Z,OAAO2Z,EAAU3wF,SACrD4wF,GAAGpO,QAAQmO,EAAU0C,yBAAsDprG,IAAhC0oG,EAAU0C,qBACrDzC,GAAG5Z,OAAO2Z,EAAUjyC,mBAA0Cz2D,IAA1B0oG,EAAUjyC,YACvD,CAEH,CAnBD,CAmBGquC,KAAqBA,GAAmB,CAAC,IAE5C,SAAWC,GAKPA,EAA2B/E,GAJ3B,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAG5Z,OAAO2Z,EACrB,CAEH,CAND,CAMG3D,KAA+BA,GAA6B,CAAC,IAEhE,SAAWC,GAWPA,EAAkBrzF,QAHlB,SAAiB/M,EAAOqmG,EAAS7xF,GAC7B,MAAO,CAAExU,QAAOqmG,UAASI,aAAcjyF,EAC3C,EAYA4rF,EAAkBkG,OAHlB,SAAgB5xE,EAAU2xE,EAAS7xF,GAC/B,MAAO,CAAExU,MAAO,CAAEwY,MAAOkc,EAAUjc,IAAKic,GAAY2xE,UAASI,aAAcjyF,EAC/E,EAWA4rF,EAAkBmG,IAHlB,SAAavmG,EAAOwU,GAChB,MAAO,CAAExU,QAAOqmG,QAAS,GAAII,aAAcjyF,EAC/C,EAMA4rF,EAAkBhF,GAJlB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOynG,GAAS7E,GAAG0I,KAAe5D,GAAiB9E,GAAG0I,EAAU2C,eAAiBtG,GAA2B/E,GAAG0I,EAAU2C,cAC7H,CAEH,CAtCD,CAsCGrG,KAAsBA,GAAoB,CAAC,IAM9C,SAAWC,GAOPA,EAAiB52F,OAHjB,SAAgBi9F,EAAcC,GAC1B,MAAO,CAAED,eAAcC,QAC3B,EAQAtG,EAAiBjF,GANjB,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IACXlD,GAAwCxF,GAAG0I,EAAU4C,eACrDr8F,MAAMyK,QAAQgvF,EAAU6C,MACnC,CAEH,CAfD,CAeGtG,KAAqBA,GAAmB,CAAC,IAE5C,SAAWC,GAcPA,EAAW72F,OAbX,SAAgB46F,EAAKtjG,EAASyT,GAC1B,IAAIpY,EAAS,CACTopG,KAAM,SACNnB,OAQJ,YANgBjpG,IAAZ2F,QAAgD3F,IAAtB2F,EAAQ6lG,gBAAsDxrG,IAA3B2F,EAAQ8lG,iBACrEzqG,EAAO2E,QAAUA,QAEF3F,IAAfoZ,IACApY,EAAOqqG,aAAejyF,GAEnBpY,CACX,EAOAkkG,EAAWlF,GALX,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,GAAgC,WAAnBA,EAAU0B,MAAqBzB,GAAG5Z,OAAO2Z,EAAUO,YAA+BjpG,IAAtB0oG,EAAU/iG,eACpD3F,IAAhC0oG,EAAU/iG,QAAQ6lG,WAA2B7C,GAAGpO,QAAQmO,EAAU/iG,QAAQ6lG,mBAAqDxrG,IAArC0oG,EAAU/iG,QAAQ8lG,gBAAgC9C,GAAGpO,QAAQmO,EAAU/iG,QAAQ8lG,yBAAkDzrG,IAA3B0oG,EAAU2C,cAA8BtG,GAA2B/E,GAAG0I,EAAU2C,cAC1R,CAEH,CArBD,CAqBGnG,KAAeA,GAAa,CAAC,IAEhC,SAAWC,GAePA,EAAW92F,OAdX,SAAgBq9F,EAAQC,EAAQhmG,EAASyT,GACrC,IAAIpY,EAAS,CACTopG,KAAM,SACNsB,SACAC,UAQJ,YANgB3rG,IAAZ2F,QAAgD3F,IAAtB2F,EAAQ6lG,gBAAsDxrG,IAA3B2F,EAAQ8lG,iBACrEzqG,EAAO2E,QAAUA,QAEF3F,IAAfoZ,IACApY,EAAOqqG,aAAejyF,GAEnBpY,CACX,EAOAmkG,EAAWnF,GALX,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,GAAgC,WAAnBA,EAAU0B,MAAqBzB,GAAG5Z,OAAO2Z,EAAUgD,SAAW/C,GAAG5Z,OAAO2Z,EAAUiD,eAAkC3rG,IAAtB0oG,EAAU/iG,eACtF3F,IAAhC0oG,EAAU/iG,QAAQ6lG,WAA2B7C,GAAGpO,QAAQmO,EAAU/iG,QAAQ6lG,mBAAqDxrG,IAArC0oG,EAAU/iG,QAAQ8lG,gBAAgC9C,GAAGpO,QAAQmO,EAAU/iG,QAAQ8lG,yBAAkDzrG,IAA3B0oG,EAAU2C,cAA8BtG,GAA2B/E,GAAG0I,EAAU2C,cAC1R,CAEH,CAtBD,CAsBGlG,KAAeA,GAAa,CAAC,IAEhC,SAAWC,GAcPA,EAAW/2F,OAbX,SAAgB46F,EAAKtjG,EAASyT,GAC1B,IAAIpY,EAAS,CACTopG,KAAM,SACNnB,OAQJ,YANgBjpG,IAAZ2F,QAAgD3F,IAAtB2F,EAAQimG,gBAAyD5rG,IAA9B2F,EAAQkmG,oBACrE7qG,EAAO2E,QAAUA,QAEF3F,IAAfoZ,IACApY,EAAOqqG,aAAejyF,GAEnBpY,CACX,EAOAokG,EAAWpF,GALX,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,GAAgC,WAAnBA,EAAU0B,MAAqBzB,GAAG5Z,OAAO2Z,EAAUO,YAA+BjpG,IAAtB0oG,EAAU/iG,eACpD3F,IAAhC0oG,EAAU/iG,QAAQimG,WAA2BjD,GAAGpO,QAAQmO,EAAU/iG,QAAQimG,mBAAwD5rG,IAAxC0oG,EAAU/iG,QAAQkmG,mBAAmClD,GAAGpO,QAAQmO,EAAU/iG,QAAQkmG,4BAAqD7rG,IAA3B0oG,EAAU2C,cAA8BtG,GAA2B/E,GAAG0I,EAAU2C,cAChS,CAEH,CArBD,CAqBGjG,KAAeA,GAAa,CAAC,IAEhC,SAAWC,GAcPA,EAAcrF,GAbd,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,SACoB1oG,IAAtB0oG,EAAUoD,cAAuD9rG,IAA9B0oG,EAAUqD,wBACf/rG,IAA9B0oG,EAAUqD,iBAAiCrD,EAAUqD,gBAAgB74B,OAAO84B,GACrErD,GAAG5Z,OAAOid,EAAO5B,MACVlF,GAAWlF,GAAGgM,IAAW7G,GAAWnF,GAAGgM,IAAW5G,GAAWpF,GAAGgM,GAGhE/G,GAAiBjF,GAAGgM,KAG3C,CAEH,CAfD,CAeG3G,KAAkBA,GAAgB,CAAC,KAwStC,SAAWC,GAQPA,EAAuBj3F,OAHvB,SAAgB46F,GACZ,MAAO,CAAEA,MACb,EASA3D,EAAuBtF,GAJvB,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAUO,IACxD,CAEH,CAjBD,CAiBG3D,KAA2BA,GAAyB,CAAC,IAMxD,SAAWC,GASPA,EAAgCl3F,OAHhC,SAAgB46F,EAAKxtB,GACjB,MAAO,CAAEwtB,MAAKxtB,UAClB,EASA8pB,EAAgCvF,GAJhC,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAUO,MAAQN,GAAG/E,QAAQ8E,EAAUjtB,QACrF,CAEH,CAlBD,CAkBG8pB,KAAoCA,GAAkC,CAAC,IAM1E,SAAWC,GASPA,EAAwCn3F,OAHxC,SAAgB46F,EAAKxtB,GACjB,MAAO,CAAEwtB,MAAKxtB,UAClB,EASA+pB,EAAwCxF,GAJxC,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAUO,OAA+B,OAAtBP,EAAUjtB,SAAoBktB,GAAG/E,QAAQ8E,EAAUjtB,SACpH,CAEH,CAlBD,CAkBG+pB,KAA4CA,GAA0C,CAAC,IAM1F,SAAWC,GAWPA,EAAiBp3F,OAHjB,SAAgB46F,EAAKjZ,EAAYvU,EAAS1rE,GACtC,MAAO,CAAEk5F,MAAKjZ,aAAYvU,UAAS1rE,OACvC,EASA01F,EAAiBzF,GAJjB,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAUO,MAAQN,GAAG5Z,OAAO2Z,EAAU1Y,aAAe2Y,GAAG/E,QAAQ8E,EAAUjtB,UAAYktB,GAAG5Z,OAAO2Z,EAAU34F,KACxJ,CAEH,CApBD,CAoBG01F,KAAqBA,GAAmB,CAAC,IAS5C,SAAWC,GAIPA,EAAWuG,UAAY,YAIvBvG,EAAWwG,SAAW,WAQtBxG,EAAW1F,GAJX,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,IAAchD,EAAWuG,WAAavD,IAAchD,EAAWwG,QAC1E,CAEH,CAjBD,CAiBGxG,KAAeA,GAAa,CAAC,IAEhC,SAAWC,GAQPA,EAAc3F,GAJd,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcxrG,IAAUsoG,GAAW1F,GAAG0I,EAAU0B,OAASzB,GAAG5Z,OAAO2Z,EAAUtrG,MAC3F,CAEH,CATD,CASGuoG,KAAkBA,GAAgB,CAAC,IAKtC,SAAWC,GACPA,EAAmBuG,KAAO,EAC1BvG,EAAmBwG,OAAS,EAC5BxG,EAAmByG,SAAW,EAC9BzG,EAAmB0G,YAAc,EACjC1G,EAAmB2G,MAAQ,EAC3B3G,EAAmB4G,SAAW,EAC9B5G,EAAmB6G,MAAQ,EAC3B7G,EAAmBhlB,UAAY,EAC/BglB,EAAmB8G,OAAS,EAC5B9G,EAAmB+G,SAAW,GAC9B/G,EAAmBgH,KAAO,GAC1BhH,EAAmBiH,MAAQ,GAC3BjH,EAAmBkH,KAAO,GAC1BlH,EAAmB5iB,QAAU,GAC7B4iB,EAAmBmH,QAAU,GAC7BnH,EAAmB1B,MAAQ,GAC3B0B,EAAmBoH,KAAO,GAC1BpH,EAAmBqH,UAAY,GAC/BrH,EAAmBsH,OAAS,GAC5BtH,EAAmBuH,WAAa,GAChCvH,EAAmBwH,SAAW,GAC9BxH,EAAmByH,OAAS,GAC5BzH,EAAmB5a,MAAQ,GAC3B4a,EAAmB0H,SAAW,GAC9B1H,EAAmB2H,cAAgB,EACtC,CA1BD,CA0BG3H,KAAuBA,GAAqB,CAAC,IAMhD,SAAWC,GAIPA,EAAiBoG,UAAY,EAW7BpG,EAAiBkH,QAAU,CAC9B,CAhBD,CAgBGlH,KAAqBA,GAAmB,CAAC,IAQ5C,SAAWC,GAIPA,EAAkB6E,WAAa,CAClC,CALD,CAKG7E,KAAsBA,GAAoB,CAAC,IAO9C,SAAWC,GAOPA,EAAkB13F,OAHlB,SAAgB48F,EAASC,EAAQv5F,GAC7B,MAAO,CAAEs5F,UAASC,SAAQv5F,UAC9B,EASAo0F,EAAkB/F,GAJlB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,GAAaC,GAAG5Z,OAAO2Z,EAAUuC,UAAYlH,GAAM/D,GAAG0I,EAAUwC,SAAWnH,GAAM/D,GAAG0I,EAAU/2F,QACzG,CAEH,CAhBD,CAgBGo0F,KAAsBA,GAAoB,CAAC,IAQ9C,SAAWC,GAQPA,EAAewH,KAAO,EAUtBxH,EAAeyH,kBAAoB,CACtC,CAnBD,CAmBGzH,KAAmBA,GAAiB,CAAC,IAExC,SAAWC,GAMPA,EAA2BjG,GAL3B,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,IAAcC,GAAG5Z,OAAO2Z,EAAUgF,cAAgC1tG,IAArB0oG,EAAUgF,UACzD/E,GAAG5Z,OAAO2Z,EAAUjyC,mBAA0Cz2D,IAA1B0oG,EAAUjyC,YACvD,CAEH,CAPD,CAOGwvC,KAA+BA,GAA6B,CAAC,IAMhE,SAAWC,GAQPA,EAAe73F,OAHf,SAAgB0J,GACZ,MAAO,CAAEA,QACb,CAEH,CATD,CASGmuF,KAAmBA,GAAiB,CAAC,IAMxC,SAAWC,GAUPA,EAAe93F,OAHf,SAAgBs/F,EAAOC,GACnB,MAAO,CAAED,MAAOA,GAAgB,GAAIC,eAAgBA,EACxD,CAEH,CAXD,CAWGzH,KAAmBA,GAAiB,CAAC,IAExC,SAAWC,GASPA,EAAayH,cAHb,SAAuBC,GACnB,OAAOA,EAAUn8F,QAAQ,wBAAyB,OACtD,EASAy0F,EAAapG,GAJb,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAG5Z,OAAO2Z,IAAeC,GAAGC,cAAcF,IAAcC,GAAG5Z,OAAO2Z,EAAUqF,WAAapF,GAAG5Z,OAAO2Z,EAAUtrG,MACxH,CAEH,CAlBD,CAkBGgpG,KAAiBA,GAAe,CAAC,IAEpC,SAAWC,GAUPA,EAAMrG,GANN,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,QAASsrG,GAAaC,GAAGC,cAAcF,KAAe/C,GAAc3F,GAAG0I,EAAUsF,WAC7E5H,GAAapG,GAAG0I,EAAUsF,WAC1BrF,GAAGmB,WAAWpB,EAAUsF,SAAU5H,GAAapG,YAAyBhgG,IAAhB5C,EAAMwH,OAAuBm/F,GAAM/D,GAAG5iG,EAAMwH,OAC5G,CAEH,CAXD,CAWGyhG,KAAUA,GAAQ,CAAC,IAMtB,SAAWC,GAUPA,EAAqBj4F,OAHrB,SAAgB0J,EAAOk2F,GACnB,OAAOA,EAAgB,CAAEl2F,QAAOk2F,iBAAkB,CAAEl2F,QACxD,CAEH,CAXD,CAWGuuF,KAAyBA,GAAuB,CAAC,IAMpD,SAAWC,GAcPA,EAAqBl4F,OAbrB,SAAgB0J,EAAOk2F,KAAkBn6F,GACrC,IAAI9S,EAAS,CAAE+W,SAUf,OATI4wF,GAAG2B,QAAQ2D,KACXjtG,EAAOitG,cAAgBA,GAEvBtF,GAAG2B,QAAQx2F,GACX9S,EAAO8S,WAAaA,EAGpB9S,EAAO8S,WAAa,GAEjB9S,CACX,CAEH,CAfD,CAeGulG,KAAyBA,GAAuB,CAAC,IAKpD,SAAWC,GAIPA,EAAsB2F,KAAO,EAI7B3F,EAAsB0H,KAAO,EAI7B1H,EAAsB2H,MAAQ,CACjC,CAbD,CAaG3H,KAA0BA,GAAwB,CAAC,IAMtD,SAAWC,GAaPA,EAAkBp4F,OAPlB,SAAgBzJ,EAAOwlG,GACnB,IAAIppG,EAAS,CAAE4D,SAIf,OAHI+jG,GAAG/e,OAAOwgB,KACVppG,EAAOopG,KAAOA,GAEXppG,CACX,CAEH,CAdD,CAcGylG,KAAsBA,GAAoB,CAAC,IAK9C,SAAWC,GACPA,EAAWsG,KAAO,EAClBtG,EAAWgG,OAAS,EACpBhG,EAAW0H,UAAY,EACvB1H,EAAW2H,QAAU,EACrB3H,EAAW+F,MAAQ,EACnB/F,EAAW0F,OAAS,EACpB1F,EAAWiG,SAAW,EACtBjG,EAAW6F,MAAQ,EACnB7F,EAAW4F,YAAc,EACzB5F,EAAWoG,KAAO,GAClBpG,EAAW9lB,UAAY,GACvB8lB,EAAW2F,SAAW,GACtB3F,EAAW8F,SAAW,GACtB9F,EAAW0G,SAAW,GACtB1G,EAAW9+D,OAAS,GACpB8+D,EAAWn+E,OAAS,GACpBm+E,EAAW/jG,QAAU,GACrB+jG,EAAWz3F,MAAQ,GACnBy3F,EAAW1iG,OAAS,GACpB0iG,EAAW4H,IAAM,GACjB5H,EAAW6H,KAAO,GAClB7H,EAAWyG,WAAa,GACxBzG,EAAW2G,OAAS,GACpB3G,EAAW1b,MAAQ,GACnB0b,EAAW4G,SAAW,GACtB5G,EAAW6G,cAAgB,EAC9B,CA3BD,CA2BG7G,KAAeA,GAAa,CAAC,IAOhC,SAAWC,GAIPA,EAAUgE,WAAa,CAC1B,CALD,CAKGhE,KAAcA,GAAY,CAAC,IAE9B,SAAWC,GAqBPA,EAAkBv4F,OAXlB,SAAgB7P,EAAM4rG,EAAMxlG,EAAOqkG,EAAKuF,GACpC,IAAIxtG,EAAS,CACTxC,OACA4rG,OACArpC,SAAU,CAAEkoC,MAAKrkG,UAKrB,OAHI4pG,IACAxtG,EAAOwtG,cAAgBA,GAEpBxtG,CACX,CAEH,CAtBD,CAsBG4lG,KAAsBA,GAAoB,CAAC,IAE9C,SAAWC,GAePA,EAAgBx4F,OALhB,SAAgB7P,EAAM4rG,EAAMnB,EAAKrkG,GAC7B,YAAiB5E,IAAV4E,EACD,CAAEpG,OAAM4rG,OAAMrpC,SAAU,CAAEkoC,MAAKrkG,UAC/B,CAAEpG,OAAM4rG,OAAMrpC,SAAU,CAAEkoC,OACpC,CAEH,CAhBD,CAgBGpC,KAAoBA,GAAkB,CAAC,IAE1C,SAAWC,GAwBPA,EAAez4F,OAbf,SAAgB7P,EAAMkvG,EAAQtD,EAAMxlG,EAAO6pG,EAAgB9yF,GACvD,IAAI3a,EAAS,CACTxC,OACAkvG,SACAtD,OACAxlG,QACA6pG,kBAKJ,YAHiBzuG,IAAb2b,IACA3a,EAAO2a,SAAWA,GAEf3a,CACX,EAeA8lG,EAAe9G,GAVf,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,GACHC,GAAG5Z,OAAO2Z,EAAUlqG,OAASmqG,GAAG/e,OAAO8e,EAAU0B,OACjDrG,GAAM/D,GAAG0I,EAAU9jG,QAAUm/F,GAAM/D,GAAG0I,EAAU+F,uBAC1BzuG,IAArB0oG,EAAUgF,QAAwB/E,GAAG5Z,OAAO2Z,EAAUgF,gBAC7B1tG,IAAzB0oG,EAAUgG,YAA4B/F,GAAGpO,QAAQmO,EAAUgG,oBACpC1uG,IAAvB0oG,EAAU/sF,UAA0B1M,MAAMyK,QAAQgvF,EAAU/sF,kBACzC3b,IAAnB0oG,EAAUiG,MAAsB1/F,MAAMyK,QAAQgvF,EAAUiG,MACjE,CAEH,CAvCD,CAuCG7H,KAAmBA,GAAiB,CAAC,IAKxC,SAAWC,GAIPA,EAAe6H,MAAQ,GAIvB7H,EAAe8H,SAAW,WAI1B9H,EAAe+H,SAAW,WAY1B/H,EAAegI,gBAAkB,mBAWjChI,EAAeiI,eAAiB,kBAahCjI,EAAekI,gBAAkB,mBAMjClI,EAAemI,OAAS,SAIxBnI,EAAeoI,sBAAwB,yBASvCpI,EAAeqI,aAAe,eACjC,CApED,CAoEGrI,KAAmBA,GAAiB,CAAC,IAOxC,SAAWC,GAIPA,EAAsBqI,QAAU,EAOhCrI,EAAsBsI,UAAY,CACrC,CAZD,CAYGtI,KAA0BA,GAAwB,CAAC,IAMtD,SAAWC,GAcPA,EAAkB54F,OAVlB,SAAgBinE,EAAai6B,EAAMC,GAC/B,IAAIxuG,EAAS,CAAEs0E,eAOf,OANIi6B,UACAvuG,EAAOuuG,KAAOA,GAEdC,UACAxuG,EAAOwuG,YAAcA,GAElBxuG,CACX,EAWAimG,EAAkBjH,GANlB,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAGmB,WAAWpB,EAAUpzB,YAAaqvB,GAAW3E,WACrDhgG,IAAnB0oG,EAAU6G,MAAsB5G,GAAGmB,WAAWpB,EAAU6G,KAAM5G,GAAG5Z,gBACvC/uF,IAA1B0oG,EAAU8G,aAA6B9G,EAAU8G,cAAgBxI,GAAsBqI,SAAW3G,EAAU8G,cAAgBxI,GAAsBsI,UAC9J,CAEH,CAzBD,CAyBGrI,KAAsBA,GAAoB,CAAC,IAE9C,SAAWC,GAmBPA,EAAW74F,OAlBX,SAAgBzD,EAAO6kG,EAAqBrF,GACxC,IAAIppG,EAAS,CAAE4J,SACX8kG,GAAY,EAchB,MAbmC,iBAAxBD,GACPC,GAAY,EACZ1uG,EAAOopG,KAAOqF,GAET7K,GAAQ5E,GAAGyP,GAChBzuG,EAAOgqG,QAAUyE,EAGjBzuG,EAAO2uG,KAAOF,EAEdC,QAAsB1vG,IAAToqG,IACbppG,EAAOopG,KAAOA,GAEXppG,CACX,EAYAkmG,EAAWlH,GAVX,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOsrG,GAAaC,GAAG5Z,OAAO2Z,EAAU99F,cACT5K,IAA1B0oG,EAAUpzB,aAA6BqzB,GAAGmB,WAAWpB,EAAUpzB,YAAaqvB,GAAW3E,YACpEhgG,IAAnB0oG,EAAU0B,MAAsBzB,GAAG5Z,OAAO2Z,EAAU0B,cACjCpqG,IAAnB0oG,EAAUiH,WAA4C3vG,IAAtB0oG,EAAUsC,gBACpBhrG,IAAtB0oG,EAAUsC,SAAyBpG,GAAQ5E,GAAG0I,EAAUsC,iBAC9BhrG,IAA1B0oG,EAAUkH,aAA6BjH,GAAGpO,QAAQmO,EAAUkH,qBACzC5vG,IAAnB0oG,EAAUiH,MAAsBtK,GAAcrF,GAAG0I,EAAUiH,MACpE,CAEH,CA/BD,CA+BGzI,KAAeA,GAAa,CAAC,IAMhC,SAAWC,GAWPA,EAAS94F,OAPT,SAAgBzJ,EAAOirG,GACnB,IAAI7uG,EAAS,CAAE4D,SAIf,OAHI+jG,GAAG2B,QAAQuF,KACX7uG,EAAO6uG,KAAOA,GAEX7uG,CACX,EASAmmG,EAASnH,GAJT,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAc3E,GAAM/D,GAAG0I,EAAU9jG,SAAW+jG,GAAG3oG,UAAU0oG,EAAUsC,UAAYpG,GAAQ5E,GAAG0I,EAAUsC,SAC1H,CAEH,CApBD,CAoBG7D,KAAaA,GAAW,CAAC,IAM5B,SAAWC,GAOPA,EAAkB/4F,OAHlB,SAAgByhG,EAASC,GACrB,MAAO,CAAED,UAASC,eACtB,EASA3I,EAAkBpH,GAJlB,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG9E,SAAS6E,EAAUoH,UAAYnH,GAAGpO,QAAQmO,EAAUqH,aAC3F,CAEH,CAhBD,CAgBG3I,KAAsBA,GAAoB,CAAC,IAM9C,SAAWC,GAOPA,EAAah5F,OAHb,SAAgBzJ,EAAO0V,EAAQu1F,GAC3B,MAAO,CAAEjrG,QAAO0V,SAAQu1F,OAC5B,EASAxI,EAAarH,GAJb,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAG2B,QAAQ5B,IAAc3E,GAAM/D,GAAG0I,EAAU9jG,SAAW+jG,GAAG3oG,UAAU0oG,EAAUpuF,SAAWquF,GAAG5Z,OAAO2Z,EAAUpuF,QACxH,CAEH,CAhBD,CAgBG+sF,KAAiBA,GAAe,CAAC,IAMpC,SAAWC,GASPA,EAAej5F,OAHf,SAAgBzJ,EAAOmX,GACnB,MAAO,CAAEnX,QAAOmX,SACpB,EAMAurF,EAAetH,GAJf,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,OAAOurG,GAAGC,cAAcF,IAAc3E,GAAM/D,GAAG0I,EAAU9jG,cAAgC5E,IAArB0oG,EAAU3sF,QAAwBurF,EAAetH,GAAG0I,EAAU3sF,QACtI,CAEH,CAfD,CAeGurF,KAAmBA,GAAiB,CAAC,IASxC,SAAWC,GACPA,EAA8B,UAAI,YAKlCA,EAAyB,KAAI,OAC7BA,EAA0B,MAAI,QAC9BA,EAAyB,KAAI,OAC7BA,EAA8B,UAAI,YAClCA,EAA2B,OAAI,SAC/BA,EAAkC,cAAI,gBACtCA,EAA8B,UAAI,YAClCA,EAA6B,SAAI,WACjCA,EAA6B,SAAI,WACjCA,EAA+B,WAAI,aACnCA,EAA0B,MAAI,QAC9BA,EAA6B,SAAI,WACjCA,EAA2B,OAAI,SAC/BA,EAA0B,MAAI,QAC9BA,EAA4B,QAAI,UAChCA,EAA6B,SAAI,WACjCA,EAA4B,QAAI,UAChCA,EAA2B,OAAI,SAC/BA,EAA2B,OAAI,SAC/BA,EAA2B,OAAI,SAC/BA,EAA6B,SAAI,WAIjCA,EAA8B,UAAI,WACrC,CA/BD,CA+BGA,KAAuBA,GAAqB,CAAC,IAShD,SAAWC,GACPA,EAAoC,YAAI,cACxCA,EAAmC,WAAI,aACvCA,EAAiC,SAAI,WACrCA,EAA+B,OAAI,SACnCA,EAAmC,WAAI,aACvCA,EAAiC,SAAI,WACrCA,EAA8B,MAAI,QAClCA,EAAqC,aAAI,eACzCA,EAAsC,cAAI,gBAC1CA,EAAuC,eAAI,gBAC9C,CAXD,CAWGA,KAA2BA,GAAyB,CAAC,IAKxD,SAAWC,GAMPA,EAAezH,GALf,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,UAAsC1oG,IAAvB0oG,EAAUsH,UAAwD,iBAAvBtH,EAAUsH,WACxF/gG,MAAMyK,QAAQgvF,EAAUmH,QAAoC,IAA1BnH,EAAUmH,KAAK9vG,QAA6C,iBAAtB2oG,EAAUmH,KAAK,GAC/F,CAEH,CAPD,CAOGpI,KAAmBA,GAAiB,CAAC,IAOxC,SAAWC,GAOPA,EAAgBr5F,OAHhB,SAAgBzJ,EAAOmL,GACnB,MAAO,CAAEnL,QAAOmL,OACpB,EAMA23F,EAAgB1H,GAJhB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,SAAiD3E,GAAM/D,GAAG0I,EAAU9jG,QAAU+jG,GAAG5Z,OAAO2Z,EAAU34F,KAC7G,CAEH,CAbD,CAaG23F,KAAoBA,GAAkB,CAAC,IAO1C,SAAWC,GAOPA,EAA0Bt5F,OAH1B,SAAgBzJ,EAAOqrG,EAAcC,GACjC,MAAO,CAAEtrG,QAAOqrG,eAAcC,sBAClC,EAOAvI,EAA0B3H,GAL1B,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,SAAiD3E,GAAM/D,GAAG0I,EAAU9jG,QAAU+jG,GAAGpO,QAAQmO,EAAUwH,uBAClGvH,GAAG5Z,OAAO2Z,EAAUuH,oBAA4CjwG,IAA3B0oG,EAAUuH,aAC3D,CAEH,CAdD,CAcGtI,KAA8BA,GAA4B,CAAC,IAO9D,SAAWC,GAOPA,EAAiCv5F,OAHjC,SAAgBzJ,EAAOurG,GACnB,MAAO,CAAEvrG,QAAOurG,aACpB,EAOAvI,EAAiC5H,GALjC,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,SAAiD3E,GAAM/D,GAAG0I,EAAU9jG,SACnE+jG,GAAG5Z,OAAO2Z,EAAUyH,kBAAwCnwG,IAAzB0oG,EAAUyH,WACzD,CAEH,CAdD,CAcGvI,KAAqCA,GAAmC,CAAC,IAQ5E,SAAWC,GAOPA,EAAmBx5F,OAHnB,SAAgB+hG,EAASC,GACrB,MAAO,CAAED,UAASC,kBACtB,EASAxI,EAAmB7H,GAJnB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAG2B,QAAQ5B,IAAc3E,GAAM/D,GAAG5iG,EAAMizG,gBACnD,CAEH,CAhBD,CAgBGxI,KAAuBA,GAAqB,CAAC,IAOhD,SAAWC,GAIPA,EAAc/lB,KAAO,EAIrB+lB,EAAc5mB,UAAY,EAI1B4mB,EAAc9H,GAHd,SAAY5iG,GACR,OAAiB,IAAVA,GAAyB,IAAVA,CAC1B,CAEH,CAbD,CAaG0qG,KAAkBA,GAAgB,CAAC,IAEtC,SAAWC,GAIPA,EAAmB15F,OAHnB,SAAgBjR,GACZ,MAAO,CAAEA,QACb,EASA2qG,EAAmB/H,GAPnB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,UACM1oG,IAAtB0oG,EAAUxuF,SAAyByuF,GAAG5Z,OAAO2Z,EAAUxuF,UAAYyrF,GAAc3F,GAAG0I,EAAUxuF,iBACvEla,IAAvB0oG,EAAU3nC,UAA0BijC,GAAShE,GAAG0I,EAAU3nC,kBACpC/gE,IAAtB0oG,EAAUsC,SAAyBpG,GAAQ5E,GAAG0I,EAAUsC,SACpE,CAEH,CAbD,CAaGjD,KAAuBA,GAAqB,CAAC,IAEhD,SAAWC,GAQPA,EAAU35F,OAPV,SAAgBirB,EAAUvhB,EAAOqyF,GAC7B,MAAMppG,EAAS,CAAEs4B,WAAUvhB,SAI3B,YAHa/X,IAAToqG,IACAppG,EAAOopG,KAAOA,GAEXppG,CACX,EAYAgnG,EAAUhI,GAVV,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAc5E,GAAS9D,GAAG0I,EAAUpvE,YACpDqvE,GAAG5Z,OAAO2Z,EAAU3wF,QAAU4wF,GAAGmB,WAAWpB,EAAU3wF,MAAOgwF,GAAmB/H,YAC7DhgG,IAAnB0oG,EAAU0B,MAAsBtC,GAAc9H,GAAG0I,EAAU0B,aACnCpqG,IAAxB0oG,EAAU4H,WAA4B3H,GAAGmB,WAAWpB,EAAU4H,UAAWzL,GAAS7E,WAC5DhgG,IAAtB0oG,EAAUxuF,SAAyByuF,GAAG5Z,OAAO2Z,EAAUxuF,UAAYyrF,GAAc3F,GAAG0I,EAAUxuF,iBACpEla,IAA1B0oG,EAAU6H,aAA6B5H,GAAGpO,QAAQmO,EAAU6H,qBACjCvwG,IAA3B0oG,EAAU8H,cAA8B7H,GAAGpO,QAAQmO,EAAU8H,cACzE,CAEH,CApBD,CAoBGxI,KAAcA,GAAY,CAAC,IAE9B,SAAWC,GAIPA,EAAYwI,cAHZ,SAAuBrzG,GACnB,MAAO,CAAEgtG,KAAM,UAAWhtG,QAC9B,CAEH,CALD,CAKG6qG,KAAgBA,GAAc,CAAC,IAElC,SAAWC,GAIPA,EAAqB75F,OAHrB,SAAgBqiG,EAAYC,EAAY/rG,EAAOomG,GAC3C,MAAO,CAAE0F,aAAYC,aAAY/rG,QAAOomG,UAC5C,CAEH,CALD,CAKG9C,KAAyBA,GAAuB,CAAC,IAEpD,SAAWC,GAIPA,EAAqB95F,OAHrB,SAAgBs/F,GACZ,MAAO,CAAEA,QACb,CAEH,CALD,CAKGxF,KAAyBA,GAAuB,CAAC,IAQpD,SAAWC,GAIPA,EAA4BiH,QAAU,EAItCjH,EAA4BkH,UAAY,CAC3C,CATD,CASGlH,KAAgCA,GAA8B,CAAC,IAElE,SAAWC,GAIPA,EAAuBh6F,OAHvB,SAAgBzJ,EAAOmL,GACnB,MAAO,CAAEnL,QAAOmL,OACpB,CAEH,CALD,CAKGs4F,KAA2BA,GAAyB,CAAC,IAExD,SAAWC,GAIPA,EAAwBj6F,OAHxB,SAAgBmhG,EAAaoB,GACzB,MAAO,CAAEpB,cAAaoB,yBAC1B,CAEH,CALD,CAKGtI,KAA4BA,GAA0B,CAAC,IAE1D,SAAWC,GAKPA,EAAgBvI,GAJhB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOurG,GAAGC,cAAcF,IAAclQ,GAAIwH,GAAG0I,EAAUO,MAAQN,GAAG5Z,OAAO2Z,EAAUlqG,KACvF,CAEH,CAND,CAMG+pG,KAAoBA,GAAkB,CAAC,IAKnC,IAAIsI,GA6KPlI,IA5KJ,SAAWkI,GA8CP,SAASC,EAAUjB,EAAMkB,GACrB,GAAIlB,EAAK9vG,QAAU,EAEf,OAAO8vG,EAEX,MAAMrgG,EAAKqgG,EAAK9vG,OAAS,EAAK,EACxBgF,EAAO8qG,EAAK5hG,MAAM,EAAGuB,GACrB3K,EAAQgrG,EAAK5hG,MAAMuB,GACzBshG,EAAU/rG,EAAMgsG,GAChBD,EAAUjsG,EAAOksG,GACjB,IAAIC,EAAU,EACVC,EAAW,EACXttG,EAAI,EACR,KAAOqtG,EAAUjsG,EAAKhF,QAAUkxG,EAAWpsG,EAAM9E,QAAQ,CACrD,IAAI+rF,EAAMilB,EAAQhsG,EAAKisG,GAAUnsG,EAAMosG,IAGnCpB,EAAKlsG,KAFLmoF,GAAO,EAEK/mF,EAAKisG,KAILnsG,EAAMosG,IAE1B,CACA,KAAOD,EAAUjsG,EAAKhF,QAClB8vG,EAAKlsG,KAAOoB,EAAKisG,KAErB,KAAOC,EAAWpsG,EAAM9E,QACpB8vG,EAAKlsG,KAAOkB,EAAMosG,KAEtB,OAAOpB,CACX,CAlEAgB,EAAaxiG,OAHb,SAAgB46F,EAAKjZ,EAAYvU,EAASh7E,GACtC,OAAO,IAAIywG,GAAiBjI,EAAKjZ,EAAYvU,EAASh7E,EAC1D,EAUAowG,EAAa7Q,GALb,SAAY5iG,GACR,IAAIsrG,EAAYtrG,EAChB,SAAOurG,GAAG2B,QAAQ5B,IAAcC,GAAG5Z,OAAO2Z,EAAUO,OAASN,GAAG3oG,UAAU0oG,EAAU1Y,aAAe2Y,GAAG5Z,OAAO2Z,EAAU1Y,cAAgB2Y,GAAG9E,SAAS6E,EAAUyI,YACtJxI,GAAG9jF,KAAK6jF,EAAU0I,UAAYzI,GAAG9jF,KAAK6jF,EAAU2I,aAAe1I,GAAG9jF,KAAK6jF,EAAU4I,UAC5F,EA0BAT,EAAaU,WAxBb,SAAoB56F,EAAU40F,GAC1B,IAAIx7F,EAAO4G,EAASy6F,UAChBI,EAAcV,EAAUvF,GAAO,CAACp2B,EAAG15C,KACnC,IAAIg2E,EAAOt8B,EAAEvwE,MAAMwY,MAAMnN,KAAOwrB,EAAE72B,MAAMwY,MAAMnN,KAC9C,OAAa,IAATwhG,EACOt8B,EAAEvwE,MAAMwY,MAAM40D,UAAYv2C,EAAE72B,MAAMwY,MAAM40D,UAE5Cy/B,CAAI,IAEXC,EAAqB3hG,EAAKhQ,OAC9B,IAAK,IAAI4D,EAAI6tG,EAAYzxG,OAAS,EAAG4D,GAAK,EAAGA,IAAK,CAC9C,IAAI9F,EAAI2zG,EAAY7tG,GAChBsxC,EAAct+B,EAAS26F,SAASzzG,EAAE+G,MAAMwY,OACxC0/B,EAAYnmC,EAAS26F,SAASzzG,EAAE+G,MAAMyY,KAC1C,KAAIy/B,GAAa40D,GAIb,MAAM,IAAIruG,MAAM,oBAHhB0M,EAAOA,EAAKxK,UAAU,EAAG0vC,GAAep3C,EAAEotG,QAAUl7F,EAAKxK,UAAUu3C,EAAW/sC,EAAKhQ,QAKvF2xG,EAAqBz8D,CACzB,CACA,OAAOllC,CACX,CAkCH,CA9ED,CA8EG8gG,KAAiBA,GAAe,CAAC,IAIpC,MAAMK,GACF,WAAA79F,CAAY41F,EAAKjZ,EAAYvU,EAASh7E,GAClCgK,KAAKknG,KAAO1I,EACZx+F,KAAKmnG,YAAc5hB,EACnBvlF,KAAK6U,SAAWm8D,EAChBhxE,KAAKonG,SAAWpxG,EAChBgK,KAAKqnG,kBAAe9xG,CACxB,CACA,OAAIipG,GACA,OAAOx+F,KAAKknG,IAChB,CACA,cAAI3hB,GACA,OAAOvlF,KAAKmnG,WAChB,CACA,WAAIn2B,GACA,OAAOhxE,KAAK6U,QAChB,CACA,OAAA8xF,CAAQxsG,GACJ,GAAIA,EAAO,CACP,IAAIwY,EAAQ3S,KAAK6mG,SAAS1sG,EAAMwY,OAC5BC,EAAM5S,KAAK6mG,SAAS1sG,EAAMyY,KAC9B,OAAO5S,KAAKonG,SAAStsG,UAAU6X,EAAOC,EAC1C,CACA,OAAO5S,KAAKonG,QAChB,CACA,MAAAE,CAAO/7F,EAAOylE,GACVhxE,KAAKonG,SAAW77F,EAAMjG,KACtBtF,KAAK6U,SAAWm8D,EAChBhxE,KAAKqnG,kBAAe9xG,CACxB,CACA,cAAAgyG,GACI,QAA0BhyG,IAAtByK,KAAKqnG,aAA4B,CACjC,IAAIG,EAAc,GACdliG,EAAOtF,KAAKonG,SACZK,GAAc,EAClB,IAAK,IAAIvuG,EAAI,EAAGA,EAAIoM,EAAKhQ,OAAQ4D,IAAK,CAC9BuuG,IACAD,EAAY5wG,KAAKsC,GACjBuuG,GAAc,GAElB,IAAInhG,EAAKhB,EAAKolC,OAAOxxC,GACrBuuG,EAAsB,OAAPnhG,GAAsB,OAAPA,EACnB,OAAPA,GAAepN,EAAI,EAAIoM,EAAKhQ,QAAiC,OAAvBgQ,EAAKolC,OAAOxxC,EAAI,IACtDA,GAER,CACIuuG,GAAeniG,EAAKhQ,OAAS,GAC7BkyG,EAAY5wG,KAAK0O,EAAKhQ,QAE1B0K,KAAKqnG,aAAeG,CACxB,CACA,OAAOxnG,KAAKqnG,YAChB,CACA,UAAAT,CAAWvgG,GACPA,EAAS7Q,KAAKC,IAAID,KAAKE,IAAI2Q,EAAQrG,KAAKonG,SAAS9xG,QAAS,GAC1D,IAAIkyG,EAAcxnG,KAAKunG,iBACnBjmF,EAAM,EAAGomF,EAAOF,EAAYlyG,OAChC,GAAa,IAAToyG,EACA,OAAOrO,GAASz1F,OAAO,EAAGyC,GAE9B,KAAOib,EAAMomF,GAAM,CACf,IAAIC,EAAMnyG,KAAKo4B,OAAOtM,EAAMomF,GAAQ,GAChCF,EAAYG,GAAOthG,EACnBqhG,EAAOC,EAGPrmF,EAAMqmF,EAAM,CAEpB,CAGA,IAAIniG,EAAO8b,EAAM,EACjB,OAAO+3E,GAASz1F,OAAO4B,EAAMa,EAASmhG,EAAYhiG,GACtD,CACA,QAAAqhG,CAASh4E,GACL,IAAI24E,EAAcxnG,KAAKunG,iBACvB,GAAI14E,EAASrpB,MAAQgiG,EAAYlyG,OAC7B,OAAO0K,KAAKonG,SAAS9xG,OAEpB,GAAIu5B,EAASrpB,KAAO,EACrB,OAAO,EAEX,IAAIoiG,EAAaJ,EAAY34E,EAASrpB,MAClCqiG,EAAkBh5E,EAASrpB,KAAO,EAAIgiG,EAAYlyG,OAAUkyG,EAAY34E,EAASrpB,KAAO,GAAKxF,KAAKonG,SAAS9xG,OAC/G,OAAOE,KAAKC,IAAID,KAAKE,IAAIkyG,EAAa/4E,EAAS04C,UAAWsgC,GAAiBD,EAC/E,CACA,aAAIlB,GACA,OAAO1mG,KAAKunG,iBAAiBjyG,MACjC,GAGJ,SAAW4oG,GACP,MAAM7mF,EAAW9d,OAAOwK,UAAUsT,SAIlC6mF,EAAG2B,QAHH,SAAiBltG,GACb,YAAwB,IAAVA,CAClB,EAKAurG,EAAG3oG,UAHH,SAAmB5C,GACf,YAAwB,IAAVA,CAClB,EAKAurG,EAAGpO,QAHH,SAAiBn9F,GACb,OAAiB,IAAVA,IAA4B,IAAVA,CAC7B,EAKAurG,EAAG5Z,OAHH,SAAgB3xF,GACZ,MAAgC,oBAAzB0kB,EAAS5T,KAAK9Q,EACzB,EAKAurG,EAAG/e,OAHH,SAAgBxsF,GACZ,MAAgC,oBAAzB0kB,EAAS5T,KAAK9Q,EACzB,EAKAurG,EAAGe,YAHH,SAAqBtsG,EAAO+C,EAAKD,GAC7B,MAAgC,oBAAzB4hB,EAAS5T,KAAK9Q,IAAgC+C,GAAO/C,GAASA,GAAS8C,CAClF,EAKAyoG,EAAG/E,QAHH,SAAiBxmG,GACb,MAAgC,oBAAzB0kB,EAAS5T,KAAK9Q,KAAiC,YAAcA,GAASA,GAAS,UAC1F,EAKAurG,EAAG9E,SAHH,SAAkBzmG,GACd,MAAgC,oBAAzB0kB,EAAS5T,KAAK9Q,IAAgC,GAAKA,GAASA,GAAS,UAChF,EAKAurG,EAAG9jF,KAHH,SAAcznB,GACV,MAAgC,sBAAzB0kB,EAAS5T,KAAK9Q,EACzB,EAQAurG,EAAGC,cANH,SAAuBxrG,GAInB,OAAiB,OAAVA,GAAmC,iBAAVA,CACpC,EAKAurG,EAAGmB,WAHH,SAAoB1sG,EAAOm1G,GACvB,OAAOtjG,MAAMyK,QAAQtc,IAAUA,EAAM81E,MAAMq/B,EAC/C,CAEH,CAjDD,CAiDG5J,KAAOA,GAAK,CAAC,ICtqET,MAAM6J,GACT,WAAAn/F,GACI5I,KAAKgoG,UAAY,EACrB,CACA,WAAIvsB,GACA,IAAIzkF,EACJ,OAA4D,QAApDA,EAAKgJ,KAAKgoG,UAAUhoG,KAAKgoG,UAAU1yG,OAAS,UAAuB,IAAP0B,EAAgBA,EAAKgJ,KAAKioG,QAClG,CACA,aAAAC,CAAcllG,GAIV,OAHAhD,KAAKioG,SAAW,IAAIE,GAAgBnlG,GACpChD,KAAKioG,SAAS9mF,KAAOnhB,KAAKioG,SAC1BjoG,KAAKgoG,UAAY,CAAChoG,KAAKioG,UAChBjoG,KAAKioG,QAChB,CACA,kBAAAG,CAAmBryG,GACf,MAAMsyG,EAAgB,IAAIC,GAK1B,OAJAD,EAAcvyG,cAAgBC,EAC9BsyG,EAAclnF,KAAOnhB,KAAKioG,SAC1BjoG,KAAKy7E,QAAQzlF,QAAQY,KAAKyxG,GAC1BroG,KAAKgoG,UAAUpxG,KAAKyxG,GACbA,CACX,CACA,aAAAE,CAAcjkG,EAAOvO,GACjB,MAAMyyG,EAAW,IAAIC,GAAgBnkG,EAAMkmC,YAAalmC,EAAM+lC,MAAM/0C,QAAQ,QAAagP,GAAQA,EAAM29B,WAAYlsC,GAInH,OAHAyyG,EAAS1yG,cAAgBC,EACzByyG,EAASrnF,KAAOnhB,KAAKioG,SACrBjoG,KAAKy7E,QAAQzlF,QAAQY,KAAK4xG,GACnBA,CACX,CACA,UAAAvvF,CAAW9kB,GACP,MAAMmd,EAASnd,EAAK8C,UACpB,GAAIqa,EAAQ,CACR,MAAMlc,EAAQkc,EAAOtb,QAAQqX,QAAQlZ,GACjCiB,GAAS,GACTkc,EAAOtb,QAAQmrF,OAAO/rF,EAAO,EAErC,CACJ,CACA,cAAAszG,CAAe92D,GACX,MAAMv8C,EAAQ,GACd,IAAK,MAAMiP,KAASstC,EAAQ,CACxB,MAAM42D,EAAW,IAAIC,GAAgBnkG,EAAMkmC,YAAalmC,EAAM+lC,MAAM/0C,QAAQ,QAAagP,GAAQA,EAAM29B,WAAW,GAClHumE,EAASrnF,KAAOnhB,KAAKioG,SACrB5yG,EAAMuB,KAAK4xG,EACf,CACA,IAAI/sB,EAAUz7E,KAAKy7E,QACfktB,GAAQ,EAEZ,GAAIltB,EAAQzlF,QAAQV,OAAS,EACzBmmF,EAAQzlF,QAAQY,QAAQvB,OAD5B,CAMA,KAAOomF,EAAQxkF,WAAW,CACtB,MAAM7B,EAAQqmF,EAAQxkF,UAAUjB,QAAQqX,QAAQouE,GAChD,GAAIrmF,EAAQ,EAAG,CAEXqmF,EAAQxkF,UAAUjB,QAAQmrF,OAAO/rF,EAAO,KAAMC,GAC9CszG,GAAQ,EACR,KACJ,CACAltB,EAAUA,EAAQxkF,SACtB,CAGK0xG,GACD3oG,KAAKioG,SAASjyG,QAAQ0K,WAAWrL,EAhBrC,CAkBJ,CACA,SAAAuzG,CAAUl4F,GACN,MAAM+qE,EAAUz7E,KAAKy7E,QAGK,iBAAf/qE,EAAKzV,QACZ+E,KAAKy7E,QAAQvmF,QAAUwb,GAE3BA,EAAKm4F,SAAWptB,EAChB,MAAMtnF,EAAO6L,KAAKgoG,UAAUzjG,MAG8C,KAArEpQ,aAAmC,EAASA,EAAK6B,QAAQV,SAC1D0K,KAAKiZ,WAAW9kB,EAExB,EAEG,MAAM20G,GAET,UAAIx3F,GACA,OAAOtR,KAAK/I,SAChB,CAEA,WAAIlB,GACA,OAAOiK,KAAKlK,aAChB,CACA,UAAIpC,GACA,OAAO,CACX,CACA,WAAIwB,GACA,IAAI8B,EAAI8B,EACR,MAAM3E,EAAuF,iBAA/C,QAAxB6C,EAAKgJ,KAAK+oG,gBAA6B,IAAP/xG,OAAgB,EAASA,EAAGiE,OAAsB+E,KAAK+oG,SAAqC,QAAzBjwG,EAAKkH,KAAK/I,iBAA8B,IAAP6B,OAAgB,EAASA,EAAG5D,QACtL,IAAKf,EACD,MAAM,IAAIyE,MAAM,2CAEpB,OAAOzE,CACX,CACA,WAAIe,CAAQvC,GACRqN,KAAK+oG,SAAWp2G,CACpB,CAEA,WAAIgD,GACA,OAAOqK,KAAK9K,OAChB,CACA,QAAIoQ,GACA,OAAOtF,KAAKmhB,KAAKopB,SAASzvC,UAAUkF,KAAKqG,OAAQrG,KAAK4S,IAC1D,EAEG,MAAM61F,WAAwBK,GACjC,UAAIziG,GACA,OAAOrG,KAAKgpG,OAChB,CACA,UAAI1zG,GACA,OAAO0K,KAAKipG,OAChB,CACA,OAAIr2F,GACA,OAAO5S,KAAKgpG,QAAUhpG,KAAKipG,OAC/B,CACA,UAAIv1G,GACA,OAAOsM,KAAKkpG,OAChB,CACA,aAAIjnE,GACA,OAAOjiC,KAAKmpG,UAChB,CACA,SAAIhvG,GACA,OAAO6F,KAAKopG,MAChB,CACA,WAAAxgG,CAAYvC,EAAQ/Q,EAAQ6E,EAAO8nC,EAAWvuC,GAAS,GACnDi/B,QACA3yB,KAAKkpG,QAAUx1G,EACfsM,KAAKgpG,QAAU3iG,EACfrG,KAAKmpG,WAAalnE,EAClBjiC,KAAKipG,QAAU3zG,EACf0K,KAAKopG,OAASjvG,CAClB,EAEG,MAAMmuG,WAA6BQ,GACtC,WAAAlgG,GACI+pB,SAASjvB,WACT1D,KAAKhK,QAAU,IAAIqzG,GAAiBrpG,KACxC,CAEA,YAAIkR,GACA,OAAOlR,KAAKhK,OAChB,CACA,UAAIqQ,GACA,IAAIrP,EAAI8B,EACR,OAAgG,QAAxFA,EAAwC,QAAlC9B,EAAKgJ,KAAKspG,0BAAuC,IAAPtyG,OAAgB,EAASA,EAAGqP,cAA2B,IAAPvN,EAAgBA,EAAK,CACjI,CACA,UAAIxD,GACA,OAAO0K,KAAK4S,IAAM5S,KAAKqG,MAC3B,CACA,OAAIuM,GACA,IAAI5b,EAAI8B,EACR,OAA4F,QAApFA,EAAuC,QAAjC9B,EAAKgJ,KAAKupG,yBAAsC,IAAPvyG,OAAgB,EAASA,EAAG4b,WAAwB,IAAP9Z,EAAgBA,EAAK,CAC7H,CACA,SAAIqB,GACA,MAAMqvG,EAAYxpG,KAAKspG,mBACjB5+E,EAAW1qB,KAAKupG,kBACtB,GAAIC,GAAa9+E,EAAU,CACvB,QAAyBn1B,IAArByK,KAAKypG,YAA2B,CAChC,MAAQtvG,MAAOuvG,GAAeF,GACtBrvG,MAAOwvG,GAAcj/E,EAC7B1qB,KAAKypG,YAAc,CAAE92F,MAAO+2F,EAAW/2F,MAAOC,IAAK+2F,EAAU/2F,IAAIpN,KAAOkkG,EAAW/2F,MAAMnN,KAAOkkG,EAAW/2F,MAAQg3F,EAAU/2F,IACjI,CACA,OAAO5S,KAAKypG,WAChB,CAEI,MAAO,CAAE92F,MAAO0mF,GAASz1F,OAAO,EAAG,GAAIgP,IAAKymF,GAASz1F,OAAO,EAAG,GAEvE,CACA,sBAAI0lG,GACA,IAAK,MAAMjpF,KAASrgB,KAAKhK,QACrB,IAAKqqB,EAAM3sB,OACP,OAAO2sB,EAGf,OAAOrgB,KAAKhK,QAAQ,EACxB,CACA,qBAAIuzG,GACA,IAAK,IAAIrwG,EAAI8G,KAAKhK,QAAQV,OAAS,EAAG4D,GAAK,EAAGA,IAAK,CAC/C,MAAMmnB,EAAQrgB,KAAKhK,QAAQkD,GAC3B,IAAKmnB,EAAM3sB,OACP,OAAO2sB,CAEf,CACA,OAAOrgB,KAAKhK,QAAQgK,KAAKhK,QAAQV,OAAS,EAC9C,EAEJ,MAAM+zG,WAAyB7kG,MAC3B,WAAAoE,CAAY0I,GACRqhB,QACA3yB,KAAKsR,OAASA,EACd/X,OAAO0sD,eAAejmD,KAAMqpG,GAAiBtlG,UACjD,CACA,IAAAnN,IAAQssG,GAEJ,OADAljG,KAAK4pG,WAAW1G,GACTvwE,MAAM/7B,QAAQssG,EACzB,CACA,OAAAxiG,IAAWwiG,GAEP,OADAljG,KAAK4pG,WAAW1G,GACTvwE,MAAMjyB,WAAWwiG,EAC5B,CACA,MAAA/hB,CAAOxuE,EAAOm1D,KAAUo7B,GAEpB,OADAljG,KAAK4pG,WAAW1G,GACTvwE,MAAMwuD,OAAOxuE,EAAOm1D,KAAUo7B,EACzC,CACA,UAAA0G,CAAW1G,GACP,IAAK,MAAMxyF,KAAQwyF,EACfxyF,EAAKzZ,UAAY+I,KAAKsR,MAE9B,EAEG,MAAM62F,WAAwBG,GACjC,QAAIhjG,GACA,OAAOtF,KAAK6pG,MAAM/uG,UAAUkF,KAAKqG,OAAQrG,KAAK4S,IAClD,CACA,YAAI23B,GACA,OAAOvqC,KAAK6pG,KAChB,CACA,WAAAjhG,CAAY5F,GACR2vB,QACA3yB,KAAK6pG,MAAQ,GACb7pG,KAAK6pG,MAAQ7mG,QAAqCA,EAAQ,EAC9D,ECrOG,MAAM8mG,GAAiBjiC,OAAO,YACrC,SAASkiC,GAAe51G,GACpB,OAAOA,EAAK8G,QAAU6uG,EAC1B,CACA,MACME,GAAkBj2G,GAASA,EAAKib,SADnB,KAC0Cjb,EAAOA,EADjD,IAEZ,MAAMk2G,GACT,WAAArhG,CAAYg9E,GACR5lF,KAAKkqG,iBAAmB,IAAI5yG,IAC5B0I,KAAKoiD,SAAW,IAAI9qD,IACpB0I,KAAK6D,MAAQ+hF,EAASzqF,OAAOskC,MAC7B,MAAMmS,EAAS5xC,KAAK6D,MAAM1L,WACpBy6F,EAAgD,eAAnChN,EAASP,iBAAiBoD,KAC7CzoF,KAAKmqG,QAAU,IAAIC,GAAkBx4D,EAAQr4C,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAGq2B,EAASzqF,OAAOkvG,cAAe,CAAEr/D,gBAAiB4nD,EAAY9nD,qBAAsB86C,EAASzqF,OAAOmvG,6BACrL,CACA,YAAAxwG,CAAa26B,EAAK81E,GACdvqG,KAAKmqG,QAAQK,OAAO/1E,EAAK81E,EAC7B,CACA,QAAAlX,CAAS5+D,EAAKosD,GACV7gF,KAAKmqG,QAAQM,WAAWh2E,EAAKosD,EACjC,CACA,IAAAh+B,CAAKpuB,EAAKosD,GACN7gF,KAAKmqG,QAAQO,SAASj2E,EAAKosD,EAC/B,CACA,UAAAl+B,CAAWluB,EAAKosD,GACZ7gF,KAAKmqG,QAAQQ,eAAel2E,EAAKosD,EACrC,CACA,OAAA+pB,CAAQ72G,GACJ,OAAOiM,KAAKoiD,SAASxqD,IAAI7D,EAC7B,CACA,WAAA82G,GACI,OAAO7qG,KAAKmqG,QAAQW,YACxB,CACA,mBAAIC,GACA,OAAO/qG,KAAKkqG,gBAChB,CACA,YAAAc,GACI,OAAOhrG,KAAKmqG,QAAQ1iD,UACxB,CACA,QAAAutC,GACIh1F,KAAKmqG,QAAQc,kBACjB,EAEG,MAAM9a,WAAsB8Z,GAC/B,WAAIxuB,GACA,OAAOz7E,KAAKkD,MAAMlD,KAAKkD,MAAM5N,OAAS,EAC1C,CACA,WAAAsT,CAAYg9E,GACRjzD,MAAMizD,GACN5lF,KAAKkrG,YAAc,IAAInD,GACvB/nG,KAAKkD,MAAQ,GACblD,KAAKmrG,cAAgB,IAAI7zG,IACzB0I,KAAKorG,OAASxlB,EAASylB,WAAWC,OAClCtrG,KAAKurG,UAAY3lB,EAASzqF,OAAO23B,eACjC9yB,KAAKwrG,cAAgB5lB,EAAS3yD,OAAOwyD,aACzC,CACA,IAAA7xF,CAAKA,EAAM+kE,GACP,MAAMlkE,EAAOuL,KAAKyrG,gBAAgB73G,GAC5B83G,EAAa1rG,KAAKmqG,QAAQwB,YAAY3B,GAAep2G,EAAKG,MAAOiM,KAAK4rG,oBAAoBn3G,EAAMkkE,GAAM7rD,KAAK9M,OAKjH,OAJAA,KAAKoiD,SAASzqD,IAAI/D,EAAKG,KAAM23G,GACzB93G,EAAKP,QACL2M,KAAK6rG,SAAWH,GAEbA,CACX,CACA,eAAAD,CAAgB73G,GACZ,IAAIA,EAAK03E,SAAT,CAGK,IAAI,QAAe13E,GACpB,OAAOk2G,GAEN,CACD,MAAMgC,GAAW,QAAoBl4G,GACrC,OAAOk4G,QAA2CA,EAAWl4G,EAAKG,IACtE,EACJ,CACA,KAAAgP,CAAMC,EAAO9H,EAAU,CAAC,GACpB8E,KAAKkrG,YAAYhD,cAAcllG,GAC/B,MAAM+oG,EAAc/rG,KAAK+rG,YAAc/rG,KAAK6D,MAAM2qC,SAASxrC,GAC3DhD,KAAKmqG,QAAQnnG,MAAQ+oG,EAAYn6D,OACjC,MAAM85D,EAAaxwG,EAAQtH,KAAOoM,KAAKoiD,SAASxqD,IAAIsD,EAAQtH,MAAQoM,KAAK6rG,SACzE,IAAKH,EACD,MAAM,IAAI9yG,MAAMsC,EAAQtH,KAAO,4BAA4BsH,EAAQtH,QAAU,2BAEjF,MAAM2C,EAASm1G,EAAWjoG,KAAKzD,KAAKmqG,QAAS,CAAC,GAI9C,OAHAnqG,KAAKkrG,YAAYxC,eAAeqD,EAAYr4G,QAC5CsM,KAAK+qG,gBAAgBh+F,QACrB/M,KAAK+rG,iBAAcx2G,EACZ,CACH5C,MAAO4D,EACP06F,YAAa8a,EAAYhpE,OACzBipE,YAAaD,EAAYE,OACzB/a,aAAclxF,KAAKmqG,QAAQpnE,OAEnC,CACA,mBAAA6oE,CAAoB3wG,EAAOmmE,GACvB,OAAQ79D,IAEJ,MAAM2oG,GAAclsG,KAAK6qG,oBAA2Bt1G,IAAV0F,EAC1C,GAAIixG,EAAY,CACZ,MAAM/3G,EAAO,CAAE8G,SACf+E,KAAKkD,MAAMtM,KAAKzC,GACZ8G,IAAU6uG,KACV31G,EAAKxB,MAAQ,GAErB,CACA,IAAI4D,EACJ,IACIA,EAAS6qE,EAAe79D,EAC5B,CACA,MAAO6tF,GACH76F,OAAShB,CACb,CAIA,YAHeA,IAAXgB,GAAwB21G,IACxB31G,EAASyJ,KAAK4oG,aAEXryG,CAAM,CAErB,CACA,mBAAA41G,CAAoB7nG,GAChB,MAAM8nG,EAAepsG,KAAK+rG,YAAYr4G,OACtC,IAAK04G,EAAa92G,OACd,MAAO,GAEX,MAAM+Q,EAAS/B,EAAMkmC,YACrB,IAAK,IAAItxC,EAAI,EAAGA,EAAIkzG,EAAa92G,OAAQ4D,IAAK,CAE1C,GADckzG,EAAalzG,GACjBsxC,YAAcnkC,EACpB,OAAO+lG,EAAajrB,OAAO,EAAGjoF,EAEtC,CACA,OAAOkzG,EAAajrB,OAAO,EAAGirB,EAAa92G,OAC/C,CACA,OAAA8mE,CAAQ3nC,EAAKwN,EAAWlsC,GACpB,MAAMuO,EAAQtE,KAAKmqG,QAAQkC,YAAY53E,EAAKwN,GAC5C,IAAKjiC,KAAK6qG,eAAiB7qG,KAAKssG,aAAahoG,GAAQ,CACjD,MAAM8nG,EAAepsG,KAAKmsG,oBAAoB7nG,GAC9CtE,KAAKkrG,YAAYxC,eAAe0D,GAChC,MAAM5D,EAAWxoG,KAAKkrG,YAAY3C,cAAcjkG,EAAOvO,IACjD,WAAEmB,EAAU,WAAEq1G,GAAevsG,KAAKwsG,cAAcz2G,GAChD0lF,EAAUz7E,KAAKy7E,QACrB,GAAIvkF,EAAY,CACZ,MAAMu1G,GAAiB,QAAU12G,GAAWuO,EAAM+lC,MAAQrqC,KAAKurG,UAAUnhB,QAAQ9lF,EAAM+lC,MAAOm+D,GAC9FxoG,KAAKuvD,OAAOr4D,EAAWw1G,SAAUx1G,EAAWnB,QAAS02G,EAAgBjE,EAAU+D,EACnF,MACK,GAAIxC,GAAetuB,GAAU,CAC9B,IAAIn2E,EAAOhB,EAAM+lC,OACZ,QAAUt0C,KACXuP,EAAOtF,KAAKurG,UAAUnhB,QAAQ9kF,EAAMkjG,GAAUnxF,YAElDokE,EAAQ9oF,OAAS2S,CACrB,CACJ,CACJ,CAOA,YAAAgnG,CAAahoG,GACT,OAAQA,EAAM0sD,uBAAyB/G,MAAM3lD,EAAMkmC,cAA2C,iBAApBlmC,EAAM+tC,YAA2B4X,MAAM3lD,EAAM+tC,UAC3H,CACA,OAAAmQ,CAAQ/tB,EAAK7gC,EAAM03E,EAAUv1E,EAASwN,GAClC,IAAIxM,EACCiJ,KAAK6qG,eAAkBv/B,IAKxBv0E,EAAUiJ,KAAKkrG,YAAY9C,mBAAmBryG,IAElD,MAAM42G,EAAgB3sG,KAAKmqG,QAAQyC,YAAYn4E,EAAK7gC,EAAM2P,IACrDvD,KAAK6qG,eAAiB9zG,GAAWA,EAAQzB,OAAS,GACnD0K,KAAK6sG,yBAAyBF,EAAe52G,EAASgB,EAE9D,CACA,wBAAA81G,CAAyBt2G,EAAQR,EAASgB,GACtC,MAAM,WAAEG,EAAU,WAAEq1G,GAAevsG,KAAKwsG,cAAcz2G,GACtD,GAAImB,EACA8I,KAAKuvD,OAAOr4D,EAAWw1G,SAAUx1G,EAAWnB,QAASQ,EAAQQ,EAASw1G,QAErE,IAAKr1G,EAAY,CAMlB,MAAMukF,EAAUz7E,KAAKy7E,QACrB,GAAIsuB,GAAetuB,GACfA,EAAQ9oF,OAAS4D,EAAO8gB,gBAEvB,GAAsB,iBAAX9gB,GAAuBA,EAAQ,CAC3C,MACMu2G,EADS9sG,KAAK+sG,sBAAsBx2G,EAAQklF,GAElDz7E,KAAKkD,MAAMqB,MACXvE,KAAKkD,MAAMtM,KAAKk2G,EACpB,CACJ,CACJ,CACA,MAAAp0G,CAAOuC,EAAOvC,GACV,IAAKsH,KAAK6qG,cAAe,CACrB,IAAItjF,EAAOvnB,KAAKy7E,QAChB,GAAI/iF,EAAO3C,SAAW2C,EAAOg0G,SAAU,CACnCnlF,EAAOvnB,KAAK4oG,YACZ5oG,KAAKkrG,YAAYjyF,WAAWsO,EAAKshF,UACpB7oG,KAAKkrG,YAAY9C,mBAAmB1vG,GAC5C1C,QAAQY,KAAK2wB,EAAKshF,UACvB,MAAMiE,EAAU,CAAE7xG,SAClB+E,KAAKkD,MAAMtM,KAAKk2G,GAChB9sG,KAAKuvD,OAAO72D,EAAOg0G,SAAUh0G,EAAO3C,QAASwxB,EAAMA,EAAKshF,UAAU,EACtE,MAEIthF,EAAKtsB,MAAQA,CAErB,CACJ,CACA,SAAA2tG,GACI,GAAI5oG,KAAK6qG,cACL,OAEJ,MAAMr4E,EAAMxyB,KAAKy7E,QAIjB,OAHA,SAAuBjpD,GACvBxyB,KAAKkrG,YAAYtC,UAAUp2E,GAC3BxyB,KAAKkD,MAAMqB,MACPwlG,GAAev3E,GACRxyB,KAAKurG,UAAUnhB,QAAQ53D,EAAI7/B,MAAO6/B,EAAIq2E,YAG7C,SAA0B7oG,KAAKwrG,cAAeh5E,GAE3CA,EACX,CACA,aAAAg6E,CAAcz2G,GACV,IAAKiK,KAAKmrG,cAAcr3G,IAAIiC,GAAU,CAClC,MAAMmB,GAAa,SAAmBnB,EAAS,MAC/CiK,KAAKmrG,cAAcxzG,IAAI5B,EAAS,CAC5BmB,WAAYA,EACZq1G,aAAYr1G,IAAa,QAAiBA,EAAW1C,WAE7D,CACA,OAAOwL,KAAKmrG,cAAcvzG,IAAI7B,EAClC,CACA,MAAAw5D,CAAOm9C,EAAU32G,EAASpD,EAAOoE,EAASw1G,GACtC,MAAM/5E,EAAMxyB,KAAKy7E,QACjB,IAAI/qE,EAOJ,OALIA,EADA67F,GAA+B,iBAAV55G,EACdqN,KAAKorG,OAAO4B,eAAex6E,EAAKz8B,EAASgB,EAASpE,GAGlDA,EAEH+5G,GACJ,IAAK,IACDl6E,EAAIz8B,GAAW2a,EACf,MAEJ,IAAK,KACD8hB,EAAIz8B,IAAW,EACf,MAEJ,IAAK,KACIyO,MAAMyK,QAAQujB,EAAIz8B,MACnBy8B,EAAIz8B,GAAW,IAEnBy8B,EAAIz8B,GAASa,KAAK8Z,GAG9B,CACA,qBAAAq8F,CAAsBl9F,EAAQzW,GAC1B,IAAK,MAAOrF,EAAMk5G,KAAkB1zG,OAAOC,QAAQJ,GAAS,CACxD,MAAM2xF,EAAWl7E,EAAO9b,QACPwB,IAAbw1F,EACAl7E,EAAO9b,GAAQk5G,EAEVzoG,MAAMyK,QAAQ87E,IAAavmF,MAAMyK,QAAQg+F,KAC9CA,EAAcr2G,QAAQm0F,GACtBl7E,EAAO9b,GAAQk5G,EAEvB,CAMA,MAAMC,EAAgBr9F,EAAOg5F,SAK7B,OAJIqE,IACAA,EAAch4G,aAAUK,EACxBsa,EAAOg5F,cAAWtzG,GAEfsa,CACX,CACA,oBAAIm/C,GACA,OAAOhvD,KAAKmqG,QAAQn7C,gBACxB,EAEG,MAAMm+C,GACT,yBAAAr6D,CAA0B53C,GACtB,OAAO,KAA2B43C,0BAA0B53C,EAChE,CACA,6BAAAg4C,CAA8Bh4C,GAC1B,OAAO,KAA2Bg4C,8BAA8Bh4C,EACpE,CACA,uBAAAk4C,CAAwBl4C,GACpB,OAAO,KAA2Bk4C,wBAAwBl4C,EAC9D,CACA,qBAAA64C,CAAsB74C,GAClB,OAAO,KAA2B64C,sBAAsB74C,EAC5D,EAEG,MAAMkyG,WAA0CD,GACnD,yBAAAr6D,EAA0B,SAAE5tC,EAAQ,OAAE6tC,IAMlC,MAAO,aALa7tC,EAASgvB,MACvB,IAAMhvB,EAASgvB,MAAQ,IACvBhvB,EAASnR,KAAKib,SAAS,OACnB,YAAY9J,EAASnR,KAAK+G,UAAU,EAAGoK,EAASnR,KAAKuB,OAAS,MAC9D,kBAAkB4P,EAASnR,uBACUg/C,EAAO1I,UAC1D,CACA,6BAAA6I,EAA8B,eAAEC,IAC5B,MAAO,qCAAqCA,EAAe9I,UAC/D,EAEG,MAAMgjE,WAAgCpD,GACzC,WAAArhG,GACI+pB,SAASjvB,WACT1D,KAAK4xC,OAAS,GACd5xC,KAAKstG,aAAe,GACpBttG,KAAKutG,iBAAmB,GACxBvtG,KAAKwtG,eAAiB,EACtBxtG,KAAKytG,UAAY,CACrB,CACA,MAAA/0G,GAEA,CACA,SAAAkwG,GAGA,CACA,KAAA7lG,CAAMC,GACFhD,KAAK0tG,aACL,MAAM97D,EAAS5xC,KAAK6D,MAAM2qC,SAASxrC,EAAO,CAAEylF,KAAM,YAKlD,OAJAzoF,KAAK4xC,OAASA,EAAOA,OACrB5xC,KAAKmqG,QAAQnnG,MAAQ,IAAIhD,KAAK4xC,QAC9B5xC,KAAK6rG,SAASpoG,KAAKzD,KAAKmqG,QAAS,CAAC,GAClCnqG,KAAK+qG,gBAAgBh+F,QACd,CACH6kC,OAAQ5xC,KAAK4xC,OACb07D,aAAc,IAAIttG,KAAKutG,kBACvBI,WAAY3tG,KAAKwtG,eAEzB,CACA,IAAA55G,CAAKA,EAAM+kE,GACP,MAAM+yC,EAAa1rG,KAAKmqG,QAAQwB,YAAY3B,GAAep2G,EAAKG,MAAOiM,KAAK4rG,oBAAoBjzC,GAAM7rD,KAAK9M,OAK3G,OAJAA,KAAKoiD,SAASzqD,IAAI/D,EAAKG,KAAM23G,GACzB93G,EAAKP,QACL2M,KAAK6rG,SAAWH,GAEbA,CACX,CACA,UAAAgC,GACI1tG,KAAKstG,aAAe,GACpBttG,KAAKutG,iBAAmB,GACxBvtG,KAAKwtG,eAAiB,EACtBxtG,KAAKytG,UAAY,CACrB,CACA,mBAAA7B,CAAoBxqC,GAChB,OAAQ79D,IACJ,MAAM8a,EAAOre,KAAK4tG,gBAClB,IACIxsC,EAAe79D,EACnB,CACA,QACIvD,KAAK6tG,eAAexvF,EACxB,EAER,CACA,wBAAAyvF,GACI9tG,KAAKstG,aAAansB,OAAOnhF,KAAKytG,UAClC,CACA,aAAAG,GACI,MAAMvvF,EAAOre,KAAKstG,aAAah4G,OAE/B,OADA0K,KAAKytG,UAAYpvF,EACVA,CACX,CACA,cAAAwvF,CAAexvF,GACXre,KAAK8tG,2BACL9tG,KAAKytG,UAAYpvF,CACrB,CACA,OAAA+9C,CAAQ3nC,EAAKwN,EAAWlsC,GACpBiK,KAAKmqG,QAAQkC,YAAY53E,EAAKwN,GACzBjiC,KAAK6qG,gBACN7qG,KAAKutG,iBAAmB,IAAIvtG,KAAKstG,aAAcv3G,GAC/CiK,KAAKwtG,eAAiBxtG,KAAKysC,QAAU,EAE7C,CACA,OAAA+V,CAAQ/tB,EAAK7gC,EAAM03E,EAAUv1E,EAASwN,GAClCvD,KAAK+tG,OAAOh4G,GACZiK,KAAKmqG,QAAQyC,YAAYn4E,EAAK7gC,EAAM2P,GACpCvD,KAAKguG,MAAMj4G,EACf,CACA,MAAAg4G,CAAOp4G,GACEqK,KAAK6qG,eACN7qG,KAAKstG,aAAa12G,KAAKjB,EAE/B,CACA,KAAAq4G,CAAMr4G,GACF,IAAKqK,KAAK6qG,cAAe,CACrB,MAAMz1G,EAAQ4K,KAAKstG,aAAazyG,YAAYlF,GACxCP,GAAS,GACT4K,KAAKstG,aAAansB,OAAO/rF,EAEjC,CACJ,CACA,WAAIq3C,GACA,OAAOzsC,KAAKmqG,QAAQ19D,OACxB,EAEJ,MAAMwhE,GAAgB,CAClBhjE,iBAAiB,EACjB6iB,qBAAsB,OACtB9iB,iBAAiB,EACjBF,qBAAsB,IAAIsiE,IAM9B,MAAMhD,WAA0B,KAC5B,WAAAxhG,CAAYgpC,EAAQ9hC,GAChB,MAAMo+F,EAAsBp+F,GAAU,iBAAkBA,EACxD6iB,MAAMif,EAAQr4C,OAAOg2D,OAAOh2D,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAG0+C,IAAgB,CAAE5+C,kBAAmB6+C,EACvF,IAAI,KAAqB,CAAE3yD,aAAczrC,EAAOyrC,eAChD,IAAIk6C,EAAwB,CAE1BC,QAAS5lF,EAAOk7B,gBAAkB,YAAYz1C,MAC3Cua,GACnB,CACA,gBAAIg7F,GACA,OAAO9qG,KAAK4iE,eAChB,CACA,WAAA+oC,CAAY53G,EAAM4kE,GACd,OAAO34D,KAAKmhE,KAAKptE,EAAM4kE,EAC3B,CACA,gBAAAsyC,GACIjrG,KAAKouD,qBACT,CACA,WAAAi+C,CAAY53E,EAAKwN,GACb,OAAOjiC,KAAKo8D,QAAQ3nC,EAAKwN,EAC7B,CACA,WAAA2qE,CAAYn4E,EAAK7gC,EAAM2P,GACnB,OAAOvD,KAAKwiD,QAAQ/tB,EAAK7gC,EAAM,CAC3B0nE,KAAM,CAAC/3D,IAEf,CACA,MAAAinG,CAAO/1E,EAAK81E,GACRvqG,KAAK8iD,GAAGruB,EAAK81E,EACjB,CACA,UAAAE,CAAWh2E,EAAKosD,GACZ7gF,KAAKyiD,OAAOhuB,EAAKosD,EACrB,CACA,QAAA6pB,CAASj2E,EAAKosD,GACV7gF,KAAK6iD,KAAKpuB,EAAKosD,EACnB,CACA,cAAA8pB,CAAel2E,EAAKosD,GAChB7gF,KAAK2iD,WAAWluB,EAAKosD,EACzB,E,0BCpdG,SAASstB,GAAat7G,EAASsI,EAAQy2C,GAO1C,OAEJ,SAAoBw8D,EAAev7G,GAC/B,MAAMw7G,GAAY,QAAqBx7G,GAAS,GAC1Cy7G,GAAc,EAAAjlC,GAAA,IAAOx2E,EAAQK,OAAOO,OAAO,MAAcA,QAAOG,GAAQy6G,EAAUv6G,IAAIF,KAC5F,IAAK,MAAMA,KAAQ06G,EAAa,CAC5B,MAAM5jD,EAAMnxD,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAG6+C,GAAgB,CAAEhyC,QAAS,EAAGi3B,SAAU,EAAG7wC,QAAS,EAAGK,KAAM,EAAGC,GAAI,IAChHsrD,EAAcjzG,OAAOvH,KAAKA,EAAM26G,GAAa7jD,EAAK92D,EAAKuE,YAC3D,CACJ,CAVIq2G,CALsB,CAClBrzG,SACAy2C,SACA7+C,UAAW,IAAIuE,KAEOzE,GACnBsI,CACX,CASA,SAASozG,GAAa7jD,EAAK/0D,EAAS84G,GAAc,GAC9C,IAAIC,EACJ,IAAI,QAAU/4G,GACV+4G,EAmOR,SAAsBhkD,EAAKv0D,GACvB,MAAMs+B,EAAMi2B,EAAI0R,UACV93D,EAAQomD,EAAI9Y,OAAOz7C,EAAQxD,OACjC,IAAK2R,EACD,MAAM,IAAI1L,MAAM,qCAAuCzC,EAAQxD,OAEnE,MAAO,IAAM+3D,EAAIvvD,OAAOihE,QAAQ3nC,EAAKnwB,EAAOnO,EAChD,CA1OiBw4G,CAAajkD,EAAK/0D,QAE1B,IAAI,QAASA,GACd+4G,EA6BR,SAAqBhkD,EAAKhyD,GACtB,MAAMD,GAAa,QAAYC,GAC/B,MAAO,IAAMgyD,EAAIvvD,OAAOzC,OAAOD,EAAYC,EAC/C,CAhCiBk2G,CAAYlkD,EAAK/0D,QAEzB,IAAI,QAAaA,GAClB+4G,EAASH,GAAa7jD,EAAK/0D,EAAQnB,eAElC,IAAI,QAAiBmB,GACtB+4G,EAASG,GAAoBnkD,EAAK/0D,QAEjC,IAAI,QAAWA,GAChB+4G,EAwBR,SAAuBhkD,EAAKokD,GACxB,MAAMl7G,EAAOk7G,EAASl7G,KAAKS,IAC3B,IAAI,QAAaT,GAAO,CACpB,MAAM6gC,EAAMi2B,EAAIlI,UACV8oB,EAAW13E,EAAK03E,SAChBx1D,EAAYg5F,EAASprG,UAAUpO,OAAS,EAetD,SAAgC1B,EAAMm7G,GAClC,MAAM/yD,EAAa+yD,EAAUt1G,KAAIrG,GAAK47G,GAAe57G,EAAET,SACvD,OAAQ4Q,IACJ,MAAM0rG,EAAW,CAAC,EAClB,IAAK,IAAI/1G,EAAI,EAAGA,EAAI8iD,EAAW1mD,OAAQ4D,IAAK,CACxC,MAAMg2G,EAAat7G,EAAKyV,WAAWnQ,GAC7B4c,EAAYkmC,EAAW9iD,GAC7B+1G,EAASC,EAAWn7G,MAAQ+hB,EAAUvS,EAC1C,CACA,OAAO0rG,CAAQ,CAEvB,CA1B0DE,CAAuBv7G,EAAMk7G,EAASprG,WAAa,KAAM,CAAG,GAC9G,OAAQH,GAASmnD,EAAIvvD,OAAOqnD,QAAQ/tB,EAAKm2E,GAAQlgD,EAAK92D,GAAO03E,EAAUwjC,EAAUh5F,EAAUvS,GAC/F,CACK,IAAI,QAAe3P,GAAO,CAC3B,MAAM6gC,EAAMi2B,EAAI0R,UACVsyC,EAASU,GAAS1kD,EAAK92D,EAAKG,MAClC,MAAO,IAAM22D,EAAIvvD,OAAOihE,QAAQ3nC,EAAKi6E,EAAQI,EACjD,CACK,IAAKl7G,EACN,MAAM,IAAI,KAAkBk7G,EAASjG,SAAU,mBAAmBiG,EAASl7G,KAAK6mF,aAGhF,QAAkB7mF,EAE1B,CA3CiBy7G,CAAc3kD,EAAK/0D,QAE3B,IAAI,QAAeA,GACpB+4G,EA8ER,SAA2BhkD,EAAK5wD,GAC5B,GAAqC,IAAjCA,EAAaC,SAASzE,OACtB,OAAOi5G,GAAa7jD,EAAK5wD,EAAaC,SAAS,IAE9C,CACD,MAAM0T,EAAU,GAChB,IAAK,MAAM9X,KAAWmE,EAAaC,SAAU,CACzC,MAAMu1G,EAAmB,CAGrB9hD,IAAK+gD,GAAa7jD,EAAK/0D,GAAS,IAE9Bg+B,EAAQ47E,GAAkB55G,GAC5Bg+B,IACA27E,EAAiBrzD,KAAO+yD,GAAer7E,IAE3ClmB,EAAQ7W,KAAK04G,EACjB,CACA,MAAM76E,EAAMi2B,EAAI5H,KAChB,OAAQv/C,GAASmnD,EAAIvvD,OAAOrB,aAAa26B,EAAKhnB,EAAQhU,KAAIi1G,IACtD,MAAMh2E,EAAM,CACR80B,IAAK,IAAMkhD,EAAOlhD,IAAIjqD,IAEpB2yF,EAAOwY,EAAOzyD,KAIpB,OAHIi6C,IACAx9D,EAAIujB,KAAO,IAAMi6C,EAAK3yF,IAEnBm1B,CAAG,IAElB,CACJ,CA5GiB82E,CAAkB9kD,EAAK/0D,QAE/B,IAAI,QAAiBA,GACtB+4G,EA0GR,SAA6BhkD,EAAKxwD,GAC9B,GAA8B,IAA1BA,EAAMH,SAASzE,OACf,OAAOi5G,GAAa7jD,EAAKxwD,EAAMH,SAAS,IAE5C,MAAM0T,EAAU,GAChB,IAAK,MAAM9X,KAAWuE,EAAMH,SAAU,CAClC,MAAMu1G,EAAmB,CAGrB9hD,IAAK+gD,GAAa7jD,EAAK/0D,GAAS,IAE9Bg+B,EAAQ47E,GAAkB55G,GAC5Bg+B,IACA27E,EAAiBrzD,KAAO+yD,GAAer7E,IAE3ClmB,EAAQ7W,KAAK04G,EACjB,CACA,MAAMG,EAAQ/kD,EAAI5H,KACZ4sD,EAAS,CAACjzB,EAAUkzB,IAEf,UAAUlzB,KADDkzB,EAAQ3E,eAAetxG,KAAK,OAG1CI,EAAgByJ,GAASmnD,EAAIvvD,OAAOrB,aAAa21G,EAAOhiG,EAAQhU,KAAI,CAACi1G,EAAQj6E,KAC/E,MAAMiE,EAAM,CAAE80B,IAAK,KAAM,GACnBryD,EAASuvD,EAAIvvD,OACnBu9B,EAAI80B,IAAM,KAEN,GADAkhD,EAAOlhD,IAAIjqD,IACNpI,EAAO0vG,cAAe,CACvB,MAAM10F,EAAMu5F,EAAOD,EAAOt0G,GACrBA,EAAO4vG,gBAAgBnzG,IAAIue,IAE5Bhb,EAAO4vG,gBAAgBpzG,IAAIwe,EAAK,IAEpC,MAAMy5F,EAAaz0G,EAAO4vG,gBAAgBnzG,IAAIue,QAC2C,KAA7Ey5F,aAA+C,EAASA,EAAWn7E,MAE3Em7E,EAAWn7E,IAAO,EAE1B,GAEJ,MAAMyhE,EAAOwY,EAAOzyD,KAWpB,OATIvjB,EAAIujB,KADJi6C,EACW,IAAMA,EAAK3yF,GAGX,KACP,MAAMssG,EAAsB10G,EAAO4vG,gBAAgBnzG,IAAI83G,EAAOD,EAAOt0G,IAErE,QADgB00G,aAAiE,EAASA,EAAoBp7E,GAClG,EAGbiE,CAAG,KAERo3E,EAAUv1G,GAAKmwD,EAAK6kD,GAAkBr1G,GAAQJ,EAAc,KAClE,OAAQyJ,IACJusG,EAAQvsG,GACHmnD,EAAIvvD,OAAO0vG,eACZngD,EAAIvvD,OAAO4vG,gBAAgBgF,OAAOL,EAAOD,EAAO/kD,EAAIvvD,QACxD,CAER,CAtKiB60G,CAAoBtlD,EAAK/0D,QAEjC,IAAI,QAAQA,GACb+4G,EAoKR,SAAoBhkD,EAAKxwD,GACrB,MAAMuT,EAAUvT,EAAMH,SAASN,KAAIrG,GAAKm7G,GAAa7jD,EAAKt3D,KAC1D,OAAQmQ,GAASkK,EAAQvZ,SAAQw6G,GAAUA,EAAOnrG,IACtD,CAvKiB0sG,CAAWvlD,EAAK/0D,OAExB,MAAI,QAAYA,GAKjB,MAAM,IAAI,KAAkBA,EAAQkzG,SAAU,4BAA4BlzG,EAAQsF,SALvD,CAC3B,MAAMw5B,EAAMi2B,EAAI0R,UAChBsyC,EAAS,IAAMhkD,EAAIvvD,OAAOihE,QAAQ3nC,EAAK,KAAK9+B,EAChD,CAGA,CACA,OAAO4E,GAAKmwD,EAAK+jD,OAAcl5G,EAAYg6G,GAAkB55G,GAAU+4G,EAAQ/4G,EAAQqE,YAC3F,CAqCA,SAASg1G,GAAelnG,GACpB,IAAI,QAAcA,GAAY,CAC1B,MAAMxN,EAAO00G,GAAelnG,EAAUxN,MAChCF,EAAQ40G,GAAelnG,EAAU1N,OACvC,OAAQmJ,GAAUjJ,EAAKiJ,IAASnJ,EAAMmJ,EAC1C,CACK,IAAI,QAAcuE,GAAY,CAC/B,MAAMxN,EAAO00G,GAAelnG,EAAUxN,MAChCF,EAAQ40G,GAAelnG,EAAU1N,OACvC,OAAQmJ,GAAUjJ,EAAKiJ,IAASnJ,EAAMmJ,EAC1C,CACK,IAAI,QAAWuE,GAAY,CAC5B,MAAMnV,EAAQq8G,GAAelnG,EAAUnV,OACvC,OAAQ4Q,IAAU5Q,EAAM4Q,EAC5B,CACK,IAAI,QAAqBuE,GAAY,CACtC,MAAM/T,EAAO+T,EAAUo5C,UAAU7sD,IAAIN,KACrC,OAAQwP,QAAkBhO,IAATgO,IAAqC,IAAfA,EAAKxP,EAChD,CACK,IAAI,QAAiB+T,GAAY,CAClC,MAAMnV,EAAQuF,QAAQ4P,EAAUooG,MAChC,MAAO,IAAMv9G,CACjB,EACA,QAAkBmV,EACtB,CAiGA,SAASynG,GAAkB55G,GACvB,IAAI,QAAQA,GACR,OAAOA,EAAQw6G,cAGvB,CACA,SAAStB,GAAoBnkD,EAAKn2D,EAAUC,EAAWD,EAASC,UAC5D,GAAKA,EAWA,KAAI,QAAWA,KAAa,QAAaA,EAASZ,KAAKS,KAAM,CAE9D,MAAMT,EAAOY,EAASZ,KAAKS,IACrBogC,EAAMi2B,EAAIlI,UAChB,OAAQj/C,GAASmnD,EAAIvvD,OAAOqnD,QAAQ/tB,EAAKm2E,GAAQlgD,EAAK92D,IAAO,EAAOW,EAAUgP,EAClF,CACK,IAAI,QAAW/O,KAAa,QAAeA,EAASZ,KAAKS,KAAM,CAChE,MAAMogC,EAAMi2B,EAAI0R,UACVvnE,EAAeu6G,GAAS1kD,EAAKl2D,EAASZ,KAAKS,IAAIN,MACrD,MAAO,IAAM22D,EAAIvvD,OAAOihE,QAAQ3nC,EAAK5/B,EAAcN,EACvD,CACK,IAAI,QAAUC,GAAW,CAC1B,MAAMigC,EAAMi2B,EAAI0R,UACVjmE,EAAUi5G,GAAS1kD,EAAKl2D,EAAS7B,OACvC,MAAO,IAAM+3D,EAAIvvD,OAAOihE,QAAQ3nC,EAAKt+B,EAAS5B,EAClD,CAEI,MAAM,IAAIqE,MAAM,yCACpB,CA7Be,CACX,IAAKrE,EAASE,KAAKJ,IACf,MAAM,IAAIuE,MAAM,wCAA0CrE,EAASE,KAAKgmF,UAE5E,MAAMvjF,GAAa,QAAmB3C,EAASE,KAAKJ,KAC9C+7G,EAAiBl5G,aAA+C,EAASA,EAAW1C,SAC1F,IAAK47G,EACD,MAAM,IAAIx3G,MAAM,6CAA8C,QAAYrE,EAASE,KAAKJ,MAE5F,OAAOw6G,GAAoBnkD,EAAKn2D,EAAU67G,EAC9C,CAoBJ,CASA,SAAS71G,GAAKmwD,EAAK/2B,EAAO+6E,EAAQ10G,GAC9B,MAAMk8F,EAAOviE,GAASq7E,GAAer7E,GACrC,IAAK35B,EAAa,CACd,GAAIk8F,EAAM,CACN,MAAMzhE,EAAMi2B,EAAI5H,KAChB,OAAQv/C,GAASmnD,EAAIvvD,OAAOrB,aAAa26B,EAAK,CAC1C,CACI+4B,IAAK,IAAMkhD,EAAOnrG,GAClB04C,KAAM,IAAMi6C,EAAK3yF,IAErB,CACIiqD,KAAK,UACLvR,KAAM,KAAOi6C,EAAK3yF,KAG9B,CAEI,OAAOmrG,CAEf,CACA,GAAoB,MAAhB10G,EAAqB,CACrB,MAAMy6B,EAAMi2B,EAAI7H,OAChB,OAAQt/C,GAASmnD,EAAIvvD,OAAO0nD,KAAKpuB,EAAK,CAClCs4B,IAAK,IAAM2hD,EAAOnrG,GAClB04C,KAAMi6C,EAAO,IAAMA,EAAK3yF,QAAQhO,GAExC,CACK,GAAoB,MAAhByE,EAAqB,CAC1B,MAAMy6B,EAAMi2B,EAAI7H,OAChB,GAAIqzC,EAAM,CACN,MAAMuZ,EAAQ/kD,EAAI5H,KAKlB,OAAQv/C,GAASmnD,EAAIvvD,OAAOrB,aAAa21G,EAAO,CAC5C,CACIjiD,IAAK,IAAM9C,EAAIvvD,OAAOwnD,WAAWluB,EAAK,CAClCs4B,IAAK,IAAM2hD,EAAOnrG,KAEtB04C,KAAM,IAAMi6C,EAAK3yF,IAErB,CACIiqD,KAAK,UACLvR,KAAM,KAAOi6C,EAAK3yF,KAG9B,CAEI,OAAQA,GAASmnD,EAAIvvD,OAAOwnD,WAAWluB,EAAK,CACxCs4B,IAAK,IAAM2hD,EAAOnrG,IAG9B,CACK,GAAoB,MAAhBvJ,EAAqB,CAC1B,MAAMy6B,EAAMi2B,EAAI2oC,WAChB,OAAQ9vF,GAASmnD,EAAIvvD,OAAOk4F,SAAS5+D,EAAK,CACtCs4B,IAAK,IAAM2hD,EAAOnrG,GAClB04C,KAAMi6C,EAAO,IAAMA,EAAK3yF,QAAQhO,GAExC,EAEI,QAAkByE,EAE1B,CACA,SAAS4wG,GAAQlgD,EAAK/0D,GAClB,MAAM5B,EAMV,SAAqB22D,EAAK/0D,GACtB,IAAI,QAAaA,GACb,OAAOA,EAAQ5B,KAEd,GAAI22D,EAAI33D,UAAUe,IAAI6B,GACvB,OAAO+0D,EAAI33D,UAAU6E,IAAIjC,GAExB,CACD,IAAI+a,EAAO/a,EACP2b,EAASZ,EAAKtZ,WACd67C,EAAWt9C,EAAQsF,MACvB,OAAQ,QAAaqW,IAAS,CAC1B,IAAI,QAAQA,KAAW,QAAeA,KAAW,QAAiBA,GAAS,CAEvE2hC,EADc3hC,EAAOvX,SAASsT,QAAQqD,GACrB2G,WAAa,IAAM47B,CACxC,CACAviC,EAAOY,EACPA,EAASA,EAAOla,UACpB,CAIA,OAFA67C,EADa3hC,EACGvd,KAAO,IAAMk/C,EAC7ByX,EAAI33D,UAAU4E,IAAIhC,EAASs9C,GACpBA,CACX,CACJ,CA9BiBo9D,CAAY3lD,EAAK/0D,GACxB/B,EAAO82D,EAAIvvD,OAAOyvG,QAAQ72G,GAChC,IAAKH,EACD,MAAM,IAAIgF,MAAM,SAAS7E,kBAC7B,OAAOH,CACX,CA0BA,SAASw7G,GAAS1kD,EAAK32D,GACnB,MAAMuQ,EAAQomD,EAAI9Y,OAAO79C,GACzB,IAAKuQ,EACD,MAAM,IAAI1L,MAAM,UAAU7E,kBAC9B,OAAOuQ,CACX,CCpWO,SAASgsG,GAAoB1qB,GAChC,MAAMzqF,EAQH,SAA8ByqF,GACjC,MAAM/yF,EAAU+yF,EAAS7P,QACnBlyE,EAAQ+hF,EAASzqF,OAAOskC,MACxBtkC,EAAS,IAAIg1F,GAAcvK,GACjC,OAAOuoB,GAAat7G,EAASsI,EAAQ0I,EAAM1L,WAC/C,CAbmBo4G,CAAqB3qB,GAEpC,OADAzqF,EAAO65F,WACA75F,CACX,C,gDCOA,IAAIq1G,GAAW,EACXC,GAA2B,GAoBxB,MAAM,GAAqB5oC,OAAO,sBAKlC,SAAS6oC,GAAqBtf,GACjC,OAAOA,IAAQ,EACnB,CAYOx8E,eAAe+7F,GAAkBrsG,GACpC,GAAIA,IAAU,MAAkBq8E,KAE5B,OAEJ,MAAMlF,EAAUm1B,YAAYp2F,MAS5B,GARIihE,EAAU+0B,IAAYC,KACtBD,GAAW/0B,QA1DR,IAAIo1B,SAAQ/jB,IAGa,oBAAjBgkB,aACPC,WAAWjkB,EAAS,GAGpBgkB,aAAahkB,EACjB,IAuDA0jB,GAAWI,YAAYp2F,OAEvBlW,EAAM0sG,wBACN,MAAM,EAEd,CAKO,MAAM,GACT,WAAApoG,GACI5I,KAAKixG,QAAU,IAAIJ,SAAQ,CAAC/jB,EAASjmF,KACjC7G,KAAK8sF,QAAWokB,IACZpkB,EAAQokB,GACDlxG,MAEXA,KAAK6G,OAAUuqF,IACXvqF,EAAOuqF,GACApxF,KACV,GAET,EC3FJ,MAAM,GACF,WAAA4I,CAAY41F,EAAKjZ,EAAYvU,EAASh7E,GAClCgK,KAAKknG,KAAO1I,EACZx+F,KAAKmnG,YAAc5hB,EACnBvlF,KAAK6U,SAAWm8D,EAChBhxE,KAAKonG,SAAWpxG,EAChBgK,KAAKqnG,kBAAe9xG,CACxB,CACA,OAAIipG,GACA,OAAOx+F,KAAKknG,IAChB,CACA,cAAI3hB,GACA,OAAOvlF,KAAKmnG,WAChB,CACA,WAAIn2B,GACA,OAAOhxE,KAAK6U,QAChB,CACA,OAAA8xF,CAAQxsG,GACJ,GAAIA,EAAO,CACP,MAAMwY,EAAQ3S,KAAK6mG,SAAS1sG,EAAMwY,OAC5BC,EAAM5S,KAAK6mG,SAAS1sG,EAAMyY,KAChC,OAAO5S,KAAKonG,SAAStsG,UAAU6X,EAAOC,EAC1C,CACA,OAAO5S,KAAKonG,QAChB,CACA,MAAAE,CAAOjG,EAASrwB,GACZ,IAAK,MAAMuwB,KAAUF,EACjB,GAAI,GAAiB8P,cAAc5P,GAAS,CAExC,MAAMpnG,EAAQi3G,GAAmB7P,EAAOpnG,OAElCqwC,EAAcxqC,KAAK6mG,SAAS1sG,EAAMwY,OAClC0/B,EAAYryC,KAAK6mG,SAAS1sG,EAAMyY,KACtC5S,KAAKonG,SAAWpnG,KAAKonG,SAAStsG,UAAU,EAAG0vC,GAAe+2D,EAAOj8F,KAAOtF,KAAKonG,SAAStsG,UAAUu3C,EAAWryC,KAAKonG,SAAS9xG,QAEzH,MAAMk7C,EAAYh7C,KAAKC,IAAI0E,EAAMwY,MAAMnN,KAAM,GACvC0sC,EAAU18C,KAAKC,IAAI0E,EAAMyY,IAAIpN,KAAM,GACzC,IAAIgiG,EAAcxnG,KAAKqnG,aACvB,MAAMgK,EAAmBC,GAAmB/P,EAAOj8F,MAAM,EAAOklC,GAChE,GAAI0H,EAAU1B,IAAc6gE,EAAiB/7G,OACzC,IAAK,IAAI4D,EAAI,EAAG8L,EAAMqsG,EAAiB/7G,OAAQ4D,EAAI8L,EAAK9L,IACpDsuG,EAAYtuG,EAAIs3C,EAAY,GAAK6gE,EAAiBn4G,QAIlDm4G,EAAiB/7G,OAAS,IAC1BkyG,EAAYrmB,OAAO3wC,EAAY,EAAG0B,EAAU1B,KAAc6gE,GAG1DrxG,KAAKqnG,aAAeG,EAAcA,EAAYhkG,MAAM,EAAGgtC,EAAY,GAAGh9C,OAAO69G,EAAkB7J,EAAYhkG,MAAM0uC,EAAU,IAGnI,MAAM80D,EAAOzF,EAAOj8F,KAAKhQ,QAAU+8C,EAAY7H,GAC/C,GAAa,IAATw8D,EACA,IAAK,IAAI9tG,EAAIs3C,EAAY,EAAI6gE,EAAiB/7G,OAAQ0P,EAAMwiG,EAAYlyG,OAAQ4D,EAAI8L,EAAK9L,IACrFsuG,EAAYtuG,GAAKsuG,EAAYtuG,GAAK8tG,CAG9C,KACK,KAAI,GAAiBuK,OAAOhQ,GAK7B,MAAM,IAAI3oG,MAAM,iCAJhBoH,KAAKonG,SAAW7F,EAAOj8F,KACvBtF,KAAKqnG,kBAAe9xG,CAIxB,CAEJyK,KAAK6U,SAAWm8D,CACpB,CACA,cAAAu2B,GAII,YAH0BhyG,IAAtByK,KAAKqnG,eACLrnG,KAAKqnG,aAAeiK,GAAmBtxG,KAAKonG,UAAU,IAEnDpnG,KAAKqnG,YAChB,CACA,UAAAT,CAAWvgG,GACPA,EAAS7Q,KAAKC,IAAID,KAAKE,IAAI2Q,EAAQrG,KAAKonG,SAAS9xG,QAAS,GAC1D,MAAMkyG,EAAcxnG,KAAKunG,iBACzB,IAAIjmF,EAAM,EAAGomF,EAAOF,EAAYlyG,OAChC,GAAa,IAAToyG,EACA,MAAO,CAAEliG,KAAM,EAAG+hE,UAAWlhE,GAEjC,KAAOib,EAAMomF,GAAM,CACf,MAAMC,EAAMnyG,KAAKo4B,OAAOtM,EAAMomF,GAAQ,GAClCF,EAAYG,GAAOthG,EACnBqhG,EAAOC,EAGPrmF,EAAMqmF,EAAM,CAEpB,CAGA,MAAMniG,EAAO8b,EAAM,EAEnB,MAAO,CAAE9b,OAAM+hE,WADflhE,EAASrG,KAAKwxG,gBAAgBnrG,EAAQmhG,EAAYhiG,KACfgiG,EAAYhiG,GACnD,CACA,QAAAqhG,CAASh4E,GACL,MAAM24E,EAAcxnG,KAAKunG,iBACzB,GAAI14E,EAASrpB,MAAQgiG,EAAYlyG,OAC7B,OAAO0K,KAAKonG,SAAS9xG,OAEpB,GAAIu5B,EAASrpB,KAAO,EACrB,OAAO,EAEX,MAAMoiG,EAAaJ,EAAY34E,EAASrpB,MACxC,GAAIqpB,EAAS04C,WAAa,EACtB,OAAOqgC,EAEX,MAAMC,EAAkBh5E,EAASrpB,KAAO,EAAIgiG,EAAYlyG,OAAUkyG,EAAY34E,EAASrpB,KAAO,GAAKxF,KAAKonG,SAAS9xG,OAC3G+Q,EAAS7Q,KAAKE,IAAIkyG,EAAa/4E,EAAS04C,UAAWsgC,GACzD,OAAO7nG,KAAKwxG,gBAAgBnrG,EAAQuhG,EACxC,CACA,eAAA4J,CAAgBnrG,EAAQuhG,GACpB,KAAOvhG,EAASuhG,GAAc6J,GAAMzxG,KAAKonG,SAAS7pE,WAAWl3B,EAAS,KAClEA,IAEJ,OAAOA,CACX,CACA,aAAIqgG,GACA,OAAO1mG,KAAKunG,iBAAiBjyG,MACjC,CACA,oBAAO67G,CAAc5lG,GACjB,MAAM0yF,EAAY1yF,EAClB,OAAO0yF,SACuB,iBAAnBA,EAAU34F,WAAyC/P,IAApB0oG,EAAU9jG,aACrB5E,IAA1B0oG,EAAUyT,aAA8D,iBAA1BzT,EAAUyT,YACjE,CACA,aAAOH,CAAOhmG,GACV,MAAM0yF,EAAY1yF,EAClB,OAAO0yF,SACuB,iBAAnBA,EAAU34F,WAAyC/P,IAApB0oG,EAAU9jG,YAAiD5E,IAA1B0oG,EAAUyT,WACzF,EAEG,IAAI,GA8DX,SAASrL,GAAUjB,EAAMkB,GACrB,GAAIlB,EAAK9vG,QAAU,EAEf,OAAO8vG,EAEX,MAAMrgG,EAAKqgG,EAAK9vG,OAAS,EAAK,EACxBgF,EAAO8qG,EAAK5hG,MAAM,EAAGuB,GACrB3K,EAAQgrG,EAAK5hG,MAAMuB,GACzBshG,GAAU/rG,EAAMgsG,GAChBD,GAAUjsG,EAAOksG,GACjB,IAAIC,EAAU,EACVC,EAAW,EACXttG,EAAI,EACR,KAAOqtG,EAAUjsG,EAAKhF,QAAUkxG,EAAWpsG,EAAM9E,QAAQ,CACrD,MAAM+rF,EAAMilB,EAAQhsG,EAAKisG,GAAUnsG,EAAMosG,IAGrCpB,EAAKlsG,KAFLmoF,GAAO,EAEK/mF,EAAKisG,KAILnsG,EAAMosG,IAE1B,CACA,KAAOD,EAAUjsG,EAAKhF,QAClB8vG,EAAKlsG,KAAOoB,EAAKisG,KAErB,KAAOC,EAAWpsG,EAAM9E,QACpB8vG,EAAKlsG,KAAOkB,EAAMosG,KAEtB,OAAOpB,CACX,CACA,SAASkM,GAAmBhsG,EAAMqsG,EAAeC,EAAa,GAC1D,MAAMr7G,EAASo7G,EAAgB,CAACC,GAAc,GAC9C,IAAK,IAAI14G,EAAI,EAAGA,EAAIoM,EAAKhQ,OAAQ4D,IAAK,CAClC,MAAMoN,EAAKhB,EAAKi4B,WAAWrkC,GACvBu4G,GAAMnrG,KACK,KAAPA,GAA2CpN,EAAI,EAAIoM,EAAKhQ,QAAqC,KAA3BgQ,EAAKi4B,WAAWrkC,EAAI,IACtFA,IAEJ3C,EAAOK,KAAKg7G,EAAa14G,EAAI,GAErC,CACA,OAAO3C,CACX,CACA,SAASk7G,GAAMv0E,GACX,OAAgB,KAATA,GAAsD,KAATA,CACxD,CACA,SAASk0E,GAAmBj3G,GACxB,MAAMwY,EAAQxY,EAAMwY,MACdC,EAAMzY,EAAMyY,IAClB,OAAID,EAAMnN,KAAOoN,EAAIpN,MAASmN,EAAMnN,OAASoN,EAAIpN,MAAQmN,EAAM40D,UAAY30D,EAAI20D,UACpE,CAAE50D,MAAOC,EAAKA,IAAKD,GAEvBxY,CACX,CACA,SAAS03G,GAAkB1S,GACvB,MAAMhlG,EAAQi3G,GAAmBjS,EAAShlG,OAC1C,OAAIA,IAAUglG,EAAShlG,MACZ,CAAEqmG,QAASrB,EAASqB,QAASrmG,SAEjCglG,CACX,EA3HA,SAAWiH,GAYPA,EAAaxiG,OAHb,SAAgB46F,EAAKjZ,EAAYvU,EAASh7E,GACtC,OAAO,IAAI,GAAiBwoG,EAAKjZ,EAAYvU,EAASh7E,EAC1D,EAoBAowG,EAAakB,OATb,SAAgBp7F,EAAUm1F,EAASrwB,GAC/B,GAAI9kE,aAAoB,GAEpB,OADAA,EAASo7F,OAAOjG,EAASrwB,GAClB9kE,EAGP,MAAM,IAAItT,MAAM,uEAExB,EA6BAwtG,EAAaU,WA3Bb,SAAoB56F,EAAU40F,GAC1B,MAAMx7F,EAAO4G,EAASy6F,UAChBI,EAAcV,GAAUvF,EAAMrnG,IAAIo4G,KAAoB,CAACnnC,EAAG15C,KAC5D,MAAMg2E,EAAOt8B,EAAEvwE,MAAMwY,MAAMnN,KAAOwrB,EAAE72B,MAAMwY,MAAMnN,KAChD,OAAa,IAATwhG,EACOt8B,EAAEvwE,MAAMwY,MAAM40D,UAAYv2C,EAAE72B,MAAMwY,MAAM40D,UAE5Cy/B,CAAI,IAEf,IAAIC,EAAqB,EACzB,MAAM6K,EAAQ,GACd,IAAK,MAAM1+G,KAAK2zG,EAAa,CACzB,MAAMv8D,EAAct+B,EAAS26F,SAASzzG,EAAE+G,MAAMwY,OAC9C,GAAI63B,EAAcy8D,EACd,MAAM,IAAIruG,MAAM,oBAEX4xC,EAAcy8D,GACnB6K,EAAMl7G,KAAK0O,EAAKxK,UAAUmsG,EAAoBz8D,IAE9Cp3C,EAAEotG,QAAQlrG,QACVw8G,EAAMl7G,KAAKxD,EAAEotG,SAEjByG,EAAqB/6F,EAAS26F,SAASzzG,EAAE+G,MAAMyY,IACnD,CAEA,OADAk/F,EAAMl7G,KAAK0O,EAAKoB,OAAOugG,IAChB6K,EAAMp4G,KAAK,GACtB,CAEH,CA5DD,CA4DG,KAAiB,GAAe,CAAC,I,ICnLzBq4G,G,YACX,SAAWA,GAKPA,EAAcA,EAAuB,QAAI,GAAK,UAM9CA,EAAcA,EAAsB,OAAI,GAAK,SAK7CA,EAAcA,EAA8B,eAAI,GAAK,iBAQrDA,EAAcA,EAA8B,eAAI,GAAK,iBAKrDA,EAAcA,EAAsB,OAAI,GAAK,SAM7CA,EAAcA,EAAiC,kBAAI,GAAK,oBAKxDA,EAAcA,EAAyB,UAAI,GAAK,WACnD,CAzCD,CAyCGA,KAAkBA,GAAgB,CAAC,IAC/B,MAAMC,GACT,WAAAppG,CAAYg9E,GACR5lF,KAAKiyG,gBAAkBrsB,EAASzyD,gBAChCnzB,KAAKkyG,cAAgBtsB,EAASK,UAAUksB,cACxCnyG,KAAKmlF,mBAAqBS,EAASK,UAAUmsB,kBACjD,CACA,aAAMC,CAAQ7T,EAAK8T,EAAoB,MAAkB3xB,MACrD,MAAM3qF,QAAgBgK,KAAKmlF,mBAAmBH,SAASwZ,GACvD,OAAOx+F,KAAKuyG,YAAY/T,EAAKxoG,EAASs8G,EAC1C,CACA,gBAAAE,CAAiB3R,EAAcrC,EAAKl6F,GAEhC,OADAk6F,EAAMA,QAAiCA,EAAM,KAAIz7F,MAAM89F,EAAarC,KAChE,MAAkBjJ,GAAGjxF,GACdtE,KAAKuyG,YAAY/T,EAAKqC,EAAcv8F,GAGpCtE,KAAK4D,OAAO46F,EAAKqC,EAAcv8F,EAE9C,CACA,UAAAmuG,CAAWntG,EAAMk5F,EAAKl6F,GAClB,OAAI,MAAkBixF,GAAGjxF,GACdtE,KAAKuyG,YAAY/T,EAAKl5F,EAAMhB,GAG5BtE,KAAK4D,OAAO46F,EAAKl5F,EAAMhB,EAEtC,CACA,SAAA6hF,CAAUusB,EAAOlU,GACb,OAAOx+F,KAAK4D,OAAO46F,EAAK,CAAEmU,OAAQD,GACtC,CACA,MAAA9uG,CAAO46F,EAAKxoG,EAASkF,GACjB,GAAuB,iBAAZlF,EAAsB,CAC7B,MAAM48G,EAAc5yG,KAAK+C,MAAMy7F,EAAKxoG,EAASkF,GAC7C,OAAO8E,KAAK6yG,sBAAsBD,EAAapU,OAAKjpG,EAAWS,EACnE,CACK,GAAI,WAAYA,EAAS,CAC1B,MAAM48G,EAAc,CAAEjgH,MAAOqD,EAAQ28G,OAAQzhB,aAAc,GAAID,YAAa,IAC5E,OAAOjxF,KAAK6yG,sBAAsBD,EAAapU,EACnD,CACK,CACD,MAAMoU,EAAc5yG,KAAK+C,MAAMy7F,EAAKxoG,EAAQ2wG,UAAWzrG,GACvD,OAAO8E,KAAK6yG,sBAAsBD,EAAapU,EAAKxoG,EACxD,CACJ,CACA,iBAAMu8G,CAAY/T,EAAKxoG,EAAS88G,GAC5B,GAAuB,iBAAZ98G,EAAsB,CAC7B,MAAM48G,QAAoB5yG,KAAK+yG,WAAWvU,EAAKxoG,EAAS88G,GACxD,OAAO9yG,KAAK6yG,sBAAsBD,EAAapU,OAAKjpG,EAAWS,EACnE,CACK,CACD,MAAM48G,QAAoB5yG,KAAK+yG,WAAWvU,EAAKxoG,EAAQ2wG,UAAWmM,GAClE,OAAO9yG,KAAK6yG,sBAAsBD,EAAapU,EAAKxoG,EACxD,CACJ,CAYA,qBAAA68G,CAAsBD,EAAapU,EAAKqC,EAAcv7F,GAClD,IAAI4G,EACJ,GAAI20F,EACA30F,EAAW,CACP0mG,cACApU,MACA35F,MAAOktG,GAAciB,OACrB3H,WAAY,GACZxK,oBAGH,CACD,MAAMoS,EAAqBjzG,KAAKkzG,yBAAyB1U,EAAKl5F,GAC9D4G,EAAW,CACP0mG,cACApU,MACA35F,MAAOktG,GAAciB,OACrB3H,WAAY,GACZ,gBAAIxK,GACA,OAAOoS,GACX,EAER,CAEA,OADAL,EAAYjgH,MAAMwgH,UAAYjnG,EACvBA,CACX,CACA,YAAMo7F,CAAOp7F,EAAUomG,GACnB,IAAIt7G,EAAI8B,EAER,MAAMs6G,EAAyD,QAA9Cp8G,EAAKkV,EAAS0mG,YAAYjgH,MAAMk2G,gBAA6B,IAAP7xG,OAAgB,EAASA,EAAGmqB,KAAKopB,SAClGs2D,EAA6C,QAA7B/nG,EAAKkH,KAAKkyG,qBAAkC,IAAPp5G,OAAgB,EAASA,EAAGlB,IAAIsU,EAASsyF,IAAInnF,YAClG/R,EAAOu7F,EAAeA,EAAa8F,gBAAkB3mG,KAAKmlF,mBAAmBH,SAAS94E,EAASsyF,KACrG,GAAIqC,EACAtnG,OAAO8wD,eAAen+C,EAAU,eAAgB,CAC5CvZ,MAAOkuG,QAGV,CACD,MAAMoS,EAAqBjzG,KAAKkzG,yBAAyBhnG,EAASsyF,IAAKl5F,GACvE/L,OAAO8wD,eAAen+C,EAAU,eAAgB,CAC5CtU,IAAKq7G,GAEb,CAQA,OALIG,IAAY9tG,IACZ4G,EAAS0mG,kBAAoB5yG,KAAK+yG,WAAW7mG,EAASsyF,IAAKl5F,EAAMgtG,GACjEpmG,EAAS0mG,YAAYjgH,MAAMwgH,UAAYjnG,GAE3CA,EAASrH,MAAQktG,GAAciB,OACxB9mG,CACX,CACA,KAAAnJ,CAAMy7F,EAAKl5F,EAAMpK,GAEb,OADiB8E,KAAKiyG,gBAAgBoB,YAAY7U,GAClCrjG,OAAOg1F,cAAcptF,MAAMuC,EAAMpK,EACrD,CACA,UAAA63G,CAAWvU,EAAKl5F,EAAMgtG,GAElB,OADiBtyG,KAAKiyG,gBAAgBoB,YAAY7U,GAClCrjG,OAAOm4G,YAAYvwG,MAAMuC,EAAMgtG,EACnD,CACA,wBAAAY,CAAyB1U,EAAKl5F,GAC1B,MAAM2sG,EAAkBjyG,KAAKiyG,gBAC7B,IAAIsB,EACJ,MAAO,IACIA,QAAyCA,EAAWA,EAAU,GAAa3vG,OAAO46F,EAAInnF,WAAY46F,EAAgBoB,YAAY7U,GAAKnZ,iBAAiBE,WAAY,EAAGjgF,QAAmCA,EAAO,GAE5N,EAEG,MAAMkuG,GACT,WAAA5qG,CAAYg9E,GACR5lF,KAAKyzG,YAAc,IAAIn8G,IACvB0I,KAAK0zG,uBAAyB9tB,EAASK,UAAUC,uBACjDlmF,KAAKiyG,gBAAkBrsB,EAASzyD,eACpC,CACA,OAAIwgF,GACA,OAAO,EAAAtqC,GAAA,IAAOrpE,KAAKyzG,YAAY1vF,SACnC,CACA,WAAA6vF,CAAY1nG,GACR,MAAM2nG,EAAY3nG,EAASsyF,IAAInnF,WAC/B,GAAIrX,KAAKyzG,YAAY3/G,IAAI+/G,GACrB,MAAM,IAAIj7G,MAAM,4BAA4Bi7G,0BAEhD7zG,KAAKyzG,YAAY97G,IAAIk8G,EAAW3nG,EACpC,CACA,WAAA4nG,CAAYtV,GACR,MAAMqV,EAAYrV,EAAInnF,WACtB,OAAOrX,KAAKyzG,YAAY77G,IAAIi8G,EAChC,CACA,yBAAME,CAAoBvV,EAAK8T,GAC3B,IAAIpmG,EAAWlM,KAAK8zG,YAAYtV,GAChC,OAAItyF,IAGJA,QAAiBlM,KAAK0zG,uBAAuBrB,QAAQ7T,EAAK8T,GAC1DtyG,KAAK4zG,YAAY1nG,GACVA,EACX,CACA,cAAA8nG,CAAexV,EAAKl5F,EAAMgtG,GACtB,GAAIA,EACA,OAAOtyG,KAAK0zG,uBAAuBjB,WAAWntG,EAAMk5F,EAAK8T,GAAmB2B,MAAK/nG,IAC7ElM,KAAK4zG,YAAY1nG,GACVA,KAGV,CACD,MAAMA,EAAWlM,KAAK0zG,uBAAuBjB,WAAWntG,EAAMk5F,GAE9D,OADAx+F,KAAK4zG,YAAY1nG,GACVA,CACX,CACJ,CACA,WAAAgoG,CAAY1V,GACR,OAAOx+F,KAAKyzG,YAAY3/G,IAAI0qG,EAAInnF,WACpC,CACA,kBAAA88F,CAAmB3V,GACf,MAAMqV,EAAYrV,EAAInnF,WAChB+8F,EAAap0G,KAAKyzG,YAAY77G,IAAIi8G,GACxC,GAAIO,EAAY,CACGp0G,KAAKiyG,gBAAgBoB,YAAY7U,GAAK6M,WAAWC,OACzDn0F,OAAOi9F,GACdA,EAAWvvG,MAAQktG,GAAcsC,QACjCD,EAAWE,uBAAoB/+G,EAC/B6+G,EAAWvpC,iBAAct1E,CAC7B,CACA,OAAO6+G,CACX,CACA,cAAAG,CAAe/V,GACX,MAAMqV,EAAYrV,EAAInnF,WAChB+8F,EAAap0G,KAAKyzG,YAAY77G,IAAIi8G,GAKxC,OAJIO,IACAA,EAAWvvG,MAAQktG,GAAcsC,QACjCr0G,KAAKyzG,YAAY1D,OAAO8D,IAErBO,CACX,EC5PJ,MAAMI,GAAgB3sC,OAAO,iBACtB,MAAM4sC,GACT,WAAA7rG,CAAYg9E,GACR5lF,KAAKq1E,WAAauQ,EAAS3yD,OAAOwyD,cAClCzlF,KAAK00G,iBAAmB,IAAM9uB,EAAS3yD,OAAOgzD,UAAU0uB,iBACxD30G,KAAK40G,cAAgBhvB,EAASylB,WAAWwJ,cACzC70G,KAAK80G,eAAiBlvB,EAASK,UAAU8uB,cAC7C,CACA,UAAMhlG,CAAK7D,EAAU4mG,EAAc,MAAkBnyB,MACjD,IAAK,MAAMxsF,KAAQ,SAAU+X,EAAS0mG,YAAYjgH,aACxCg+G,GAAkBmC,IACxB,SAAiB3+G,GAAMD,SAAQG,GAAO2L,KAAKg1G,OAAO3gH,EAAK6X,IAE/D,CACA,MAAA8oG,CAAO96B,EAAShuE,GACZ,IAAIlV,EACJ,MAAM3C,EAAM6lF,EAAQU,UAEpB,QAAiBrlF,IAAblB,EAAI4gH,KAAoB,CACxB5gH,EAAI4gH,KAAOT,GACX,IACI,MAAMxoD,EAAchsD,KAAKk1G,aAAah7B,GACtC,IAAI,SAAeluB,GACf33D,EAAI4gH,KAAOjpD,OAIX,GADA33D,EAAI8gH,iBAAmBnpD,EACnBhsD,KAAK00G,mBAAmBR,YAAYloD,EAAYopD,aAAc,CAE9D,MAAMC,EAAar1G,KAAKs1G,YAAYtpD,GACpC33D,EAAI4gH,KAAOI,QAA+CA,EAAar1G,KAAKu1G,mBAAmBr7B,EAASluB,EAC5G,MAGI33D,EAAI4gH,UAAO1/G,CAGvB,CACA,MAAO67F,GACHj1E,QAAQrZ,MAAM,mDAAmDzO,EAAIomF,aAAc2W,GACnF,MAAM9hC,EAAsC,QAAtBt4D,EAAKo6F,EAAIz1D,eAA4B,IAAP3kC,EAAgBA,EAAKmmC,OAAOi0D,GAChF/8F,EAAI4gH,KAAO17G,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAG2qB,GAAU,CAAEv+C,QAAS,mDAAmDtnC,EAAIomF,cAAcnrB,KACzI,CAKApjD,EAASm/F,WAAWz0G,KAAKvC,EAC7B,CACJ,CACA,MAAA8iB,CAAOjL,GACH,IAAK,MAAM7X,KAAO6X,EAASm/F,kBAChBh3G,EAAI4gH,YACJ5gH,EAAI8gH,iBAEfjpG,EAASm/F,WAAa,EAC1B,CACA,YAAA6J,CAAah7B,GACT,MACMluB,EADQhsD,KAAK40G,cAAcY,SAASt7B,GAChBu7B,WAAWv7B,EAAQU,UAAUH,UACvD,OAAOzuB,QAAiDA,EAAchsD,KAAKu1G,mBAAmBr7B,EAClG,CACA,cAAA8yB,CAAe74G,EAAMa,EAAU0gH,EAASC,GAGpC,MAAMvK,EAASprG,KACT46E,EAAY,CACdg7B,SAAUF,EACVj7B,SAAUk7B,EACV,OAAIthH,GACA,IAAI2C,EACJ,IAAI,SAAUgJ,KAAKi1G,MAEf,OAAOj1G,KAAKi1G,KAEX,IAAI,SAAqBj1G,KAAKm1G,kBAAmB,CAElD,MAAME,EAAajK,EAAOkK,YAAYt1G,KAAKm1G,kBAC3Cn1G,KAAKi1G,KAAOI,QAA+CA,EAAajK,EAAOmK,mBAAmB,CAAE36B,YAAW3jF,UAAW9C,EAAMa,YAAYgL,KAAKm1G,iBACrJ,MACK,QAAkB5/G,IAAdyK,KAAKi1G,KAAoB,CAE9Bj1G,KAAKi1G,KAAOT,GACZ,MAAMtoG,GAAW,SAAa/X,GAAMg/G,UAC9B0C,EAAUzK,EAAO0K,cAAc,CAAEl7B,YAAW3jF,UAAW9C,EAAMa,aACnE,GAAI6gH,EAAQ/yG,OAASoJ,GAAYA,EAASrH,MAAQktG,GAAcgE,eAE5D,OAAO/1G,KAAKi1G,UAAO1/G,EAEvByK,KAAKi1G,KAA+B,QAAvBj+G,EAAK6+G,EAAQ1hH,YAAyB,IAAP6C,EAAgBA,EAAK6+G,EAAQ/yG,MACzE9C,KAAKm1G,iBAAmBU,EAAQ5jC,MAChC/lE,SAAoDA,EAASm/F,WAAWz0G,KAAKoJ,KACjF,MACK,GAAIA,KAAKi1G,OAAST,GACnB,MAAM,IAAI57G,MAAM,yCAAyCwyG,EAAO0J,eAAekB,eAAe7hH,MAASa,cAAqB2gH,OAEhI,OAAO,SAAU31G,KAAKi1G,MAAQj1G,KAAKi1G,UAAO1/G,CAC9C,EACA,oBAAI0gH,GACA,OAAOj2G,KAAKm1G,gBAChB,EACA,SAAIryG,GACA,OAAO,SAAe9C,KAAKi1G,MAAQj1G,KAAKi1G,UAAO1/G,CACnD,GAEJ,OAAOqlF,CACX,CACA,aAAAk7B,CAAc57B,GACV,IAAIljF,EACJ,IACI,MAAMg1D,EAAchsD,KAAKk1G,aAAah7B,GACtC,IAAI,SAAeluB,GACf,MAAO,CAAElpD,MAAOkpD,GAEpB,MAAMqpD,EAAar1G,KAAKs1G,YAAYtpD,GACpC,OAAIqpD,EACO,CAAElhH,KAAMkhH,EAAYpjC,MAAOjmB,GAG3B,CACHimB,MAAOjmB,EACPlpD,MAAO9C,KAAKu1G,mBAAmBr7B,EAASluB,GAGpD,CACA,MAAOolC,GACHj1E,QAAQrZ,MAAM,mDAAmDo3E,EAAQU,UAAUH,aAAc2W,GACjG,MAAM9hC,EAAsC,QAAtBt4D,EAAKo6F,EAAIz1D,eAA4B,IAAP3kC,EAAgBA,EAAKmmC,OAAOi0D,GAChF,MAAO,CACHtuF,MAAOvJ,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAG2qB,GAAU,CAAEv+C,QAAS,mDAAmDu+C,EAAQU,UAAUH,cAAcnrB,MAEvJ,CACJ,CACA,WAAAgmD,CAAYY,GACR,GAAIA,EAAgB/hH,KAChB,OAAO+hH,EAAgB/hH,KAE3B,MAAMkgB,EAAMrU,KAAK00G,mBAAmBZ,YAAYoC,EAAgBd,aAChE,OAAK/gG,EAGErU,KAAK80G,eAAeqB,WAAW9hG,EAAIu+F,YAAYjgH,MAAOujH,EAAgBh8F,WAH7E,CAIJ,CACA,kBAAAq7F,CAAmBr7B,EAASk8B,GAGxB,MAAMlqG,GAAW,SAAaguE,EAAQjjF,WAAWk8G,UAC7CjnG,GAAYA,EAASrH,MAAQktG,GAAcgE,gBAC3C55F,QAAQ0e,KAAK,gFAAgF3uB,EAASsyF,SAE1G,MAAM6X,EAAgBr2G,KAAKq1E,WAAW4E,iBAAiBC,GACvD,OAAO3gF,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAG2qB,GAAU,CAAEv+C,QAAS,kCAAkC06E,YAAwBn8B,EAAQU,UAAUH,aAAc27B,qBAC1J,ECzJG,MAAME,GACT,OAAAC,CAAQpiH,GACJ,GALD,SAAiBA,GACpB,MAA4B,iBAAdA,EAAKJ,IACvB,CAGYyiH,CAAQriH,GACR,OAAOA,EAAKJ,IAGpB,CACA,WAAA0iH,CAAYtiH,GACR,OAAO,QAAoBA,EAAK00G,SAAU,OAC9C,ECXG,IAAI6N,IACX,SAAWA,GACPA,EAASrpB,SAAW,KAAMA,SAC1BqpB,EAAStpB,QAAU,KAAMA,QACzBspB,EAASppB,QAAU,KAAMA,QACzBopB,EAASlnB,SAAW,KAAMA,SAC1BknB,EAASjnB,YAAc,KAAMA,YAI7BinB,EAASC,OAHT,SAAgBjsC,EAAG15C,GACf,OAAQ05C,aAA6B,EAASA,EAAErzD,eAAiB2Z,aAA6B,EAASA,EAAE3Z,WAC7G,EAiBAq/F,EAASxpB,SAfT,SAAkB9wD,EAAMC,GACpB,MAAMu6E,EAA2B,iBAATx6E,EAAoBA,EAAOA,EAAKliB,KAClD28F,EAAuB,iBAAPx6E,EAAkBA,EAAKA,EAAGniB,KAC1C48F,EAAYF,EAASnwG,MAAM,KAAKhT,QAAOL,GAAKA,EAAEkC,OAAS,IACvDyhH,EAAUF,EAAOpwG,MAAM,KAAKhT,QAAOL,GAAKA,EAAEkC,OAAS,IACzD,IAAI4D,EAAI,EACR,KAAOA,EAAI49G,EAAUxhH,QACbwhH,EAAU59G,KAAO69G,EAAQ79G,GADJA,KAO7B,MAFiB,MAAM89G,OAAOF,EAAUxhH,OAAS4D,GAClC69G,EAAQvzG,MAAMtK,GAAGQ,KAAK,IAEzC,EAKAg9G,EAAS1pB,UAHT,SAAmBwR,GACf,OAAO,KAAIz7F,MAAMy7F,EAAInnF,YAAYA,UACrC,CAEH,CA9BD,CA8BGq/F,KAAaA,GAAW,CAAC,IC3BrB,MAAMO,GACT,WAAAruG,CAAYg9E,GACR5lF,KAAKk3G,aAAetxB,EAASylB,WAAW8L,aACxCn3G,KAAK5K,MAAQwwF,EAAS3yD,OAAOgzD,UAAUmxB,aACvCp3G,KAAKq3G,YAAczxB,EAASK,UAAU8uB,cAC1C,CACA,eAAAuC,CAAgBC,GACZ,GAAIA,EAAe,CACf,MAAMrgH,GAAa,QAAeqgH,GAC5BC,EAAWD,EAAcriH,QAC/B,GAAIgC,GAAcsgH,EAAU,CACxB,MAAM58B,EAAY48B,EAAStgH,EAAWnB,SACtC,IAAI,SAAY6kF,GACZ,OAAOA,EAAUvmF,IAEhB,GAAImQ,MAAMyK,QAAQ2rE,GACnB,IAAK,MAAMvmF,KAAOumF,EACd,IAAI,SAAYvmF,IAAQA,EAAIuhH,UACrBvhH,EAAIuhH,SAASvvG,QAAUkxG,EAAclxG,QACrChS,EAAIuhH,SAAShjG,KAAO2kG,EAAc3kG,IACrC,OAAOve,EAAIA,GAI3B,CACA,GAAImjH,EAAU,CACV,MAAMC,EAAWz3G,KAAKk3G,aAAaT,YAAYe,GAE/C,GAAIC,IAAaA,IAAaF,IAAiB,QAAYA,EAAeE,IACtE,OAAOD,CAEf,CACJ,CAEJ,CACA,mBAAAE,CAAoBH,GAChB,MAAMriH,EAAU8K,KAAKs3G,gBAAgBC,GACrC,GAAIriH,aAAyC,EAASA,EAAQ2zG,SAAU,CACpE,MAAM8O,EAAa33G,KAAKk3G,aAAaT,YAAYvhH,GACjD,OAAOyiH,QAA+CA,EAAaziH,EAAQ2zG,QAC/E,CAEJ,CACA,cAAA+O,CAAeD,EAAYz8G,GACvB,MAAM28G,EAAO,GACb,GAAI38G,EAAQ48G,mBAAoB,CAC5B,MAAMzjH,EAAM2L,KAAK+3G,mBAAmBJ,GAChCtjH,GACAwjH,EAAKjhH,KAAKvC,EAElB,CACA,IAAI2jH,EAAkBh4G,KAAK5K,MAAM6iH,kBAAkBN,EAAY33G,KAAKq3G,YAAYrB,eAAe2B,IAK/F,OAJIz8G,EAAQk6G,cACR4C,EAAkBA,EAAgBvkH,QAAOY,GAAOqiH,GAASC,OAAOtiH,EAAI6jH,UAAWh9G,EAAQk6G,gBAE3FyC,EAAKjhH,QAAQohH,IACN,EAAA3uC,GAAA,IAAOwuC,EAClB,CACA,kBAAAE,CAAmBJ,GACf,MAAMF,EAAWz3G,KAAKk3G,aAAaT,YAAYkB,GAC/C,GAAIF,EAAU,CACV,MAAMpjG,GAAM,SAAYsjG,GAClBz9F,EAAOla,KAAKq3G,YAAYrB,eAAe2B,GAC7C,MAAO,CACHO,UAAW7jG,EAAImqF,IACf2Z,WAAYj+F,EACZukF,UAAWpqF,EAAImqF,IACf15C,WAAY5qC,EACZk+F,SAAS,QAAkBX,GAC3BY,OAAO,EAEf,CAEJ,EC3EG,MAAMC,GACT,WAAA1vG,CAAY7O,GAER,GADAiG,KAAKvG,IAAM,IAAInC,IACXyC,EACA,IAAK,MAAOoc,EAAKxjB,KAAUoH,EACvBiG,KAAKhM,IAAImiB,EAAKxjB,EAG1B,CAIA,QAAI0rB,GACA,OAAO,MAAUqI,KAAI,EAAA2iD,GAAA,IAAOrpE,KAAKvG,IAAIsqB,UAAUtqB,KAAIixE,GAAKA,EAAEp1E,SAC9D,CAIA,KAAAyX,GACI/M,KAAKvG,IAAIsT,OACb,CASA,OAAOoJ,EAAKxjB,GACR,QAAc4C,IAAV5C,EACA,OAAOqN,KAAKvG,IAAIs2G,OAAO55F,GAEtB,CACD,MAAM4N,EAAS/jB,KAAKvG,IAAI7B,IAAIue,GAC5B,GAAI4N,EAAQ,CACR,MAAM3uB,EAAQ2uB,EAAO1W,QAAQ1a,GAC7B,GAAIyC,GAAS,EAOT,OANsB,IAAlB2uB,EAAOzuB,OACP0K,KAAKvG,IAAIs2G,OAAO55F,GAGhB4N,EAAOo9D,OAAO/rF,EAAO,IAElB,CAEf,CACA,OAAO,CACX,CACJ,CAQA,GAAAwC,CAAIue,GACA,IAAInf,EACJ,OAAoC,QAA5BA,EAAKgJ,KAAKvG,IAAI7B,IAAIue,UAAyB,IAAPnf,EAAgBA,EAAK,EACrE,CAMA,GAAAlD,CAAIqiB,EAAKxjB,GACL,QAAc4C,IAAV5C,EACA,OAAOqN,KAAKvG,IAAI3F,IAAIqiB,GAEnB,CACD,MAAM4N,EAAS/jB,KAAKvG,IAAI7B,IAAIue,GAC5B,QAAI4N,GACOA,EAAO1W,QAAQ1a,IAAU,CAGxC,CACJ,CAIA,GAAAqB,CAAImiB,EAAKxjB,GAOL,OANIqN,KAAKvG,IAAI3F,IAAIqiB,GACbnW,KAAKvG,IAAI7B,IAAIue,GAAKvf,KAAKjE,GAGvBqN,KAAKvG,IAAI9B,IAAIwe,EAAK,CAACxjB,IAEhBqN,IACX,CAIA,MAAAu4G,CAAOpiG,EAAK4N,GAOR,OANI/jB,KAAKvG,IAAI3F,IAAIqiB,GACbnW,KAAKvG,IAAI7B,IAAIue,GAAKvf,QAAQmtB,GAG1B/jB,KAAKvG,IAAI9B,IAAIwe,EAAK3R,MAAM43B,KAAKrY,IAE1B/jB,IACX,CAIA,OAAA9L,CAAQy0E,GACJ3oE,KAAKvG,IAAIvF,SAAQ,CAACmiB,EAAOF,IAAQE,EAAMniB,SAAQvB,GAASg2E,EAAWh2E,EAAOwjB,EAAKnW,SACnF,CAIA,CAAC6nE,OAAOvxE,YACJ,OAAO0J,KAAKxG,UAAUlD,UAC1B,CAIA,OAAAkD,GACI,OAAO,EAAA6vE,GAAA,IAAOrpE,KAAKvG,IAAID,WAClBvD,SAAQ,EAAEkgB,EAAKE,KAAWA,EAAM5c,KAAI9G,GAAS,CAACwjB,EAAKxjB,MAC5D,CAIA,IAAAkf,GACI,OAAO,EAAAw3D,GAAA,IAAOrpE,KAAKvG,IAAIoY,OAC3B,CAIA,MAAAkS,GACI,OAAO,EAAAslD,GAAA,IAAOrpE,KAAKvG,IAAIsqB,UAAUqlD,MACrC,CAIA,mBAAAovC,GACI,OAAO,EAAAnvC,GAAA,IAAOrpE,KAAKvG,IAAID,UAC3B,EAEG,MAAMi/G,GACT,QAAIp6F,GACA,OAAOre,KAAKvG,IAAI4kB,IACpB,CACA,WAAAzV,CAAY7O,GAGR,GAFAiG,KAAKvG,IAAM,IAAInC,IACf0I,KAAK04G,QAAU,IAAIphH,IACfyC,EACA,IAAK,MAAOoc,EAAKxjB,KAAUoH,EACvBiG,KAAKrI,IAAIwe,EAAKxjB,EAG1B,CACA,KAAAoa,GACI/M,KAAKvG,IAAIsT,QACT/M,KAAK04G,QAAQ3rG,OACjB,CACA,GAAApV,CAAIwe,EAAKxjB,GAGL,OAFAqN,KAAKvG,IAAI9B,IAAIwe,EAAKxjB,GAClBqN,KAAK04G,QAAQ/gH,IAAIhF,EAAOwjB,GACjBnW,IACX,CACA,GAAApI,CAAIue,GACA,OAAOnW,KAAKvG,IAAI7B,IAAIue,EACxB,CACA,MAAAwiG,CAAOhmH,GACH,OAAOqN,KAAK04G,QAAQ9gH,IAAIjF,EAC5B,CACA,OAAOwjB,GACH,MAAMxjB,EAAQqN,KAAKvG,IAAI7B,IAAIue,GAC3B,YAAc5gB,IAAV5C,IACAqN,KAAKvG,IAAIs2G,OAAO55F,GAChBnW,KAAK04G,QAAQ3I,OAAOp9G,IACb,EAGf,ECrKG,MAAMimH,GACT,WAAAhwG,CAAYg9E,GACR5lF,KAAKk3G,aAAetxB,EAASylB,WAAW8L,aACxCn3G,KAAKkyE,aAAe0T,EAASK,UAAU4yB,0BAC3C,CACA,oBAAMC,CAAe5sG,EAAU4mG,EAAc,MAAkBnyB,MAC3D,OAAO3gF,KAAK+4G,sBAAsB7sG,EAAS0mG,YAAYjgH,MAAOuZ,OAAU3W,EAAWu9G,EACvF,CAaA,2BAAMiG,CAAsBC,EAAY9sG,EAAUgF,EAAW,MAAgB4hG,EAAc,MAAkBnyB,MACzG,MAAMN,EAAU,GAChBrgF,KAAKi5G,WAAWD,EAAY34B,EAASn0E,GACrC,IAAK,MAAM/X,KAAQ+c,EAAS8nG,SAClBrI,GAAkBmC,GACxB9yG,KAAKi5G,WAAW9kH,EAAMksF,EAASn0E,GAEnC,OAAOm0E,CACX,CAKA,UAAA44B,CAAW9kH,EAAMksF,EAASn0E,GACtB,MAAMnY,EAAOiM,KAAKk3G,aAAaX,QAAQpiH,GACnCJ,GACAssF,EAAQzpF,KAAKoJ,KAAKkyE,aAAagnC,kBAAkB/kH,EAAMJ,EAAMmY,GAErE,CACA,wBAAMitG,CAAmBjtG,EAAU4mG,EAAc,MAAkBnyB,MAC/D,MAAMsnB,EAAW/7F,EAAS0mG,YAAYjgH,MAChCymH,EAAS,IAAId,GAEnB,IAAK,MAAMnkH,KAAQ,SAAkB8zG,SAC3B0I,GAAkBmC,GACxB9yG,KAAKq5G,YAAYllH,EAAM+X,EAAUktG,GAErC,OAAOA,CACX,CAMA,WAAAC,CAAYllH,EAAM+X,EAAUktG,GACxB,MAAMniH,EAAY9C,EAAKiD,WACvB,GAAIH,EAAW,CACX,MAAMlD,EAAOiM,KAAKk3G,aAAaX,QAAQpiH,GACnCJ,GACAqlH,EAAOplH,IAAIiD,EAAW+I,KAAKkyE,aAAagnC,kBAAkB/kH,EAAMJ,EAAMmY,GAE9E,CACJ,ECvEG,MAAMotG,GACT,WAAA1wG,CAAY7O,EAAUw/G,EAAYr+G,GAC9B,IAAIlE,EACJgJ,KAAKjG,SAAWA,EAChBiG,KAAKu5G,WAAaA,EAClBv5G,KAAK4rE,gBAAuG,QAApF50E,EAAKkE,aAAyC,EAASA,EAAQ0wE,uBAAoC,IAAP50E,GAAgBA,CACxI,CACA,cAAAwiH,GACI,OAAIx5G,KAAKu5G,WACEv5G,KAAKjG,SAASvG,OAAOwM,KAAKu5G,WAAWC,kBAGrCx5G,KAAKjG,QAEpB,CACA,UAAA07G,CAAW1hH,GACP,MAAMskH,EAAQr4G,KAAK4rE,gBACb5rE,KAAKjG,SAAS5G,MAAKC,GAAKA,EAAEW,KAAK8D,gBAAkB9D,EAAK8D,gBACtDmI,KAAKjG,SAAS5G,MAAKC,GAAKA,EAAEW,OAASA,IACzC,OAAIskH,IAGAr4G,KAAKu5G,WACEv5G,KAAKu5G,WAAW9D,WAAW1hH,QADtC,EAIJ,EAEG,MAAM0lH,GACT,WAAA7wG,CAAY7O,EAAUw/G,EAAYr+G,GAC9B,IAAIlE,EACJgJ,KAAKjG,SAAW,IAAIzC,IACpB0I,KAAK4rE,gBAAuG,QAApF50E,EAAKkE,aAAyC,EAASA,EAAQ0wE,uBAAoC,IAAP50E,GAAgBA,EACpI,IAAK,MAAMrB,KAAWoE,EAAU,CAC5B,MAAMhG,EAAOiM,KAAK4rE,gBACZj2E,EAAQ5B,KAAK8D,cACblC,EAAQ5B,KACdiM,KAAKjG,SAASpC,IAAI5D,EAAM4B,EAC5B,CACAqK,KAAKu5G,WAAaA,CACtB,CACA,UAAA9D,CAAW1hH,GACP,MAAM2lH,EAAY15G,KAAK4rE,gBAAkB73E,EAAK8D,cAAgB9D,EACxDskH,EAAQr4G,KAAKjG,SAASnC,IAAI8hH,GAChC,OAAIrB,IAGAr4G,KAAKu5G,WACEv5G,KAAKu5G,WAAW9D,WAAW1hH,QADtC,EAIJ,CACA,cAAAylH,GACI,IAAIG,GAAgB,EAAAtwC,GAAA,IAAOrpE,KAAKjG,SAASgqB,UAIzC,OAHI/jB,KAAKu5G,aACLI,EAAgBA,EAAcnmH,OAAOwM,KAAKu5G,WAAWC,mBAElDG,CACX,EChEG,MAAMC,GACT,WAAAhxG,GACI5I,KAAK65G,UAAY,GACjB75G,KAAK85G,YAAa,CACtB,CACA,SAAAC,CAAUC,GACNh6G,KAAK65G,UAAUjjH,KAAKojH,EACxB,CACA,OAAAt5B,GACI1gF,KAAKi6G,kBACLj6G,KAAK+M,QACL/M,KAAK85G,YAAa,EAClB95G,KAAK65G,UAAU3lH,SAAQ8lH,GAAcA,EAAWt5B,WACpD,CACA,eAAAu5B,GACI,GAAIj6G,KAAK85G,WACL,MAAM,IAAIlhH,MAAM,uCAExB,EAEG,MAAMshH,WAAoBN,GAC7B,WAAAhxG,GACI+pB,SAASjvB,WACT1D,KAAKzI,MAAQ,IAAID,GACrB,CACA,GAAAxD,CAAIqiB,GAEA,OADAnW,KAAKi6G,kBACEj6G,KAAKzI,MAAMzD,IAAIqiB,EAC1B,CACA,GAAAxe,CAAIwe,EAAKxjB,GACLqN,KAAKi6G,kBACLj6G,KAAKzI,MAAMI,IAAIwe,EAAKxjB,EACxB,CACA,GAAAiF,CAAIue,EAAKgkG,GAEL,GADAn6G,KAAKi6G,kBACDj6G,KAAKzI,MAAMzD,IAAIqiB,GACf,OAAOnW,KAAKzI,MAAMK,IAAIue,GAErB,GAAIgkG,EAAU,CACf,MAAMxnH,EAAQwnH,IAEd,OADAn6G,KAAKzI,MAAMI,IAAIwe,EAAKxjB,GACbA,CACX,CAIJ,CACA,OAAOwjB,GAEH,OADAnW,KAAKi6G,kBACEj6G,KAAKzI,MAAMw4G,OAAO55F,EAC7B,CACA,KAAApJ,GACI/M,KAAKi6G,kBACLj6G,KAAKzI,MAAMwV,OACf,EAEG,MAAMqtG,WAAqBR,GAC9B,WAAAhxG,CAAY2iG,GACR54E,QACA3yB,KAAKzI,MAAQ,IAAID,IACjB0I,KAAKurG,UAAYA,QAA6CA,EAAa54G,GAASA,CACxF,CACA,GAAAmB,CAAIumH,EAAYlkG,GAEZ,OADAnW,KAAKi6G,kBACEj6G,KAAKs6G,gBAAgBD,GAAYvmH,IAAIqiB,EAChD,CACA,GAAAxe,CAAI0iH,EAAYlkG,EAAKxjB,GACjBqN,KAAKi6G,kBACLj6G,KAAKs6G,gBAAgBD,GAAY1iH,IAAIwe,EAAKxjB,EAC9C,CACA,GAAAiF,CAAIyiH,EAAYlkG,EAAKgkG,GACjBn6G,KAAKi6G,kBACL,MAAMM,EAAev6G,KAAKs6G,gBAAgBD,GAC1C,GAAIE,EAAazmH,IAAIqiB,GACjB,OAAOokG,EAAa3iH,IAAIue,GAEvB,GAAIgkG,EAAU,CACf,MAAMxnH,EAAQwnH,IAEd,OADAI,EAAa5iH,IAAIwe,EAAKxjB,GACfA,CACX,CAIJ,CACA,OAAO0nH,EAAYlkG,GAEf,OADAnW,KAAKi6G,kBACEj6G,KAAKs6G,gBAAgBD,GAAYtK,OAAO55F,EACnD,CACA,KAAApJ,CAAMstG,GAEF,GADAr6G,KAAKi6G,kBACDI,EAAY,CACZ,MAAMvhB,EAAS94F,KAAKurG,UAAU8O,GAC9Br6G,KAAKzI,MAAMw4G,OAAOjX,EACtB,MAEI94F,KAAKzI,MAAMwV,OAEnB,CACA,eAAAutG,CAAgBD,GACZ,MAAMvhB,EAAS94F,KAAKurG,UAAU8O,GAC9B,IAAIG,EAAgBx6G,KAAKzI,MAAMK,IAAIkhG,GAKnC,OAJK0hB,IACDA,EAAgB,IAAIljH,IACpB0I,KAAKzI,MAAMI,IAAImhG,EAAQ0hB,IAEpBA,CACX,EA6CG,MAAMC,WAAuBP,GAShC,WAAAtxG,CAAY8xG,EAAgB71G,GACxB8tB,QACI9tB,GACA7E,KAAK65G,UAAUjjH,KAAK8jH,EAAez0B,UAAU00B,gBAAgBC,aAAa/1G,GAAO,KAC7E7E,KAAK+M,OAAO,KAEhB/M,KAAK65G,UAAUjjH,KAAK8jH,EAAez0B,UAAU00B,gBAAgBE,UAAS,CAACC,EAAUC,KACzEA,EAAQzlH,OAAS,GACjB0K,KAAK+M,OACT,MAIJ/M,KAAK65G,UAAUjjH,KAAK8jH,EAAez0B,UAAU00B,gBAAgBE,UAAS,KAClE76G,KAAK+M,OAAO,IAGxB,EC9KG,MAAMiuG,GACT,WAAApyG,CAAYg9E,GACR5lF,KAAKq1E,WAAauQ,EAAS3yD,OAAOwyD,cAClCzlF,KAAKk3G,aAAetxB,EAASylB,WAAW8L,aACxCn3G,KAAKkyE,aAAe0T,EAASK,UAAU4yB,2BACvC74G,KAAKi7G,aAAer1B,EAAS3yD,OAAOgzD,UAAUmxB,aAC9Cp3G,KAAKk7G,iBAAmB,IAAIT,GAAe70B,EAAS3yD,OACxD,CACA,QAAAuiF,CAASxiF,GACL,MAAMomF,EAAS,GACT/C,EAAgBr2G,KAAKq1E,WAAW4E,iBAAiBjnD,GACjDmoF,GAAc,SAAYnoF,EAAQ/7B,WAAWq9G,kBACnD,GAAI6G,EAAa,CACb,IAAIC,EAAcpoF,EAAQ/7B,UAC1B,EAAG,CACC,MAAMokH,EAAkBF,EAAYvjH,IAAIwjH,GACpCC,EAAgB/lH,OAAS,GACzB8jH,EAAOxiH,MAAK,EAAAyyE,GAAA,IAAOgyC,GAAiB5nH,QAAO6nH,GAAQt7G,KAAKq1E,WAAW2E,UAAUshC,EAAK7mH,KAAM4hH,MAE5F+E,EAAcA,EAAYhkH,UAC9B,OAASgkH,EACb,CACA,IAAI7kH,EAASyJ,KAAKu7G,eAAelF,EAAerjF,GAChD,IAAK,IAAI95B,EAAIkgH,EAAO9jH,OAAS,EAAG4D,GAAK,EAAGA,IACpC3C,EAASyJ,KAAKw7G,YAAYpC,EAAOlgH,GAAI3C,GAEzC,OAAOA,CACX,CAIA,WAAAilH,CAAYzhH,EAAUw/G,EAAYr+G,GAC9B,OAAO,IAAIo+G,IAAY,EAAAjwC,GAAA,IAAOtvE,GAAWw/G,EAAYr+G,EACzD,CAKA,mBAAAugH,CAAoB1hH,EAAUw/G,EAAYr+G,GACtC,MAAMjC,GAAI,EAAAowE,GAAA,IAAOtvE,GAAUN,KAAIrG,IAC3B,MAAMW,EAAOiM,KAAKk3G,aAAaX,QAAQnjH,GACvC,GAAIW,EACA,OAAOiM,KAAKkyE,aAAagnC,kBAAkB9lH,EAAGW,EAElC,IACjB60E,cACH,OAAO,IAAI0wC,GAAYrgH,EAAGsgH,EAAYr+G,EAC1C,CAIA,cAAAqgH,CAAelF,EAAeqF,GAC1B,OAAO17G,KAAKk7G,iBAAiBtjH,IAAIy+G,GAAe,IAAM,IAAIoD,GAASz5G,KAAKi7G,aAAaU,YAAYtF,KACrG,EClDJ,SAASuF,GAAwBppF,GAC7B,MAAsB,iBAARA,KAAsBA,IAAQ,SAAUA,GAAO,WAAYA,EAC7E,CACO,MAAMqpF,GACT,WAAAjzG,CAAYg9E,GAER5lF,KAAK87G,iBAAmB,IAAI9oH,IAAI,CAAC,aAAc,qBAAsB,kBAAmB,YAAa,aACrGgN,KAAK00G,iBAAmB9uB,EAAS3yD,OAAOgzD,UAAU0uB,iBAClD30G,KAAK80G,eAAiBlvB,EAASK,UAAU8uB,eACzC/0G,KAAKk3G,aAAetxB,EAASylB,WAAW8L,aACxCn3G,KAAK+7G,gBAAkBn2B,EAAS4d,cAAcwY,eAClD,CACA,SAAAC,CAAU9nH,EAAM+G,GACZ,MAAMghH,EAAmBhhH,QAAyCA,EAAU,CAAC,EACvEihH,EAAmBjhH,aAAyC,EAASA,EAAQkhH,SAC7EC,EAAkB,CAAClmG,EAAKxjB,IAAUqN,KAAKo8G,SAASjmG,EAAKxjB,EAAOupH,GAC5DE,EAAWD,EAAmB,CAAChmG,EAAKxjB,IAAUwpH,EAAiBhmG,EAAKxjB,EAAO0pH,GAAmBA,EACpG,IAEI,OADAr8G,KAAKkxE,iBAAkB,SAAY/8E,GAC5Bqa,KAAKC,UAAUta,EAAMioH,EAAUlhH,aAAyC,EAASA,EAAQohH,MACpG,CACA,QACIt8G,KAAKkxE,qBAAkB37E,CAC3B,CACJ,CACA,WAAAywF,CAAYhwF,EAASkF,GACjB,MAAMqhH,EAAqBrhH,QAAyCA,EAAU,CAAC,EACzEimB,EAAO3S,KAAKzL,MAAM/M,GAExB,OADAgK,KAAKw8G,SAASr7F,EAAMA,EAAMo7F,GACnBp7F,CACX,CACA,QAAAi7F,CAASjmG,EAAKxjB,GAAO,QAAEgjH,EAAO,WAAE8G,EAAU,YAAEC,EAAW,SAAEC,EAAQ,aAAEC,IAC/D,IAAI5lH,EAAI8B,EAAIC,EAAI8jH,EAChB,IAAI78G,KAAK87G,iBAAiBhoH,IAAIqiB,GAA9B,CAGK,IAAI,SAAYxjB,GAAQ,CACzB,MAAMmqH,EAAWnqH,EAAM0B,IACjBomF,EAAWk7B,EAAUhjH,EAAM8nF,cAAWllF,EAC5C,GAAIunH,EAAU,CACV,MAAMC,GAAiB,SAAYD,GACnC,IAAIre,EAAY,GACZz+F,KAAKkxE,iBAAmBlxE,KAAKkxE,kBAAoB6rC,IAE7Cte,EADAme,EACYA,EAAaG,EAAeve,IAAK7rG,GAGjCoqH,EAAeve,IAAInnF,YAIvC,MAAO,CACH2lG,KAAM,GAAGve,KAFMz+F,KAAK80G,eAAekB,eAAe8G,KAGlDriC,WAER,CAEI,MAAO,CACHwiC,OAAsF,QAA7EnkH,EAA4B,QAAtB9B,EAAKrE,EAAMmQ,aAA0B,IAAP9L,OAAgB,EAASA,EAAG2kC,eAA4B,IAAP7iC,EAAgBA,EAAK,8BACnH2hF,WAGZ,CACK,IAAI,SAAU9nF,GAAQ,CACvB,IAAIuC,EAYJ,GAXIwnH,IACAxnH,EAAU8K,KAAKk9G,kCAAkC3jH,OAAOg2D,OAAO,CAAC,EAAG58D,IAC7DwjB,IAAOxjB,EAAMwgH,aAAej+G,aAAyC,EAASA,EAAQioH,eAExFjoH,EAAQioH,YAAYC,YAA8C,QAA/BrkH,EAAKiH,KAAKkxE,uBAAoC,IAAPn4E,OAAgB,EAASA,EAAGylG,IAAInnF,aAG9GolG,IAAetmG,IACfjhB,UAAoDA,EAAUqE,OAAOg2D,OAAO,CAAC,EAAG58D,IAChFuC,EAAQmoH,YAAwC,QAAzBR,EAAKlqH,EAAMk2G,gBAA6B,IAAPgU,OAAgB,EAASA,EAAGv3G,MAEpFq3G,EAAU,CACVznH,UAAoDA,EAAUqE,OAAOg2D,OAAO,CAAC,EAAG58D,IAChF,MAAM2qH,EAAUt9G,KAAK+7G,gBAAgBwB,WAAW5qH,GAC5C2qH,IACApoH,EAAQsoH,SAAWF,EAAQp2G,QAAQ,MAAO,IAElD,CACA,OAAOhS,QAAyCA,EAAUvC,CAC9D,CAEI,OAAOA,CACX,CACJ,CACA,iCAAAuqH,CAAkC/oH,GAC9B,MAAMspH,EAAwB1mH,IAAW,CACrCsP,OAAQtP,EAAQsP,OAChBuM,IAAK7b,EAAQ6b,IACbtd,OAAQyB,EAAQzB,OAChB6E,MAAOpD,EAAQoD,QAEnB,GAAIhG,EAAK00G,SAAU,CACf,MACM6U,GADavpH,EAAKgpH,YAAcM,EAAsBtpH,EAAK00G,WAClC6U,YAAc,CAAC,EAO9C,OANAnkH,OAAOsY,KAAK1d,GAAMV,QAAO0iB,IAAQA,EAAItM,WAAW,OAAM3V,SAAQiiB,IAC1D,MAAMwnG,GAAsB,QAAqBxpH,EAAK00G,SAAU1yF,GAAK1c,IAAIgkH,GACtC,IAA/BE,EAAoBroH,SACpBooH,EAAYvnG,GAAOwnG,EACvB,IAEGxpH,CACX,CAEJ,CACA,QAAAqoH,CAASroH,EAAMgtB,EAAMjmB,EAASjE,EAAW2mH,EAAmBC,GACxD,IAAK,MAAOC,EAAcptG,KAASnX,OAAOC,QAAQrF,GAC9C,GAAIqQ,MAAMyK,QAAQyB,GACd,IAAK,IAAItb,EAAQ,EAAGA,EAAQsb,EAAKpb,OAAQF,IAAS,CAC9C,MAAMO,EAAU+a,EAAKtb,GACjBwmH,GAAwBjmH,GACxB+a,EAAKtb,GAAS4K,KAAK+9G,gBAAgB5pH,EAAM2pH,EAAc38F,EAAMxrB,EAASuF,IAEjE,SAAUvF,IACfqK,KAAKw8G,SAAS7mH,EAASwrB,EAAMjmB,EAAS/G,EAAM2pH,EAAc1oH,EAElE,MAEKwmH,GAAwBlrG,GAC7Bvc,EAAK2pH,GAAgB99G,KAAK+9G,gBAAgB5pH,EAAM2pH,EAAc38F,EAAMzQ,EAAMxV,IAErE,SAAUwV,IACf1Q,KAAKw8G,SAAS9rG,EAAMyQ,EAAMjmB,EAAS/G,EAAM2pH,GAGjD,MAAME,EAAU7pH,EAChB6pH,EAAQ5mH,WAAaH,EACrB+mH,EAAQC,mBAAqBL,EAC7BI,EAAQE,gBAAkBL,CAC9B,CACA,eAAAE,CAAgB9mH,EAAWjC,EAAUmsB,EAAMy5D,EAAW1/E,GAClD,IAAIy6G,EAAU/6B,EAAUH,SACpB33E,EAAQ83E,EAAUqiC,OACtB,GAAIriC,EAAUoiC,KAAM,CAChB,MAAM3oH,EAAM2L,KAAKm+G,WAAWh9F,EAAMy5D,EAAUoiC,KAAM9hH,EAAQ0hH,cAC1D,IAAI,SAAUvoH,GAIV,OAHKshH,IACDA,EAAU31G,KAAKk3G,aAAaX,QAAQliH,IAEjC,CACHomF,SAAUk7B,QAAyCA,EAAU,GAC7DthH,OAIJyO,EAAQzO,CAEhB,CACA,GAAIyO,EAAO,CACP,MAAMzO,EAAM,CACRomF,SAAUk7B,QAAyCA,EAAU,IAQjE,OANAthH,EAAIyO,MAAQ,CACR7L,YACAjC,WACA2mC,QAAS74B,EACT83E,UAAWvmF,GAERA,CACX,CAIJ,CACA,UAAA8pH,CAAWh9F,EAAMq9E,EAAKoe,GAClB,IACI,MAAMwB,EAAgB5f,EAAInxF,QAAQ,KAClC,GAAsB,IAAlB+wG,EAAqB,CACrB,MAAMjqH,EAAO6L,KAAK80G,eAAeqB,WAAWh1F,EAAMq9E,EAAI1jG,UAAU,IAChE,OAAK3G,GACM,2BAA6BqqG,CAG5C,CACA,GAAI4f,EAAgB,EAAG,CACnB,MAAMhJ,EAAcwH,EAAeA,EAAape,GAAO,KAAIz7F,MAAMy7F,GAC3DtyF,EAAWlM,KAAK00G,iBAAiBZ,YAAYsB,GACnD,OAAKlpG,EAGEA,EAAS0mG,YAAYjgH,MAFjB,oCAAsC6rG,CAGrD,CACA,MAAM4W,EAAcwH,EAAeA,EAAape,EAAI1jG,UAAU,EAAGsjH,IAAkB,KAAIr7G,MAAMy7F,EAAI1jG,UAAU,EAAGsjH,IACxGlyG,EAAWlM,KAAK00G,iBAAiBZ,YAAYsB,GACnD,IAAKlpG,EACD,MAAO,oCAAsCsyF,EAEjD,GAAI4f,IAAkB5f,EAAIlpG,OAAS,EAC/B,OAAO4W,EAAS0mG,YAAYjgH,MAEhC,MAAMwB,EAAO6L,KAAK80G,eAAeqB,WAAWjqG,EAAS0mG,YAAYjgH,MAAO6rG,EAAI1jG,UAAUsjH,EAAgB,IACtG,OAAKjqH,GACM,0BAA4BqqG,CAG3C,CACA,MAAOpN,GACH,OAAOj0D,OAAOi0D,EAClB,CACJ,EC9MG,MAAMitB,GAIT,OAAI5kH,GACA,OAAOuG,KAAKs+G,gBAChB,CACA,WAAA11G,CAAYg9E,GACR5lF,KAAKu+G,cAAgB,IAAIjnH,IACzB0I,KAAKs+G,iBAAmB,IAAIhnH,IAC5B0I,KAAKkyG,cAAgBtsB,aAA2C,EAASA,EAASK,UAAUksB,aAChG,CACA,QAAA/+E,CAASkwE,GACL,MAAM8B,EAAO9B,EAASje,iBACtB,IAAK,MAAMoI,KAAO2X,EAAK9f,eACftlF,KAAKs+G,iBAAiBxqH,IAAI25F,IAC1BtxE,QAAQ0e,KAAK,sBAAsB4yD,2DAA6D2X,EAAK7f,gBAEzGvlF,KAAKs+G,iBAAiB3mH,IAAI81F,EAAK6V,GAEnCtjG,KAAKu+G,cAAc5mH,IAAIytG,EAAK7f,WAAY+d,GACR,IAA5BtjG,KAAKu+G,cAAclgG,KACnBre,KAAKw+G,UAAYlb,EAGjBtjG,KAAKw+G,eAAYjpH,CAEzB,CACA,WAAA89G,CAAY7U,GACR,IAAIxnG,EAAI8B,EACR,QAAuBvD,IAAnByK,KAAKw+G,UACL,OAAOx+G,KAAKw+G,UAEhB,GAAgC,IAA5Bx+G,KAAKu+G,cAAclgG,KACnB,MAAM,IAAIzlB,MAAM,yFAEpB,MAAM2sF,EAAmG,QAArFzsF,EAAmC,QAA7B9B,EAAKgJ,KAAKkyG,qBAAkC,IAAPl7G,OAAgB,EAASA,EAAGY,IAAI4mG,UAAyB,IAAP1lG,OAAgB,EAASA,EAAGysF,WAC7I,QAAmBhwF,IAAfgwF,EAA0B,CAC1B,MAAMK,EAAW5lF,KAAKu+G,cAAc3mH,IAAI2tF,GACxC,GAAIK,EACA,OAAOA,CAEf,CACA,MAAM6H,EAAMipB,GAASppB,QAAQkR,GACvB5Y,EAAW5lF,KAAKs+G,iBAAiB1mH,IAAI61F,GAC3C,IAAK7H,EACD,MAAIL,EACM,IAAI3sF,MAAM,gEAAgE60F,oBAAsBlI,OAGhG,IAAI3sF,MAAM,gEAAgE60F,OAGxF,OAAO7H,CACX,CACA,WAAA64B,CAAYjgB,GACR,IAEI,OADAx+F,KAAKqzG,YAAY7U,IACV,CACX,CACA,MAAOxnG,GACH,OAAO,CACX,CACJ,CACA,OAAI28G,GACA,OAAOnvG,MAAM43B,KAAKp8B,KAAKu+G,cAAcx6F,SACzC,EC/DG,SAAS26F,GAAexiF,GAC3B,MAAO,CAAEA,OACb,CACO,IAAIyiF,GC2NAC,ID1NX,SAAWD,GACPA,EAAmBhL,IAAM,CAAC,OAAQ,OAAQ,WAC7C,CAFD,CAEGgL,KAAuBA,GAAqB,CAAC,IAIzC,MAAME,GACT,WAAAj2G,CAAYg9E,GACR5lF,KAAKxG,QAAU,IAAI8+G,GACnBt4G,KAAK8+G,cAAgB,GACrB9+G,KAAK++G,aAAe,GACpB/+G,KAAKq1E,WAAauQ,EAAS3yD,OAAOwyD,aACtC,CASA,QAAAryD,CAAS4rF,EAAcC,EAAUj/G,KAAMk/G,EAAW,QAC9C,GAAiB,aAAbA,EACA,MAAM,IAAItmH,MAAM,6EAEpB,IAAK,MAAOnE,EAAM6R,KAAO/M,OAAOC,QAAQwlH,GAAe,CACnD,MAAM19B,EAAYh7E,EAClB,GAAI9B,MAAMyK,QAAQqyE,GACd,IAAK,MAAMwmB,KAASxmB,EAAW,CAC3B,MAAMjuF,EAAQ,CACVy0G,MAAO9nG,KAAKm/G,wBAAwBrX,EAAOmX,GAC3CC,YAEJl/G,KAAKo/G,SAAS3qH,EAAMpB,EACxB,MAEC,GAAyB,mBAAdiuF,EAA0B,CACtC,MAAMjuF,EAAQ,CACVy0G,MAAO9nG,KAAKm/G,wBAAwB79B,EAAW29B,GAC/CC,YAEJl/G,KAAKo/G,SAAS3qH,EAAMpB,EACxB,MAEI,QAAkBiuF,EAE1B,CACJ,CACA,uBAAA69B,CAAwBrX,EAAOmX,GAC3B,OAAOrqG,MAAOzgB,EAAMkgC,EAAQy+E,WAClB9yG,KAAKq/G,iBAAgB,IAAMvX,EAAMrkG,KAAKw7G,EAAS9qH,EAAMkgC,EAAQy+E,IAAc,sCAAuCz+E,EAAQlgC,EAAK,CAE7I,CACA,qBAAMkrH,CAAgBC,EAAeC,EAAgBlrF,EAAQlgC,GACzD,UACUmrH,GACV,CACA,MAAOluB,GACH,GAAIsf,GAAqBtf,GACrB,MAAMA,EAEVj1E,QAAQrZ,MAAM,GAAGy8G,KAAmBnuB,GAChCA,aAAex4F,OAASw4F,EAAIluF,OAC5BiZ,QAAQrZ,MAAMsuF,EAAIluF,OAGtBmxB,EAAO,QAAS,GAAGkrF,MADInuB,aAAex4F,MAAQw4F,EAAIz1D,QAAUwB,OAAOi0D,KACX,CAAEj9F,QAC9D,CACJ,CACA,QAAAirH,CAAS3qH,EAAMpB,GACX,GAAa,YAAToB,EAIJ,IAAK,MAAMqlF,KAAW95E,KAAKq1E,WAAW6F,eAAezmF,GACjDuL,KAAKxG,QAAQxF,IAAI8lF,EAASzmF,QAJ1B2M,KAAKxG,QAAQxF,IAAI,UAAWX,EAMpC,CACA,SAAAmsH,CAAU/qH,EAAMw0C,GACZ,IAAIw2E,GAAS,EAAAp2C,GAAA,IAAOrpE,KAAKxG,QAAQ5B,IAAInD,IAChCjB,OAAOwM,KAAKxG,QAAQ5B,IAAI,YAI7B,OAHIqxC,IACAw2E,EAASA,EAAOhsH,QAAOJ,GAAS41C,EAAWjuC,SAAS3H,EAAM6rH,aAEvDO,EAAOhmH,KAAIpG,GAASA,EAAMy0G,OACrC,CAiBA,sBAAA4X,CAAuBC,EAAaV,EAAUj/G,MAC1CA,KAAK8+G,cAAcloH,KAAKoJ,KAAK4/G,yBAAyBD,EAAa,oDAAqDV,GAC5H,CAiBA,qBAAAY,CAAsBC,EAAYb,EAAUj/G,MACxCA,KAAK++G,aAAanoH,KAAKoJ,KAAK4/G,yBAAyBE,EAAY,uDAAwDb,GAC7H,CACA,wBAAAW,CAAyB9X,EAAOyX,EAAgBN,GAC5C,OAAOrqG,MAAOqzF,EAAU5zE,EAAQ4U,EAAY6pE,WAClC9yG,KAAKq/G,iBAAgB,IAAMvX,EAAMrkG,KAAKw7G,EAAShX,EAAU5zE,EAAQ4U,EAAY6pE,IAAcyM,EAAgBlrF,EAAQ4zE,EAAS,CAE1I,CACA,gBAAI8X,GACA,OAAO//G,KAAK8+G,aAChB,CACA,eAAIkB,GACA,OAAOhgH,KAAK++G,YAChB,EC3IG,MAAMkB,GACT,WAAAr3G,CAAYg9E,GACR5lF,KAAKkgH,mBAAqBt6B,EAASu6B,WAAWtB,mBAC9C7+G,KAAKogH,SAAWx6B,EAASP,gBAC7B,CACA,sBAAMg7B,CAAiBn0G,EAAUhR,EAAU,CAAC,EAAG43G,EAAc,MAAkBnyB,MAC3E,MAAMiyB,EAAc1mG,EAAS0mG,YACvB/nC,EAAc,GAEpB,SADM8lC,GAAkBmC,IACnB53G,EAAQ+tC,YAAc/tC,EAAQ+tC,WAAWjuC,SAAS,YAAa,CAEhE,GADAgF,KAAKsgH,oBAAoB1N,EAAa/nC,EAAa3vE,GAC/CA,EAAQqlH,uBAAyB11C,EAAYnC,MAAKmlB,IAAO,IAAI72F,EAAI,OAA0B,QAAjBA,EAAK62F,EAAEuX,YAAyB,IAAPpuG,OAAgB,EAASA,EAAGklC,QAAU0iF,GAAkB4B,WAAW,IACtK,OAAO31C,EAGX,GADA7qE,KAAKygH,qBAAqB7N,EAAa/nC,EAAa3vE,GAChDA,EAAQwlH,wBAA0B71C,EAAYnC,MAAKmlB,IAAO,IAAI72F,EAAI,OAA0B,QAAjBA,EAAK62F,EAAEuX,YAAyB,IAAPpuG,OAAgB,EAASA,EAAGklC,QAAU0iF,GAAkB+B,YAAY,IACxK,OAAO91C,EAGX,GADA7qE,KAAK4gH,qBAAqB10G,EAAU2+D,EAAa3vE,GAC7CA,EAAQ2lH,wBAA0Bh2C,EAAYnC,MAAKmlB,IAAO,IAAI72F,EAAI,OAA0B,QAAjBA,EAAK62F,EAAEuX,YAAyB,IAAPpuG,OAAgB,EAASA,EAAGklC,QAAU0iF,GAAkBkC,YAAY,IACxK,OAAOj2C,CAEf,CAEA,IACIA,EAAYj0E,cAAcoJ,KAAK+gH,YAAYnO,EAAYjgH,MAAOuI,EAAS43G,GAC3E,CACA,MAAO1hB,GACH,GAAIsf,GAAqBtf,GACrB,MAAMA,EAEVj1E,QAAQrZ,MAAM,uCAAwCsuF,EAC1D,CAEA,aADMuf,GAAkBmC,GACjBjoC,CACX,CACA,mBAAAy1C,CAAoB1N,EAAa/nC,EAAa4W,GAC1C,IAAIzqF,EAAI8B,EAAIC,EACZ,MAAMioH,EAAmB,IAAIpO,EAAY3hB,eAA8G,QAA7Fn4F,EAAwC,QAAlC9B,EAAK47G,EAAY5G,mBAAgC,IAAPh1G,OAAgB,EAASA,EAAG6zE,mBAAgC,IAAP/xE,EAAgBA,EAAK,IACpL,IAAK,MAAMmoH,KAAmBD,EAAkB,CAC5C,MAAM5gB,EAA+C,QAAnCrnG,EAAKkoH,EAAgB7gB,gBAA6B,IAAPrnG,EAAgBA,EAAK,QAC5EmoH,EAAa,CACf9gB,SAAU+gB,GAAqB/gB,GAC/BjmG,MAAO,CACHwY,MAAO,CACHnN,KAAMy7G,EAAgBz7G,KAAO,EAC7B+hE,UAAW05C,EAAgBx2E,OAAS,GAExC73B,IAAK,CACDpN,KAAMy7G,EAAgBz7G,KAAO,EAC7B+hE,UAAW05C,EAAgBx2E,OAASw2E,EAAgB3rH,OAAS,IAGrEqmC,QAASslF,EAAgBtlF,QACzBypE,KAAMgc,GAAiBhhB,GACvBhnG,OAAQ4G,KAAKqhH,aAEjBx2C,EAAYj0E,KAAKsqH,EACrB,CACJ,CACA,oBAAAT,CAAqB7N,EAAa/nC,EAAa4W,GAC3C,IAAK,MAAM6/B,KAAe1O,EAAY1hB,aAAc,CAChD,IAAI/2F,EAIJ,GAAI8vD,MAAMq3D,EAAYh9G,MAAMkmC,cAGxB,GAAI,kBAAmB82E,EAAa,CAChC,MAAMh9G,EAAQg9G,EAAYl7D,cAC1B,GAAK6D,MAAM3lD,EAAMkmC,aAIZ,CAGD,MAAM3b,EAAW,CAAErpB,KAAM,EAAG+hE,UAAW,GACvCptE,EAAQ,CAAEwY,MAAOkc,EAAUjc,IAAKic,EACpC,KAT+B,CAC3B,MAAMA,EAAW,CAAErpB,KAAMlB,EAAM4tC,QAAU,EAAGq1B,UAAWjjE,EAAM6tC,WAC7Dh4C,EAAQ,CAAEwY,MAAOkc,EAAUjc,IAAKic,EACpC,CAOJ,OAGA10B,GAAQ,QAAamnH,EAAYh9G,OAErC,GAAInK,EAAO,CACP,MAAM+mH,EAAa,CACf9gB,SAAU+gB,GAAqB,SAC/BhnH,QACAwhC,QAAS2lF,EAAY3lF,QACrBypE,KAAMsZ,GAAeE,GAAkB+B,cACvCvnH,OAAQ4G,KAAKqhH,aAEjBx2C,EAAYj0E,KAAKsqH,EACrB,CACJ,CACJ,CACA,oBAAAN,CAAqB10G,EAAU2+D,EAAa4W,GACxC,IAAK,MAAM7G,KAAa1uE,EAASm/F,WAAY,CACzC,MAAMkW,EAAe3mC,EAAU93E,MAC/B,GAAIy+G,EAAc,CACd,MAAMxsG,EAAO,CACT5gB,KAAMotH,EAAatqH,UACnBjC,SAAUusH,EAAavsH,SACvBI,MAAOmsH,EAAansH,MACpBgwG,KAAM,CACFlpE,KAAM0iF,GAAkBkC,aACxBU,cAAeD,EAAatqH,UAAUgE,MACtCjG,SAAUusH,EAAavsH,SACvB2gH,QAAS4L,EAAa3mC,UAAUH,WAGxC5P,EAAYj0E,KAAKoJ,KAAKyhH,aAAa,QAASF,EAAa5lF,QAAS5mB,GACtE,CACJ,CACJ,CACA,iBAAMgsG,CAAY9Y,EAAU/sG,EAAS43G,EAAc,MAAkBnyB,MACjE,MAAM+gC,EAAkB,GAClBC,EAAW,CAACvhB,EAAUzkE,EAAS5mB,KACjC2sG,EAAgB9qH,KAAKoJ,KAAKyhH,aAAarhB,EAAUzkE,EAAS5mB,GAAM,EAKpE,aAHM/U,KAAK4hH,kBAAkB3Z,EAAU/sG,EAASymH,EAAU7O,SACpD9yG,KAAK6hH,iBAAiB5Z,EAAU/sG,EAASymH,EAAU7O,SACnD9yG,KAAK8hH,iBAAiB7Z,EAAU/sG,EAASymH,EAAU7O,GAClD4O,CACX,CACA,uBAAME,CAAkB3Z,EAAU/sG,EAASymH,EAAU7O,EAAc,MAAkBnyB,MACjF,IAAI3pF,EACJ,MAAM+oH,EAAe//G,KAAKkgH,mBAAmBH,aAC7C,IAAK,MAAMJ,KAAeI,QAChBpP,GAAkBmC,SAClB6M,EAAY1X,EAAU0Z,EAAwC,QAA7B3qH,EAAKkE,EAAQ+tC,kBAA+B,IAAPjyC,EAAgBA,EAAK,GAAI87G,EAE7G,CACA,sBAAM+O,CAAiB5Z,EAAU/sG,EAASymH,EAAU7O,EAAc,MAAkBnyB,YAC1EkwB,QAAQ8C,KAAI,SAAU1L,GAAUxuG,KAAImb,MAAOzgB,UACvCw8G,GAAkBmC,GACxB,MAAM2M,EAASz/G,KAAKkgH,mBAAmBV,UAAUrrH,EAAK8G,MAAOC,EAAQ+tC,YACrE,IAAK,MAAM6+D,KAAS2X,QACV3X,EAAM3zG,EAAMwtH,EAAU7O,EAChC,IAER,CACA,sBAAMgP,CAAiB7Z,EAAU/sG,EAASymH,EAAU7O,EAAc,MAAkBnyB,MAChF,IAAI3pF,EACJ,MAAMgpH,EAAchgH,KAAKkgH,mBAAmBF,YAC5C,IAAK,MAAMF,KAAcE,QACfrP,GAAkBmC,SAClBgN,EAAW7X,EAAU0Z,EAAwC,QAA7B3qH,EAAKkE,EAAQ+tC,kBAA+B,IAAPjyC,EAAgBA,EAAK,GAAI87G,EAE5G,CACA,YAAA2O,CAAarhB,EAAUzkE,EAAS5mB,GAC5B,MAAO,CACH4mB,UACAxhC,MAAO4nH,GAAmBhtG,GAC1BqrF,SAAU+gB,GAAqB/gB,GAC/BlkE,KAAMnnB,EAAKmnB,KACXokE,gBAAiBvrF,EAAKurF,gBACtB4D,KAAMnvF,EAAKmvF,KACX7D,mBAAoBtrF,EAAKsrF,mBACzB+E,KAAMrwF,EAAKqwF,KACXhsG,OAAQ4G,KAAKqhH,YAErB,CACA,SAAAA,GACI,OAAOrhH,KAAKogH,SAAS76B,UACzB,EAEG,SAASw8B,GAAmBhtG,GAC/B,GAAIA,EAAK5a,MACL,OAAO4a,EAAK5a,MAEhB,IAAIpD,EAQJ,MAP6B,iBAAlBge,EAAK/f,SACZ+B,GAAU,QAAoBge,EAAK5gB,KAAK00G,SAAU9zF,EAAK/f,SAAU+f,EAAK3f,OAEzC,iBAAjB2f,EAAK5e,UACjBY,GAAU,QAAmBge,EAAK5gB,KAAK00G,SAAU9zF,EAAK5e,QAAS4e,EAAK3f,QAExE2B,UAAoDA,EAAUge,EAAK5gB,KAAK00G,UACnE9xG,EAMEA,EAAQoD,MALJ,CACHwY,MAAO,CAAEnN,KAAM,EAAG+hE,UAAW,GAC7B30D,IAAK,CAAEpN,KAAM,EAAG+hE,UAAW,GAIvC,CAOO,SAAS45C,GAAqB/gB,GACjC,OAAQA,GACJ,IAAK,QACD,OAAO,EACX,IAAK,UACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,QACI,MAAM,IAAIxnG,MAAM,gCAAkCwnG,GAE9D,CACO,SAASghB,GAAiBhhB,GAC7B,OAAQA,GACJ,IAAK,QACD,OAAOse,GAAeE,GAAkB4B,aAC5C,IAAK,UACD,OAAO9B,GAAeE,GAAkBoD,eAC5C,IAAK,OACD,OAAOtD,GAAeE,GAAkBqD,YAC5C,IAAK,OACD,OAAOvD,GAAeE,GAAkBsD,YAC5C,QACI,MAAM,IAAItpH,MAAM,gCAAkCwnG,GAE9D,EAEA,SAAWwe,GACPA,EAAkB4B,YAAc,eAChC5B,EAAkBoD,cAAgB,iBAClCpD,EAAkBqD,WAAa,cAC/BrD,EAAkBsD,WAAa,cAC/BtD,EAAkB+B,aAAe,gBACjC/B,EAAkBkC,aAAe,eACpC,CAPD,CAOGlC,KAAsBA,GAAoB,CAAC,ICvOvC,MAAMuD,GACT,WAAAv5G,CAAYg9E,GACR5lF,KAAK80G,eAAiBlvB,EAASK,UAAU8uB,eACzC/0G,KAAKk3G,aAAetxB,EAASylB,WAAW8L,YAC5C,CACA,iBAAA+B,CAAkB/kH,EAAMJ,EAAMmY,GAC1B,MAAMmI,EAAMnI,QAA2CA,GAAW,SAAY/X,GAC9EJ,UAA2CA,EAAOiM,KAAKk3G,aAAaX,QAAQpiH,IAC5E,MAAM+lB,EAAOla,KAAK80G,eAAekB,eAAe7hH,GAChD,IAAKJ,EACD,MAAM,IAAI6E,MAAM,gBAAgBshB,kBAEpC,IAAIkoG,EACJ,MAAMC,EAAoB,KAAQ,IAAIrrH,EAAI,OAAOorH,QAAyDA,EAAmBA,GAAkB,QAAiE,QAA9CprH,EAAKgJ,KAAKk3G,aAAaT,YAAYtiH,UAA0B,IAAP6C,EAAgBA,EAAK7C,EAAK00G,SAAU,EAC5P,MAAO,CACH10G,OACAJ,OACA,eAAIuuH,GACA,OAAOD,GACX,EACAE,kBAAkB,QAAkBpuH,EAAK00G,UACzCp0G,KAAMN,EAAK8G,MACXm6G,YAAa/gG,EAAImqF,IACjBtkF,OAER,EAEG,MAAMsoG,GACT,WAAA55G,CAAYg9E,GACR5lF,KAAKq3G,YAAczxB,EAASK,UAAU8uB,cAC1C,CACA,wBAAM0N,CAAmBv2G,EAAU4mG,EAAc,MAAkBnyB,MAC/D,MAAM1O,EAAQ,GACRg2B,EAAW/7F,EAAS0mG,YAAYjgH,MACtC,IAAK,MAAMuC,KAAW,SAAU+yG,SACtB0I,GAAkBmC,IACxB,SAAiB59G,GAASzB,QAAOymF,KAAY,SAAeA,KAAUhmF,SAAQgmF,IAE1E,MAAMluB,EAAchsD,KAAKk5G,kBAAkBh/B,GACvCluB,GACAimB,EAAMr7E,KAAKo1D,EACf,IAGR,OAAOimB,CACX,CACA,iBAAAinC,CAAkBh/B,GACd,MAAMwoC,EAAkBxoC,EAAQU,UAAUq7B,iBACpC0M,EAAazoC,EAAQU,UAAUg7B,SACrC,IAAK8M,IAAoBC,EACrB,OAEJ,MAAMC,GAAS,SAAY1oC,EAAQjjF,WAAWunG,IAC9C,MAAO,CACH0Z,UAAW0K,EACXzK,WAAYn4G,KAAKq3G,YAAYrB,eAAe97B,EAAQjjF,WACpDwnG,UAAWikB,EAAgBtN,YAC3BtwD,WAAY49D,EAAgBxoG,KAC5Bk+F,SAAS,QAAkBuK,GAC3BtK,MAAO3B,GAASC,OAAO+L,EAAgBtN,YAAawN,GAE5D,ECnEG,MAAMC,GACT,WAAAj6G,GACI5I,KAAK8iH,iBAAmB,IACxB9iH,KAAK+iH,eAAiB,GAC1B,CACA,cAAA/M,CAAe7hH,GACX,GAAIA,EAAKiD,WAAY,CACjB,MAAM4rH,EAAgBhjH,KAAKg2G,eAAe7hH,EAAKiD,YACzC6rH,EAAajjH,KAAKkjH,eAAe/uH,GAEvC,OADiB6uH,EAAgBhjH,KAAK8iH,iBAAmBG,CAE7D,CACA,MAAO,EACX,CACA,cAAAC,EAAe,mBAAEjF,EAAkB,gBAAEC,IACjC,IAAKD,EACD,MAAM,IAAIrlH,MAAM,6CAEpB,YAAwBrD,IAApB2oH,EACOD,EAAqBj+G,KAAK+iH,eAAiB7E,EAE/CD,CACX,CACA,UAAA9H,CAAWhiH,EAAM+lB,GAEb,OADiBA,EAAKzT,MAAMzG,KAAK8iH,kBACjBx2F,QAAO,CAACw8C,EAAeq6C,KACnC,IAAKr6C,GAAyC,IAAxBq6C,EAAa7tH,OAC/B,OAAOwzE,EAEX,MAAMs6C,EAAgBD,EAAa91G,QAAQrN,KAAK+iH,gBAChD,GAAIK,EAAgB,EAAG,CACnB,MAAMpuH,EAAWmuH,EAAaroH,UAAU,EAAGsoH,GACrCC,EAAajkC,SAAS+jC,EAAaroH,UAAUsoH,EAAgB,IAC7D/sG,EAAQyyD,EAAc9zE,GAC5B,OAAOqhB,aAAqC,EAASA,EAAMgtG,EAC/D,CACA,OAAOv6C,EAAcq6C,EAAa,GACnChvH,EACP,E,ICtCOmvH,G,WCKJ,MAAMC,GACT,WAAA36G,CAAYg9E,GACR5lF,KAAKwjH,OAAS,IAAI,GAClBxjH,KAAKyjH,SAAW,CAAC,EACjBzjH,KAAK0jH,iBAAkB,EACvB1jH,KAAK2jH,oCAAsC,IAAI,GAAArjC,QAC/CtgF,KAAKiyG,gBAAkBrsB,EAASzyD,eACpC,CACA,SAAIywF,GACA,OAAO5jH,KAAKwjH,OAAOvS,OACvB,CACA,UAAAjhD,CAAW6zD,GACP,IAAI7sH,EAAI8B,EACRkH,KAAK0jH,gBAAwH,QAArG5qH,EAA8C,QAAxC9B,EAAK6sH,EAAOC,aAAa79B,iBAA8B,IAAPjvF,OAAgB,EAASA,EAAG+sH,qBAAkC,IAAPjrH,GAAgBA,CACzJ,CACA,iBAAMkrH,CAAYH,GACd,GAAI7jH,KAAK0jH,gBAAiB,CACtB,GAAIG,EAAOzwF,SAAU,CAGjB,MAAM6wF,EAAYjkH,KAAKiyG,gBAAgB0B,IACvCkQ,EAAOzwF,SAAS,CAEZ8wF,QAASD,EAAUxqH,KAAI0qH,GAAQnkH,KAAKokH,cAAcD,EAAK9+B,iBAAiBE,eAEhF,CACA,GAAIs+B,EAAOQ,mBAAoB,CAG3B,MAAMC,EAAiBtkH,KAAKiyG,gBAAgB0B,IAAIl6G,KAAI0qH,IAAQ,CAExDD,QAASlkH,KAAKokH,cAAcD,EAAK9+B,iBAAiBE,gBAGhDwP,QAAgB8uB,EAAOQ,mBAAmBC,GAChDA,EAAepwH,SAAQ,CAAC8gB,EAAMyf,KAC1Bz0B,KAAKukH,2BAA2BvvG,EAAKkvG,QAASnvB,EAAQtgE,GAAK,GAEnE,CACJ,CACAz0B,KAAKwjH,OAAO12B,SAChB,CAOA,mBAAA03B,CAAoBjjB,GACXA,EAAOkiB,UAGZlqH,OAAOsY,KAAK0vF,EAAOkiB,UAAUvvH,SAAQgwH,IACjC,MAAMH,EAAgBxiB,EAAOkiB,SAASS,GACtClkH,KAAKukH,2BAA2BL,EAASH,GACzC/jH,KAAK2jH,oCAAoC1hC,KAAK,CAAEiiC,UAASH,iBAAgB,GAEjF,CACA,0BAAAQ,CAA2BL,EAASH,GAChC/jH,KAAKyjH,SAASS,GAAWH,CAC7B,CAOA,sBAAMU,CAAiBnhB,EAAUygB,SACvB/jH,KAAK4jH,MACX,MAAMc,EAAc1kH,KAAKokH,cAAc9gB,GACvC,GAAItjG,KAAKyjH,SAASiB,GACd,OAAO1kH,KAAKyjH,SAASiB,GAAaX,EAE1C,CACA,aAAAK,CAAc7+B,GACV,MAAO,GAAGA,GACd,CACA,gCAAIo/B,GACA,OAAO3kH,KAAK2jH,oCAAoCp4G,KACpD,GDnFJ,SAAW+3G,GAMPA,EAAW1/G,OALX,SAAgBi9E,GACZ,MAAO,CACHH,QAAS9rE,eAAkBisE,IAEnC,CAEH,CAPD,CAOGyiC,KAAeA,GAAa,CAAC,IEDzB,MAAMsB,GACT,WAAAh8G,CAAYg9E,GACR5lF,KAAK6kH,mBAAqB,CAEtB1E,WAAY,CACRl3E,WAAY,CAAC,WAAY,UAGjCjpC,KAAK8kH,gBAAkB,GACvB9kH,KAAK+kH,oBAAsB,IAAIzM,GAC/Bt4G,KAAKglH,uBAAyB,IAAI1M,GAClCt4G,KAAK6Y,WAAa,IAAIvhB,IACtB0I,KAAKilH,qBAAuB,IAAI3tH,IAChC0I,KAAKklH,aAAenT,GAAcsC,QAClCr0G,KAAK00G,iBAAmB9uB,EAASK,UAAU0uB,iBAC3C30G,KAAK0zG,uBAAyB9tB,EAASK,UAAUC,uBACjDlmF,KAAKkyG,cAAgBtsB,EAASK,UAAUksB,cACxCnyG,KAAKi7G,aAAer1B,EAASK,UAAUmxB,aACvCp3G,KAAKiyG,gBAAkBrsB,EAASzyD,eACpC,CACA,WAAMgyF,CAAMr0C,EAAW51E,EAAU,CAAC,EAAG43G,EAAc,MAAkBnyB,MACjE,IAAI3pF,EAAI8B,EACR,IAAK,MAAMoT,KAAY4kE,EAAW,CAC9B,MAAM36D,EAAMjK,EAASsyF,IAAInnF,WACzB,GAAInL,EAASrH,QAAUktG,GAAcqT,WACjC,GAAkC,kBAAvBlqH,EAAQilH,YAA4BjlH,EAAQilH,WAEnDj0G,EAASrH,MAAQktG,GAAcsT,kBAC/Bn5G,EAAS2+D,iBAAct1E,EACvByK,KAAK6Y,WAAWk3F,OAAO55F,QAEtB,GAAkC,iBAAvBjb,EAAQilH,WAAyB,CAC7C,MAAMtnG,EAAa7Y,KAAK6Y,WAAWjhB,IAAIue,GACjCmvG,EAA0G,QAApFtuH,EAAK6hB,aAA+C,EAASA,EAAWtiB,cAA2B,IAAPS,OAAgB,EAASA,EAAGuuH,iBACpJ,GAAID,EAAoB,CAGpB,MACMr8E,GADyD,QAAxCnwC,EAAKoC,EAAQilH,WAAWl3E,kBAA+B,IAAPnwC,EAAgBA,EAAK6lH,GAAmBhL,KAC9ElgH,QAAO4T,IAAMi+G,EAAmBtqH,SAASqM,KACtE4hC,EAAW3zC,OAAS,IACpB0K,KAAK6Y,WAAWlhB,IAAIwe,EAAK,CACrBqvG,WAAW,EACXtqH,QAAS,CACLilH,WAAY5mH,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAGr0D,EAAQilH,YAAa,CAAEl3E,gBAEvE1yC,OAAQsiB,EAAWtiB,SAEvB2V,EAASrH,MAAQktG,GAAcsT,kBAEvC,CACJ,OAIArlH,KAAK6Y,WAAWk3F,OAAO55F,EAE/B,CACAnW,KAAKklH,aAAenT,GAAcsC,cAC5Br0G,KAAKylH,WAAW30C,EAAUr3E,KAAIrG,GAAKA,EAAEorG,MAAM,UAC3Cx+F,KAAK0lH,eAAe50C,EAAW51E,EAAS43G,EAClD,CACA,YAAMxL,CAAOqe,EAAS5K,EAASjI,EAAc,MAAkBnyB,MAC3D3gF,KAAKklH,aAAenT,GAAcsC,QAElC,IAAK,MAAMuR,KAAc7K,EACrB/6G,KAAK00G,iBAAiBH,eAAeqR,GACrC5lH,KAAK6Y,WAAWk3F,OAAO6V,EAAWvuG,YAClCrX,KAAKi7G,aAAah6B,OAAO2kC,GAG7B,IAAK,MAAMC,KAAcF,EAAS,CAE9B,IADoB3lH,KAAK00G,iBAAiBP,mBAAmB0R,GAC3C,CAId,MAAMC,EAAc9lH,KAAK0zG,uBAAuBvtB,UAAU,CAAElrF,MAAO,WAAa4qH,GAChFC,EAAYjhH,MAAQktG,GAAcsC,QAClCr0G,KAAK00G,iBAAiBd,YAAYkS,EACtC,CACA9lH,KAAK6Y,WAAWk3F,OAAO8V,EAAWxuG,WACtC,CAEA,MAAM0uG,GAAiB,EAAA18C,GAAA,IAAOs8C,GAASnyH,OAAOunH,GAASthH,KAAI+kG,GAAOA,EAAInnF,aAAY2wD,QAClFhoE,KAAK00G,iBAAiBf,IACjBlgH,QAAO4gB,IAAQ0xG,EAAejyH,IAAIugB,EAAImqF,IAAInnF,aAAerX,KAAKgmH,aAAa3xG,EAAK0xG,KAChF7xH,SAAQmgB,IACMrU,KAAKiyG,gBAAgBoB,YAAYh/F,EAAImqF,KAAK6M,WAAWC,OAC7Dn0F,OAAO9C,GACdA,EAAIxP,MAAQrP,KAAKE,IAAI2e,EAAIxP,MAAOktG,GAAcgE,gBAC9C1hG,EAAIw2D,iBAAct1E,CAAS,UAGzByK,KAAKylH,WAAWE,EAAS5K,SAEzBpK,GAAkBmC,GAExB,MAAMmT,EAAmBjmH,KAAKkmH,cAAclmH,KAAK00G,iBAAiBf,IAC7DlgH,QAAO4gB,IACR,IAAIrd,EAEJ,OAAOqd,EAAIxP,MAAQktG,GAAcoU,UAE2B,QAAlDnvH,EAAKgJ,KAAK6Y,WAAWjhB,IAAIyc,EAAImqF,IAAInnF,mBAAgC,IAAPrgB,OAAgB,EAASA,EAAGwuH,UAAU,IAEzGz9C,iBACC/nE,KAAK0lH,eAAeO,EAAkBjmH,KAAK6kH,mBAAoB/R,EACzE,CACA,gBAAM2S,CAAWE,EAAS5K,SAChBlK,QAAQ8C,IAAI3zG,KAAK8kH,gBAAgBrrH,KAAIkoF,GAAYA,EAASgkC,EAAS5K,KAC7E,CAQA,aAAAmL,CAAcp1C,GACV,IAAIx2E,EAAO,EACPF,EAAQ02E,EAAUx7E,OAAS,EAC/B,KAAOgF,EAAOF,GAAO,CACjB,KAAOE,EAAOw2E,EAAUx7E,QAAU0K,KAAKomH,gBAAgBt1C,EAAUx2E,KAC7DA,IAEJ,KAAOF,GAAS,IAAM4F,KAAKomH,gBAAgBt1C,EAAU12E,KACjDA,IAEAE,EAAOF,KACN02E,EAAUx2E,GAAOw2E,EAAU12E,IAAU,CAAC02E,EAAU12E,GAAQ02E,EAAUx2E,IAE3E,CACA,OAAOw2E,CACX,CACA,eAAAs1C,CAAgB/xG,GACZ,IAAIrd,EACJ,OAAOkB,QAAsC,QAA7BlB,EAAKgJ,KAAKkyG,qBAAkC,IAAPl7G,OAAgB,EAASA,EAAGY,IAAIyc,EAAImqF,KAC7F,CAIA,YAAAwnB,CAAa95G,EAAUm6G,GAEnB,QAAIn6G,EAASm/F,WAAW3iC,MAAKr0E,QAAqBkB,IAAdlB,EAAIyO,SAIjC9C,KAAKi7G,aAAaqL,WAAWp6G,EAAUm6G,EAClD,CACA,QAAAxL,CAASh6B,GAEL,OADA7gF,KAAK8kH,gBAAgBluH,KAAKiqF,GACnByiC,GAAW1/G,QAAO,KACrB,MAAMxO,EAAQ4K,KAAK8kH,gBAAgBz3G,QAAQwzE,GACvCzrF,GAAS,GACT4K,KAAK8kH,gBAAgB3jC,OAAO/rF,EAAO,EACvC,GAER,CAUA,oBAAMswH,CAAe50C,EAAW51E,EAAS43G,GACrC9yG,KAAKumH,aAAaz1C,EAAW51E,SAEvB8E,KAAKwmH,cAAc11C,EAAWihC,GAAciB,OAAQF,GAAaz+F,GAAOrU,KAAK0zG,uBAAuBpM,OAAOjzF,EAAKy+F,WAEhH9yG,KAAKwmH,cAAc11C,EAAWihC,GAAc0U,eAAgB3T,GAAaz+F,GAAOrU,KAAKi7G,aAAayL,cAAcryG,EAAKy+F,WAErH9yG,KAAKwmH,cAAc11C,EAAWihC,GAAcgE,eAAgBjD,GAAal+F,MAAOP,IAClF,MAAMsyG,EAAmB3mH,KAAKiyG,gBAAgBoB,YAAYh/F,EAAImqF,KAAK6M,WAAWub,iBAC9EvyG,EAAIigG,wBAA0BqS,EAAiBxN,mBAAmB9kG,EAAKy+F,EAAY,UAGjF9yG,KAAKwmH,cAAc11C,EAAWihC,GAAcoU,OAAQrT,GAAaz+F,GACpDrU,KAAKiyG,gBAAgBoB,YAAYh/F,EAAImqF,KAAK6M,WAAWC,OACtDv7F,KAAKsE,EAAKy+F,WAGtB9yG,KAAKwmH,cAAc11C,EAAWihC,GAAcsT,kBAAmBvS,GAAaz+F,GAAOrU,KAAKi7G,aAAa4L,iBAAiBxyG,EAAKy+F,KAEjI,MAAMgU,EAAgBh2C,EAAUr9E,QAAO4gB,GAAOrU,KAAK+mH,eAAe1yG,WAC5DrU,KAAKwmH,cAAcM,EAAe/U,GAAcqT,UAAWtS,GAAaz+F,GAAOrU,KAAKkoD,SAAS7zC,EAAKy+F,KAExG,IAAK,MAAMz+F,KAAOy8D,EAAW,CACzB,MAAMjsE,EAAQ7E,KAAK6Y,WAAWjhB,IAAIyc,EAAImqF,IAAInnF,YACtCxS,IACAA,EAAM2gH,WAAY,EAE1B,CACJ,CAOA,YAAAe,CAAaz1C,EAAW51E,GACpB,IAAK,MAAMmZ,KAAOy8D,EAAW,CACzB,MAAM36D,EAAM9B,EAAImqF,IAAInnF,WACdxS,EAAQ7E,KAAK6Y,WAAWjhB,IAAIue,GAI7BtR,IAASA,EAAM2gH,WAChBxlH,KAAK6Y,WAAWlhB,IAAIwe,EAAK,CACrBqvG,WAAW,EACXtqH,UACA3E,OAAQsO,aAAqC,EAASA,EAAMtO,QAGxE,CACJ,CAWA,mBAAMiwH,CAAc11C,EAAWk2C,EAAalU,EAAajyB,GACrD,MAAMomC,EAAWn2C,EAAUr9E,QAAO4gB,GAAOA,EAAIxP,MAAQmiH,IACrD,IAAK,MAAM96G,KAAY+6G,QACbtW,GAAkBmC,SAClBjyB,EAAS30E,GACfA,EAASrH,MAAQmiH,QACXhnH,KAAKknH,oBAAoBh7G,EAAU86G,EAAalU,GAK1D,MAAMqU,EAAkBr2C,EAAUr9E,QAAO4gB,GAAOA,EAAIxP,QAAUmiH,UACxDhnH,KAAKonH,iBAAiBD,EAAiBH,EAAalU,GAC1D9yG,KAAKklH,aAAe8B,CACxB,CACA,YAAApM,CAAaoM,EAAanmC,GAEtB,OADA7gF,KAAK+kH,oBAAoB/wH,IAAIgzH,EAAanmC,GACnCyiC,GAAW1/G,QAAO,KACrB5D,KAAK+kH,oBAAoBhV,OAAOiX,EAAanmC,EAAS,GAE9D,CACA,eAAAwmC,CAAgBL,EAAanmC,GAEzB,OADA7gF,KAAKglH,uBAAuBhxH,IAAIgzH,EAAanmC,GACtCyiC,GAAW1/G,QAAO,KACrB5D,KAAKglH,uBAAuBjV,OAAOiX,EAAanmC,EAAS,GAEjE,CACA,SAAAymC,CAAUziH,EAAO0iH,EAAYzU,GACzB,IAAItU,EAQJ,GAPI+oB,GAAc,SAAUA,EACxB/oB,EAAM+oB,EAGNzU,EAAcyU,EAElBzU,UAAgEA,EAAc,MAAkBnyB,MAC5F6d,EAAK,CACL,MAAMtyF,EAAWlM,KAAK00G,iBAAiBZ,YAAYtV,GACnD,GAAItyF,GAAYA,EAASrH,MAAQA,EAC7B,OAAOgsG,QAAQ/jB,QAAQ0R,EAE/B,CACA,OAAIx+F,KAAKklH,cAAgBrgH,EACdgsG,QAAQ/jB,aAAQv3F,GAElBu9G,EAAY9B,wBACVH,QAAQhqG,OAAO,IAEnB,IAAIgqG,SAAQ,CAAC/jB,EAASjmF,KACzB,MAAM2gH,EAAkBxnH,KAAK46G,aAAa/1G,GAAO,KAG7C,GAFA2iH,EAAgB9mC,UAChB+mC,EAAiB/mC,UACb8d,EAAK,CACL,MAAMtyF,EAAWlM,KAAK00G,iBAAiBZ,YAAYtV,GACnD1R,EAAQ5gF,aAA2C,EAASA,EAASsyF,IACzE,MAEI1R,OAAQv3F,EACZ,IAEEkyH,EAAmB3U,EAAY4U,yBAAwB,KACzDF,EAAgB9mC,UAChB+mC,EAAiB/mC,UACjB75E,EAAO,GAAmB,GAC5B,GAEV,CACA,yBAAMqgH,CAAoBh7G,EAAUrH,EAAOiuG,GACvC,MACM6U,EADY3nH,KAAKglH,uBAAuBptH,IAAIiN,GAClBrB,QAChC,IAAK,MAAMm+E,KAAYgmC,EACnB,UACUhmC,EAASz1E,EAAU4mG,EAC7B,CACA,MAAO1hB,GAGH,IAAKsf,GAAqBtf,GACtB,MAAMA,CAEd,CAER,CACA,sBAAMg2B,CAAiBt2C,EAAWjsE,EAAOiuG,GACrC,GAAyB,IAArBhiC,EAAUx7E,OAEV,OAEJ,MACMqyH,EADY3nH,KAAK+kH,oBAAoBntH,IAAIiN,GACfrB,QAChC,IAAK,MAAMm+E,KAAYgmC,QACbhX,GAAkBmC,SAClBnxB,EAAS7Q,EAAWgiC,EAElC,CAMA,cAAAiU,CAAe76G,GACX,OAAOhU,QAAQ8H,KAAK4nH,gBAAgB17G,GAAUi0G,WAClD,CAKA,cAAMj4D,CAASh8C,EAAU4mG,GACrB,IAAI97G,EAAI8B,EACR,MAAM+uH,EAAY7nH,KAAKiyG,gBAAgBoB,YAAYnnG,EAASsyF,KAAK2hB,WAAWvB,kBACtEkJ,EAAoB9nH,KAAK4nH,gBAAgB17G,GAAUi0G,WACnDjlH,EAAuC,iBAAtB4sH,EAAiCA,OAAoBvyH,EACtEs1E,QAAoBg9C,EAAUxH,iBAAiBn0G,EAAUhR,EAAS43G,GACpE5mG,EAAS2+D,YACT3+D,EAAS2+D,YAAYj0E,QAAQi0E,GAG7B3+D,EAAS2+D,YAAcA,EAG3B,MAAMhmE,EAAQ7E,KAAK6Y,WAAWjhB,IAAIsU,EAASsyF,IAAInnF,YAC/C,GAAIxS,EAAO,CACiB,QAAvB7N,EAAK6N,EAAMtO,cAA2B,IAAPS,IAAsB6N,EAAMtO,OAAS,CAAC,GACtE,MAAM6yC,EAAgG,QAA/EtwC,EAAKoC,aAAyC,EAASA,EAAQ+tC,kBAA+B,IAAPnwC,EAAgBA,EAAK6lH,GAAmBhL,IAClJ9uG,EAAMtO,OAAOgvH,iBACb1gH,EAAMtO,OAAOgvH,iBAAiB3uH,QAAQwyC,GAGtCvkC,EAAMtO,OAAOgvH,iBAAmB,IAAIn8E,EAE5C,CACJ,CACA,eAAAw+E,CAAgB17G,GACZ,IAAIlV,EAAI8B,EACR,OAAsH,QAA9GA,EAA6D,QAAvD9B,EAAKgJ,KAAK6Y,WAAWjhB,IAAIsU,EAASsyF,IAAInnF,mBAAgC,IAAPrgB,OAAgB,EAASA,EAAGkE,eAA4B,IAAPpC,EAAgBA,EAAK,CAAC,CACxJ,EC7WG,MAAMivH,GACT,WAAAn/G,CAAYg9E,GAKR5lF,KAAKgoH,YAAc,IAAI1wH,IAKvB0I,KAAKioH,kBAAoB,IAAI7N,GAM7Bp6G,KAAKkoH,eAAiB,IAAI5wH,IAC1B0I,KAAK8wE,UAAY8U,EAASK,UAAU0uB,iBACpC30G,KAAKiyG,gBAAkBrsB,EAASzyD,gBAChCnzB,KAAKwrG,cAAgB5lB,EAASH,aAClC,CACA,iBAAAwyB,CAAkBN,EAAYwQ,GAC1B,MAAMC,GAAe,SAAYzQ,GAAYnZ,IACvCjoG,EAAS,GAQf,OAPAyJ,KAAKkoH,eAAeh0H,SAAQm0H,IACxBA,EAAQn0H,SAAQo0H,IACR5R,GAASC,OAAO2R,EAAS7pB,UAAW2pB,IAAiBE,EAASxjE,aAAeqjE,GAC7E5xH,EAAOK,KAAK0xH,EAChB,GACF,KAEC,EAAAj/C,GAAA,IAAO9yE,EAClB,CACA,WAAAolH,CAAY4M,EAAUC,GAClB,IAAIC,GAAe,EAAAp/C,GAAA,IAAOrpE,KAAKgoH,YAAYn2G,QAI3C,OAHI22G,IACAC,EAAeA,EAAah1H,QAAO+qG,IAAQgqB,GAAQA,EAAK10H,IAAI0qG,MAEzDiqB,EACFhvH,KAAI+kG,GAAOx+F,KAAK0oH,oBAAoBlqB,EAAK+pB,KACzCn/C,MACT,CACA,mBAAAs/C,CAAoBlqB,EAAK+pB,GACrB,IAAIvxH,EACJ,IAAKuxH,EACD,OAA4C,QAApCvxH,EAAKgJ,KAAKgoH,YAAYpwH,IAAI4mG,UAAyB,IAAPxnG,EAAgBA,EAAK,GAE7E,MAAMk7E,EAAelyE,KAAKioH,kBAAkBrwH,IAAI4mG,EAAK+pB,GAAU,KAC3D,IAAIvxH,EAEJ,OADiE,QAApCA,EAAKgJ,KAAKgoH,YAAYpwH,IAAI4mG,UAAyB,IAAPxnG,EAAgBA,EAAK,IACnEvD,QAAOL,GAAK4M,KAAKwrG,cAAcxxB,UAAU5mF,EAAEqB,KAAM8zH,IAAU,IAE1F,OAAOr2C,CACX,CACA,MAAA+O,CAAOud,GACH,MAAMqV,EAAYrV,EAAInnF,WACtBrX,KAAKgoH,YAAYjY,OAAO8D,GACxB7zG,KAAKioH,kBAAkBl7G,MAAM8mG,GAC7B7zG,KAAKkoH,eAAenY,OAAO8D,EAC/B,CACA,mBAAM6S,CAAcx6G,EAAU4mG,EAAc,MAAkBnyB,MAC1D,MAAMiF,EAAW5lF,KAAKiyG,gBAAgBoB,YAAYnnG,EAASsyF,KACrDne,QAAgBuF,EAASylB,WAAWub,iBAAiB9N,eAAe5sG,EAAU4mG,GAC9EtU,EAAMtyF,EAASsyF,IAAInnF,WACzBrX,KAAKgoH,YAAYrwH,IAAI6mG,EAAKne,GAC1BrgF,KAAKioH,kBAAkBl7G,MAAMyxF,EACjC,CACA,sBAAMqoB,CAAiB36G,EAAU4mG,EAAc,MAAkBnyB,MAC7D,MAAMiF,EAAW5lF,KAAKiyG,gBAAgBoB,YAAYnnG,EAASsyF,KACrDmqB,QAAkB/iC,EAASK,UAAU2iC,6BAA6BnG,mBAAmBv2G,EAAU4mG,GACrG9yG,KAAKkoH,eAAevwH,IAAIuU,EAASsyF,IAAInnF,WAAYsxG,EACrD,CACA,UAAArC,CAAWp6G,EAAUm6G,GACjB,MAAMhb,EAAarrG,KAAKkoH,eAAetwH,IAAIsU,EAASsyF,IAAInnF,YACxD,QAAKg0F,GAGEA,EAAW3iC,MAAKr0E,IAAQA,EAAIgkH,OAASgO,EAAYvyH,IAAIO,EAAIoqG,UAAUpnF,aAC9E,ECjFG,MAAMwxG,GACT,WAAAjgH,CAAYg9E,GACR5lF,KAAK8oH,oBAAsB,CAAC,EAC5B9oH,KAAKwjH,OAAS,IAAI,GAClBxjH,KAAKiyG,gBAAkBrsB,EAASzyD,gBAChCnzB,KAAK00G,iBAAmB9uB,EAASK,UAAU0uB,iBAC3C30G,KAAK+oH,gBAAkBnjC,EAASK,UAAU00B,gBAC1C36G,KAAKmlF,mBAAqBS,EAASK,UAAUmsB,mBAC7CpyG,KAAKgpH,MAAQpjC,EAASK,UAAUgjC,aACpC,CACA,SAAIrF,GACA,OAAO5jH,KAAKwjH,OAAOvS,OACvB,CACA,oBAAIiY,GACA,OAAOlpH,KAAKmpH,OAChB,CACA,UAAAn5D,CAAW6zD,GACP,IAAI7sH,EACJgJ,KAAKmpH,QAA6C,QAAlCnyH,EAAK6sH,EAAOqF,wBAAqC,IAAPlyH,EAAgBA,OAAKzB,CACnF,CACA,WAAAyuH,CAAYoF,GAGR,OAAOppH,KAAKgpH,MAAMK,OAAM/kH,IAAW,IAAItN,EAAI,OAAOgJ,KAAKspH,oBAA4C,QAAvBtyH,EAAKgJ,KAAKmpH,eAA4B,IAAPnyH,EAAgBA,EAAK,GAAIsN,EAAM,GAC9I,CACA,yBAAMglH,CAAoBH,EAASrW,EAAc,MAAkBnyB,MAC/D,MAAM7P,QAAkB9wE,KAAKupH,eAAeJ,SAGtCxY,GAAkBmC,SAClB9yG,KAAK+oH,gBAAgB5D,MAAMr0C,EAAW9wE,KAAK8oH,oBAAqBhW,EAC1E,CAKA,oBAAMyW,CAAeJ,GACjB,MAAM7jC,EAAiBtlF,KAAKiyG,gBAAgB0B,IAAI19G,SAAQ7C,GAAKA,EAAEiyF,iBAAiBC,iBAC1ExU,EAAY,GACZ04C,EAAat9G,IACf4kE,EAAUl6E,KAAKsV,GACVlM,KAAK00G,iBAAiBR,YAAYhoG,EAASsyF,MAC5Cx+F,KAAK00G,iBAAiBd,YAAY1nG,EACtC,EASJ,aAJMlM,KAAKypH,wBAAwBN,EAASK,SACtC3Y,QAAQ8C,IAAIwV,EAAQ1vH,KAAIiwH,GAAM,CAACA,EAAI1pH,KAAK2pH,cAAcD,MACvDjwH,KAAImb,MAAOvhB,GAAU2M,KAAK4pH,kBAAkBv2H,EAAOiyF,EAAgBkkC,MACxExpH,KAAKwjH,OAAO12B,UACLhc,CACX,CAMA,uBAAA24C,CAAwBI,EAAUC,GAC9B,OAAOjZ,QAAQ/jB,SACnB,CAMA,aAAA68B,CAAcI,GACV,OAAO,KAAIhnH,MAAMgnH,EAAgBvrB,IACrC,CAKA,oBAAMorB,CAAeG,EAAiBC,EAAY1kC,EAAgBkkC,GAC9D,MAAMxzH,QAAgBgK,KAAKmlF,mBAAmBF,cAAc+kC,SACtDnZ,QAAQ8C,IAAI39G,EAAQyD,KAAImb,MAAOvhB,IACjC,GAAI2M,KAAKiqH,aAAaF,EAAiB12H,EAAOiyF,GAC1C,GAAIjyF,EAAM62H,kBACAlqH,KAAK4pH,eAAeG,EAAiB12H,EAAMmrG,IAAKlZ,EAAgBkkC,QAErE,GAAIn2H,EAAM82H,OAAQ,CACnB,MAAMj+G,QAAiBlM,KAAK00G,iBAAiBX,oBAAoB1gH,EAAMmrG,KACvEgrB,EAAUt9G,EACd,CACJ,IAER,CAIA,YAAA+9G,CAAaG,EAAkB/2H,EAAOiyF,GAClC,MAAMvxF,EAAO2iH,GAASrpB,SAASh6F,EAAMmrG,KACrC,GAAIzqG,EAAK8V,WAAW,KAChB,OAAO,EAEX,GAAIxW,EAAM62H,YACN,MAAgB,iBAATn2H,GAAoC,QAATA,EAEjC,GAAIV,EAAM82H,OAAQ,CACnB,MAAM78B,EAAUopB,GAASppB,QAAQj6F,EAAMmrG,KACvC,OAAOlZ,EAAetqF,SAASsyF,EACnC,CACA,OAAO,CACX,EC1GG,MAAM+8B,GACT,gCAAA//E,CAAiCC,EAAUC,EAAal1C,EAAQkQ,EAAMilC,GAClE,OAAO,KAA0BH,iCAAiCC,EAAUC,EAAal1C,EAAQkQ,EAAMilC,EAC3G,CACA,gCAAAL,CAAiC9lC,GAC7B,OAAO,KAA0B8lC,iCAAiC9lC,EACtE,EAEG,MAAMgmH,GAA2B,CAAE7hC,KAAM,QACzC,MAAM8hC,GACT,WAAA3hH,CAAYg9E,GACR5lF,KAAK8qC,qBAAuB86C,EAASzqF,OAAOqvH,0BAC5CxqH,KAAKyqH,aAAe7kC,EAASzqF,OAAO03B,aACpC,MAAM+e,EAAS5xC,KAAKyqH,aAAa3/C,YAAY8a,EAAS7P,QAAS,CAC3DnK,gBAAiBga,EAASP,iBAAiBzZ,kBAE/C5rE,KAAK6+B,WAAa7+B,KAAK0qH,sBAAsB94E,GAC7C,MAAM+4E,EAAcC,GAAsBh5E,GAAUr4C,OAAOwqB,OAAO6tB,GAAUA,EACtEghD,EAAgD,eAAnChN,EAASP,iBAAiBoD,KAC7CzoF,KAAK6qH,gBAAkB,IAAI,KAAgBF,EAAa,CACpDzrF,iBAAkB,OAClB8L,gBAAiB4nD,EACjB9nD,qBAAsB9qC,KAAK8qC,sBAEnC,CACA,cAAI3yC,GACA,OAAO6H,KAAK6+B,UAChB,CACA,QAAA2P,CAASlpC,EAAMm8E,EAAW6oC,IACtB,IAAItzH,EAAI8B,EAAIC,EACZ,MAAM+xH,EAAmB9qH,KAAK6qH,gBAAgBr8E,SAASlpC,GACvD,MAAO,CACHssC,OAAQk5E,EAAiBl5E,OACzB7O,OAAQ+nF,EAAiB/nF,OACzBrvC,OAAkD,QAAzCsD,EAAK8zH,EAAiBv7E,OAAO77C,cAA2B,IAAPsD,EAAgBA,EAAK,GAC/Ei1G,OAA8D,QAArDlzG,GAAMD,EAAKkH,KAAKyqH,cAAcr/C,yBAAsC,IAAPryE,OAAgB,EAASA,EAAG0K,KAAK3K,EAAIwM,GAEnH,CACA,qBAAAolH,CAAsB5/C,GAClB,GAAI8/C,GAAsB9/C,GACtB,OAAOA,EACX,MAAMl5B,EAASm5E,GAA4BjgD,GAAevxE,OAAOwqB,OAAO+mD,EAAY7jC,OAAOmiC,OAAS0B,EAC9FkgD,EAAM,CAAC,EAEb,OADAp5E,EAAO19C,SAAQoQ,GAAS0mH,EAAI1mH,EAAMvQ,MAAQuQ,IACnC0mH,CACX,EAWG,SAASD,GAA4B56D,GACxC,OAAOA,GAAmB,UAAWA,GAAmB,gBAAiBA,CAC7E,CAIO,SAASy6D,GAAsBz6D,GAClC,OAbG,SAA0BA,GAC7B,OAAO3rD,MAAMyK,QAAQkhD,KAAgD,IAA3BA,EAAgB76D,QAAgB,SAAU66D,EAAgB,GACxG,CAWY86D,CAAiB96D,KAAqB46D,GAA4B56D,EAC9E,CC9DO,SAAS+6D,GAAW/2H,EAAMwe,EAAOzX,GACpC,IAAIi0B,EACAN,EACgB,iBAAT16B,GACP06B,EAAWlc,EACXwc,EAAOj0B,IAGP2zB,EAAW16B,EAAKgG,MAAMwY,MACtBwc,EAAOxc,GAENkc,IACDA,EAAWwqE,GAASz1F,OAAO,EAAG,IAElC,MAEMguC,EAoCV,SAAkB5e,GACd,IAAIh8B,EAAI8B,EAAIC,EACZ,MAAM64C,EAAS,GACf,IAAIu5E,EAAcn4F,EAAQnE,SAASrpB,KAC/B4lH,EAAmBp4F,EAAQnE,SAAS04C,UACxC,IAAK,IAAIruE,EAAI,EAAGA,EAAI85B,EAAQxsB,MAAMlR,OAAQ4D,IAAK,CAC3C,MAAMtD,EAAc,IAANsD,EACRquB,EAAOruB,IAAM85B,EAAQxsB,MAAMlR,OAAS,EAC1C,IAAIkQ,EAAOwtB,EAAQxsB,MAAMtN,GACrB9D,EAAQ,EACZ,GAAIQ,GAASo9B,EAAQ93B,QAAQyX,MAAO,CAChC,MAAMpN,EAAyC,QAAhCvO,EAAKg8B,EAAQ93B,QAAQyX,aAA0B,IAAP3b,OAAgB,EAASA,EAAGyS,KAAKjE,GACpFD,IACAnQ,EAAQmQ,EAAMnQ,MAAQmQ,EAAM,GAAGjQ,OAEvC,KACK,CACD,MAAMiQ,EAAwC,QAA/BzM,EAAKk6B,EAAQ93B,QAAQsK,YAAyB,IAAP1M,OAAgB,EAASA,EAAG2Q,KAAKjE,GACnFD,IACAnQ,EAAQmQ,EAAMnQ,MAAQmQ,EAAM,GAAGjQ,OAEvC,CACA,GAAIiyB,EAAM,CACN,MAAMhiB,EAAuC,QAA9BxM,EAAKi6B,EAAQ93B,QAAQ0X,WAAwB,IAAP7Z,OAAgB,EAASA,EAAG0Q,KAAKjE,GAClFD,IACAC,EAAOA,EAAK1K,UAAU,EAAGyK,EAAMnQ,OAEvC,CACAoQ,EAAOA,EAAK1K,UAAU,EAAGuwH,GAAc7lH,IAEvC,GADsB8lH,GAAe9lH,EAAMpQ,IACtBoQ,EAAKlQ,QAEtB,GAAIs8C,EAAOt8C,OAAS,EAAG,CACnB,MAAMu5B,EAAWwqE,GAASz1F,OAAOunH,EAAaC,GAC9Cx5E,EAAOh7C,KAAK,CACRnC,KAAM,QACNuB,QAAS,GACTmE,MAAOm/F,GAAM11F,OAAOirB,EAAUA,IAEtC,MAEC,CACD08F,GAASzjF,UAAY1yC,EACrB,MAAMo2H,EAAWD,GAAS9hH,KAAKjE,GAC/B,GAAIgmH,EAAU,CACV,MAAMC,EAAYD,EAAS,GACrB74H,EAAQ64H,EAAS,GACjB74G,EAAQ0mF,GAASz1F,OAAOunH,EAAaC,EAAmBh2H,GACxDwd,EAAMymF,GAASz1F,OAAOunH,EAAaC,EAAmBh2H,EAAQq2H,EAAUn2H,QAC9Es8C,EAAOh7C,KAAK,CACRnC,KAAM,MACNuB,QAASrD,EACTwH,MAAOm/F,GAAM11F,OAAO+O,EAAOC,KAE/Bxd,GAASq2H,EAAUn2H,OACnBF,EAAQk2H,GAAe9lH,EAAMpQ,EACjC,CACA,GAAIA,EAAQoQ,EAAKlQ,OAAQ,CACrB,MAAMmuD,EAAOj+C,EAAK1K,UAAU1F,GACtBs2H,EAAmBlnH,MAAM43B,KAAKqnB,EAAKkoE,SAASC,KAClDh6E,EAAOh7C,QAAQi1H,GAAkBH,EAAkBjoE,EAAM0nE,EAAaC,EAAmBh2H,GAC7F,CACJ,CACA+1H,IACAC,EAAmB,CACvB,CAEA,GAAIx5E,EAAOt8C,OAAS,GAAwC,UAAnCs8C,EAAOA,EAAOt8C,OAAS,GAAGb,KAC/C,OAAOm9C,EAAOpuC,MAAM,GAAI,GAE5B,OAAOouC,CACX,CA3GmBpD,CAAS,CACpBhoC,MAHUslH,GAAS33H,GAInB06B,WACA3zB,QAJsB6wH,GAAiB58F,KAM3C,OAsLJ,SAA2B6D,GACvB,IAAIh8B,EAAI8B,EAAIC,EAAI8jH,EAChB,MAAMmP,EAAgB3yB,GAASz1F,OAAOovB,EAAQnE,SAASrpB,KAAMwtB,EAAQnE,SAAS04C,WAC9E,GAA8B,IAA1Bv0C,EAAQ4e,OAAOt8C,OACf,OAAO,IAAI22H,GAAiB,GAAI3yB,GAAM11F,OAAOooH,EAAeA,IAEhE,MAAMjyH,EAAW,GACjB,KAAOi5B,EAAQ59B,MAAQ49B,EAAQ4e,OAAOt8C,QAAQ,CAC1C,MAAMK,EAAUu2H,GAAkBl5F,EAASj5B,EAASA,EAASzE,OAAS,IAClEK,GACAoE,EAASnD,KAAKjB,EAEtB,CACA,MAAMgd,EAA0F,QAAjF7Z,EAA4B,QAAtB9B,EAAK+C,EAAS,UAAuB,IAAP/C,OAAgB,EAASA,EAAGmD,MAAMwY,aAA0B,IAAP7Z,EAAgBA,EAAKkzH,EACvHp5G,EAAwG,QAAjGiqG,EAA8C,QAAxC9jH,EAAKgB,EAASA,EAASzE,OAAS,UAAuB,IAAPyD,OAAgB,EAASA,EAAGoB,MAAMyY,WAAwB,IAAPiqG,EAAgBA,EAAKmP,EAC3I,OAAO,IAAIC,GAAiBlyH,EAAUu/F,GAAM11F,OAAO+O,EAAOC,GAC9D,CAtMWu5G,CAAkB,CACrB/2H,MAAO,EACPw8C,SACA/iB,YAER,CAaA,SAASi9F,GAAS33H,GACd,IAAI6B,EAAU,GAEVA,EADgB,iBAAT7B,EACGA,EAGAA,EAAKmR,KAGnB,OADctP,EAAQyQ,MAAM,KAEhC,CACA,MAAM8kH,GAAW,kCACXK,GAAiB,iDAyEvB,SAASC,GAAkB3nB,EAAM1+F,EAAM4mH,EAAWC,GAC9C,MAAMz6E,EAAS,GACf,GAAoB,IAAhBsyD,EAAK5uG,OAAc,CACnB,MAAMqd,EAAQ0mF,GAASz1F,OAAOwoH,EAAWC,GACnCz5G,EAAMymF,GAASz1F,OAAOwoH,EAAWC,EAAiB7mH,EAAKlQ,QAC7Ds8C,EAAOh7C,KAAK,CACRnC,KAAM,OACNuB,QAASwP,EACTrL,MAAOm/F,GAAM11F,OAAO+O,EAAOC,IAEnC,KACK,CACD,IAAIk1B,EAAY,EAChB,IAAK,MAAMviC,KAAS2+F,EAAM,CACtB,MAAMooB,EAAa/mH,EAAMnQ,MACnBm3H,EAAe/mH,EAAK1K,UAAUgtC,EAAWwkF,GAC3CC,EAAaj3H,OAAS,GACtBs8C,EAAOh7C,KAAK,CACRnC,KAAM,OACNuB,QAASwP,EAAK1K,UAAUgtC,EAAWwkF,GACnCnyH,MAAOm/F,GAAM11F,OAAOy1F,GAASz1F,OAAOwoH,EAAWtkF,EAAYukF,GAAiBhzB,GAASz1F,OAAOwoH,EAAWE,EAAaD,MAG5H,IAAIhmH,EAASkmH,EAAaj3H,OAAS,EACnC,MAAMk3H,EAAUjnH,EAAM,GAOtB,GANAqsC,EAAOh7C,KAAK,CACRnC,KAAM,aACNuB,QAASw2H,EACTryH,MAAOm/F,GAAM11F,OAAOy1F,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAASgmH,GAAiBhzB,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAASmmH,EAAQl3H,OAAS+2H,MAE1JhmH,GAAUmmH,EAAQl3H,OACG,IAAjBiQ,EAAMjQ,OAAc,CACpB+Q,GAAUd,EAAM,GAAGjQ,OACnB,MAAM3C,EAAQ4S,EAAM,GACpBqsC,EAAOh7C,KAAK,CACRnC,KAAM,OACNuB,QAASrD,EACTwH,MAAOm/F,GAAM11F,OAAOy1F,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAASgmH,GAAiBhzB,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAAS1T,EAAM2C,OAAS+2H,KAE5J,MAEIz6E,EAAOh7C,KAAK,CACRnC,KAAM,OACNuB,QAAS,GACTmE,MAAOm/F,GAAM11F,OAAOy1F,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAASgmH,GAAiBhzB,GAASz1F,OAAOwoH,EAAWtkF,EAAYzhC,EAASgmH,MAG7IvkF,EAAYwkF,EAAa/mH,EAAM,GAAGjQ,MACtC,CACA,MAAMm3H,EAAajnH,EAAK1K,UAAUgtC,GAC9B2kF,EAAWn3H,OAAS,GACpBs8C,EAAOh7C,KAAK,CACRnC,KAAM,OACNuB,QAASy2H,EACTtyH,MAAOm/F,GAAM11F,OAAOy1F,GAASz1F,OAAOwoH,EAAWtkF,EAAYukF,GAAiBhzB,GAASz1F,OAAOwoH,EAAWtkF,EAAYukF,EAAiBI,EAAWn3H,UAG3J,CACA,OAAOs8C,CACX,CACA,MAAM86E,GAAqB,KACrBC,GAAqB,OAC3B,SAASrB,GAAe9lH,EAAMpQ,GAC1B,MAAMmQ,EAAQC,EAAK1K,UAAU1F,GAAOmQ,MAAMmnH,IAC1C,OAAInnH,EACOnQ,EAAQmQ,EAAMnQ,MAGdoQ,EAAKlQ,MAEpB,CACA,SAAS+1H,GAAc7lH,GACnB,MAAMD,EAAQC,EAAKD,MAAMonH,IACzB,GAAIpnH,GAAgC,iBAAhBA,EAAMnQ,MACtB,OAAOmQ,EAAMnQ,KAGrB,CAmBA,SAAS82H,GAAkBl5F,EAASzL,GAChC,MAAM9wB,EAAOu8B,EAAQ4e,OAAO5e,EAAQ59B,OACpC,MAAkB,QAAdqB,EAAKhC,KACEm4H,GAAc55F,GAAS,GAEX,SAAdv8B,EAAKhC,MAAiC,eAAdgC,EAAKhC,KAC3Bo4H,GAAe75F,IAQ9B,SAAyB1uB,EAAO3O,GAC5B,GAAIA,EAAS,CACT,MAAM6P,EAAO,IAAIsnH,GAAc,GAAIxoH,EAAMnK,OACrC,YAAaxE,EACbA,EAAQo3H,QAAQn2H,KAAK4O,GAGrB7P,EAAQK,QAAQ+2H,QAAQn2H,KAAK4O,EAErC,CACJ,CAfQwnH,CAAgBv2H,EAAM8wB,QACtByL,EAAQ59B,QAGhB,CAYA,SAASy3H,GAAe75F,GACpB,IAAI1uB,EAAQ0uB,EAAQ4e,OAAO5e,EAAQ59B,OACnC,MAAM63H,EAAa3oH,EACnB,IAAI4oH,EAAY5oH,EAChB,MAAMkC,EAAQ,GACd,KAAOlC,GAAwB,UAAfA,EAAM7P,MAAmC,QAAf6P,EAAM7P,MAC5C+R,EAAM5P,KAAKu2H,GAAiBn6F,IAC5Bk6F,EAAY5oH,EACZA,EAAQ0uB,EAAQ4e,OAAO5e,EAAQ59B,OAEnC,OAAO,IAAIg4H,GAAc5mH,EAAO8yF,GAAM11F,OAAOqpH,EAAW9yH,MAAMwY,MAAOu6G,EAAU/yH,MAAMyY,KACzF,CACA,SAASu6G,GAAiBn6F,GAEtB,MAAmB,eADLA,EAAQ4e,OAAO5e,EAAQ59B,OAC3BX,KACCm4H,GAAc55F,GAAS,GAGvBq6F,GAAer6F,EAE9B,CACA,SAAS45F,GAAc55F,EAASs6F,GAC5B,MAAMC,EAAWv6F,EAAQ4e,OAAO5e,EAAQ59B,SAClCrB,EAAOw5H,EAASv3H,QAAQ8E,UAAU,GAClCuhD,EAAYrpB,EAAQ4e,OAAO5e,EAAQ59B,OACzC,GAA+E,UAA1EinD,aAA6C,EAASA,EAAU5nD,MAAkB,CACnF,GAAI64H,EAAQ,CACR,MAAME,EAAUH,GAAer6F,GAC/B,OAAO,IAAIy6F,GAAa15H,EAAM,IAAIq5H,GAAc,CAACI,GAAUA,EAAQrzH,OAAQmzH,EAAQh0B,GAAM11F,OAAO2pH,EAASpzH,MAAMwY,MAAO66G,EAAQrzH,MAAMyY,KACxI,CACK,CACD,MAAM2gG,EAAUsZ,GAAe75F,GAC/B,OAAO,IAAIy6F,GAAa15H,EAAMw/G,EAAS+Z,EAAQh0B,GAAM11F,OAAO2pH,EAASpzH,MAAMwY,MAAO4gG,EAAQp5G,MAAMyY,KACpG,CACJ,CACK,CACD,MAAMzY,EAAQozH,EAASpzH,MACvB,OAAO,IAAIszH,GAAa15H,EAAM,IAAIq5H,GAAc,GAAIjzH,GAAQmzH,EAAQnzH,EACxE,CACJ,CACA,SAASkzH,GAAer6F,GACpB,MAAM1uB,EAAQ0uB,EAAQ4e,OAAO5e,EAAQ59B,SACrC,OAAO,IAAI03H,GAAcxoH,EAAMtO,QAASsO,EAAMnK,MAClD,CACA,SAAS4xH,GAAiB7wH,GACtB,IAAKA,EACD,OAAO6wH,GAAiB,CACpBp5G,MAAO,MACPC,IAAK,KACLpN,KAAM,MAGd,MAAM,MAAEmN,EAAK,IAAEC,EAAG,KAAEpN,GAAStK,EAC7B,MAAO,CACHyX,MAAO+6G,GAAgB/6G,GAAO,GAC9BC,IAAK86G,GAAgB96G,GAAK,GAC1BpN,KAAMkoH,GAAgBloH,GAAM,GAEpC,CACA,SAASkoH,GAAgBjrE,EAAQ9vC,GAC7B,GAAsB,iBAAX8vC,GAAyC,iBAAXA,EAAqB,CAC1D,MAAMkrE,EAA4B,iBAAXlrE,GAAsB,QAAaA,GAAUA,EAAOrpD,OAC3E,OAAIuZ,EACO,IAAIhZ,OAAO,QAAQg0H,KAGnB,IAAIh0H,OAAO,OAAOg0H,SAEjC,CAEI,OAAOlrE,CAEf,CACA,MAAMwpE,GACF,WAAArjH,CAAY7O,EAAUI,GAClB6F,KAAKjG,SAAWA,EAChBiG,KAAK7F,MAAQA,CACjB,CACA,MAAAyzH,CAAO75H,GACH,OAAOiM,KAAK6tH,aAAa16H,MAAKC,GAAKA,EAAEW,OAASA,GAClD,CACA,OAAA+5H,CAAQ/5H,GACJ,OAAOiM,KAAK6tH,aAAap6H,QAAOL,GAAKA,EAAEW,OAASA,GACpD,CACA,UAAA85H,GACI,OAAO7tH,KAAKjG,SAAStG,QAAQL,GAAM,SAAUA,GACjD,CACA,QAAAikB,GACI,IAAI1kB,EAAQ,GACZ,IAAK,MAAMgD,KAAWqK,KAAKjG,SACvB,GAAqB,IAAjBpH,EAAM2C,OACN3C,EAAQgD,EAAQ0hB,eAEf,CACD,MAAM/R,EAAO3P,EAAQ0hB,WACrB1kB,GAASo7H,GAAap7H,GAAS2S,CACnC,CAEJ,OAAO3S,EAAM0N,MACjB,CACA,UAAA2tH,CAAW9yH,GACP,IAAIvI,EAAQ,GACZ,IAAK,MAAMgD,KAAWqK,KAAKjG,SACvB,GAAqB,IAAjBpH,EAAM2C,OACN3C,EAAQgD,EAAQq4H,WAAW9yH,OAE1B,CACD,MAAMoK,EAAO3P,EAAQq4H,WAAW9yH,GAChCvI,GAASo7H,GAAap7H,GAAS2S,CACnC,CAEJ,OAAO3S,EAAM0N,MACjB,EAEJ,MAAMotH,GACF,WAAA7kH,CAAY7U,EAAMiC,EAASs3H,EAAQnzH,GAC/B6F,KAAKjM,KAAOA,EACZiM,KAAKhK,QAAUA,EACfgK,KAAKstH,OAASA,EACdttH,KAAK7F,MAAQA,CACjB,CACA,QAAAkd,GACI,IAAI/R,EAAO,IAAItF,KAAKjM,OACpB,MAAMiC,EAAUgK,KAAKhK,QAAQqhB,WAO7B,OANoC,IAAhCrX,KAAKhK,QAAQ+2H,QAAQz3H,OACrBgQ,EAAO,GAAGA,KAAQtP,IAEbgK,KAAKhK,QAAQ+2H,QAAQz3H,OAAS,IACnCgQ,EAAO,GAAGA,MAAStP,KAEnBgK,KAAKstH,OAEE,IAAIhoH,KAGJA,CAEf,CACA,UAAA0oH,CAAW9yH,GACP,IAAIlE,EAAI8B,EACR,OAAyJ,QAAjJA,EAAoF,QAA9E9B,EAAKkE,aAAyC,EAASA,EAAQ+yH,iBAA8B,IAAPj3H,OAAgB,EAASA,EAAGyM,KAAKvI,EAAS8E,aAA0B,IAAPlH,EAAgBA,EAAKkH,KAAKkuH,kBAAkBhzH,EACjN,CACA,iBAAAgzH,CAAkBhzH,GACd,MAAMlF,EAAUgK,KAAKhK,QAAQg4H,WAAW9yH,GACxC,GAAI8E,KAAKstH,OAAQ,CACb,MAAMa,EA+BlB,SAAyBC,EAAKp4H,EAASkF,GACnC,IAAIlE,EAAI8B,EACR,GAAY,cAARs1H,GAA+B,aAARA,GAA8B,SAARA,EAAgB,CAC7D,MAAMh5H,EAAQY,EAAQqX,QAAQ,KAC9B,IAAIghH,EAAUr4H,EACd,GAAIZ,EAAQ,EAAG,CACX,MAAMk5H,EAAehD,GAAet1H,EAASZ,GAC7Ci5H,EAAUr4H,EAAQ8E,UAAUwzH,GAC5Bt4H,EAAUA,EAAQ8E,UAAU,EAAG1F,EACnC,EACY,aAARg5H,GAA+B,SAARA,GAAmC,SAAjBlzH,EAAQ6U,QAEjDs+G,EAAU,KAAKA,OAEnB,MAAME,EAA4H,QAA5Gz1H,EAAmC,QAA7B9B,EAAKkE,EAAQszH,kBAA+B,IAAPx3H,OAAgB,EAASA,EAAGyM,KAAKvI,EAASlF,EAASq4H,UAA6B,IAAPv1H,EAAgBA,EAKlK,SAA2B9C,EAASq4H,GAChC,IAEI,OADA,KAAItrH,MAAM/M,GAAS,GACZ,IAAIq4H,MAAYr4H,IAC3B,CACA,MAAOgB,GACH,OAAOhB,CACX,CACJ,CAbuKy4H,CAAkBz4H,EAASq4H,GAC1L,OAAOE,CACX,CACA,MACJ,CAjD6BG,CAAgB1uH,KAAKjM,KAAMiC,EAASkF,QAAyCA,EAAU,CAAC,GACzG,GAAwB,iBAAbizH,EACP,OAAOA,CAEf,CACA,IAAI18G,EAAS,GAC2D,YAAnEvW,aAAyC,EAASA,EAAQkzH,WAAyF74H,KAAnE2F,aAAyC,EAASA,EAAQkzH,KAC3I38G,EAAS,IAEgE,UAAnEvW,aAAyC,EAASA,EAAQkzH,KAChE38G,EAAS,KAEgE,iBAAnEvW,aAAyC,EAASA,EAAQkzH,OAChE38G,EAAS,OAEb,IAAInM,EAAO,GAAGmM,KAAUzR,KAAKjM,OAAO0d,IAOpC,OANoC,IAAhCzR,KAAKhK,QAAQ+2H,QAAQz3H,OACrBgQ,EAAO,GAAGA,OAAUtP,IAEfgK,KAAKhK,QAAQ+2H,QAAQz3H,OAAS,IACnCgQ,EAAO,GAAGA,MAAStP,KAEnBgK,KAAKstH,OAEE,IAAIhoH,KAGJA,CAEf,EA8BJ,MAAM8nH,GACF,WAAAxkH,CAAYpC,EAAOrM,GACf6F,KAAK+sH,QAAUvmH,EACfxG,KAAK7F,MAAQA,CACjB,CACA,QAAAkd,GACI,IAAI/R,EAAO,GACX,IAAK,IAAIpM,EAAI,EAAGA,EAAI8G,KAAK+sH,QAAQz3H,OAAQ4D,IAAK,CAC1C,MAAMo0H,EAASttH,KAAK+sH,QAAQ7zH,GACtBzC,EAAOuJ,KAAK+sH,QAAQ7zH,EAAI,GAC9BoM,GAAQgoH,EAAOj2G,WACX5gB,GAAQA,EAAK0D,MAAMwY,MAAMnN,KAAO8nH,EAAOnzH,MAAMwY,MAAMnN,OACnDF,GAAQ,KAEhB,CACA,OAAOA,CACX,CACA,UAAA0oH,CAAW9yH,GACP,IAAIoK,EAAO,GACX,IAAK,IAAIpM,EAAI,EAAGA,EAAI8G,KAAK+sH,QAAQz3H,OAAQ4D,IAAK,CAC1C,MAAMo0H,EAASttH,KAAK+sH,QAAQ7zH,GACtBzC,EAAOuJ,KAAK+sH,QAAQ7zH,EAAI,GAC9BoM,GAAQgoH,EAAOU,WAAW9yH,GACtBzE,GAAQA,EAAK0D,MAAMwY,MAAMnN,KAAO8nH,EAAOnzH,MAAMwY,MAAMnN,OACnDF,GAAQ,KAEhB,CACA,OAAOA,CACX,EAEJ,MAAMwnH,GACF,WAAAlkH,CAAYtD,EAAMnL,GACd6F,KAAKsF,KAAOA,EACZtF,KAAK7F,MAAQA,CACjB,CACA,QAAAkd,GACI,OAAOrX,KAAKsF,IAChB,CACA,UAAA0oH,GACI,OAAOhuH,KAAKsF,IAChB,EAEJ,SAASyoH,GAAazoH,GAClB,OAAIA,EAAK0J,SAAS,MACP,KAGA,MAEf,CCnfO,MAAM2/G,GACT,WAAA/lH,CAAYg9E,GACR5lF,KAAKi7G,aAAer1B,EAAS3yD,OAAOgzD,UAAUmxB,aAC9Cp3G,KAAK+7G,gBAAkBn2B,EAAS4d,cAAcwY,eAClD,CACA,gBAAA4S,CAAiBz6H,GACb,MAAMmpH,EAAUt9G,KAAK+7G,gBAAgBwB,WAAWppH,GAChD,GAAImpH,GDqBL,SAAiBnpH,EAAM+G,GAC1B,MAAM2zH,EAAoB9C,GAAiB7wH,GACrCsL,EAAQslH,GAAS33H,GACvB,GAAqB,IAAjBqS,EAAMlR,OACN,OAAO,EAEX,MAAMM,EAAQ4Q,EAAM,GACd+gB,EAAO/gB,EAAMA,EAAMlR,OAAS,GAC5Bw5H,EAAaD,EAAkBl8G,MAC/Bo8G,EAAYF,EAAkBj8G,IACpC,OAAO1a,QAAQ42H,aAA+C,EAASA,EAAWrlH,KAAK7T,KAAWsC,QAAQ62H,aAA6C,EAASA,EAAUtlH,KAAK8d,GACnL,CChCuBynG,CAAQ1R,GAAU,CAE7B,OADoB4N,GAAW5N,GACZ0Q,WAAW,CAC1BQ,WAAY,CAACz+G,EAAMs+G,IACRruH,KAAKivH,0BAA0B96H,EAAM4b,EAAMs+G,GAEtDJ,UAAYG,GACDpuH,KAAKkvH,yBAAyB/6H,EAAMi6H,IAGvD,CAEJ,CACA,yBAAAa,CAA0B96H,EAAMJ,EAAMs6H,GAClC,IAAIr3H,EACJ,MAAMg1D,EAAsE,QAAvDh1D,EAAKgJ,KAAKmvH,4BAA4Bh7H,EAAMJ,UAA0B,IAAPiD,EAAgBA,EAAKgJ,KAAKovH,sBAAsBj7H,EAAMJ,GAC1I,GAAIi4D,GAAeA,EAAYs2D,YAAa,CACxC,MAAM98G,EAAOwmD,EAAYs2D,YAAYnoH,MAAMwY,MAAMnN,KAAO,EAClD+hE,EAAYvb,EAAYs2D,YAAYnoH,MAAMwY,MAAM40D,UAAY,EAElE,MAAO,IAAI8mD,MADCriE,EAAYopD,YAAY1mB,KAAK,CAAEpjB,SAAU,IAAI9lE,KAAQ+hE,MACtClwD,aAC/B,CAIJ,CACA,wBAAA63G,CAAyBG,EAAOC,GAGhC,CACA,2BAAAH,CAA4Bh7H,EAAMJ,GAC9B,MACMonH,GADW,SAAYhnH,GACAmgH,kBAC7B,IAAK6G,EACD,OAEJ,IAAIC,EAAcjnH,EAClB,EAAG,CACC,MACM63D,EADkBmvD,EAAYvjH,IAAIwjH,GACJjoH,MAAKC,GAAKA,EAAEW,OAASA,IACzD,GAAIi4D,EACA,OAAOA,EAEXovD,EAAcA,EAAYhkH,UAC9B,OAASgkH,EAEb,CACA,qBAAAgU,CAAsBj7H,EAAMJ,GAExB,OADoBiM,KAAKi7G,aAAaU,cAAcxoH,MAAKC,GAAKA,EAAEW,OAASA,GAE7E,ECzDG,MAAMw7H,GACT,WAAA3mH,CAAYg9E,GACR5lF,KAAKwvH,cAAgB,IAAM5pC,EAASzqF,OAAOs0H,aAC/C,CACA,UAAAlS,CAAWppH,GACP,IAAI6C,EACJ,OdJD,SAA8B7C,GACjC,MAAgC,iBAAlBA,EAAKqpH,QACvB,CcEYkS,CAAqBv7H,GACdA,EAAKqpH,SAE6E,QAArFxmH,GAAK,OAAgB7C,EAAK00G,SAAU7oG,KAAKwvH,gBAAgBG,8BAA2C,IAAP34H,OAAgB,EAASA,EAAGsO,IACrI,ECJG,MAAMsqH,GACT,WAAAhnH,CAAYg9E,GACR5lF,KAAK6vH,WAAajqC,EAASzqF,OAAOg1F,aACtC,CACA,KAAAptF,CAAMuC,EAAMwqH,GACR,OAAOjf,QAAQ/jB,QAAQ9sF,KAAK6vH,WAAW9sH,MAAMuC,GACjD,ECZG,MAAMyqH,GACT,WAAAnnH,GACI5I,KAAKgwH,oBAAsB,IAAI,MAC/BhwH,KAAKiwH,WAAa,GAClBjwH,KAAKkwH,UAAY,GACjBlwH,KAAKtJ,MAAO,CAChB,CACA,KAAA2yH,CAAM3wH,GACFsH,KAAKmwH,cACL,MAAMC,G5BYV5f,GAAWI,YAAYp2F,MAChB,IAAI,O4BXP,OADAxa,KAAKgwH,oBAAsBI,EACpBpwH,KAAKoX,QAAQpX,KAAKiwH,WAAYv3H,EAAQ03H,EAAY9rH,MAC7D,CACA,IAAA+rH,CAAK33H,GACD,OAAOsH,KAAKoX,QAAQpX,KAAKkwH,UAAWx3H,EACxC,CACA,OAAA0e,CAAQk5G,EAAO53H,EAAQ45G,EAAoB,MAAkB3xB,MACzD,MAAM4vC,EAAW,IAAI,GACfl9H,EAAQ,CACVqF,SACA63H,WACAje,qBAIJ,OAFAge,EAAM15H,KAAKvD,GACX2M,KAAKwwH,uBACED,EAAStf,OACpB,CACA,0BAAMuf,GACF,IAAKxwH,KAAKtJ,KACN,OAEJ,MAAM8C,EAAU,GAChB,GAAIwG,KAAKiwH,WAAW36H,OAAS,EAEzBkE,EAAQ5C,KAAKoJ,KAAKiwH,WAAWQ,aAE5B,MAAIzwH,KAAKkwH,UAAU56H,OAAS,GAK7B,OAHAkE,EAAQ5C,QAAQoJ,KAAKkwH,UAAU/uC,OAAO,EAAGnhF,KAAKkwH,UAAU56H,QAI5D,CACA0K,KAAKtJ,MAAO,QACNm6G,QAAQ8C,IAAIn6G,EAAQC,KAAImb,OAASlc,SAAQ63H,WAAUje,wBACrD,IAEI,MAAM/7G,QAAes6G,QAAQ/jB,UAAUmnB,MAAK,IAAMv7G,EAAO45G,KACzDie,EAASzjC,QAAQv2F,EACrB,CACA,MAAO66F,GACCsf,GAAqBtf,GAErBm/B,EAASzjC,aAAQv3F,GAGjBg7H,EAAS1pH,OAAOuqF,EAExB,MAEJpxF,KAAKtJ,MAAO,EACZsJ,KAAKwwH,sBACT,CACA,WAAAL,GACInwH,KAAKgwH,oBAAoBU,QAC7B,EC7DG,MAAMC,GACT,WAAA/nH,CAAYg9E,GACR5lF,KAAK4wH,oBAAsB,IAAInY,GAC/Bz4G,KAAK6wH,eAAiB,IAAIpY,GAC1Bz4G,KAAKnN,QAAU+yF,EAAS7P,QACxB/1E,KAAK6D,MAAQ+hF,EAASzqF,OAAOskC,MAC7Bz/B,KAAKorG,OAASxlB,EAASylB,WAAWC,MACtC,CACA,SAAAwlB,CAAUv6H,GACN,MAAO,CACH06F,YAAa16F,EAAO06F,YACpB+a,YAAaz1G,EAAOy1G,YAAchsG,KAAK+wH,qBAAqBx6H,EAAOy1G,kBAAez2G,EAGlF27F,aAAc36F,EAAO26F,aAAaz3F,KAAIrG,GAAMmG,OAAOg2D,OAAOh2D,OAAOg2D,OAAO,CAAC,EAAGn8D,GAAI,CAAEuoC,QAASvoC,EAAEuoC,YAC7FhpC,MAAOqN,KAAKgxH,iBAAiBz6H,EAAO5D,MAAOqN,KAAKixH,wBAAwB16H,EAAO5D,QAEvF,CACA,oBAAAo+H,CAAqB/kB,GAEjB,OAAOA,CACX,CACA,uBAAAilB,CAAwB98H,GACpB,MAAM+8H,EAAW,IAAI55H,IACf65H,EAAW,IAAI75H,IACrB,IAAK,MAAMpC,KAAW,SAAUf,GAC5B+8H,EAASv5H,IAAIzC,EAAS,CAAC,GAE3B,GAAIf,EAAK00G,SACL,IAAK,MAAM9xG,KAAW,QAAU5C,EAAK00G,UACjCsoB,EAASx5H,IAAIZ,EAAS,CAAC,GAG/B,MAAO,CACHm6H,WACAC,WAER,CACA,gBAAAH,CAAiB78H,EAAM6+B,GACnB,MAAMR,EAAMQ,EAAQk+F,SAASt5H,IAAIzD,GACjCq+B,EAAIv3B,MAAQ9G,EAAK8G,MACjBu3B,EAAI0rF,gBAAkB/pH,EAAK+pH,gBAC3B1rF,EAAIyrF,mBAAqB9pH,EAAK8pH,wBACR1oH,IAAlBpB,EAAK00G,WACLr2E,EAAIq2E,SAAW7oG,KAAKoxH,iBAAiBj9H,EAAK00G,SAAU71E,IAExD,IAAK,MAAOj/B,EAAMpB,KAAU4G,OAAOC,QAAQrF,GACvC,IAAIJ,EAAK8V,WAAW,KAGpB,GAAIrF,MAAMyK,QAAQtc,GAAQ,CACtB,MAAM0+H,EAAM,GACZ7+F,EAAIz+B,GAAQs9H,EACZ,IAAK,MAAM3gH,KAAQ/d,GACX,SAAU+d,GACV2gH,EAAIz6H,KAAKoJ,KAAKgxH,iBAAiBtgH,EAAMsiB,KAEhC,SAAYtiB,GACjB2gH,EAAIz6H,KAAKoJ,KAAKsxH,mBAAmB5gH,EAAMsiB,IAGvCq+F,EAAIz6H,KAAK8Z,EAGrB,MACS,SAAU/d,GACf6/B,EAAIz+B,GAAQiM,KAAKgxH,iBAAiBr+H,EAAOqgC,IAEpC,SAAYrgC,GACjB6/B,EAAIz+B,GAAQiM,KAAKsxH,mBAAmB3+H,EAAOqgC,QAE5Bz9B,IAAV5C,IACL6/B,EAAIz+B,GAAQpB,GAGpB,OAAO6/B,CACX,CACA,kBAAA8+F,CAAmB12C,EAAW5nD,GAC1B,MAAMR,EAAM,CAAC,EAKb,OAJAA,EAAIioD,SAAWG,EAAUH,SACrBG,EAAUg7B,WACVpjF,EAAIojF,SAAW5iF,EAAQm+F,SAASv5H,IAAIgjF,EAAUg7B,WAE3CpjF,CACX,CACA,gBAAA4+F,CAAiBj9H,EAAM6+B,GACnB,MAAMj8B,EAAUi8B,EAAQm+F,SAASv5H,IAAIzD,GAsBrC,OArBI,SAAcA,GACd4C,EAAQwzC,SAAWp2C,EAAKo2C,SAIxBxzC,EAAQjB,cAAgBkK,KAAKuxH,oBAAoBp9H,EAAK2B,eAE1DiB,EAAQrD,OAASS,EAAKT,OACtBqD,EAAQ7B,QAAU89B,EAAQk+F,SAASt5H,IAAIzD,EAAKe,UACxC,SAAmBf,GACnB4C,EAAQf,QAAU7B,EAAK6B,QAAQyD,KAAI4mB,GAASrgB,KAAKoxH,iBAAiB/wG,EAAO2S,MAEpE,SAAc7+B,KACnB4C,EAAQkrC,UAAY9tC,EAAK8tC,UAAUluC,KACnCgD,EAAQsP,OAASlS,EAAKkS,OACtBtP,EAAQzB,OAASnB,EAAKmB,OACtByB,EAAQy5C,UAAYr8C,EAAKgG,MAAMwY,MAAMnN,KACrCzO,EAAQ05C,YAAct8C,EAAKgG,MAAMwY,MAAM40D,UACvCxwE,EAAQm7C,QAAU/9C,EAAKgG,MAAMyY,IAAIpN,KACjCzO,EAAQo7C,UAAYh+C,EAAKgG,MAAMyY,IAAI20D,WAEhCxwE,CACX,CACA,OAAAy6H,CAAQj7H,GACJ,MAAMpC,EAAOoC,EAAO5D,MACdqgC,EAAUhzB,KAAKyxH,uBAAuBt9H,GAI5C,MAHI,aAAcA,GACd6L,KAAK0xH,eAAev9H,EAAK00G,SAAU71E,GAEhC,CACHi+D,YAAa16F,EAAO06F,YACpB+a,YAAaz1G,EAAOy1G,YACpB9a,aAAc36F,EAAO26F,aACrBv+F,MAAOqN,KAAK2xH,eAAex9H,EAAM6+B,GAEzC,CACA,sBAAAy+F,CAAuBt9H,GACnB,MAAM+8H,EAAW,IAAI55H,IACf65H,EAAW,IAAI75H,IACrB,IAAK,MAAMpC,KAAW,SAAUf,GAC5B+8H,EAASv5H,IAAIzC,EAAS,CAAC,GAE3B,IAAIisB,EACJ,GAAIhtB,EAAK00G,SACL,IAAK,MAAM9xG,KAAW,QAAU5C,EAAK00G,UAAW,CAC5C,IAAI9vC,EACA,aAAchiE,GACdgiE,EAAM,IAAIovC,GAAgBpxG,EAAQwzC,UAClCppB,EAAO43C,GAEF,YAAahiE,EAClBgiE,EAAM,IAAIuvC,GAEL,cAAevxG,IACpBgiE,EAAM/4D,KAAK4xH,mBAAmB76H,IAE9BgiE,IACAo4D,EAASx5H,IAAIZ,EAASgiE,GACtBA,EAAI53C,KAAOA,EAEnB,CAEJ,MAAO,CACH+vG,WACAC,WAER,CACA,cAAAQ,CAAex9H,EAAM6+B,GACjB,MAAM99B,EAAU89B,EAAQk+F,SAASt5H,IAAIzD,GACrCe,EAAQ+F,MAAQ9G,EAAK8G,MACrB/F,EAAQgpH,gBAAkB/pH,EAAK+pH,gBAC/BhpH,EAAQ+oH,mBAAqB9pH,EAAK8pH,mBAC9B9pH,EAAK00G,WACL3zG,EAAQ2zG,SAAW71E,EAAQm+F,SAASv5H,IAAIzD,EAAK00G,WAEjD,IAAK,MAAO90G,EAAMpB,KAAU4G,OAAOC,QAAQrF,GACvC,IAAIJ,EAAK8V,WAAW,KAGpB,GAAIrF,MAAMyK,QAAQtc,GAAQ,CACtB,MAAM0+H,EAAM,GACZn8H,EAAQnB,GAAQs9H,EAChB,IAAK,MAAM3gH,KAAQ/d,GACX,SAAU+d,GACV2gH,EAAIz6H,KAAKoJ,KAAK2c,UAAU3c,KAAK2xH,eAAejhH,EAAMsiB,GAAU99B,KAEvD,SAAYwb,GACjB2gH,EAAIz6H,KAAKoJ,KAAK6xH,iBAAiBnhH,EAAMxb,EAASnB,EAAMi/B,IAGpDq+F,EAAIz6H,KAAK8Z,EAGrB,MACS,SAAU/d,GACfuC,EAAQnB,GAAQiM,KAAK2c,UAAU3c,KAAK2xH,eAAeh/H,EAAOqgC,GAAU99B,IAE/D,SAAYvC,GACjBuC,EAAQnB,GAAQiM,KAAK6xH,iBAAiBl/H,EAAOuC,EAASnB,EAAMi/B,QAE7Cz9B,IAAV5C,IACLuC,EAAQnB,GAAQpB,GAGxB,OAAOuC,CACX,CACA,SAAAynB,CAAUxoB,EAAMmd,GAEZ,OADAnd,EAAKiD,WAAaka,EACXnd,CACX,CACA,gBAAA09H,CAAiBj3C,EAAWzmF,EAAMJ,EAAMi/B,GACpC,OAAOhzB,KAAKorG,OAAO4B,eAAe74G,EAAMJ,EAAMi/B,EAAQm+F,SAASv5H,IAAIgjF,EAAUg7B,UAAWh7B,EAAUH,SACtG,CACA,cAAAi3C,CAAe36H,EAASi8B,EAAS8+F,EAAM,GACnC,MAAMC,EAAa/+F,EAAQm+F,SAASv5H,IAAIb,GAKxC,GAJqC,iBAA1BA,EAAQjB,gBACfi8H,EAAWj8H,cAAgBkK,KAAKgyH,kBAAkBj7H,EAAQjB,gBAE9Di8H,EAAW78H,QAAU89B,EAAQk+F,SAASt5H,IAAIb,EAAQ7B,UAC9C,SAAmB68H,GACnB,IAAK,MAAM1xG,KAAStpB,EAAQf,QAAS,CACjC,MAAMi8H,EAAWjyH,KAAK0xH,eAAerxG,EAAO2S,EAAS8+F,KACrDC,EAAW/7H,QAAQY,KAAKq7H,EAC5B,CAEJ,OAAOF,CACX,CACA,kBAAAH,CAAmB76H,GACf,MAAMkrC,EAAYjiC,KAAKkyH,aAAan7H,EAAQkrC,WACtC57B,EAAStP,EAAQsP,OACjB/Q,EAASyB,EAAQzB,OACjBk7C,EAAYz5C,EAAQy5C,UACpBC,EAAc15C,EAAQ05C,YACtByB,EAAUn7C,EAAQm7C,QAClBC,EAAYp7C,EAAQo7C,UACpBz+C,EAASqD,EAAQrD,OAWvB,OAVa,IAAI+0G,GAAgBpiG,EAAQ/Q,EAAQ,CAC7Cqd,MAAO,CACHnN,KAAMgrC,EACN+2B,UAAW92B,GAEf79B,IAAK,CACDpN,KAAM0sC,EACNq1B,UAAWp1B,IAEhBlQ,EAAWvuC,EAElB,CACA,YAAAw+H,CAAan+H,GACT,OAAOiM,KAAK6D,MAAM1L,WAAWpE,EACjC,CACA,mBAAAw9H,CAAoBp9H,GAChB,GAAKA,EAML,OAHsC,IAAlC6L,KAAK4wH,oBAAoBvyG,MACzBre,KAAKmyH,4BAEFnyH,KAAK4wH,oBAAoBh5H,IAAIzD,EACxC,CACA,iBAAA69H,CAAkB5oH,GACwB,IAAlCpJ,KAAK4wH,oBAAoBvyG,MACzBre,KAAKmyH,4BAGT,OADgBnyH,KAAK4wH,oBAAoBjY,OAAOvvG,EAEpD,CACA,yBAAA+oH,GACI,IAAI/oH,EAAK,EACT,IAAK,MAAMzT,KAAW,SAAUqK,KAAKnN,UAC7B,QAAkB8C,IAClBqK,KAAK4wH,oBAAoBj5H,IAAIhC,EAASyT,IAGlD,EC3OG,SAASgpH,GAAwBp/F,GACpC,MAAO,CACHwwE,cAAe,CACXwY,gBAAkBp2B,GAAa,IAAI2pC,GAAuB3pC,GAC1DysC,sBAAwBzsC,GAAa,IAAI+oC,GAA2B/oC,IAExEzqF,OAAQ,CACJm4G,YAAc1tB,GAAa,IAAIgqC,GAAmBhqC,GAClD6pC,cAAgB7pC,GChCrB,SAA6BA,GAChC,MAAM1yF,EAAQ,GACRL,EAAU+yF,EAAS7P,QACzB,IAAK,MAAMniF,KAAQf,EAAQK,OACnB,QAAeU,KAAS,QAAkBA,KAAS,SAAmB,OAAcA,KACpFV,EAAM0D,KAAKhD,EAAKG,MAGxB,MAAO,CACH47H,sBAAuBz8H,EACvBo/H,WAAY,KAEpB,CDoByCC,CAAoB3sC,GACjDuK,cAAgBvK,GAAa0qB,GAAoB1qB,GACjD4sC,iBAAmB5sC,GExCxB,SAAgCA,GACnC,MAAM/yF,EAAU+yF,EAAS7P,QACnBlyE,EAAQ+hF,EAASzqF,OAAOskC,MACxBtkC,EAAS,IAAIkyG,GAAwBznB,GAG3C,OAFAuoB,GAAat7G,EAASsI,EAAQ0I,EAAM1L,YACpCgD,EAAO65F,WACA75F,CACX,CFiC4Cs3H,CAAuB7sC,GACvD9yD,eAAgB,IAAM,IAAI,KAC1BD,aAAc,IAAM,IAAI,KACxB4M,MAAQmmD,GAAa,IAAI2kC,GAAa3kC,GACtC0kB,2BAA4B,IAAM,IAAI8C,GACtCod,0BAA2B,IAAM,IAAIH,IAEzCpkC,UAAW,CACP8uB,eAAgB,IAAM,IAAI8N,GAC1BhK,2BAA6BjzB,GAAa,IAAIu8B,GAAkCv8B,GAChFgjC,6BAA+BhjC,GAAa,IAAI48B,GAAoC58B,IAExFylB,WAAY,CACRC,OAAS1lB,GAAa,IAAI6uB,GAAc7uB,GACxCuxB,aAAc,IAAM,IAAIb,GACxBzB,cAAgBjvB,GAAa,IAAIo1B,GAAqBp1B,GACtDghC,iBAAmBhhC,GAAa,IAAIgzB,GAAwBhzB,GAC5D8sC,WAAa9sC,GAAa,IAAIqxB,GAAkBrxB,IAEpDE,WAAY,CACR6sC,SAAW/sC,GAAa,IAAI+qC,GAAgB/qC,GAC5CG,eAAiBH,GAAa,IAAIi2B,GAAsBj2B,IAE5Du6B,WAAY,CACRvB,kBAAoBh5B,GAAa,IAAIq6B,GAAyBr6B,GAC9Di5B,mBAAqBj5B,GAAa,IAAIi5B,GAAmBj5B,IAE7D3yD,OAAQ,IAAMD,EAAQC,OAE9B,CAKO,SAAS2/F,GAA8B5/F,GAC1C,MAAO,CACHG,gBAAkByyD,GAAa,IAAIy4B,GAAuBz4B,GAC1DK,UAAW,CACP0uB,iBAAmB/uB,GAAa,IAAI4tB,GAAwB5tB,GAC5DM,uBAAyBN,GAAa,IAAIosB,GAA8BpsB,GACxE+0B,gBAAkB/0B,GAAa,IAAIg/B,GAAuBh/B,GAC1DwxB,aAAexxB,GAAa,IAAImiC,GAAoBniC,GACpDitC,iBAAmBjtC,GAAa,IAAIijC,GAAwBjjC,GAC5DwsB,mBAAqBxsB,GAAa5yD,EAAQmyD,mBAAmBS,GAC7DqjC,cAAe,IAAM,IAAI8G,GACzB+C,sBAAwBltC,GAAa,IAAI29B,GAA6B39B,IAGlF,C,uBG1FO,IAAIqc,EA0BJ,SAAS8wB,EAAOC,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,GAE3F,OAAOC,EADQ,CAACT,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,EAASC,GAASlnG,OAAOonG,EAAQ,CAAC,GAErH,C,iCA5BA,SAAWzxB,GACPA,EAAO0xB,MAAQ,CAACC,EAAIC,IAAOH,EAAOA,EAAO,CAAC,EAAGE,GAAKC,EACrD,CAFD,CAEG5xB,IAAWA,EAAS,CAAC,IA2BxB,MAAM6xB,EAAUjsD,OAAO,WAiBvB,SAAS4rD,EAAQM,EAAQC,GACrB,MAAMC,EAAQ,IAAIC,MAAM,CAAC,EAAG,CACxBC,eAAgB,KAAM,EACtBx8H,IAAK,KACD,MAAM,IAAIiB,MAAM,oDAAoD,EAExEhB,IAAK,CAAC46B,EAAKlW,IACHA,IAASw3G,GAIFM,EAAS5hG,EAAKlW,EAAMy3G,EAAQC,GAAYC,GAGvD5vD,yBAA0B,CAAC7xC,EAAKlW,KAAU83G,EAAS5hG,EAAKlW,EAAMy3G,EAAQC,GAAYC,GAAQ16H,OAAO8qE,yBAAyB7xC,EAAKlW,IAC/HxoB,IAAK,CAAC2zE,EAAGnrD,IAASA,KAAQy3G,EAC1BM,QAAS,IAAM,IAAI96H,OAAO2qE,oBAAoB6vD,MAElD,OAAOE,CACX,CAKA,MAAMK,EAAgBzsD,SAatB,SAASusD,EAAS5hG,EAAKlW,EAAMy3G,EAAQC,GACjC,GAAI13G,KAAQkW,EAAK,CACb,GAAIA,EAAIlW,aAAiB1jB,MACrB,MAAM,IAAIA,MAAM,mFAAoF,CAAE27H,MAAO/hG,EAAIlW,KAErH,GAAIkW,EAAIlW,KAAUg4G,EACd,MAAM,IAAI17H,MAAM,gCAAkCukC,OAAO7gB,GAAQ,0GAErE,OAAOkW,EAAIlW,EACf,CACK,GAAIA,KAAQy3G,EAAQ,CACrB,MAAMphI,EAAQohI,EAAOz3G,GACrBkW,EAAIlW,GAAQg4G,EACZ,IACI9hG,EAAIlW,GAA0B,mBAAV3pB,EAAwBA,EAAMqhI,GAAYP,EAAQ9gI,EAAOqhI,EACjF,CACA,MAAOlxH,GAEH,MADA0vB,EAAIlW,GAAQxZ,aAAiBlK,MAAQkK,OAAQvN,EACvCuN,CACV,CACA,OAAO0vB,EAAIlW,EACf,CAIJ,CAQA,SAASo3G,EAAO7jH,EAAQzW,GACpB,GAAIA,EACA,IAAK,MAAO+c,EAAKq+G,KAAWj7H,OAAOC,QAAQJ,GACvC,QAAe7D,IAAXi/H,EAAsB,CACtB,MAAMC,EAAS5kH,EAAOsG,GAElBtG,EAAOsG,GADI,OAAXs+G,GAA8B,OAAXD,GAAqC,iBAAXC,GAAyC,iBAAXD,EAC7Dd,EAAOe,EAAQD,GAGfA,CAEtB,CAGR,OAAO3kH,CACX,C,qBCnIA,IAAI6kH,EACJ,SAASC,IACL,QAAap/H,IAATm/H,EACA,MAAM,IAAI97H,MAAM,0CAEpB,OAAO87H,CACX,CAPAn7H,OAAO8wD,eAAeg2B,EAAS,aAAc,CAAE1tF,OAAO,IAQtD,SAAWgiI,GAOPA,EAAIC,QANJ,SAAiBC,GACb,QAAYt/H,IAARs/H,EACA,MAAM,IAAIj8H,MAAM,yCAEpB87H,EAAOG,CACX,CAEH,CARD,CAQGF,IAAQA,EAAM,CAAC,IAClBt0C,EAAA,QAAkBs0C,C,uDCrBlB,IAGI,EAHcp7H,OAAOwK,UAGQC,eAcjC,MAJA,SAAiBgW,EAAQ7D,GACvB,OAAiB,MAAV6D,GAAkB,EAAevW,KAAKuW,EAAQ7D,EACvD,E,UCkBA,MAJA,SAAa6D,EAAQE,GACnB,OAAiB,MAAVF,IAAkB,OAAQA,EAAQE,EAAM,EACjD,C,0RCpBO,SAAS46G,EAAuB3gI,GACnC,IAAK,MAAOJ,EAAMpB,KAAU4G,OAAOC,QAAQrF,GAClCJ,EAAK8V,WAAW,OACbrF,MAAMyK,QAAQtc,GACdA,EAAMuB,SAAQ,CAACwc,EAAMtb,MACb,QAAUsb,KACVA,EAAKtZ,WAAajD,EAClBuc,EAAKutG,mBAAqBlqH,EAC1B2c,EAAKwtG,gBAAkB9oH,EAC3B,KAGC,QAAUzC,KACfA,EAAMyE,WAAajD,EACnBxB,EAAMsrH,mBAAqBlqH,GAI3C,CAMO,SAASghI,EAAmB5gI,EAAM6gI,GACrC,IAAItkH,EAAOvc,EACX,KAAOuc,GAAM,CACT,GAAIskH,EAActkH,GACd,OAAOA,EAEXA,EAAOA,EAAKtZ,UAChB,CAEJ,CAqBO,SAAS08G,EAAY3/G,GACxB,MACMoC,EADW0+H,EAAa9gI,GACNg/G,UACxB,IAAK58G,EACD,MAAM,IAAIqC,MAAM,6BAEpB,OAAOrC,CACX,CAIO,SAAS0+H,EAAa9gI,GACzB,KAAOA,EAAKiD,YACRjD,EAAOA,EAAKiD,WAEhB,OAAOjD,CACX,CAKO,SAAS+gI,EAAe/gI,EAAM+G,GACjC,IAAK/G,EACD,MAAM,IAAIyE,MAAM,4BAEpB,MAAMuB,EAAQe,aAAyC,EAASA,EAAQf,MACxE,OAAO,IAAI,MAAW,KAAM,CACxB0X,KAAMtY,OAAOsY,KAAK1d,GAClBghI,SAAU,EACV9R,WAAY,MACZx+G,IACA,KAAOA,EAAMswH,SAAWtwH,EAAMgN,KAAKvc,QAAQ,CACvC,MAAMN,EAAW6P,EAAMgN,KAAKhN,EAAMswH,UAClC,IAAKngI,EAAS6U,WAAW,KAAM,CAC3B,MAAMlX,EAAQwB,EAAKa,GACnB,IAAI,QAAUrC,IAEV,GADAkS,EAAMswH,WACFC,EAAiBziI,EAAOwH,GACxB,MAAO,CAAEzD,MAAM,EAAO/D,cAGzB,GAAI6R,MAAMyK,QAAQtc,GAAQ,CAC3B,KAAOkS,EAAMw+G,WAAa1wH,EAAM2C,QAAQ,CACpC,MACMK,EAAUhD,EADFkS,EAAMw+G,cAEpB,IAAI,QAAU1tH,IAAYy/H,EAAiBz/H,EAASwE,GAChD,MAAO,CAAEzD,MAAM,EAAO/D,MAAOgD,EAErC,CACAkP,EAAMw+G,WAAa,CACvB,CACJ,CACAx+G,EAAMswH,UACV,CACA,OAAO,IAAW,GAE1B,CAKO,SAASE,EAAkBl0G,EAAMjmB,GACpC,IAAKimB,EACD,MAAM,IAAIvoB,MAAM,iCAEpB,OAAO,IAAI,KAAeuoB,GAAMhtB,GAAQ+gI,EAAe/gI,EAAM+G,IACjE,CAKO,SAASo6H,EAAUn0G,EAAMjmB,GAC5B,IAAKimB,EACD,MAAM,IAAIvoB,MAAM,iCAEf,OAAKsC,aAAyC,EAASA,EAAQf,SAAWi7H,EAAiBj0G,EAAMjmB,EAAQf,OAEnG,IAAI,KAAegnB,GAAM,IAAM,KAEnC,IAAI,KAAeA,GAAMhtB,GAAQ+gI,EAAe/gI,EAAM+G,IAAU,CAAEqvE,aAAa,GAC1F,CACA,SAAS6qD,EAAiBlgI,EAASiF,GAC/B,IAAInD,EACJ,IAAKmD,EACD,OAAO,EAEX,MAAMo7H,EAAwC,QAA3Bv+H,EAAK9B,EAAQ2zG,gBAA6B,IAAP7xG,OAAgB,EAASA,EAAGmD,MAClF,QAAKo7H,IAGE,QAAQA,EAAWp7H,EAC9B,CAKO,SAASq7H,EAAiBrhI,GAC7B,OAAO,IAAI,MAAW,KAAM,CACxB0d,KAAMtY,OAAOsY,KAAK1d,GAClBghI,SAAU,EACV9R,WAAY,MACZx+G,IACA,KAAOA,EAAMswH,SAAWtwH,EAAMgN,KAAKvc,QAAQ,CACvC,MAAMN,EAAW6P,EAAMgN,KAAKhN,EAAMswH,UAClC,IAAKngI,EAAS6U,WAAW,KAAM,CAC3B,MAAMlX,EAAQwB,EAAKa,GACnB,IAAI,QAAYrC,GAEZ,OADAkS,EAAMswH,WACC,CAAEz+H,MAAM,EAAO/D,MAAO,CAAEioF,UAAWjoF,EAAOsE,UAAW9C,EAAMa,aAEjE,GAAIwP,MAAMyK,QAAQtc,GAAQ,CAC3B,KAAOkS,EAAMw+G,WAAa1wH,EAAM2C,QAAQ,CACpC,MAAMF,EAAQyP,EAAMw+G,aACd1tH,EAAUhD,EAAMyC,GACtB,IAAI,QAAYO,GACZ,MAAO,CAAEe,MAAM,EAAO/D,MAAO,CAAEioF,UAAWjlF,EAASsB,UAAW9C,EAAMa,WAAUI,SAEtF,CACAyP,EAAMw+G,WAAa,CACvB,CACJ,CACAx+G,EAAMswH,UACV,CACA,OAAO,IAAW,GAE1B,CAwBO,SAASM,EAA0BpgD,EAAYlhF,GAClD,MAAMuhI,EAAergD,EAAW+E,gBAAgBjmF,EAAK8G,OAC/C06H,EAAcxhI,EACpB,IAAK,MAAMa,KAAY0gI,EAAar7C,gBAEF9kF,IAA1BP,EAASslF,mBAA6D/kF,IAA/BogI,EAAY3gI,EAASjB,QAC5D4hI,EAAY3gI,EAASjB,MAAQ6hI,EAAiB5gI,EAASslF,cAGnE,CACA,SAASs7C,EAAiBC,GACtB,OAAIrxH,MAAMyK,QAAQ4mH,GACP,IAAIA,EAAap8H,IAAIm8H,IAGrBC,CAEf,C,yDC3MA,IALA,SAAkBljI,GAChB,MAAuB,iBAATA,KACV,OAAQA,KAAU,OAAaA,IArBrB,oBAqB+B,OAAWA,EAC1D,C,uBCrBA0tF,EAAQ,GAA0BA,EAAQ,QAAoB,EAC9D,MAAMG,EAAQ,EAAQ,MAChB0d,EAAK,EAAQ,MACb43B,EAAW,EAAQ,MACzB,IAAIC,GACJ,SAAWA,GACPA,EAAkBp1C,KAAOpnF,OAAO2xC,OAAO,CACnC8lE,yBAAyB,EACzB0W,wBAAyBoO,EAASv1C,MAAMI,OAE5Co1C,EAAkBC,UAAYz8H,OAAO2xC,OAAO,CACxC8lE,yBAAyB,EACzB0W,wBAAyBoO,EAASv1C,MAAMI,OAQ5Co1C,EAAkBxgC,GANlB,SAAY5iG,GACR,MAAMsrG,EAAYtrG,EAClB,OAAOsrG,IAAcA,IAAc83B,EAAkBp1C,MAC9Csd,IAAc83B,EAAkBC,WAC/B93B,EAAGpO,QAAQmO,EAAU+S,4BAA8B/S,EAAUypB,wBACzE,CAEH,CAhBD,CAgBGqO,IAAsB11C,EAAQ,GAAoB01C,EAAoB,CAAC,IAC1E,MAAME,EAAgB18H,OAAO2xC,QAAO,SAAU21C,EAAU7tD,GACpD,MAAMmgE,GAAS,EAAI3S,EAAMgB,WAAWt5C,MAAM6oE,WAAWlwB,EAAS/zE,KAAKkmB,GAAU,GAC7E,MAAO,CAAE,OAAA0tD,GAAYyS,EAAOzS,SAAW,EAC3C,IACA,MAAMw1C,EACF,WAAAttH,GACI5I,KAAKm2H,cAAe,CACxB,CACA,MAAAzF,GACS1wH,KAAKm2H,eACNn2H,KAAKm2H,cAAe,EAChBn2H,KAAKo2H,WACLp2H,KAAKo2H,SAASn0C,UAAK1sF,GACnByK,KAAK0gF,WAGjB,CACA,2BAAIswB,GACA,OAAOhxG,KAAKm2H,YAChB,CACA,2BAAIzO,GACA,OAAI1nH,KAAKm2H,aACEF,GAENj2H,KAAKo2H,WACNp2H,KAAKo2H,SAAW,IAAIN,EAASx1C,SAE1BtgF,KAAKo2H,SAAS7qH,MACzB,CACA,OAAAm1E,GACQ1gF,KAAKo2H,WACLp2H,KAAKo2H,SAAS11C,UACd1gF,KAAKo2H,cAAW7gI,EAExB,EAiCJ8qF,EAAQ,GA/BR,MACI,SAAI/7E,GAMA,OALKtE,KAAKq2H,SAGNr2H,KAAKq2H,OAAS,IAAIH,GAEfl2H,KAAKq2H,MAChB,CACA,MAAA3F,GACS1wH,KAAKq2H,OAONr2H,KAAKq2H,OAAO3F,SAHZ1wH,KAAKq2H,OAASN,EAAkBC,SAKxC,CACA,OAAAt1C,GACS1gF,KAAKq2H,OAIDr2H,KAAKq2H,kBAAkBH,GAE5Bl2H,KAAKq2H,OAAO31C,UAJZ1gF,KAAKq2H,OAASN,EAAkBp1C,IAMxC,E,mGC5EA21C,EAAqB,cAAc,aAEnC,QAAOt2H,KAAM,qBACf,CACA,WAAA4I,GACE+pB,MAAM,CAAC,eACT,GAIE4jG,EAAe,CACjBp7H,OAAQ,CACN03B,cAA8B,SAAO,IAAM,IAAIyjG,GAAsB,gBACrExjG,gBAAgC,SAAO,IAAM,IAAI,MAAwB,oBAG7E,SAASu9D,EAAqBr9D,EAAU,KACtC,MAAMC,GAAS,SACb,OAA8BD,GAC9B,MAEIq0D,GAAS,SACb,OAAwB,CAAEp0D,WAC1B,KACAsjG,GAGF,OADAtjG,EAAOE,gBAAgBC,SAASi0D,GACzB,CAAEp0D,SAAQo0D,SACnB,EACA,QAAOgJ,EAAsB,uB","sources":["webpack://gatsby-starter-blog/./node_modules/lodash-es/clone.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/grammar-utils.js","webpack://gatsby-starter-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-A2AXSNBT.mjs","webpack://gatsby-starter-blog/./node_modules/lodash-es/_createFind.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/findIndex.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/find.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/uniqueId.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseRange.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_createRange.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/range.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/data/list.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/greedy-fas.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/acyclic.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_basePick.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_flatRest.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/pick.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseGt.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/max.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/mapValues.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/now.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/util.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/add-border-segments.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/coordinate-system.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/normalize.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/minBy.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/rank/util.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/rank/feasible-tree.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/dijkstra.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/floyd-warshall.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_asciiSize.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_hasUnicode.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_unicodeSize.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/topsort.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/dfs.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/rank/network-simplex.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/postorder.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/alg/preorder.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/rank/index.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/nesting-graph.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/cloneDeep.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/build-layer-graph.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseZipObject.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/zipObject.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseSortBy.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_compareAscending.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_compareMultiple.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseOrderBy.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/sortBy.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/cross-count.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/resolve-conflicts.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/sort.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/sort-subgraph.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/barycenter.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/index.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/init-order.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/order/add-subgraph-constraints.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/parent-dummy-chains.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/forOwn.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/forIn.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/position/bk.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/position/index.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/dagre/layout.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs","webpack://gatsby-starter-blog/./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseSlice.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/drop.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/assign.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/pickBy.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseIsRegExp.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/isRegExp.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/gast/lib/src/model.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/gast/lib/src/visitor.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseSome.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/some.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/includes.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_arrayEvery.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseEvery.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/every.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/gast/lib/src/helpers.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/rest.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/uniq.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/first.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/constants.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/follow.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/negate.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/reject.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/indexOf.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseDifference.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/difference.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/compact.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/head.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/utils/lib/src/print.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/reg_exp.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/lexer.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/utils/lib/src/timer.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/tokens.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/lexer_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/scan/tokens_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/errors_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_arrayAggregator.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseAggregator.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_createAggregator.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/groupBy.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/dropRight.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/checks.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/exceptions_public.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/keys.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/cst/cst.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/lang/lang_extensions.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/parser.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js","webpack://gatsby-starter-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/union.js","webpack://gatsby-starter-blog/./node_modules/dagre-d3-es/src/graphlib/graph.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/errors.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/stream.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/token-builder.js","webpack://gatsby-starter-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-AEK57VVT.mjs","webpack://gatsby-starter-blog/./node_modules/langium/lib/languages/generated/ast.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/syntax-tree.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseExtremum.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseMap.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js","webpack://gatsby-starter-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js","webpack://gatsby-starter-blog/./node_modules/vscode-jsonrpc/lib/common/events.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/regexp-utils.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/defaults.js","webpack://gatsby-starter-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-RZ5BOZE2.mjs","webpack://gatsby-starter-blog/./node_modules/lodash-es/_trimmedEndIndex.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseTrim.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/toNumber.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/toFinite.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/flatten.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/file-system-provider.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/map.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/grammar-loader.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/value-converter.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseSet.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_basePickBy.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseLt.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/cst-utils.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/min.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/last.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs","webpack://gatsby-starter-blog/./node_modules/vscode-uri/lib/esm/index.mjs","webpack://gatsby-starter-blog/./node_modules/lodash-es/flatMap.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs","webpack://gatsby-starter-blog/./node_modules/vscode-jsonrpc/lib/common/is.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/toInteger.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs","webpack://gatsby-starter-blog/./node_modules/chevrotain-allstar/lib/atn.js","webpack://gatsby-starter-blog/./node_modules/chevrotain-allstar/lib/dfa.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/uniqBy.js","webpack://gatsby-starter-blog/./node_modules/chevrotain-allstar/lib/all-star-lookahead.js","webpack://gatsby-starter-blog/./node_modules/vscode-languageserver-types/lib/esm/main.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/cst-node-builder.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/langium-parser.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/parser-builder-base.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/langium-parser-builder.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/promise-utils.js","webpack://gatsby-starter-blog/./node_modules/vscode-languageserver-textdocument/lib/esm/main.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/documents.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/linker.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/name-provider.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/uri-utils.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/references.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/collections.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/scope-computation.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/scope.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/caching.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/references/scope-provider.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/serializer/json-serializer.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/service-registry.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/validation/validation-registry.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/validation/document-validator.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/ast-descriptions.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/ast-node-locator.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/disposable.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/configuration.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/document-builder.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/index-manager.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/workspace-manager.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/lexer.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/documentation/jsdoc.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/documentation/documentation-provider.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/documentation/comment-provider.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/async-parser.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/workspace/workspace-lock.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/serializer/hydrator.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/default-module.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/languages/grammar-config.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/parser/completion-parser-builder.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/dependency-injection.js","webpack://gatsby-starter-blog/./node_modules/vscode-jsonrpc/lib/common/ral.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/_baseHas.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/has.js","webpack://gatsby-starter-blog/./node_modules/langium/lib/utils/ast-utils.js","webpack://gatsby-starter-blog/./node_modules/lodash-es/isString.js","webpack://gatsby-starter-blog/./node_modules/vscode-jsonrpc/lib/common/cancellation.js","webpack://gatsby-starter-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs"],"sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../utils/errors.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\nimport { streamCst } from './cst-utils.js';\nimport { escapeRegExp, isWhitespace } from './regexp-utils.js';\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nexport function getEntryRule(grammar) {\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry);\n}\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nexport function getHiddenRules(grammar) {\n    return grammar.rules.filter((e) => ast.isTerminalRule(e) && e.hidden);\n}\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nexport function getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = new Set();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n    const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n    const rules = new Set();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    streamAllContents(rule).forEach(node => {\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nexport function getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    }\n    else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return undefined;\n}\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nexport function isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !isWhitespace(terminalRegex(terminalRule));\n}\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nexport function findNodesForProperty(node, property) {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForProperty(node, property, index) {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first) {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nexport function findNodesForKeyword(node, keyword) {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForKeyword(node, keyword, index) {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nexport function findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            }\n            else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nexport function findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nexport function findNameAssignment(type) {\n    let startNode = type;\n    if (ast.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (ast.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container;\n        }\n        else if (ast.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        }\n        else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    // the cache is only required to prevent infinite loops\n    function go(node, refType) {\n        let childAssignment = undefined;\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of streamAllContents(startNode)) {\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        }\n        else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        }\n        else if (ast.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\nexport function getActionAtElement(element) {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            }\n            else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    }\n    else {\n        return undefined;\n    }\n}\nexport function isOptionalCardinality(cardinality, element) {\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\nexport function isArrayCardinality(cardinality) {\n    return cardinality === '*' || cardinality === '+';\n}\nexport function isArrayOperator(operator) {\n    return operator === '+=';\n}\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nexport function isDataTypeRule(rule) {\n    return isDataTypeRuleInternal(rule, new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) {\n        return true;\n    }\n    else {\n        visited.add(rule);\n    }\n    for (const node of streamAllContents(rule)) {\n        if (ast.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        }\n        else if (ast.isAssignment(node)) {\n            return false;\n        }\n        else if (ast.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\nexport function isDataType(type) {\n    return isDataTypeInternal(type.type, new Set());\n}\nfunction isDataTypeInternal(type, visited) {\n    if (visited.has(type)) {\n        return true;\n    }\n    else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    }\n    else if (ast.isReferenceType(type)) {\n        return false;\n    }\n    else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    }\n    else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        }\n        else if (type.stringType !== undefined) {\n            return true;\n        }\n        else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nexport function getExplicitRuleType(rule) {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    }\n    else if (rule.dataType) {\n        return rule.dataType;\n    }\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            // check if we need to check Action as return type\n            if (ast.isParserRule(refType)) {\n                return refType.name;\n            }\n            else if (ast.isInterface(refType) || ast.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\nexport function getTypeName(type) {\n    var _a;\n    if (ast.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    }\n    else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\n        return type.name;\n    }\n    else if (ast.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    }\n    else if (ast.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\nexport function getActionType(action) {\n    var _a;\n    if (action.inferredType) {\n        return action.inferredType.name;\n    }\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n/**\n * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.\n * For data type rules, the name of the rule is returned,\n * e.g. \"INT_value returns number: MY_INT;\" returns \"INT_value\".\n * @param rule the given rule\n * @returns the name of the AST node type of the rule\n */\nexport function getRuleTypeName(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\n/**\n * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.\n * For data type rules, the name of the declared return type of the rule is returned (if any),\n * e.g. \"INT_value returns number: MY_INT;\" returns \"number\".\n * @param rule the given rule\n * @returns the name of the type of the produced values of the rule at runtime\n */\nexport function getRuleType(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\nexport function terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n    if (ast.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    }\n    else if (ast.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    }\n    else if (ast.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    }\n    else if (ast.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else if (ast.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    }\n    else if (ast.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    }\n    else if (ast.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    }\n    else if (ast.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else {\n        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n    }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\nfunction terminalGroupToRegex(group) {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\nfunction untilTokenToRegex(until) {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\nfunction negateTokenToRegex(negate) {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\nfunction characterRangeToRegex(range) {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\nfunction keywordToRegex(keyword) {\n    return escapeRegExp(keyword.value);\n}\nfunction withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n//# sourceMappingURL=grammar-utils.js.map","import {\n  getDiagramElement,\n  setupViewPortForSVG\n} from \"./chunk-RZ5BOZE2.mjs\";\nimport {\n  getRegisteredLayoutAlgorithm,\n  render\n} from \"./chunk-TYCBKAJE.mjs\";\nimport {\n  getEdgeId,\n  utils_default\n} from \"./chunk-O4NI6UNU.mjs\";\nimport {\n  __name,\n  clear,\n  common_default,\n  getAccDescription,\n  getAccTitle,\n  getConfig2 as getConfig,\n  getDiagramTitle,\n  log,\n  parseGenericTypes,\n  sanitizeText,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/diagrams/class/parser/classDiagram.jison\nvar parser = function() {\n  var o = /* @__PURE__ */ __name(function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;\n    return o2;\n  }, \"o\"), $V0 = [1, 18], $V1 = [1, 19], $V2 = [1, 20], $V3 = [1, 41], $V4 = [1, 42], $V5 = [1, 26], $V6 = [1, 24], $V7 = [1, 25], $V8 = [1, 32], $V9 = [1, 33], $Va = [1, 34], $Vb = [1, 45], $Vc = [1, 35], $Vd = [1, 36], $Ve = [1, 37], $Vf = [1, 38], $Vg = [1, 27], $Vh = [1, 28], $Vi = [1, 29], $Vj = [1, 30], $Vk = [1, 31], $Vl = [1, 44], $Vm = [1, 46], $Vn = [1, 43], $Vo = [1, 47], $Vp = [1, 9], $Vq = [1, 8, 9], $Vr = [1, 58], $Vs = [1, 59], $Vt = [1, 60], $Vu = [1, 61], $Vv = [1, 62], $Vw = [1, 63], $Vx = [1, 64], $Vy = [1, 8, 9, 41], $Vz = [1, 76], $VA = [1, 8, 9, 12, 13, 22, 39, 41, 44, 66, 67, 68, 69, 70, 71, 72, 77, 79], $VB = [1, 8, 9, 12, 13, 17, 20, 22, 39, 41, 44, 48, 58, 66, 67, 68, 69, 70, 71, 72, 77, 79, 84, 99, 101, 102], $VC = [13, 58, 84, 99, 101, 102], $VD = [13, 58, 71, 72, 84, 99, 101, 102], $VE = [13, 58, 66, 67, 68, 69, 70, 84, 99, 101, 102], $VF = [1, 98], $VG = [1, 115], $VH = [1, 107], $VI = [1, 113], $VJ = [1, 108], $VK = [1, 109], $VL = [1, 110], $VM = [1, 111], $VN = [1, 112], $VO = [1, 114], $VP = [22, 58, 59, 80, 84, 85, 86, 87, 88, 89], $VQ = [1, 8, 9, 39, 41, 44], $VR = [1, 8, 9, 22], $VS = [1, 143], $VT = [1, 8, 9, 59], $VU = [1, 8, 9, 22, 58, 59, 80, 84, 85, 86, 87, 88, 89];\n  var parser2 = {\n    trace: /* @__PURE__ */ __name(function trace() {\n    }, \"trace\"),\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"mermaidDoc\": 4, \"statements\": 5, \"graphConfig\": 6, \"CLASS_DIAGRAM\": 7, \"NEWLINE\": 8, \"EOF\": 9, \"statement\": 10, \"classLabel\": 11, \"SQS\": 12, \"STR\": 13, \"SQE\": 14, \"namespaceName\": 15, \"alphaNumToken\": 16, \"DOT\": 17, \"className\": 18, \"classLiteralName\": 19, \"GENERICTYPE\": 20, \"relationStatement\": 21, \"LABEL\": 22, \"namespaceStatement\": 23, \"classStatement\": 24, \"memberStatement\": 25, \"annotationStatement\": 26, \"clickStatement\": 27, \"styleStatement\": 28, \"cssClassStatement\": 29, \"noteStatement\": 30, \"classDefStatement\": 31, \"direction\": 32, \"acc_title\": 33, \"acc_title_value\": 34, \"acc_descr\": 35, \"acc_descr_value\": 36, \"acc_descr_multiline_value\": 37, \"namespaceIdentifier\": 38, \"STRUCT_START\": 39, \"classStatements\": 40, \"STRUCT_STOP\": 41, \"NAMESPACE\": 42, \"classIdentifier\": 43, \"STYLE_SEPARATOR\": 44, \"members\": 45, \"CLASS\": 46, \"ANNOTATION_START\": 47, \"ANNOTATION_END\": 48, \"MEMBER\": 49, \"SEPARATOR\": 50, \"relation\": 51, \"NOTE_FOR\": 52, \"noteText\": 53, \"NOTE\": 54, \"CLASSDEF\": 55, \"classList\": 56, \"stylesOpt\": 57, \"ALPHA\": 58, \"COMMA\": 59, \"direction_tb\": 60, \"direction_bt\": 61, \"direction_rl\": 62, \"direction_lr\": 63, \"relationType\": 64, \"lineType\": 65, \"AGGREGATION\": 66, \"EXTENSION\": 67, \"COMPOSITION\": 68, \"DEPENDENCY\": 69, \"LOLLIPOP\": 70, \"LINE\": 71, \"DOTTED_LINE\": 72, \"CALLBACK\": 73, \"LINK\": 74, \"LINK_TARGET\": 75, \"CLICK\": 76, \"CALLBACK_NAME\": 77, \"CALLBACK_ARGS\": 78, \"HREF\": 79, \"STYLE\": 80, \"CSSCLASS\": 81, \"style\": 82, \"styleComponent\": 83, \"NUM\": 84, \"COLON\": 85, \"UNIT\": 86, \"SPACE\": 87, \"BRKT\": 88, \"PCT\": 89, \"commentToken\": 90, \"textToken\": 91, \"graphCodeTokens\": 92, \"textNoTagsToken\": 93, \"TAGSTART\": 94, \"TAGEND\": 95, \"==\": 96, \"--\": 97, \"DEFAULT\": 98, \"MINUS\": 99, \"keywords\": 100, \"UNICODE_TEXT\": 101, \"BQUOTE_STR\": 102, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 7: \"CLASS_DIAGRAM\", 8: \"NEWLINE\", 9: \"EOF\", 12: \"SQS\", 13: \"STR\", 14: \"SQE\", 17: \"DOT\", 20: \"GENERICTYPE\", 22: \"LABEL\", 33: \"acc_title\", 34: \"acc_title_value\", 35: \"acc_descr\", 36: \"acc_descr_value\", 37: \"acc_descr_multiline_value\", 39: \"STRUCT_START\", 41: \"STRUCT_STOP\", 42: \"NAMESPACE\", 44: \"STYLE_SEPARATOR\", 46: \"CLASS\", 47: \"ANNOTATION_START\", 48: \"ANNOTATION_END\", 49: \"MEMBER\", 50: \"SEPARATOR\", 52: \"NOTE_FOR\", 54: \"NOTE\", 55: \"CLASSDEF\", 58: \"ALPHA\", 59: \"COMMA\", 60: \"direction_tb\", 61: \"direction_bt\", 62: \"direction_rl\", 63: \"direction_lr\", 66: \"AGGREGATION\", 67: \"EXTENSION\", 68: \"COMPOSITION\", 69: \"DEPENDENCY\", 70: \"LOLLIPOP\", 71: \"LINE\", 72: \"DOTTED_LINE\", 73: \"CALLBACK\", 74: \"LINK\", 75: \"LINK_TARGET\", 76: \"CLICK\", 77: \"CALLBACK_NAME\", 78: \"CALLBACK_ARGS\", 79: \"HREF\", 80: \"STYLE\", 81: \"CSSCLASS\", 84: \"NUM\", 85: \"COLON\", 86: \"UNIT\", 87: \"SPACE\", 88: \"BRKT\", 89: \"PCT\", 92: \"graphCodeTokens\", 94: \"TAGSTART\", 95: \"TAGEND\", 96: \"==\", 97: \"--\", 98: \"DEFAULT\", 99: \"MINUS\", 100: \"keywords\", 101: \"UNICODE_TEXT\", 102: \"BQUOTE_STR\" },\n    productions_: [0, [3, 1], [3, 1], [4, 1], [6, 4], [5, 1], [5, 2], [5, 3], [11, 3], [15, 1], [15, 3], [15, 2], [18, 1], [18, 3], [18, 1], [18, 2], [18, 2], [18, 2], [10, 1], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [23, 4], [23, 5], [38, 2], [40, 1], [40, 2], [40, 3], [24, 1], [24, 3], [24, 4], [24, 6], [43, 2], [43, 3], [26, 4], [45, 1], [45, 2], [25, 1], [25, 2], [25, 1], [25, 1], [21, 3], [21, 4], [21, 4], [21, 5], [30, 3], [30, 2], [31, 3], [56, 1], [56, 3], [32, 1], [32, 1], [32, 1], [32, 1], [51, 3], [51, 2], [51, 2], [51, 1], [64, 1], [64, 1], [64, 1], [64, 1], [64, 1], [65, 1], [65, 1], [27, 3], [27, 4], [27, 3], [27, 4], [27, 4], [27, 5], [27, 3], [27, 4], [27, 4], [27, 5], [27, 4], [27, 5], [27, 5], [27, 6], [28, 3], [29, 3], [57, 1], [57, 3], [82, 1], [82, 2], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [90, 1], [90, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [93, 1], [93, 1], [93, 1], [93, 1], [16, 1], [16, 1], [16, 1], [16, 1], [19, 1], [53, 1]],\n    performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 8:\n          this.$ = $$[$0 - 1];\n          break;\n        case 9:\n        case 12:\n        case 14:\n          this.$ = $$[$0];\n          break;\n        case 10:\n        case 13:\n          this.$ = $$[$0 - 2] + \".\" + $$[$0];\n          break;\n        case 11:\n        case 15:\n          this.$ = $$[$0 - 1] + $$[$0];\n          break;\n        case 16:\n        case 17:\n          this.$ = $$[$0 - 1] + \"~\" + $$[$0] + \"~\";\n          break;\n        case 18:\n          yy.addRelation($$[$0]);\n          break;\n        case 19:\n          $$[$0 - 1].title = yy.cleanupLabel($$[$0]);\n          yy.addRelation($$[$0 - 1]);\n          break;\n        case 30:\n          this.$ = $$[$0].trim();\n          yy.setAccTitle(this.$);\n          break;\n        case 31:\n        case 32:\n          this.$ = $$[$0].trim();\n          yy.setAccDescription(this.$);\n          break;\n        case 33:\n          yy.addClassesToNamespace($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 34:\n          yy.addClassesToNamespace($$[$0 - 4], $$[$0 - 1]);\n          break;\n        case 35:\n          this.$ = $$[$0];\n          yy.addNamespace($$[$0]);\n          break;\n        case 36:\n          this.$ = [$$[$0]];\n          break;\n        case 37:\n          this.$ = [$$[$0 - 1]];\n          break;\n        case 38:\n          $$[$0].unshift($$[$0 - 2]);\n          this.$ = $$[$0];\n          break;\n        case 40:\n          yy.setCssClass($$[$0 - 2], $$[$0]);\n          break;\n        case 41:\n          yy.addMembers($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 42:\n          yy.setCssClass($$[$0 - 5], $$[$0 - 3]);\n          yy.addMembers($$[$0 - 5], $$[$0 - 1]);\n          break;\n        case 43:\n          this.$ = $$[$0];\n          yy.addClass($$[$0]);\n          break;\n        case 44:\n          this.$ = $$[$0 - 1];\n          yy.addClass($$[$0 - 1]);\n          yy.setClassLabel($$[$0 - 1], $$[$0]);\n          break;\n        case 45:\n          yy.addAnnotation($$[$0], $$[$0 - 2]);\n          break;\n        case 46:\n        case 59:\n          this.$ = [$$[$0]];\n          break;\n        case 47:\n          $$[$0].push($$[$0 - 1]);\n          this.$ = $$[$0];\n          break;\n        case 48:\n          break;\n        case 49:\n          yy.addMember($$[$0 - 1], yy.cleanupLabel($$[$0]));\n          break;\n        case 50:\n          break;\n        case 51:\n          break;\n        case 52:\n          this.$ = { \"id1\": $$[$0 - 2], \"id2\": $$[$0], relation: $$[$0 - 1], relationTitle1: \"none\", relationTitle2: \"none\" };\n          break;\n        case 53:\n          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 1], relationTitle1: $$[$0 - 2], relationTitle2: \"none\" };\n          break;\n        case 54:\n          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: \"none\", relationTitle2: $$[$0 - 1] };\n          break;\n        case 55:\n          this.$ = { id1: $$[$0 - 4], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: $$[$0 - 3], relationTitle2: $$[$0 - 1] };\n          break;\n        case 56:\n          yy.addNote($$[$0], $$[$0 - 1]);\n          break;\n        case 57:\n          yy.addNote($$[$0]);\n          break;\n        case 58:\n          this.$ = $$[$0 - 2];\n          yy.defineClass($$[$0 - 1], $$[$0]);\n          break;\n        case 60:\n          this.$ = $$[$0 - 2].concat([$$[$0]]);\n          break;\n        case 61:\n          yy.setDirection(\"TB\");\n          break;\n        case 62:\n          yy.setDirection(\"BT\");\n          break;\n        case 63:\n          yy.setDirection(\"RL\");\n          break;\n        case 64:\n          yy.setDirection(\"LR\");\n          break;\n        case 65:\n          this.$ = { type1: $$[$0 - 2], type2: $$[$0], lineType: $$[$0 - 1] };\n          break;\n        case 66:\n          this.$ = { type1: \"none\", type2: $$[$0], lineType: $$[$0 - 1] };\n          break;\n        case 67:\n          this.$ = { type1: $$[$0 - 1], type2: \"none\", lineType: $$[$0] };\n          break;\n        case 68:\n          this.$ = { type1: \"none\", type2: \"none\", lineType: $$[$0] };\n          break;\n        case 69:\n          this.$ = yy.relationType.AGGREGATION;\n          break;\n        case 70:\n          this.$ = yy.relationType.EXTENSION;\n          break;\n        case 71:\n          this.$ = yy.relationType.COMPOSITION;\n          break;\n        case 72:\n          this.$ = yy.relationType.DEPENDENCY;\n          break;\n        case 73:\n          this.$ = yy.relationType.LOLLIPOP;\n          break;\n        case 74:\n          this.$ = yy.lineType.LINE;\n          break;\n        case 75:\n          this.$ = yy.lineType.DOTTED_LINE;\n          break;\n        case 76:\n        case 82:\n          this.$ = $$[$0 - 2];\n          yy.setClickEvent($$[$0 - 1], $$[$0]);\n          break;\n        case 77:\n        case 83:\n          this.$ = $$[$0 - 3];\n          yy.setClickEvent($$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 2], $$[$0]);\n          break;\n        case 78:\n          this.$ = $$[$0 - 2];\n          yy.setLink($$[$0 - 1], $$[$0]);\n          break;\n        case 79:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);\n          break;\n        case 80:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 2], $$[$0]);\n          break;\n        case 81:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);\n          yy.setTooltip($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 84:\n          this.$ = $$[$0 - 3];\n          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);\n          break;\n        case 85:\n          this.$ = $$[$0 - 4];\n          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 3], $$[$0]);\n          break;\n        case 86:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0]);\n          break;\n        case 87:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 1], $$[$0]);\n          break;\n        case 88:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 3], $$[$0]);\n          break;\n        case 89:\n          this.$ = $$[$0 - 5];\n          yy.setLink($$[$0 - 4], $$[$0 - 2], $$[$0]);\n          yy.setTooltip($$[$0 - 4], $$[$0 - 1]);\n          break;\n        case 90:\n          this.$ = $$[$0 - 2];\n          yy.setCssStyle($$[$0 - 1], $$[$0]);\n          break;\n        case 91:\n          yy.setCssClass($$[$0 - 1], $$[$0]);\n          break;\n        case 92:\n          this.$ = [$$[$0]];\n          break;\n        case 93:\n          $$[$0 - 2].push($$[$0]);\n          this.$ = $$[$0 - 2];\n          break;\n        case 95:\n          this.$ = $$[$0 - 1] + $$[$0];\n          break;\n      }\n    }, \"anonymous\"),\n    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: [1, 6], 10: 5, 16: 39, 18: 21, 19: 40, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: $V0, 35: $V1, 37: $V2, 38: 22, 42: $V3, 43: 23, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, o($Vp, [2, 5], { 8: [1, 48] }), { 8: [1, 49] }, o($Vq, [2, 18], { 22: [1, 50] }), o($Vq, [2, 20]), o($Vq, [2, 21]), o($Vq, [2, 22]), o($Vq, [2, 23]), o($Vq, [2, 24]), o($Vq, [2, 25]), o($Vq, [2, 26]), o($Vq, [2, 27]), o($Vq, [2, 28]), o($Vq, [2, 29]), { 34: [1, 51] }, { 36: [1, 52] }, o($Vq, [2, 32]), o($Vq, [2, 48], { 51: 53, 64: 56, 65: 57, 13: [1, 54], 22: [1, 55], 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv, 71: $Vw, 72: $Vx }), { 39: [1, 65] }, o($Vy, [2, 39], { 39: [1, 67], 44: [1, 66] }), o($Vq, [2, 50]), o($Vq, [2, 51]), { 16: 68, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 16: 39, 18: 69, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 16: 39, 18: 70, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 16: 39, 18: 71, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 58: [1, 72] }, { 13: [1, 73] }, { 16: 39, 18: 74, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 13: $Vz, 53: 75 }, { 56: 77, 58: [1, 78] }, o($Vq, [2, 61]), o($Vq, [2, 62]), o($Vq, [2, 63]), o($Vq, [2, 64]), o($VA, [2, 12], { 16: 39, 19: 40, 18: 80, 17: [1, 79], 20: [1, 81], 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }), o($VA, [2, 14], { 20: [1, 82] }), { 15: 83, 16: 84, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 16: 39, 18: 85, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VB, [2, 118]), o($VB, [2, 119]), o($VB, [2, 120]), o($VB, [2, 121]), o([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 66, 67, 68, 69, 70, 71, 72, 77, 79], [2, 122]), o($Vp, [2, 6], { 10: 5, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 18: 21, 38: 22, 43: 23, 16: 39, 19: 40, 5: 86, 33: $V0, 35: $V1, 37: $V2, 42: $V3, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }), { 5: 87, 10: 5, 16: 39, 18: 21, 19: 40, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: $V0, 35: $V1, 37: $V2, 38: 22, 42: $V3, 43: 23, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($Vq, [2, 19]), o($Vq, [2, 30]), o($Vq, [2, 31]), { 13: [1, 89], 16: 39, 18: 88, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 51: 90, 64: 56, 65: 57, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv, 71: $Vw, 72: $Vx }, o($Vq, [2, 49]), { 65: 91, 71: $Vw, 72: $Vx }, o($VC, [2, 68], { 64: 92, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv }), o($VD, [2, 69]), o($VD, [2, 70]), o($VD, [2, 71]), o($VD, [2, 72]), o($VD, [2, 73]), o($VE, [2, 74]), o($VE, [2, 75]), { 8: [1, 94], 24: 95, 40: 93, 43: 23, 46: $V4 }, { 16: 96, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 45: 97, 49: $VF }, { 48: [1, 99] }, { 13: [1, 100] }, { 13: [1, 101] }, { 77: [1, 102], 79: [1, 103] }, { 22: $VG, 57: 104, 58: $VH, 80: $VI, 82: 105, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, { 58: [1, 116] }, { 13: $Vz, 53: 117 }, o($Vq, [2, 57]), o($Vq, [2, 123]), { 22: $VG, 57: 118, 58: $VH, 59: [1, 119], 80: $VI, 82: 105, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, o($VP, [2, 59]), { 16: 39, 18: 120, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VA, [2, 15]), o($VA, [2, 16]), o($VA, [2, 17]), { 39: [2, 35] }, { 15: 122, 16: 84, 17: [1, 121], 39: [2, 9], 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, o($VQ, [2, 43], { 11: 123, 12: [1, 124] }), o($Vp, [2, 7]), { 9: [1, 125] }, o($VR, [2, 52]), { 16: 39, 18: 126, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 13: [1, 128], 16: 39, 18: 127, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VC, [2, 67], { 64: 129, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv }), o($VC, [2, 66]), { 41: [1, 130] }, { 24: 95, 40: 131, 43: 23, 46: $V4 }, { 8: [1, 132], 41: [2, 36] }, o($Vy, [2, 40], { 39: [1, 133] }), { 41: [1, 134] }, { 41: [2, 46], 45: 135, 49: $VF }, { 16: 39, 18: 136, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($Vq, [2, 76], { 13: [1, 137] }), o($Vq, [2, 78], { 13: [1, 139], 75: [1, 138] }), o($Vq, [2, 82], { 13: [1, 140], 78: [1, 141] }), { 13: [1, 142] }, o($Vq, [2, 90], { 59: $VS }), o($VT, [2, 92], { 83: 144, 22: $VG, 58: $VH, 80: $VI, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }), o($VU, [2, 94]), o($VU, [2, 96]), o($VU, [2, 97]), o($VU, [2, 98]), o($VU, [2, 99]), o($VU, [2, 100]), o($VU, [2, 101]), o($VU, [2, 102]), o($VU, [2, 103]), o($VU, [2, 104]), o($Vq, [2, 91]), o($Vq, [2, 56]), o($Vq, [2, 58], { 59: $VS }), { 58: [1, 145] }, o($VA, [2, 13]), { 15: 146, 16: 84, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 39: [2, 11] }, o($VQ, [2, 44]), { 13: [1, 147] }, { 1: [2, 4] }, o($VR, [2, 54]), o($VR, [2, 53]), { 16: 39, 18: 148, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VC, [2, 65]), o($Vq, [2, 33]), { 41: [1, 149] }, { 24: 95, 40: 150, 41: [2, 37], 43: 23, 46: $V4 }, { 45: 151, 49: $VF }, o($Vy, [2, 41]), { 41: [2, 47] }, o($Vq, [2, 45]), o($Vq, [2, 77]), o($Vq, [2, 79]), o($Vq, [2, 80], { 75: [1, 152] }), o($Vq, [2, 83]), o($Vq, [2, 84], { 13: [1, 153] }), o($Vq, [2, 86], { 13: [1, 155], 75: [1, 154] }), { 22: $VG, 58: $VH, 80: $VI, 82: 156, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, o($VU, [2, 95]), o($VP, [2, 60]), { 39: [2, 10] }, { 14: [1, 157] }, o($VR, [2, 55]), o($Vq, [2, 34]), { 41: [2, 38] }, { 41: [1, 158] }, o($Vq, [2, 81]), o($Vq, [2, 85]), o($Vq, [2, 87]), o($Vq, [2, 88], { 75: [1, 159] }), o($VT, [2, 93], { 83: 144, 22: $VG, 58: $VH, 80: $VI, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }), o($VQ, [2, 8]), o($Vy, [2, 42]), o($Vq, [2, 89])],\n    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 83: [2, 35], 122: [2, 11], 125: [2, 4], 135: [2, 47], 146: [2, 10], 150: [2, 38] },\n    parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    }, \"parseError\"),\n    parse: /* @__PURE__ */ __name(function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n      }\n      __name(popStack, \"popStack\");\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      __name(lex, \"lex\");\n      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n              if (recovering > 0) {\n                recovering--;\n              }\n            } else {\n              symbol = preErrorSymbol;\n              preErrorSymbol = null;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }, \"parse\")\n  };\n  var lexer = /* @__PURE__ */ function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      }, \"parseError\"),\n      // resets the lexer, sets new input\n      setInput: /* @__PURE__ */ __name(function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      }, \"setInput\"),\n      // consumes and returns one char from the input\n      input: /* @__PURE__ */ __name(function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      }, \"input\"),\n      // unshifts one char (or a string) into the input\n      unput: /* @__PURE__ */ __name(function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      }, \"unput\"),\n      // When called from action, caches matched text and appends it on next action\n      more: /* @__PURE__ */ __name(function() {\n        this._more = true;\n        return this;\n      }, \"more\"),\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: /* @__PURE__ */ __name(function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      }, \"reject\"),\n      // retain first n characters of the match\n      less: /* @__PURE__ */ __name(function(n) {\n        this.unput(this.match.slice(n));\n      }, \"less\"),\n      // displays already matched input, i.e. for error messages\n      pastInput: /* @__PURE__ */ __name(function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      }, \"pastInput\"),\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: /* @__PURE__ */ __name(function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      }, \"upcomingInput\"),\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: /* @__PURE__ */ __name(function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      }, \"showPosition\"),\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      }, \"test_match\"),\n      // return next match in input\n      next: /* @__PURE__ */ __name(function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      }, \"next\"),\n      // return next match that has a token\n      lex: /* @__PURE__ */ __name(function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      }, \"lex\"),\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: /* @__PURE__ */ __name(function begin(condition) {\n        this.conditionStack.push(condition);\n      }, \"begin\"),\n      // pop the previously active lexer condition state off the condition stack\n      popState: /* @__PURE__ */ __name(function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      }, \"popState\"),\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: /* @__PURE__ */ __name(function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      }, \"_currentRules\"),\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: /* @__PURE__ */ __name(function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      }, \"topState\"),\n      // alias for begin(condition)\n      pushState: /* @__PURE__ */ __name(function pushState(condition) {\n        this.begin(condition);\n      }, \"pushState\"),\n      // return the number of states currently on the stack\n      stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {\n        return this.conditionStack.length;\n      }, \"stateStackSize\"),\n      options: {},\n      performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        var YYSTATE = YY_START;\n        switch ($avoiding_name_collisions) {\n          case 0:\n            return 60;\n            break;\n          case 1:\n            return 61;\n            break;\n          case 2:\n            return 62;\n            break;\n          case 3:\n            return 63;\n            break;\n          case 4:\n            break;\n          case 5:\n            break;\n          case 6:\n            this.begin(\"acc_title\");\n            return 33;\n            break;\n          case 7:\n            this.popState();\n            return \"acc_title_value\";\n            break;\n          case 8:\n            this.begin(\"acc_descr\");\n            return 35;\n            break;\n          case 9:\n            this.popState();\n            return \"acc_descr_value\";\n            break;\n          case 10:\n            this.begin(\"acc_descr_multiline\");\n            break;\n          case 11:\n            this.popState();\n            break;\n          case 12:\n            return \"acc_descr_multiline_value\";\n            break;\n          case 13:\n            return 8;\n            break;\n          case 14:\n            break;\n          case 15:\n            return 7;\n            break;\n          case 16:\n            return 7;\n            break;\n          case 17:\n            return \"EDGE_STATE\";\n            break;\n          case 18:\n            this.begin(\"callback_name\");\n            break;\n          case 19:\n            this.popState();\n            break;\n          case 20:\n            this.popState();\n            this.begin(\"callback_args\");\n            break;\n          case 21:\n            return 77;\n            break;\n          case 22:\n            this.popState();\n            break;\n          case 23:\n            return 78;\n            break;\n          case 24:\n            this.popState();\n            break;\n          case 25:\n            return \"STR\";\n            break;\n          case 26:\n            this.begin(\"string\");\n            break;\n          case 27:\n            return 80;\n            break;\n          case 28:\n            return 55;\n            break;\n          case 29:\n            this.begin(\"namespace\");\n            return 42;\n            break;\n          case 30:\n            this.popState();\n            return 8;\n            break;\n          case 31:\n            break;\n          case 32:\n            this.begin(\"namespace-body\");\n            return 39;\n            break;\n          case 33:\n            this.popState();\n            return 41;\n            break;\n          case 34:\n            return \"EOF_IN_STRUCT\";\n            break;\n          case 35:\n            return 8;\n            break;\n          case 36:\n            break;\n          case 37:\n            return \"EDGE_STATE\";\n            break;\n          case 38:\n            this.begin(\"class\");\n            return 46;\n            break;\n          case 39:\n            this.popState();\n            return 8;\n            break;\n          case 40:\n            break;\n          case 41:\n            this.popState();\n            this.popState();\n            return 41;\n            break;\n          case 42:\n            this.begin(\"class-body\");\n            return 39;\n            break;\n          case 43:\n            this.popState();\n            return 41;\n            break;\n          case 44:\n            return \"EOF_IN_STRUCT\";\n            break;\n          case 45:\n            return \"EDGE_STATE\";\n            break;\n          case 46:\n            return \"OPEN_IN_STRUCT\";\n            break;\n          case 47:\n            break;\n          case 48:\n            return \"MEMBER\";\n            break;\n          case 49:\n            return 81;\n            break;\n          case 50:\n            return 73;\n            break;\n          case 51:\n            return 74;\n            break;\n          case 52:\n            return 76;\n            break;\n          case 53:\n            return 52;\n            break;\n          case 54:\n            return 54;\n            break;\n          case 55:\n            return 47;\n            break;\n          case 56:\n            return 48;\n            break;\n          case 57:\n            return 79;\n            break;\n          case 58:\n            this.popState();\n            break;\n          case 59:\n            return \"GENERICTYPE\";\n            break;\n          case 60:\n            this.begin(\"generic\");\n            break;\n          case 61:\n            this.popState();\n            break;\n          case 62:\n            return \"BQUOTE_STR\";\n            break;\n          case 63:\n            this.begin(\"bqstring\");\n            break;\n          case 64:\n            return 75;\n            break;\n          case 65:\n            return 75;\n            break;\n          case 66:\n            return 75;\n            break;\n          case 67:\n            return 75;\n            break;\n          case 68:\n            return 67;\n            break;\n          case 69:\n            return 67;\n            break;\n          case 70:\n            return 69;\n            break;\n          case 71:\n            return 69;\n            break;\n          case 72:\n            return 68;\n            break;\n          case 73:\n            return 66;\n            break;\n          case 74:\n            return 70;\n            break;\n          case 75:\n            return 71;\n            break;\n          case 76:\n            return 72;\n            break;\n          case 77:\n            return 22;\n            break;\n          case 78:\n            return 44;\n            break;\n          case 79:\n            return 99;\n            break;\n          case 80:\n            return 17;\n            break;\n          case 81:\n            return \"PLUS\";\n            break;\n          case 82:\n            return 85;\n            break;\n          case 83:\n            return 59;\n            break;\n          case 84:\n            return 88;\n            break;\n          case 85:\n            return 88;\n            break;\n          case 86:\n            return 89;\n            break;\n          case 87:\n            return \"EQUALS\";\n            break;\n          case 88:\n            return \"EQUALS\";\n            break;\n          case 89:\n            return 58;\n            break;\n          case 90:\n            return 12;\n            break;\n          case 91:\n            return 14;\n            break;\n          case 92:\n            return \"PUNCTUATION\";\n            break;\n          case 93:\n            return 84;\n            break;\n          case 94:\n            return 101;\n            break;\n          case 95:\n            return 87;\n            break;\n          case 96:\n            return 87;\n            break;\n          case 97:\n            return 9;\n            break;\n        }\n      }, \"anonymous\"),\n      rules: [/^(?:.*direction\\s+TB[^\\n]*)/, /^(?:.*direction\\s+BT[^\\n]*)/, /^(?:.*direction\\s+RL[^\\n]*)/, /^(?:.*direction\\s+LR[^\\n]*)/, /^(?:%%(?!\\{)*[^\\n]*(\\r?\\n?)+)/, /^(?:%%[^\\n]*(\\r?\\n)*)/, /^(?:accTitle\\s*:\\s*)/, /^(?:(?!\\n||)*[^\\n]*)/, /^(?:accDescr\\s*:\\s*)/, /^(?:(?!\\n||)*[^\\n]*)/, /^(?:accDescr\\s*\\{\\s*)/, /^(?:[\\}])/, /^(?:[^\\}]*)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:classDiagram-v2\\b)/, /^(?:classDiagram\\b)/, /^(?:\\[\\*\\])/, /^(?:call[\\s]+)/, /^(?:\\([\\s]*\\))/, /^(?:\\()/, /^(?:[^(]*)/, /^(?:\\))/, /^(?:[^)]*)/, /^(?:[\"])/, /^(?:[^\"]*)/, /^(?:[\"])/, /^(?:style\\b)/, /^(?:classDef\\b)/, /^(?:namespace\\b)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:\\[\\*\\])/, /^(?:class\\b)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:[}])/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\\[\\*\\])/, /^(?:[{])/, /^(?:[\\n])/, /^(?:[^{}\\n]*)/, /^(?:cssClass\\b)/, /^(?:callback\\b)/, /^(?:link\\b)/, /^(?:click\\b)/, /^(?:note for\\b)/, /^(?:note\\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:href\\b)/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:~)/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:[`])/, /^(?:_self\\b)/, /^(?:_blank\\b)/, /^(?:_parent\\b)/, /^(?:_top\\b)/, /^(?:\\s*<\\|)/, /^(?:\\s*\\|>)/, /^(?:\\s*>)/, /^(?:\\s*<)/, /^(?:\\s*\\*)/, /^(?:\\s*o\\b)/, /^(?:\\s*\\(\\))/, /^(?:--)/, /^(?:\\.\\.)/, /^(?::{1}[^:\\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\\.)/, /^(?:\\+)/, /^(?::)/, /^(?:,)/, /^(?:#)/, /^(?:#)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\\w+)/, /^(?:\\[)/, /^(?:\\])/, /^(?:[!\"#$%&'*+,-.`?\\\\/])/, /^(?:[0-9]+)/, /^(?:[\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6]|[\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377]|[\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5]|[\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA]|[\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE]|[\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA]|[\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0]|[\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977]|[\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2]|[\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A]|[\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39]|[\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8]|[\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C]|[\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C]|[\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99]|[\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0]|[\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D]|[\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3]|[\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10]|[\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1]|[\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81]|[\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3]|[\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6]|[\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A]|[\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081]|[\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D]|[\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0]|[\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310]|[\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C]|[\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711]|[\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7]|[\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C]|[\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16]|[\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF]|[\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC]|[\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D]|[\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D]|[\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3]|[\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F]|[\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128]|[\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184]|[\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3]|[\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6]|[\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE]|[\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C]|[\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D]|[\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC]|[\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B]|[\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788]|[\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805]|[\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB]|[\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28]|[\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5]|[\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4]|[\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E]|[\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D]|[\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36]|[\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D]|[\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC]|[\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF]|[\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC])/, /^(?:\\s)/, /^(?:\\s)/, /^(?:$)/],\n      conditions: { \"namespace-body\": { \"rules\": [26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"namespace\": { \"rules\": [26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"class-body\": { \"rules\": [26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"class\": { \"rules\": [26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_descr_multiline\": { \"rules\": [11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_descr\": { \"rules\": [9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_title\": { \"rules\": [7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"callback_args\": { \"rules\": [22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"callback_name\": { \"rules\": [19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"href\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"struct\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"generic\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"bqstring\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"string\": { \"rules\": [24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  __name(Parser, \"Parser\");\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nvar classDiagram_default = parser;\n\n// src/diagrams/class/classDb.ts\nimport { select } from \"d3\";\n\n// src/diagrams/class/classTypes.ts\nvar visibilityValues = [\"#\", \"+\", \"~\", \"-\", \"\"];\nvar ClassMember = class {\n  static {\n    __name(this, \"ClassMember\");\n  }\n  constructor(input, memberType) {\n    this.memberType = memberType;\n    this.visibility = \"\";\n    this.classifier = \"\";\n    this.text = \"\";\n    const sanitizedInput = sanitizeText(input, getConfig());\n    this.parseMember(sanitizedInput);\n  }\n  getDisplayDetails() {\n    let displayText = this.visibility + parseGenericTypes(this.id);\n    if (this.memberType === \"method\") {\n      displayText += `(${parseGenericTypes(this.parameters.trim())})`;\n      if (this.returnType) {\n        displayText += \" : \" + parseGenericTypes(this.returnType);\n      }\n    }\n    displayText = displayText.trim();\n    const cssStyle = this.parseClassifier();\n    return {\n      displayText,\n      cssStyle\n    };\n  }\n  parseMember(input) {\n    let potentialClassifier = \"\";\n    if (this.memberType === \"method\") {\n      const methodRegEx = /([#+~-])?(.+)\\((.*)\\)([\\s$*])?(.*)([$*])?/;\n      const match = methodRegEx.exec(input);\n      if (match) {\n        const detectedVisibility = match[1] ? match[1].trim() : \"\";\n        if (visibilityValues.includes(detectedVisibility)) {\n          this.visibility = detectedVisibility;\n        }\n        this.id = match[2];\n        this.parameters = match[3] ? match[3].trim() : \"\";\n        potentialClassifier = match[4] ? match[4].trim() : \"\";\n        this.returnType = match[5] ? match[5].trim() : \"\";\n        if (potentialClassifier === \"\") {\n          const lastChar = this.returnType.substring(this.returnType.length - 1);\n          if (/[$*]/.exec(lastChar)) {\n            potentialClassifier = lastChar;\n            this.returnType = this.returnType.substring(0, this.returnType.length - 1);\n          }\n        }\n      }\n    } else {\n      const length = input.length;\n      const firstChar = input.substring(0, 1);\n      const lastChar = input.substring(length - 1);\n      if (visibilityValues.includes(firstChar)) {\n        this.visibility = firstChar;\n      }\n      if (/[$*]/.exec(lastChar)) {\n        potentialClassifier = lastChar;\n      }\n      this.id = input.substring(\n        this.visibility === \"\" ? 0 : 1,\n        potentialClassifier === \"\" ? length : length - 1\n      );\n    }\n    this.classifier = potentialClassifier;\n    this.id = this.id.startsWith(\" \") ? \" \" + this.id.trim() : this.id.trim();\n    const combinedText = `${this.visibility ? \"\\\\\" + this.visibility : \"\"}${parseGenericTypes(this.id)}${this.memberType === \"method\" ? `(${parseGenericTypes(this.parameters)})${this.returnType ? \" : \" + parseGenericTypes(this.returnType) : \"\"}` : \"\"}`;\n    this.text = combinedText.replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\n    if (this.text.startsWith(\"\\\\&lt;\")) {\n      this.text = this.text.replace(\"\\\\&lt;\", \"~\");\n    }\n  }\n  parseClassifier() {\n    switch (this.classifier) {\n      case \"*\":\n        return \"font-style:italic;\";\n      case \"$\":\n        return \"text-decoration:underline;\";\n      default:\n        return \"\";\n    }\n  }\n};\n\n// src/diagrams/class/classDb.ts\nvar MERMAID_DOM_ID_PREFIX = \"classId-\";\nvar classCounter = 0;\nvar sanitizeText2 = /* @__PURE__ */ __name((txt) => common_default.sanitizeText(txt, getConfig()), \"sanitizeText\");\nvar ClassDB = class {\n  constructor() {\n    this.relations = [];\n    this.classes = /* @__PURE__ */ new Map();\n    this.styleClasses = /* @__PURE__ */ new Map();\n    this.notes = [];\n    this.interfaces = [];\n    // private static classCounter = 0;\n    this.namespaces = /* @__PURE__ */ new Map();\n    this.namespaceCounter = 0;\n    this.functions = [];\n    this.lineType = {\n      LINE: 0,\n      DOTTED_LINE: 1\n    };\n    this.relationType = {\n      AGGREGATION: 0,\n      EXTENSION: 1,\n      COMPOSITION: 2,\n      DEPENDENCY: 3,\n      LOLLIPOP: 4\n    };\n    this.setupToolTips = /* @__PURE__ */ __name((element) => {\n      let tooltipElem = select(\".mermaidTooltip\");\n      if ((tooltipElem._groups || tooltipElem)[0][0] === null) {\n        tooltipElem = select(\"body\").append(\"div\").attr(\"class\", \"mermaidTooltip\").style(\"opacity\", 0);\n      }\n      const svg = select(element).select(\"svg\");\n      const nodes = svg.selectAll(\"g.node\");\n      nodes.on(\"mouseover\", (event) => {\n        const el = select(event.currentTarget);\n        const title = el.attr(\"title\");\n        if (title === null) {\n          return;\n        }\n        const rect = this.getBoundingClientRect();\n        tooltipElem.transition().duration(200).style(\"opacity\", \".9\");\n        tooltipElem.text(el.attr(\"title\")).style(\"left\", window.scrollX + rect.left + (rect.right - rect.left) / 2 + \"px\").style(\"top\", window.scrollY + rect.top - 14 + document.body.scrollTop + \"px\");\n        tooltipElem.html(tooltipElem.html().replace(/&lt;br\\/&gt;/g, \"<br/>\"));\n        el.classed(\"hover\", true);\n      }).on(\"mouseout\", (event) => {\n        tooltipElem.transition().duration(500).style(\"opacity\", 0);\n        const el = select(event.currentTarget);\n        el.classed(\"hover\", false);\n      });\n    }, \"setupToolTips\");\n    this.direction = \"TB\";\n    this.setAccTitle = setAccTitle;\n    this.getAccTitle = getAccTitle;\n    this.setAccDescription = setAccDescription;\n    this.getAccDescription = getAccDescription;\n    this.setDiagramTitle = setDiagramTitle;\n    this.getDiagramTitle = getDiagramTitle;\n    this.getConfig = /* @__PURE__ */ __name(() => getConfig().class, \"getConfig\");\n    this.functions.push(this.setupToolTips.bind(this));\n    this.clear();\n    this.addRelation = this.addRelation.bind(this);\n    this.addClassesToNamespace = this.addClassesToNamespace.bind(this);\n    this.addNamespace = this.addNamespace.bind(this);\n    this.setCssClass = this.setCssClass.bind(this);\n    this.addMembers = this.addMembers.bind(this);\n    this.addClass = this.addClass.bind(this);\n    this.setClassLabel = this.setClassLabel.bind(this);\n    this.addAnnotation = this.addAnnotation.bind(this);\n    this.addMember = this.addMember.bind(this);\n    this.cleanupLabel = this.cleanupLabel.bind(this);\n    this.addNote = this.addNote.bind(this);\n    this.defineClass = this.defineClass.bind(this);\n    this.setDirection = this.setDirection.bind(this);\n    this.setLink = this.setLink.bind(this);\n    this.bindFunctions = this.bindFunctions.bind(this);\n    this.clear = this.clear.bind(this);\n    this.setTooltip = this.setTooltip.bind(this);\n    this.setClickEvent = this.setClickEvent.bind(this);\n    this.setCssStyle = this.setCssStyle.bind(this);\n  }\n  static {\n    __name(this, \"ClassDB\");\n  }\n  splitClassNameAndType(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    let genericType = \"\";\n    let className = id;\n    if (id.indexOf(\"~\") > 0) {\n      const split = id.split(\"~\");\n      className = sanitizeText2(split[0]);\n      genericType = sanitizeText2(split[1]);\n    }\n    return { className, type: genericType };\n  }\n  setClassLabel(_id, label) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    if (label) {\n      label = sanitizeText2(label);\n    }\n    const { className } = this.splitClassNameAndType(id);\n    this.classes.get(className).label = label;\n    this.classes.get(className).text = `${label}${this.classes.get(className).type ? `<${this.classes.get(className).type}>` : \"\"}`;\n  }\n  /**\n   * Function called by parser when a node definition has been found.\n   *\n   * @param id - Id of the class to add\n   * @public\n   */\n  addClass(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    const { className, type } = this.splitClassNameAndType(id);\n    if (this.classes.has(className)) {\n      return;\n    }\n    const name = common_default.sanitizeText(className, getConfig());\n    this.classes.set(name, {\n      id: name,\n      type,\n      label: name,\n      text: `${name}${type ? `&lt;${type}&gt;` : \"\"}`,\n      shape: \"classBox\",\n      cssClasses: \"default\",\n      methods: [],\n      members: [],\n      annotations: [],\n      styles: [],\n      domId: MERMAID_DOM_ID_PREFIX + name + \"-\" + classCounter\n    });\n    classCounter++;\n  }\n  addInterface(label, classId) {\n    const classInterface = {\n      id: `interface${this.interfaces.length}`,\n      label,\n      classId\n    };\n    this.interfaces.push(classInterface);\n  }\n  /**\n   * Function to lookup domId from id in the graph definition.\n   *\n   * @param id - class ID to lookup\n   * @public\n   */\n  lookUpDomId(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    if (this.classes.has(id)) {\n      return this.classes.get(id).domId;\n    }\n    throw new Error(\"Class not found: \" + id);\n  }\n  clear() {\n    this.relations = [];\n    this.classes = /* @__PURE__ */ new Map();\n    this.notes = [];\n    this.interfaces = [];\n    this.functions = [];\n    this.functions.push(this.setupToolTips.bind(this));\n    this.namespaces = /* @__PURE__ */ new Map();\n    this.namespaceCounter = 0;\n    this.direction = \"TB\";\n    clear();\n  }\n  getClass(id) {\n    return this.classes.get(id);\n  }\n  getClasses() {\n    return this.classes;\n  }\n  getRelations() {\n    return this.relations;\n  }\n  getNotes() {\n    return this.notes;\n  }\n  addRelation(classRelation) {\n    log.debug(\"Adding relation: \" + JSON.stringify(classRelation));\n    const invalidTypes = [\n      this.relationType.LOLLIPOP,\n      this.relationType.AGGREGATION,\n      this.relationType.COMPOSITION,\n      this.relationType.DEPENDENCY,\n      this.relationType.EXTENSION\n    ];\n    if (classRelation.relation.type1 === this.relationType.LOLLIPOP && !invalidTypes.includes(classRelation.relation.type2)) {\n      this.addClass(classRelation.id2);\n      this.addInterface(classRelation.id1, classRelation.id2);\n      classRelation.id1 = `interface${this.interfaces.length - 1}`;\n    } else if (classRelation.relation.type2 === this.relationType.LOLLIPOP && !invalidTypes.includes(classRelation.relation.type1)) {\n      this.addClass(classRelation.id1);\n      this.addInterface(classRelation.id2, classRelation.id1);\n      classRelation.id2 = `interface${this.interfaces.length - 1}`;\n    } else {\n      this.addClass(classRelation.id1);\n      this.addClass(classRelation.id2);\n    }\n    classRelation.id1 = this.splitClassNameAndType(classRelation.id1).className;\n    classRelation.id2 = this.splitClassNameAndType(classRelation.id2).className;\n    classRelation.relationTitle1 = common_default.sanitizeText(\n      classRelation.relationTitle1.trim(),\n      getConfig()\n    );\n    classRelation.relationTitle2 = common_default.sanitizeText(\n      classRelation.relationTitle2.trim(),\n      getConfig()\n    );\n    this.relations.push(classRelation);\n  }\n  /**\n   * Adds an annotation to the specified class Annotations mark special properties of the given type\n   * (like 'interface' or 'service')\n   *\n   * @param className - The class name\n   * @param annotation - The name of the annotation without any brackets\n   * @public\n   */\n  addAnnotation(className, annotation) {\n    const validatedClassName = this.splitClassNameAndType(className).className;\n    this.classes.get(validatedClassName).annotations.push(annotation);\n  }\n  /**\n   * Adds a member to the specified class\n   *\n   * @param className - The class name\n   * @param member - The full name of the member. If the member is enclosed in `<<brackets>>` it is\n   *   treated as an annotation If the member is ending with a closing bracket ) it is treated as a\n   *   method Otherwise the member will be treated as a normal property\n   * @public\n   */\n  addMember(className, member) {\n    this.addClass(className);\n    const validatedClassName = this.splitClassNameAndType(className).className;\n    const theClass = this.classes.get(validatedClassName);\n    if (typeof member === \"string\") {\n      const memberString = member.trim();\n      if (memberString.startsWith(\"<<\") && memberString.endsWith(\">>\")) {\n        theClass.annotations.push(sanitizeText2(memberString.substring(2, memberString.length - 2)));\n      } else if (memberString.indexOf(\")\") > 0) {\n        theClass.methods.push(new ClassMember(memberString, \"method\"));\n      } else if (memberString) {\n        theClass.members.push(new ClassMember(memberString, \"attribute\"));\n      }\n    }\n  }\n  addMembers(className, members) {\n    if (Array.isArray(members)) {\n      members.reverse();\n      members.forEach((member) => this.addMember(className, member));\n    }\n  }\n  addNote(text, className) {\n    const note = {\n      id: `note${this.notes.length}`,\n      class: className,\n      text\n    };\n    this.notes.push(note);\n  }\n  cleanupLabel(label) {\n    if (label.startsWith(\":\")) {\n      label = label.substring(1);\n    }\n    return sanitizeText2(label.trim());\n  }\n  /**\n   * Called by parser when assigning cssClass to a class\n   *\n   * @param ids - Comma separated list of ids\n   * @param className - Class to add\n   */\n  setCssClass(ids, className) {\n    ids.split(\",\").forEach((_id) => {\n      let id = _id;\n      if (/\\d/.exec(_id[0])) {\n        id = MERMAID_DOM_ID_PREFIX + id;\n      }\n      const classNode = this.classes.get(id);\n      if (classNode) {\n        classNode.cssClasses += \" \" + className;\n      }\n    });\n  }\n  defineClass(ids, style) {\n    for (const id of ids) {\n      let styleClass = this.styleClasses.get(id);\n      if (styleClass === void 0) {\n        styleClass = { id, styles: [], textStyles: [] };\n        this.styleClasses.set(id, styleClass);\n      }\n      if (style) {\n        style.forEach((s) => {\n          if (/color/.exec(s)) {\n            const newStyle = s.replace(\"fill\", \"bgFill\");\n            styleClass.textStyles.push(newStyle);\n          }\n          styleClass.styles.push(s);\n        });\n      }\n      this.classes.forEach((value) => {\n        if (value.cssClasses.includes(id)) {\n          value.styles.push(...style.flatMap((s) => s.split(\",\")));\n        }\n      });\n    }\n  }\n  /**\n   * Called by parser when a tooltip is found, e.g. a clickable element.\n   *\n   * @param ids - Comma separated list of ids\n   * @param tooltip - Tooltip to add\n   */\n  setTooltip(ids, tooltip) {\n    ids.split(\",\").forEach((id) => {\n      if (tooltip !== void 0) {\n        this.classes.get(id).tooltip = sanitizeText2(tooltip);\n      }\n    });\n  }\n  getTooltip(id, namespace) {\n    if (namespace && this.namespaces.has(namespace)) {\n      return this.namespaces.get(namespace).classes.get(id).tooltip;\n    }\n    return this.classes.get(id).tooltip;\n  }\n  /**\n   * Called by parser when a link is found. Adds the URL to the vertex data.\n   *\n   * @param ids - Comma separated list of ids\n   * @param linkStr - URL to create a link for\n   * @param target - Target of the link, _blank by default as originally defined in the svgDraw.js file\n   */\n  setLink(ids, linkStr, target) {\n    const config = getConfig();\n    ids.split(\",\").forEach((_id) => {\n      let id = _id;\n      if (/\\d/.exec(_id[0])) {\n        id = MERMAID_DOM_ID_PREFIX + id;\n      }\n      const theClass = this.classes.get(id);\n      if (theClass) {\n        theClass.link = utils_default.formatUrl(linkStr, config);\n        if (config.securityLevel === \"sandbox\") {\n          theClass.linkTarget = \"_top\";\n        } else if (typeof target === \"string\") {\n          theClass.linkTarget = sanitizeText2(target);\n        } else {\n          theClass.linkTarget = \"_blank\";\n        }\n      }\n    });\n    this.setCssClass(ids, \"clickable\");\n  }\n  /**\n   * Called by parser when a click definition is found. Registers an event handler.\n   *\n   * @param ids - Comma separated list of ids\n   * @param functionName - Function to be called on click\n   * @param functionArgs - Function args the function should be called with\n   */\n  setClickEvent(ids, functionName, functionArgs) {\n    ids.split(\",\").forEach((id) => {\n      this.setClickFunc(id, functionName, functionArgs);\n      this.classes.get(id).haveCallback = true;\n    });\n    this.setCssClass(ids, \"clickable\");\n  }\n  setClickFunc(_domId, functionName, functionArgs) {\n    const domId = common_default.sanitizeText(_domId, getConfig());\n    const config = getConfig();\n    if (config.securityLevel !== \"loose\") {\n      return;\n    }\n    if (functionName === void 0) {\n      return;\n    }\n    const id = domId;\n    if (this.classes.has(id)) {\n      const elemId = this.lookUpDomId(id);\n      let argList = [];\n      if (typeof functionArgs === \"string\") {\n        argList = functionArgs.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/);\n        for (let i = 0; i < argList.length; i++) {\n          let item = argList[i].trim();\n          if (item.startsWith('\"') && item.endsWith('\"')) {\n            item = item.substr(1, item.length - 2);\n          }\n          argList[i] = item;\n        }\n      }\n      if (argList.length === 0) {\n        argList.push(elemId);\n      }\n      this.functions.push(() => {\n        const elem = document.querySelector(`[id=\"${elemId}\"]`);\n        if (elem !== null) {\n          elem.addEventListener(\n            \"click\",\n            () => {\n              utils_default.runFunc(functionName, ...argList);\n            },\n            false\n          );\n        }\n      });\n    }\n  }\n  bindFunctions(element) {\n    this.functions.forEach((fun) => {\n      fun(element);\n    });\n  }\n  getDirection() {\n    return this.direction;\n  }\n  setDirection(dir) {\n    this.direction = dir;\n  }\n  /**\n   * Function called by parser when a namespace definition has been found.\n   *\n   * @param id - Id of the namespace to add\n   * @public\n   */\n  addNamespace(id) {\n    if (this.namespaces.has(id)) {\n      return;\n    }\n    this.namespaces.set(id, {\n      id,\n      classes: /* @__PURE__ */ new Map(),\n      children: {},\n      domId: MERMAID_DOM_ID_PREFIX + id + \"-\" + this.namespaceCounter\n    });\n    this.namespaceCounter++;\n  }\n  getNamespace(name) {\n    return this.namespaces.get(name);\n  }\n  getNamespaces() {\n    return this.namespaces;\n  }\n  /**\n   * Function called by parser when a namespace definition has been found.\n   *\n   * @param id - Id of the namespace to add\n   * @param classNames - Ids of the class to add\n   * @public\n   */\n  addClassesToNamespace(id, classNames) {\n    if (!this.namespaces.has(id)) {\n      return;\n    }\n    for (const name of classNames) {\n      const { className } = this.splitClassNameAndType(name);\n      this.classes.get(className).parent = id;\n      this.namespaces.get(id).classes.set(className, this.classes.get(className));\n    }\n  }\n  setCssStyle(id, styles) {\n    const thisClass = this.classes.get(id);\n    if (!styles || !thisClass) {\n      return;\n    }\n    for (const s of styles) {\n      if (s.includes(\",\")) {\n        thisClass.styles.push(...s.split(\",\"));\n      } else {\n        thisClass.styles.push(s);\n      }\n    }\n  }\n  /**\n   * Gets the arrow marker for a type index\n   *\n   * @param type - The type to look for\n   * @returns The arrow marker\n   */\n  getArrowMarker(type) {\n    let marker;\n    switch (type) {\n      case 0:\n        marker = \"aggregation\";\n        break;\n      case 1:\n        marker = \"extension\";\n        break;\n      case 2:\n        marker = \"composition\";\n        break;\n      case 3:\n        marker = \"dependency\";\n        break;\n      case 4:\n        marker = \"lollipop\";\n        break;\n      default:\n        marker = \"none\";\n    }\n    return marker;\n  }\n  getData() {\n    const nodes = [];\n    const edges = [];\n    const config = getConfig();\n    for (const namespaceKey of this.namespaces.keys()) {\n      const namespace = this.namespaces.get(namespaceKey);\n      if (namespace) {\n        const node = {\n          id: namespace.id,\n          label: namespace.id,\n          isGroup: true,\n          padding: config.class.padding ?? 16,\n          // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]\n          shape: \"rect\",\n          cssStyles: [\"fill: none\", \"stroke: black\"],\n          look: config.look\n        };\n        nodes.push(node);\n      }\n    }\n    for (const classKey of this.classes.keys()) {\n      const classNode = this.classes.get(classKey);\n      if (classNode) {\n        const node = classNode;\n        node.parentId = classNode.parent;\n        node.look = config.look;\n        nodes.push(node);\n      }\n    }\n    let cnt = 0;\n    for (const note of this.notes) {\n      cnt++;\n      const noteNode = {\n        id: note.id,\n        label: note.text,\n        isGroup: false,\n        shape: \"note\",\n        padding: config.class.padding ?? 6,\n        cssStyles: [\n          \"text-align: left\",\n          \"white-space: nowrap\",\n          `fill: ${config.themeVariables.noteBkgColor}`,\n          `stroke: ${config.themeVariables.noteBorderColor}`\n        ],\n        look: config.look\n      };\n      nodes.push(noteNode);\n      const noteClassId = this.classes.get(note.class)?.id ?? \"\";\n      if (noteClassId) {\n        const edge = {\n          id: `edgeNote${cnt}`,\n          start: note.id,\n          end: noteClassId,\n          type: \"normal\",\n          thickness: \"normal\",\n          classes: \"relation\",\n          arrowTypeStart: \"none\",\n          arrowTypeEnd: \"none\",\n          arrowheadStyle: \"\",\n          labelStyle: [\"\"],\n          style: [\"fill: none\"],\n          pattern: \"dotted\",\n          look: config.look\n        };\n        edges.push(edge);\n      }\n    }\n    for (const _interface of this.interfaces) {\n      const interfaceNode = {\n        id: _interface.id,\n        label: _interface.label,\n        isGroup: false,\n        shape: \"rect\",\n        cssStyles: [\"opacity: 0;\"],\n        look: config.look\n      };\n      nodes.push(interfaceNode);\n    }\n    cnt = 0;\n    for (const classRelation of this.relations) {\n      cnt++;\n      const edge = {\n        id: getEdgeId(classRelation.id1, classRelation.id2, {\n          prefix: \"id\",\n          counter: cnt\n        }),\n        start: classRelation.id1,\n        end: classRelation.id2,\n        type: \"normal\",\n        label: classRelation.title,\n        labelpos: \"c\",\n        thickness: \"normal\",\n        classes: \"relation\",\n        arrowTypeStart: this.getArrowMarker(classRelation.relation.type1),\n        arrowTypeEnd: this.getArrowMarker(classRelation.relation.type2),\n        startLabelRight: classRelation.relationTitle1 === \"none\" ? \"\" : classRelation.relationTitle1,\n        endLabelLeft: classRelation.relationTitle2 === \"none\" ? \"\" : classRelation.relationTitle2,\n        arrowheadStyle: \"\",\n        labelStyle: [\"display: inline-block\"],\n        style: classRelation.style || \"\",\n        pattern: classRelation.relation.lineType == 1 ? \"dashed\" : \"solid\",\n        look: config.look\n      };\n      edges.push(edge);\n    }\n    return { nodes, edges, other: {}, config, direction: this.getDirection() };\n  }\n};\n\n// src/diagrams/class/styles.js\nvar getStyles = /* @__PURE__ */ __name((options) => `g.classGroup text {\n  fill: ${options.nodeBorder || options.classText};\n  stroke: none;\n  font-family: ${options.fontFamily};\n  font-size: 10px;\n\n  .title {\n    font-weight: bolder;\n  }\n\n}\n\n.nodeLabel, .edgeLabel {\n  color: ${options.classText};\n}\n.edgeLabel .label rect {\n  fill: ${options.mainBkg};\n}\n.label text {\n  fill: ${options.classText};\n}\n\n.labelBkg {\n  background: ${options.mainBkg};\n}\n.edgeLabel .label span {\n  background: ${options.mainBkg};\n}\n\n.classTitle {\n  font-weight: bolder;\n}\n.node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n\n.divider {\n  stroke: ${options.nodeBorder};\n  stroke-width: 1;\n}\n\ng.clickable {\n  cursor: pointer;\n}\n\ng.classGroup rect {\n  fill: ${options.mainBkg};\n  stroke: ${options.nodeBorder};\n}\n\ng.classGroup line {\n  stroke: ${options.nodeBorder};\n  stroke-width: 1;\n}\n\n.classLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ${options.mainBkg};\n  opacity: 0.5;\n}\n\n.classLabel .label {\n  fill: ${options.nodeBorder};\n  font-size: 10px;\n}\n\n.relation {\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n  fill: none;\n}\n\n.dashed-line{\n  stroke-dasharray: 3;\n}\n\n.dotted-line{\n  stroke-dasharray: 1 2;\n}\n\n#compositionStart, .composition {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#compositionEnd, .composition {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#extensionStart, .extension {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#extensionEnd, .extension {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#aggregationStart, .aggregation {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#aggregationEnd, .aggregation {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#lollipopStart, .lollipop {\n  fill: ${options.mainBkg} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#lollipopEnd, .lollipop {\n  fill: ${options.mainBkg} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n.edgeTerminals {\n  font-size: 11px;\n  line-height: initial;\n}\n\n.classTitleText {\n  text-anchor: middle;\n  font-size: 18px;\n  fill: ${options.textColor};\n}\n`, \"getStyles\");\nvar styles_default = getStyles;\n\n// src/diagrams/class/classRenderer-v3-unified.ts\nvar getDir = /* @__PURE__ */ __name((parsedItem, defaultDir = \"TB\") => {\n  if (!parsedItem.doc) {\n    return defaultDir;\n  }\n  let dir = defaultDir;\n  for (const parsedItemDoc of parsedItem.doc) {\n    if (parsedItemDoc.stmt === \"dir\") {\n      dir = parsedItemDoc.value;\n    }\n  }\n  return dir;\n}, \"getDir\");\nvar getClasses = /* @__PURE__ */ __name(function(text, diagramObj) {\n  return diagramObj.db.getClasses();\n}, \"getClasses\");\nvar draw = /* @__PURE__ */ __name(async function(text, id, _version, diag) {\n  log.info(\"REF0:\");\n  log.info(\"Drawing class diagram (v3)\", id);\n  const { securityLevel, state: conf, layout } = getConfig();\n  const data4Layout = diag.db.getData();\n  const svg = getDiagramElement(id, securityLevel);\n  data4Layout.type = diag.type;\n  data4Layout.layoutAlgorithm = getRegisteredLayoutAlgorithm(layout);\n  data4Layout.nodeSpacing = conf?.nodeSpacing || 50;\n  data4Layout.rankSpacing = conf?.rankSpacing || 50;\n  data4Layout.markers = [\"aggregation\", \"extension\", \"composition\", \"dependency\", \"lollipop\"];\n  data4Layout.diagramId = id;\n  await render(data4Layout, svg);\n  const padding = 8;\n  utils_default.insertTitle(\n    svg,\n    \"classDiagramTitleText\",\n    conf?.titleTopMargin ?? 25,\n    diag.db.getDiagramTitle()\n  );\n  setupViewPortForSVG(svg, padding, \"classDiagram\", conf?.useMaxWidth ?? true);\n}, \"draw\");\nvar classRenderer_v3_unified_default = {\n  getClasses,\n  draw,\n  getDir\n};\n\nexport {\n  classDiagram_default,\n  ClassDB,\n  styles_default,\n  classRenderer_v3_unified_default\n};\n","import baseIteratee from './_baseIteratee.js';\nimport isArrayLike from './isArrayLike.js';\nimport keys from './keys.js';\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nexport default createFind;\n","import baseFindIndex from './_baseFindIndex.js';\nimport baseIteratee from './_baseIteratee.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nexport default findIndex;\n","import createFind from './_createFind.js';\nimport findIndex from './findIndex.js';\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nexport default find;\n","import toString from './toString.js';\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nexport default uniqueId;\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nexport default baseRange;\n","import baseRange from './_baseRange.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toFinite from './toFinite.js';\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nexport default createRange;\n","import createRange from './_createRange.js';\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nexport default range;\n","/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nexport { List };\n\nclass List {\n  constructor() {\n    var sentinel = {};\n    sentinel._next = sentinel._prev = sentinel;\n    this._sentinel = sentinel;\n  }\n  dequeue() {\n    var sentinel = this._sentinel;\n    var entry = sentinel._prev;\n    if (entry !== sentinel) {\n      unlink(entry);\n      return entry;\n    }\n  }\n  enqueue(entry) {\n    var sentinel = this._sentinel;\n    if (entry._prev && entry._next) {\n      unlink(entry);\n    }\n    entry._next = sentinel._next;\n    sentinel._next._prev = entry;\n    sentinel._next = entry;\n    entry._prev = sentinel;\n  }\n  toString() {\n    var strs = [];\n    var sentinel = this._sentinel;\n    var curr = sentinel._prev;\n    while (curr !== sentinel) {\n      strs.push(JSON.stringify(curr, filterOutLinks));\n      curr = curr._prev;\n    }\n    return '[' + strs.join(', ') + ']';\n  }\n}\n\nfunction unlink(entry) {\n  entry._prev._next = entry._next;\n  entry._next._prev = entry._prev;\n  delete entry._next;\n  delete entry._prev;\n}\n\nfunction filterOutLinks(k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v;\n  }\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\nimport { List } from './data/list.js';\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nexport { greedyFAS };\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _.flatten(\n    _.map(results, function (e) {\n      return g.outEdges(e.v, e.w);\n    }),\n  );\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    while ((entry = sources.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry['in'] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, in: 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function (e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, (fasGraph.node(e.v).out += weight));\n    maxIn = Math.max(maxIn, (fasGraph.node(e.w)['in'] += weight));\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function () {\n    return new List();\n  });\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry);\n  }\n}\n","import * as _ from 'lodash-es';\nimport { greedyFAS } from './greedy-fas.js';\n\nexport { run, undo };\n\nfunction run(g) {\n  var fas = g.graph().acyclicer === 'greedy' ? greedyFAS(g, weightFn(g)) : dfsFAS(g);\n  _.forEach(fas, function (e) {\n    var label = g.edge(e);\n    g.removeEdge(e);\n    label.forwardName = e.name;\n    label.reversed = true;\n    g.setEdge(e.w, e.v, label, _.uniqueId('rev'));\n  });\n\n  function weightFn(g) {\n    return function (e) {\n      return g.edge(e).weight;\n    };\n  }\n}\n\nfunction dfsFAS(g) {\n  var fas = [];\n  var stack = {};\n  var visited = {};\n\n  function dfs(v) {\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return;\n    }\n    visited[v] = true;\n    stack[v] = true;\n    _.forEach(g.outEdges(v), function (e) {\n      if (Object.prototype.hasOwnProperty.call(stack, e.w)) {\n        fas.push(e);\n      } else {\n        dfs(e.w);\n      }\n    });\n    delete stack[v];\n  }\n\n  _.forEach(g.nodes(), dfs);\n  return fas;\n}\n\nfunction undo(g) {\n  _.forEach(g.edges(), function (e) {\n    var label = g.edge(e);\n    if (label.reversed) {\n      g.removeEdge(e);\n\n      var forwardName = label.forwardName;\n      delete label.reversed;\n      delete label.forwardName;\n      g.setEdge(e.w, e.v, label, forwardName);\n    }\n  });\n}\n","import basePickBy from './_basePickBy.js';\nimport hasIn from './hasIn.js';\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, paths) {\n  return basePickBy(object, paths, function(value, path) {\n    return hasIn(object, path);\n  });\n}\n\nexport default basePick;\n","import flatten from './flatten.js';\nimport overRest from './_overRest.js';\nimport setToString from './_setToString.js';\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nexport default flatRest;\n","import basePick from './_basePick.js';\nimport flatRest from './_flatRest.js';\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nexport default pick;\n","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nexport default baseGt;\n","import baseExtremum from './_baseExtremum.js';\nimport baseGt from './_baseGt.js';\nimport identity from './identity.js';\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nexport default max;\n","import baseAssignValue from './_baseAssignValue.js';\nimport baseForOwn from './_baseForOwn.js';\nimport baseIteratee from './_baseIteratee.js';\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nexport default mapValues;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\n\nexport {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime,\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function (v) {\n    simplified.setNode(v, g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen),\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function (v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function (v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle');\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = (h * dx) / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = (w * dy) / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function () {\n    return [];\n  });\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.min(\n    _.map(g.nodes(), function (v) {\n      return g.node(v).rank;\n    }),\n  );\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (_.has(node, 'rank')) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.min(\n    _.map(g.nodes(), function (v) {\n      return g.node(v).rank;\n    }),\n  );\n\n  var layers = [];\n  _.forEach(g.nodes(), function (v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function (vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function (v) {\n        g.node(v).rank += delta;\n      });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0,\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, 'border', node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(\n    _.map(g.nodes(), function (v) {\n      var rank = g.node(v).rank;\n      if (!_.isUndefined(rank)) {\n        return rank;\n      }\n    }),\n  );\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + ' time: ' + (_.now() - start) + 'ms');\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n","import * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { addBorderSegments };\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    var children = g.children(v);\n    var node = g.node(v);\n    if (children.length) {\n      _.forEach(children, dfs);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank);\n        addBorderNode(g, 'borderRight', '_br', v, node, rank);\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  var label = { width: 0, height: 0, rank: rank, borderType: prop };\n  var prev = sgNode[prop][rank - 1];\n  var curr = util.addDummyNode(g, 'border', label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n","import * as _ from 'lodash-es';\n\nexport { adjust, undo };\n\nfunction adjust(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g);\n  }\n}\n\nfunction undo(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g);\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g);\n    swapWidthHeight(g);\n  }\n}\n\nfunction swapWidthHeight(g) {\n  _.forEach(g.nodes(), function (v) {\n    swapWidthHeightOne(g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    swapWidthHeightOne(g.edge(e));\n  });\n}\n\nfunction swapWidthHeightOne(attrs) {\n  var w = attrs.width;\n  attrs.width = attrs.height;\n  attrs.height = w;\n}\n\nfunction reverseY(g) {\n  _.forEach(g.nodes(), function (v) {\n    reverseYOne(g.node(v));\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, reverseYOne);\n    if (Object.prototype.hasOwnProperty.call(edge, 'y')) {\n      reverseYOne(edge);\n    }\n  });\n}\n\nfunction reverseYOne(attrs) {\n  attrs.y = -attrs.y;\n}\n\nfunction swapXY(g) {\n  _.forEach(g.nodes(), function (v) {\n    swapXYOne(g.node(v));\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, swapXYOne);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      swapXYOne(edge);\n    }\n  });\n}\n\nfunction swapXYOne(attrs) {\n  var x = attrs.x;\n  attrs.x = attrs.y;\n  attrs.y = x;\n}\n","/**\n * TypeScript type imports:\n *\n * @import { Graph } from '../graphlib/graph.js';\n */\nimport * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { run, undo };\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _.forEach(g.edges(), function (edge) {\n    normalizeEdge(g, edge);\n  });\n}\n\n/**\n * @param {Graph} g\n */\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  /**\n   * @typedef {Object} Attrs\n   * @property {number} width\n   * @property {number} height\n   * @property {ReturnType<Graph[\"node\"]>} edgeLabel\n   * @property {any} edgeObj\n   * @property {ReturnType<Graph[\"node\"]>[\"rank\"]} rank\n   * @property {string} [dummy]\n   * @property {ReturnType<Graph[\"node\"]>[\"labelpos\"]} [labelpos]\n   */\n\n  /** @type {Attrs | undefined} */\n  var attrs = undefined;\n  var dummy, i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank,\n    };\n    dummy = util.addDummyNode(g, 'edge', attrs, '_d');\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = 'edge-label';\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n","import baseExtremum from './_baseExtremum.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseLt from './_baseLt.js';\n\n/**\n * This method is like `_.min` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * // The `_.property` iteratee shorthand.\n * _.minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nfunction minBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)\n    : undefined;\n}\n\nexport default minBy;\n","import * as _ from 'lodash-es';\n\nexport { longestPath, slack };\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(\n      _.map(g.outEdges(v), function (e) {\n        return dfs(e.w) - g.edge(e).minlen;\n      }),\n    );\n\n    if (\n      rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n      rank === undefined || // return value of _.map([]) for Lodash 4\n      rank === null\n    ) {\n      // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport { slack } from './util.js';\n\nexport { feasibleTree };\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree(g) {\n  var t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n\n  var edge, delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree(t, g) {\n  function dfs(v) {\n    _.forEach(g.nodeEdges(v), function (e) {\n      var edgeV = e.v,\n        w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  }\n\n  _.forEach(t.nodes(), dfs);\n  return t.nodeCount();\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge(t, g) {\n  return _.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n  });\n}\n\nfunction shiftRanks(t, g, delta) {\n  _.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta;\n  });\n}\n","import * as _ from 'lodash-es';\nimport { PriorityQueue } from '../data/priority-queue.js';\n\nexport { dijkstra };\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction dijkstra(g, source, weightFn, edgeFn) {\n  return runDijkstra(\n    g,\n    String(source),\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn ||\n      function (v) {\n        return g.outEdges(v);\n      },\n  );\n}\n\nfunction runDijkstra(g, source, weightFn, edgeFn) {\n  var results = {};\n  var pq = new PriorityQueue();\n  var v, vEntry;\n\n  var updateNeighbors = function (edge) {\n    var w = edge.v !== v ? edge.v : edge.w;\n    var wEntry = results[w];\n    var weight = weightFn(edge);\n    var distance = vEntry.distance + weight;\n\n    if (weight < 0) {\n      throw new Error(\n        'dijkstra does not allow negative edge weights. ' +\n          'Bad edge: ' +\n          edge +\n          ' Weight: ' +\n          weight,\n      );\n    }\n\n    if (distance < wEntry.distance) {\n      wEntry.distance = distance;\n      wEntry.predecessor = v;\n      pq.decrease(w, distance);\n    }\n  };\n\n  g.nodes().forEach(function (v) {\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n    results[v] = { distance: distance };\n    pq.add(v, distance);\n  });\n\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    vEntry = results[v];\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\n      break;\n    }\n\n    edgeFn(v).forEach(updateNeighbors);\n  }\n\n  return results;\n}\n","import * as _ from 'lodash-es';\n\nexport { floydWarshall };\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction floydWarshall(g, weightFn, edgeFn) {\n  return runFloydWarshall(\n    g,\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn ||\n      function (v) {\n        return g.outEdges(v);\n      },\n  );\n}\n\nfunction runFloydWarshall(g, weightFn, edgeFn) {\n  var results = {};\n  var nodes = g.nodes();\n\n  nodes.forEach(function (v) {\n    results[v] = {};\n    results[v][v] = { distance: 0 };\n    nodes.forEach(function (w) {\n      if (v !== w) {\n        results[v][w] = { distance: Number.POSITIVE_INFINITY };\n      }\n    });\n    edgeFn(v).forEach(function (edge) {\n      var w = edge.v === v ? edge.w : edge.v;\n      var d = weightFn(edge);\n      results[v][w] = { distance: d, predecessor: v };\n    });\n  });\n\n  nodes.forEach(function (k) {\n    var rowK = results[k];\n    nodes.forEach(function (i) {\n      var rowI = results[i];\n      nodes.forEach(function (j) {\n        var ik = rowI[k];\n        var kj = rowK[j];\n        var ij = rowI[j];\n        var altDistance = ik.distance + kj.distance;\n        if (altDistance < ij.distance) {\n          ij.distance = altDistance;\n          ij.predecessor = kj.predecessor;\n        }\n      });\n    });\n  });\n\n  return results;\n}\n","import baseProperty from './_baseProperty.js';\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = baseProperty('length');\n\nexport default asciiSize;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nexport default hasUnicode;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\n\nexport default unicodeSize;\n","import * as _ from 'lodash-es';\n\nexport { topsort, CycleException };\n\ntopsort.CycleException = CycleException;\n\nfunction topsort(g) {\n  var visited = {};\n  var stack = {};\n  var results = [];\n\n  function visit(node) {\n    if (Object.prototype.hasOwnProperty.call(stack, node)) {\n      throw new CycleException();\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(visited, node)) {\n      stack[node] = true;\n      visited[node] = true;\n      _.each(g.predecessors(node), visit);\n      delete stack[node];\n      results.push(node);\n    }\n  }\n\n  _.each(g.sinks(), visit);\n\n  if (_.size(visited) !== g.nodeCount()) {\n    throw new CycleException();\n  }\n\n  return results;\n}\n\nfunction CycleException() {}\nCycleException.prototype = new Error(); // must be an instance of Error to pass testing\n","import * as _ from 'lodash-es';\n\nexport { dfs };\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nfunction dfs(g, vs, order) {\n  if (!_.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);\n\n  var acc = [];\n  var visited = {};\n  _.each(vs, function (v) {\n    if (!g.hasNode(v)) {\n      throw new Error('Graph does not have node: ' + v);\n    }\n\n    doDfs(g, v, order === 'post', visited, navigation, acc);\n  });\n  return acc;\n}\n\nfunction doDfs(g, v, postorder, visited, navigation, acc) {\n  if (!Object.prototype.hasOwnProperty.call(visited, v)) {\n    visited[v] = true;\n\n    if (!postorder) {\n      acc.push(v);\n    }\n    _.each(navigation(v), function (w) {\n      doDfs(g, w, postorder, visited, navigation, acc);\n    });\n    if (postorder) {\n      acc.push(v);\n    }\n  }\n}\n","import * as _ from 'lodash-es';\nimport * as alg from '../../graphlib/alg/index.js';\nimport { simplify } from '../util.js';\nimport { feasibleTree } from './feasible-tree.js';\nimport { longestPath, slack } from './util.js';\n\nexport { networkSimplex };\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  longestPath(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = alg.postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!Object.prototype.hasOwnProperty.call(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function (edge) {\n    return (\n      flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n      flip !== isDescendant(t, t.node(edge.w), tailLabel)\n    );\n  });\n\n  return _.minBy(candidates, function (edge) {\n    return slack(g, edge);\n  });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n  var vs = alg.preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function (v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n","import { dfs } from './dfs.js';\n\nexport { postorder };\n\nfunction postorder(g, vs) {\n  return dfs(g, vs, 'post');\n}\n","import { dfs } from './dfs.js';\n\nexport { preorder };\n\nfunction preorder(g, vs) {\n  return dfs(g, vs, 'pre');\n}\n","import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\n\nexport { rank };\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n","import * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { run, cleanup };\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = util.addDummyNode(g, 'root', {}, '_root');\n  var depths = treeDepths(g);\n  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function (e) {\n    g.edge(e).minlen *= nodeSep;\n  });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = util.addBorderNode(g, '_bt');\n  var bottom = util.addBorderNode(g, '_bb');\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true,\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true,\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _.forEach(children, function (child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _.forEach(g.children(), function (v) {\n    dfs(v, 1);\n  });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _.reduce(\n    g.edges(),\n    function (acc, e) {\n      return acc + g.edge(e).weight;\n    },\n    0,\n  );\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nexport default cloneDeep;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\n\nexport { buildLayerGraph };\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true })\n      .setGraph({ root: root })\n      .setDefaultNodeLabel(function (v) {\n        return g.node(v);\n      });\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank],\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v;\n}\n","/**\n * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n *\n * @private\n * @param {Array} props The property identifiers.\n * @param {Array} values The property values.\n * @param {Function} assignFunc The function to assign values.\n * @returns {Object} Returns the new object.\n */\nfunction baseZipObject(props, values, assignFunc) {\n  var index = -1,\n      length = props.length,\n      valsLength = values.length,\n      result = {};\n\n  while (++index < length) {\n    var value = index < valsLength ? values[index] : undefined;\n    assignFunc(result, props[index], value);\n  }\n  return result;\n}\n\nexport default baseZipObject;\n","import assignValue from './_assignValue.js';\nimport baseZipObject from './_baseZipObject.js';\n\n/**\n * This method is like `_.fromPairs` except that it accepts two arrays,\n * one of property identifiers and one of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 0.4.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction zipObject(props, values) {\n  return baseZipObject(props || [], values || [], assignValue);\n}\n\nexport default zipObject;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nexport default baseSortBy;\n","import isSymbol from './isSymbol.js';\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nexport default compareAscending;\n","import compareAscending from './_compareAscending.js';\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nexport default compareMultiple;\n","import arrayMap from './_arrayMap.js';\nimport baseGet from './_baseGet.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseMap from './_baseMap.js';\nimport baseSortBy from './_baseSortBy.js';\nimport baseUnary from './_baseUnary.js';\nimport compareMultiple from './_compareMultiple.js';\nimport identity from './identity.js';\nimport isArray from './isArray.js';\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  if (iteratees.length) {\n    iteratees = arrayMap(iteratees, function(iteratee) {\n      if (isArray(iteratee)) {\n        return function(value) {\n          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n        }\n      }\n      return iteratee;\n    });\n  } else {\n    iteratees = [identity];\n  }\n\n  var index = -1;\n  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nexport default baseOrderBy;\n","import baseFlatten from './_baseFlatten.js';\nimport baseOrderBy from './_baseOrderBy.js';\nimport baseRest from './_baseRest.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nexport default sortBy;\n","import * as _ from 'lodash-es';\n\nexport { crossCount };\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(\n    southLayer,\n    _.map(southLayer, function (v, i) {\n      return i;\n    }),\n  );\n  var southEntries = _.flatten(\n    _.map(northLayer, function (v) {\n      return _.sortBy(\n        _.map(g.outEdges(v), function (e) {\n          return { pos: southPos[e.w], weight: g.edge(e).weight };\n        }),\n        'pos',\n      );\n    }),\n  );\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(\n    // @ts-expect-error\n    southEntries.forEach(function (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n      // @ts-expect-error\n      while (index > 0) {\n        // @ts-expect-error\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        // @ts-expect-error\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight * weightSum;\n    }),\n  );\n\n  return cc;\n}\n","import * as _ from 'lodash-es';\n\nexport { resolveConflicts };\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _.forEach(entries, function (entry, i) {\n    var tmp = (mappedEntries[entry.v] = {\n      indegree: 0,\n      in: [],\n      out: [],\n      vs: [entry.v],\n      i: i,\n    });\n    if (!_.isUndefined(entry.barycenter)) {\n      // @ts-expect-error\n      tmp.barycenter = entry.barycenter;\n      // @ts-expect-error\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function (e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function (entry) {\n    // @ts-expect-error\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (\n        _.isUndefined(uEntry.barycenter) ||\n        _.isUndefined(vEntry.barycenter) ||\n        uEntry.barycenter >= vEntry.barycenter\n      ) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _.forEach(entry['in'].reverse(), handleIn(entry));\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(\n    _.filter(entries, function (entry) {\n      return !entry.merged;\n    }),\n    function (entry) {\n      return _.pick(entry, ['vs', 'i', 'barycenter', 'weight']);\n    },\n  );\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n","import * as _ from 'lodash-es';\nimport * as util from '../util.js';\n\nexport { sort };\n\nfunction sort(entries, biasRight) {\n  var parts = util.partition(entries, function (entry) {\n    return Object.prototype.hasOwnProperty.call(entry, 'barycenter');\n  });\n  var sortable = parts.lhs,\n    unsortable = _.sortBy(parts.rhs, function (entry) {\n      return -entry.i;\n    }),\n    vs = [],\n    sum = 0,\n    weight = 0,\n    vsIndex = 0;\n\n  sortable.sort(compareWithBias(!!biasRight));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  var result = { vs: _.flatten(vs) };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n}\n\nfunction consumeUnsortable(vs, unsortable, index) {\n  var last;\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop();\n    vs.push(last.vs);\n    index++;\n  }\n  return index;\n}\n\nfunction compareWithBias(bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n}\n","import * as _ from 'lodash-es';\nimport { barycenter } from './barycenter.js';\nimport { resolveConflicts } from './resolve-conflicts.js';\nimport { sort } from './sort.js';\n\nexport { sortSubgraph };\n\nfunction sortSubgraph(g, v, cg, biasRight) {\n  var movable = g.children(v);\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight : undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = _.filter(movable, function (w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = barycenter(g, movable);\n  _.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (Object.prototype.hasOwnProperty.call(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  var entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  var result = sort(entries, biasRight);\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br]);\n    if (g.predecessors(bl).length) {\n      var blPred = g.node(g.predecessors(bl)[0]),\n        brPred = g.node(g.predecessors(br)[0]);\n      if (!Object.prototype.hasOwnProperty.call(result, 'barycenter')) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter =\n        (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n}\n\nfunction expandSubgraphs(entries, subgraphs) {\n  _.forEach(entries, function (entry) {\n    entry.vs = _.flatten(\n      entry.vs.map(function (v) {\n        if (subgraphs[v]) {\n          return subgraphs[v].vs;\n        }\n        return v;\n      }),\n    );\n  });\n}\n\nfunction mergeBarycenters(target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter =\n      (target.barycenter * target.weight + other.barycenter * other.weight) /\n      (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n}\n","import * as _ from 'lodash-es';\n\nexport { barycenter };\n\nfunction barycenter(g, movable) {\n  return _.map(movable, function (v) {\n    var inV = g.inEdges(v);\n    if (!inV.length) {\n      return { v: v };\n    } else {\n      var result = _.reduce(\n        inV,\n        function (acc, e) {\n          var edge = g.edge(e),\n            nodeU = g.node(e.v);\n          return {\n            sum: acc.sum + edge.weight * nodeU.order,\n            weight: acc.weight + edge.weight,\n          };\n        },\n        { sum: 0, weight: 0 },\n      );\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight,\n      };\n    }\n  });\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\nimport { addSubgraphConstraints } from './add-subgraph-constraints.js';\nimport { buildLayerGraph } from './build-layer-graph.js';\nimport { crossCount } from './cross-count.js';\nimport { initOrder } from './init-order.js';\nimport { sortSubgraph } from './sort-subgraph.js';\n\nexport { order };\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n","import * as _ from 'lodash-es';\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nexport function initOrder(g) {\n  var visited = {};\n  var simpleNodes = _.filter(g.nodes(), function (v) {\n    return !g.children(v).length;\n  });\n  var maxRank = _.max(\n    _.map(simpleNodes, function (v) {\n      return g.node(v).rank;\n    }),\n  );\n  var layers = _.map(_.range(maxRank + 1), function () {\n    return [];\n  });\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    layers[node.rank].push(v);\n    _.forEach(g.successors(v), dfs);\n  }\n\n  var orderedVs = _.sortBy(simpleNodes, function (v) {\n    return g.node(v).rank;\n  });\n  _.forEach(orderedVs, dfs);\n\n  return layers;\n}\n","import * as _ from 'lodash-es';\n\nexport { addSubgraphConstraints };\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {},\n    rootPrev;\n\n  _.forEach(vs, function (v) {\n    var child = g.parent(v),\n      parent,\n      prevChild;\n    while (child) {\n      parent = g.parent(child);\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n      child = parent;\n    }\n  });\n\n  /*\n  function dfs(v) {\n    var children = v ? g.children(v) : g.children();\n    if (children.length) {\n      var min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.each(children, function(child) {\n        var childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n","import * as _ from 'lodash-es';\n\nexport { parentDummyChains };\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (\n          pathIdx < path.length - 1 &&\n          g.node((pathV = path[pathIdx + 1])).minRank <= node.rank\n        ) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n","import baseForOwn from './_baseForOwn.js';\nimport castFunction from './_castFunction.js';\n\n/**\n * Iterates over own enumerable string keyed properties of an object and\n * invokes `iteratee` for each property. The iteratee is invoked with three\n * arguments: (value, key, object). Iteratee functions may exit iteration\n * early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forOwnRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forOwn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forOwn(object, iteratee) {\n  return object && baseForOwn(object, castFunction(iteratee));\n}\n\nexport default forOwn;\n","import baseFor from './_baseFor.js';\nimport castFunction from './_castFunction.js';\nimport keysIn from './keysIn.js';\n\n/**\n * Iterates over own and inherited enumerable string keyed properties of an\n * object and invokes `iteratee` for each property. The iteratee is invoked\n * with three arguments: (value, key, object). Iteratee functions may exit\n * iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forInRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forIn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n */\nfunction forIn(object, iteratee) {\n  return object == null\n    ? object\n    : baseFor(object, castFunction(iteratee), keysIn);\n}\n\nexport default forIn;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\n\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nexport {\n  positionX,\n  findType1Conflicts,\n  findType2Conflicts,\n  addConflict,\n  hasConflict,\n  verticalAlignment,\n  horizontalCompaction,\n  alignCoordinates,\n  findSmallestWidthAlignment,\n  balance,\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function (v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        // @ts-expect-error\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          var uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          // @ts-expect-error\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return !!conflicts[v] && Object.prototype.hasOwnProperty.call(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function (layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function (v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) {\n          return pos[w];\n        });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? 'borderLeft' : 'borderRight';\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function (acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function (layer) {\n    var u;\n    _.forEach(layer, function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) {\n          return x + delta;\n        });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse();\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === 'u' ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r');\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) {\n          return -x;\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (Object.prototype.hasOwnProperty.call(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = -vLabel.width / 2;\n          break;\n        case 'r':\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (Object.prototype.hasOwnProperty.call(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = wLabel.width / 2;\n          break;\n        case 'r':\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n","import * as _ from 'lodash-es';\nimport * as util from '../util.js';\nimport { positionX } from './bk.js';\n\nexport { position };\n\nfunction position(g) {\n  g = util.asNonCompoundGraph(g);\n\n  positionY(g);\n  _.forOwn(positionX(g), function (x, v) {\n    g.node(v).x = x;\n  });\n}\n\nfunction positionY(g) {\n  var layering = util.buildLayerMatrix(g);\n  var rankSep = g.graph().ranksep;\n  var prevY = 0;\n  _.forEach(layering, function (layer) {\n    var maxHeight = _.max(\n      _.map(layer, function (v) {\n        return g.node(v).height;\n      }),\n    );\n    _.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2;\n    });\n    prevY += maxHeight + rankSep;\n  });\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\nimport { addBorderSegments } from './add-border-segments.js';\nimport * as coordinateSystem from './coordinate-system.js';\nimport * as acyclic from './acyclic.js';\nimport * as normalize from './normalize.js';\nimport { rank } from './rank/index.js';\nimport * as nestingGraph from './nesting-graph.js';\nimport { order } from './order/index.js';\nimport { parentDummyChains } from './parent-dummy-chains.js';\nimport { position } from './position/index.js';\nimport * as util from './util.js';\n\nexport { layout };\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time('layout', () => {\n    var layoutGraph = time('  buildLayoutGraph', () => buildLayoutGraph(g));\n    time('  runLayout', () => runLayout(layoutGraph, time));\n    time('  updateInputGraph', () => updateInputGraph(g, layoutGraph));\n  });\n}\n\nfunction runLayout(g, time) {\n  time('    makeSpaceForEdgeLabels', () => makeSpaceForEdgeLabels(g));\n  time('    removeSelfEdges', () => removeSelfEdges(g));\n  time('    acyclic', () => acyclic.run(g));\n  time('    nestingGraph.run', () => nestingGraph.run(g));\n  time('    rank', () => rank(util.asNonCompoundGraph(g)));\n  time('    injectEdgeLabelProxies', () => injectEdgeLabelProxies(g));\n  time('    removeEmptyRanks', () => util.removeEmptyRanks(g));\n  time('    nestingGraph.cleanup', () => nestingGraph.cleanup(g));\n  time('    normalizeRanks', () => util.normalizeRanks(g));\n  time('    assignRankMinMax', () => assignRankMinMax(g));\n  time('    removeEdgeLabelProxies', () => removeEdgeLabelProxies(g));\n  time('    normalize.run', () => normalize.run(g));\n  time('    parentDummyChains', () => parentDummyChains(g));\n  time('    addBorderSegments', () => addBorderSegments(g));\n  time('    order', () => order(g));\n  time('    insertSelfEdges', () => insertSelfEdges(g));\n  time('    adjustCoordinateSystem', () => coordinateSystem.adjust(g));\n  time('    position', () => position(g));\n  time('    positionSelfEdges', () => positionSelfEdges(g));\n  time('    removeBorderNodes', () => removeBorderNodes(g));\n  time('    normalize.undo', () => normalize.undo(g));\n  time('    fixupEdgeLabelCoords', () => fixupEdgeLabelCoords(g));\n  time('    undoCoordinateSystem', () => coordinateSystem.undo(g));\n  time('    translateGraph', () => translateGraph(g));\n  time('    assignNodeIntersects', () => assignNodeIntersects(g));\n  time('    reversePoints', () => reversePointsForReversedEdges(g));\n  time('    acyclic.undo', () => acyclic.undo(g));\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (Object.prototype.hasOwnProperty.call(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' };\nvar graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align'];\nvar nodeNumAttrs = ['width', 'height'];\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset'];\nvar edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r',\n};\nvar edgeAttrs = ['labelpos'];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(\n    _.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _.pick(graph, graphAttrs)),\n  );\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(\n      e,\n      _.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _.pick(edge, edgeAttrs)),\n    );\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, 'edge-proxy', label, '_ep');\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      // @ts-expect-error\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function (v) {\n    getExtremes(g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, function (p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      edge.x -= minX;\n    }\n    if (Object.prototype.hasOwnProperty.call(edge, 'y')) {\n      edge.y -= minY;\n    }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n        case 'l':\n          edge.x -= edge.width / 2 + edge.labeloffset;\n          break;\n        case 'r':\n          edge.x += edge.width / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  _.forEach(layers, function (layer) {\n    var orderShift = 0;\n    _.forEach(layer, function (v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(\n          g,\n          'selfedge',\n          {\n            width: selfEdge.label.width,\n            height: selfEdge.label.height,\n            rank: node.rank,\n            order: i + ++orderShift,\n            e: selfEdge.e,\n            label: selfEdge.label,\n          },\n          '_se',\n        );\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'selfedge') {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + (2 * dx) / 3, y: y - dy },\n        { x: x + (5 * dx) / 6, y: y - dy },\n        { x: x + dx, y: y },\n        { x: x + (5 * dx) / 6, y: y + dy },\n        { x: x + (2 * dx) / 3, y: y + dy },\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  RadarGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/radar/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/radar/tokenBuilder.ts\nvar RadarTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"RadarTokenBuilder\");\n  }\n  constructor() {\n    super([\"radar-beta\"]);\n  }\n};\n\n// src/language/radar/module.ts\nvar RadarModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new RadarTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createRadarServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Radar = inject(\n    createDefaultCoreModule({ shared }),\n    RadarGeneratedModule,\n    RadarModule\n  );\n  shared.ServiceRegistry.register(Radar);\n  return { shared, Radar };\n}\n__name(createRadarServices, \"createRadarServices\");\n\nexport {\n  RadarModule,\n  createRadarServices\n};\n","// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    if (1)\n        return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    // - https://esbuild.github.io/content-types/#direct-eval\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    (0, eval)(toBecomeFast);\n}\n//# sourceMappingURL=to-fast-properties.js.map","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default drop;\n","import assignValue from './_assignValue.js';\nimport copyObject from './_copyObject.js';\nimport createAssigner from './_createAssigner.js';\nimport isArrayLike from './isArrayLike.js';\nimport isPrototype from './_isPrototype.js';\nimport keys from './keys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nexport default assign;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport basePickBy from './_basePickBy.js';\nimport getAllKeysIn from './_getAllKeysIn.js';\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nexport default pickBy;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nexport default baseIsRegExp;\n","import baseIsRegExp from './_baseIsRegExp.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nexport default isRegExp;\n","import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nexport class AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        forEach(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nexport class NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nexport class Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = \"\";\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternation extends AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Terminal {\n    constructor(options) {\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nexport function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction);\n}\nexport function serializeProduction(node) {\n    function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = isRegExp(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition),\n        };\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=model.js.map","import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport class GAstVisitor {\n    visit(node) {\n        const nodeAny = node;\n        switch (nodeAny.constructor) {\n            case NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case Alternative:\n                return this.visitAlternative(nodeAny);\n            case Option:\n                return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n                return this.visitRepetition(nodeAny);\n            case Alternation:\n                return this.visitAlternation(nodeAny);\n            case Terminal:\n                return this.visitTerminal(nodeAny);\n            case Rule:\n                return this.visitRule(nodeAny);\n            /* c8 ignore next 2 */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) { }\n    /* c8 ignore next */\n    visitAlternative(node) { }\n    /* c8 ignore next */\n    visitOption(node) { }\n    /* c8 ignore next */\n    visitRepetition(node) { }\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) { }\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) { }\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) { }\n    /* c8 ignore next */\n    visitAlternation(node) { }\n    /* c8 ignore next */\n    visitTerminal(node) { }\n    /* c8 ignore next */\n    visitRule(node) { }\n}\n//# sourceMappingURL=visitor.js.map","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nexport default baseSome;\n","import arraySome from './_arraySome.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseSome from './_baseSome.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default some;\n","import baseIndexOf from './_baseIndexOf.js';\nimport isArrayLike from './isArrayLike.js';\nimport isString from './isString.js';\nimport toInteger from './toInteger.js';\nimport values from './values.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nexport default includes;\n","/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default arrayEvery;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nexport default baseEvery;\n","import arrayEvery from './_arrayEvery.js';\nimport baseEvery from './_baseEvery.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default every;\n","import { every, includes, some } from \"lodash-es\";\nimport { AbstractProduction, Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport function isSequenceProd(prod) {\n    return (prod instanceof Alternative ||\n        prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionMandatory ||\n        prod instanceof RepetitionMandatoryWithSeparator ||\n        prod instanceof RepetitionWithSeparator ||\n        prod instanceof Terminal ||\n        prod instanceof Rule);\n}\nexport function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return some(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return every(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nexport function isBranchingProd(prod) {\n    return prod instanceof Alternation;\n}\nexport function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { drop, forEach } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport class RestWalker {\n    walk(prod, prevRest = []) {\n        forEach(prod.definition, (subProd, index) => {\n            const currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new Option({ definition: manyProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            const prodWrapper = new Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator }),\n            ].concat(repSepProd.definition),\n        }),\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map","import baseUniq from './_baseUniq.js';\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nexport default uniq;\n","import { flatten, map, uniq } from \"lodash-es\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd, NonTerminal, Terminal, } from \"@chevrotain/gast\";\nexport function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n        return first(innerProd);\n    });\n    return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map","// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map","import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative } from \"@chevrotain/gast\";\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new Alternative({ definition: fullRest });\n        const t_in_topProd_follows = first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n}\nexport function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    forEach(topProductions, (topProd) => {\n        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nexport function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN;\n}\nexport function buildInProdFollowPrefix(terminal) {\n    const terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + IN;\n}\n//# sourceMappingURL=follow.js.map","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nexport default negate;\n","import arrayFilter from './_arrayFilter.js';\nimport baseFilter from './_baseFilter.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport negate from './negate.js';\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nexport default reject;\n","import baseIndexOf from './_baseIndexOf.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nexport default indexOf;\n","import SetCache from './_SetCache.js';\nimport arrayIncludes from './_arrayIncludes.js';\nimport arrayIncludesWith from './_arrayIncludesWith.js';\nimport arrayMap from './_arrayMap.js';\nimport baseUnary from './_baseUnary.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseDifference;\n","import baseDifference from './_baseDifference.js';\nimport baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nexport default difference;\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default compact;\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nexport default head;\n","export function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(`Error: ${msg}`);\n    }\n}\nexport function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(`Warning: ${msg}`);\n    }\n}\n//# sourceMappingURL=print.js.map","import { RegExpParser, } from \"@chevrotain/regexp-to-ast\";\nlet regExpAstCache = {};\nconst regExpParser = new RegExpParser();\nexport function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        const regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nexport function clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map","import { BaseRegExpVisitor, } from \"@chevrotain/regexp-to-ast\";\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\nconst complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n        const ast = getRegExpAst(regExp);\n        const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                PRINT_WARNING(`${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            let msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\\n` +\n                `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n                `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n                \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (let i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            const terms = ast.value;\n            for (let i = 0; i < terms.length; i++) {\n                const term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                const atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        forEach(atom.value, (code) => {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                const range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= minOptimizationVal) {\n                                        const minUnOptVal = range.from >= minOptimizationVal\n                                            ? range.from\n                                            : minOptimizationVal;\n                                        const maxUnOptVal = range.to;\n                                        const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                                        const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code);\n    const upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        const lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return find(setNode.value, (codeOrRange) => {\n        if (typeof codeOrRange === \"number\") {\n            return includes(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            const range = codeOrRange;\n            return (find(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    const quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return isArray(ast.value)\n        ? every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nclass CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n        super();\n        this.targetCharCodes = targetCharCodes;\n        this.found = false;\n    }\n    visitChildren(node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        super.visitChildren(node);\n    }\n    visitCharacter(node) {\n        if (includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    }\n    visitSet(node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    }\n}\nexport function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        const ast = getRegExpAst(pattern);\n        const charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (find(pattern, (char) => {\n            return includes(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map","import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType, } from \"./lexer_public.js\";\nimport { compact, defaults, difference, filter, find, first, flatten, forEach, has, includes, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, reduce, reject, values, } from \"lodash-es\";\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices, } from \"./reg_exp.js\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nconst PATTERN = \"PATTERN\";\nexport const DEFAULT_MODE = \"defaultMode\";\nexport const MODES = \"modes\";\nexport let SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n    SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n    SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: (msg, action) => action(),\n    });\n    const tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n        initCharCodeToOptimizedIndexMap();\n    });\n    let onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", () => {\n        onlyRelevantTypes = reject(tokenTypes, (currType) => {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    let hasCustom = false;\n    let allTransformedPatterns;\n    tracer(\"Transform Patterns\", () => {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n            const currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (isRegExp(currPattern)) {\n                const regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\" &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !includes([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\",\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (isFunction(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (typeof currPattern === \"object\") {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    const wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    let patternIdxToType;\n    let patternIdxToGroup;\n    let patternIdxToLongerAltIdxArr;\n    let patternIdxToPushMode;\n    let patternIdxToPopMode;\n    tracer(\"misc mapping\", () => {\n        patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n        patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n            const groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if (isString(groupName)) {\n                return groupName;\n            }\n            else if (isUndefined(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n            const longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                const longerAltIdxArr = isArray(longerAltType)\n                    ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n                    : [indexOf(onlyRelevantTypes, longerAltType)];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n        patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, \"POP_MODE\"));\n    });\n    let patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", () => {\n        const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    return !!tokType.LINE_BREAKS;\n                }\n                else {\n                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n                        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN));\n                }\n            });\n        }\n    });\n    let patternIdxToIsCustom;\n    let patternIdxToShort;\n    let emptyGroups;\n    let patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", () => {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, (acc, clazz) => {\n            const groupName = clazz.GROUP;\n            if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx],\n            };\n        });\n    });\n    let canBeOptimized = true;\n    let charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", () => {\n            charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, (result, currTokType, idx) => {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    const charCode = currTokType.PATTERN.charCodeAt(0);\n                    const optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (isArray(currTokType.START_CHARS_HINT)) {\n                    let lastOptimizedIdx;\n                    forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                        const charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx !== currOptimizedIdx) {\n                            lastOptimizedIdx = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                                `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (isEmpty(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        forEach(optimizedCodes, (code) => {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                            `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized,\n    };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n    let errors = [];\n    const missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    const invalidResult = findInvalidPatterns(missingResult.valid);\n    const validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    let errors = [];\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp(currTokType[PATTERN]));\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n        return !has(currType, PATTERN);\n    });\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors, valid };\n}\nexport function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return (!isRegExp(pattern) &&\n            !isFunction(pattern) &&\n            !has(pattern, \"exec\") &&\n            !isString(pattern));\n    });\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors, valid };\n}\nconst end_of_input = /[^\\\\][$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitEndAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        return pattern.test(\"\");\n    });\n    const errors = map(matchesEmptyString, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitStartAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    const errors = map(invalidFlags, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n    const found = [];\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n        return reduce(tokenTypes, (result, innerType) => {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !includes(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = compact(identicalPatterns);\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n        return currIdenticalSet.length > 1;\n    });\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n        const tokenTypeNames = map(setOfIdentical, (currType) => {\n            return currType.name;\n        });\n        const dupPatternSrc = first(setOfIdentical).PATTERN;\n        return {\n            message: `The same RegExp pattern ->${dupPatternSrc}<-` +\n                `has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical,\n        };\n    });\n    return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n        if (!has(clazz, \"GROUP\")) {\n            return false;\n        }\n        const group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n    });\n    const errors = map(invalidTypes, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n        return (clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE));\n    });\n    const errors = map(invalidModes, (tokType) => {\n        const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n            `which does not exist`;\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType],\n        };\n    });\n    return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n    const errors = [];\n    const canBeTested = reduce(tokenTypes, (result, tokType, idx) => {\n        const pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n            result.push({ str: pattern, idx, tokenType: tokType });\n        }\n        else if (isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    forEach(tokenTypes, (tokType, testIdx) => {\n        forEach(canBeTested, ({ str, idx, tokenType }) => {\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                const msg = `Token: ->${tokenType.name}<- can never be matched.\\n` +\n                    `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n                    `in the lexer's definition.\\n` +\n                    `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType],\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        const regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (isFunction(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (has(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\",\n    ];\n    return (find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined);\n}\nexport function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags);\n}\nexport function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = [];\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n        });\n    }\n    if (!has(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n        });\n    }\n    if (has(lexerDefinition, MODES) &&\n        has(lexerDefinition, DEFAULT_MODE) &&\n        !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n                `which does not exist\\n`,\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n        });\n    }\n    if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n            forEach(currModeValue, (currTokType, currIdx) => {\n                if (isUndefined(currTokType)) {\n                    errors.push({\n                        message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                            `<${currModeName}> at index: <${currIdx}>\\n`,\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n                    });\n                }\n                else if (has(currTokType, \"LONGER_ALT\")) {\n                    const longerAlt = isArray(currTokType.LONGER_ALT)\n                        ? currTokType.LONGER_ALT\n                        : [currTokType.LONGER_ALT];\n                    forEach(longerAlt, (currLongerAlt) => {\n                        if (!isUndefined(currLongerAlt) &&\n                            !includes(currModeValue, currLongerAlt)) {\n                            errors.push({\n                                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = [];\n    let hasAnyLineBreak = false;\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        forEach(concreteTokenTypes, (tokType) => {\n            const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                const message = buildLineBreakIssueMessage(tokType, currIssue);\n                const warningDescriptor = {\n                    message,\n                    type: currIssue.issue,\n                    tokenType: tokType,\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n        });\n    }\n    return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {};\n    const groupKeys = keys(emptyGroups);\n    forEach(groupKeys, (currKey) => {\n        const currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (isArray(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        return false;\n    }\n    else if (isFunction(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (has(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (isString(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        const len = text.length;\n        for (let i = this.lastIndex; i < len; i++) {\n            const c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0,\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (isRegExp(tokType.PATTERN)) {\n            try {\n                // TODO: why is the casting suddenly needed?\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message,\n                };\n            }\n            return false;\n        }\n        else if (isString(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            `\\t Root cause: ${details.errMsg}.\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n        if (isString(numOrString)) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexport const minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap = [];\nexport function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (let i = 0; i < 65536; i++) {\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map","export function timer(func) {\n    const start = new Date().getTime();\n    const val = func();\n    const end = new Date().getTime();\n    const total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=timer.js.map","import { clone, compact, difference, flatten, forEach, has, includes, isArray, isEmpty, map, } from \"lodash-es\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport let tokenShortNameIdx = 1;\nexport const tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, (tokType) => {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes);\n    let categories = tokenTypes;\n    let searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)));\n        const newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, (val, key) => {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n        const newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!includes(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map","export const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return (`unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` + ` skipped ${length} characters.`);\n    },\n};\n//# sourceMappingURL=lexer_errors_public.js.map","import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns, } from \"./lexer.js\";\nimport { assign, clone, forEach, identity, isArray, isEmpty, isUndefined, keys, last, map, noop, reduce, reject, } from \"lodash-es\";\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\nimport { augmentTokenTypes } from \"./tokens.js\";\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nconst DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nexport class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser's perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (this.traceInitPerf === true) {\n                this.traceInitIndent++;\n                const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    console.log(`${indent}--> <${phaseDesc}>`);\n                }\n                const { time, value } = timer(phaseImpl);\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                const traceMethod = time > 10 ? console.warn : console.log;\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n                }\n                this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = assign({}, DEFAULT_LEXER_CONFIG, config);\n        const traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", () => {\n            let actualDefinition;\n            let hasOnlySingleMode = true;\n            this.TRACE_INIT(\"Lexer Config handling\", () => {\n                if (this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n                this.trackEndLines = /full/i.test(this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: clone(lexerDefinition) },\n                        defaultMode: DEFAULT_MODE,\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = clone(lexerDefinition);\n                }\n            });\n            if (this.config.skipValidations === false) {\n                this.TRACE_INIT(\"performRuntimeChecks\", () => {\n                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n                this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n                actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType));\n            });\n            const allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, (currModDef, currModName) => {\n                this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n                    this.modes.push(currModName);\n                    if (this.config.skipValidations === false) {\n                        this.TRACE_INIT(`validatePatterns`, () => {\n                            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        let currAnalyzeResult;\n                        this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                            currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: this.TRACE_INIT,\n                            });\n                        });\n                        this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult.patternIdxToConfig;\n                        this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult.charCodeToPatternIdxToConfig;\n                        this.emptyGroups = assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n                        this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult.canBeOptimized;\n                    }\n                });\n            });\n            this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(this.lexerDefinitionErrors) &&\n                !this.config.deferDefinitionErrorsHandling) {\n                const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                    return error.message;\n                });\n                const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    this.chopInput = identity;\n                    this.match = this.matchWithTest;\n                }\n                else {\n                    this.updateLastIndex = noop;\n                    this.match = this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    this.handleModes = noop;\n                }\n                if (this.trackStartLines === false) {\n                    this.computeNewColumn = identity;\n                }\n                if (this.trackEndLines === false) {\n                    this.updateTokenEndLineColumnLocation = noop;\n                }\n                if (/full/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createFullToken;\n                }\n                else if (/onlyStart/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n                }\n                if (this.hasCustom) {\n                    this.addToken = this.addTokenUsingPush;\n                    this.handlePayload = this.handlePayloadWithCustom;\n                }\n                else {\n                    this.addToken = this.addTokenUsingMemberAccess;\n                    this.handlePayload = this.handlePayloadNoCustom;\n                }\n            });\n            this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n                const unOptimizedModes = reduce(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\\n` +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n                clearRegExpParserCache();\n            });\n            this.TRACE_INIT(\"toFastProperties\", () => {\n                toFastProperties(this);\n            });\n        });\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                return error.message;\n            });\n            const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        const orgText = text;\n        const orgLength = orgText.length;\n        let offset = 0;\n        let matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        const guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        const matchedTokens = new Array(guessedNumberOfTokens);\n        const errors = [];\n        let line = this.trackStartLines ? 1 : undefined;\n        let column = this.trackStartLines ? 1 : undefined;\n        const groups = cloneEmptyGroups(this.emptyGroups);\n        const trackLines = this.trackStartLines;\n        const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        let currModePatternsLength = 0;\n        let patternIdxToConfig = [];\n        let currCharCodeToPatternIdxToConfig = [];\n        const modeStack = [];\n        const emptyArray = [];\n        Object.freeze(emptyArray);\n        let getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        const pop_mode = (popToken) => {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg,\n                });\n            }\n            else {\n                modeStack.pop();\n                const newMode = last(modeStack);\n                patternIdxToConfig = this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        let currConfig;\n        const recoveryEnabled = this.config.recoveryEnabled;\n        while (offset < orgLength) {\n            matchedImage = null;\n            const nextCharCode = orgText.charCodeAt(offset);\n            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            const chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                const currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                const singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        const longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            const longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won't be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    let numOfLTsInMatch = 0;\n                    let foundTerminator;\n                    let lastLTEndOffset;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                const errorStartOffset = offset;\n                const errorLine = line;\n                const errorColumn = column;\n                let foundResyncPoint = recoveryEnabled === false;\n                while (foundResyncPoint === false && offset < orgLength) {\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        const currConfig = patternIdxToConfig[j];\n                        const currPattern = currConfig.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        const singleCharCode = currConfig.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                column = this.computeNewColumn(column, errLength);\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg,\n                });\n                if (recoveryEnabled === false) {\n                    break;\n                }\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors,\n        };\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            const pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    }\n    chopInput(text, length) {\n        return text.substring(length);\n    }\n    updateLastIndex(regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        let lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image,\n            startOffset,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image,\n            startOffset,\n            startLine,\n            startColumn,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image,\n            startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine,\n            endLine: startLine,\n            startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    }\n    handlePayloadNoCustom(token, payload) { }\n    handlePayloadWithCustom(token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    }\n    matchWithTest(pattern, text, offset) {\n        const found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    }\n    matchWithExec(pattern, text) {\n        const regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    }\n}\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\n//# sourceMappingURL=lexer_public.js.map","import { has, isString, isUndefined } from \"lodash-es\";\nimport { Lexer } from \"./lexer_public.js\";\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\nexport function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nexport function tokenName(tokType) {\n    return tokType.name;\n}\nexport function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\nexport function createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    const pattern = config.pattern;\n    const tokenType = {};\n    tokenType.name = config.name;\n    if (!isUndefined(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if (has(config, PARENT)) {\n        throw (\"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\");\n    }\n    if (has(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    augmentTokenTypes([tokenType]);\n    if (has(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if (has(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if (has(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if (has(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if (has(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if (has(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if (has(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nexport function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image,\n        startOffset,\n        endOffset,\n        startLine,\n        endLine,\n        startColumn,\n        endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType,\n    };\n}\nexport function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map","import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport { getProductionDslName, NonTerminal, Rule, Terminal, } from \"@chevrotain/gast\";\nexport const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = hasTokenLabel(expected);\n        const expectedMsg = hasLabel\n            ? `--> ${tokenLabel(expected)} <--`\n            : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = map(allLookAheadPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = map(expectedIterationPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n};\nObject.freeze(defaultParserErrorProvider);\nexport const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    },\n};\nexport const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = first(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames\n            .concat([ruleName])\n            .join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    },\n};\n//# sourceMappingURL=errors_public.js.map","import { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor } from \"@chevrotain/gast\";\nexport function resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nexport class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        forEach(values(this.nameToTopRule), (prod) => {\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName,\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    }\n}\n//# sourceMappingURL=resolver.js.map","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default dropRight;\n","import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../scan/tokens.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, } from \"@chevrotain/gast\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory ||\n        prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator ||\n        prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator ||\n        prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function getLookaheadPaths(options) {\n    const { occurrence, rule, prodType, maxLookahead } = options;\n    const type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n        return every(currAlt, (currPath) => {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            const predicates = map(orAlts, (currAlt) => currAlt.GATE);\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                const currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        const singleTokenAlts = map(alts, (currAlt) => {\n            return flatten(currAlt);\n        });\n        const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) => {\n            forEach(currAlt, (currTokType) => {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        }\n        else {\n            const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) => {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (let j = 0; j < numOfPaths; j++) {\n                const currPath = alt[j];\n                const currPathLength = currPath.length;\n                for (let i = 0; i < currPathLength; i++) {\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            super.walkOption(optionProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            super.walkOption(atLeastOneProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(atLeastOneSepProd, currRest, prevRest);\n        }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            super.walkOption(manyProd, currRest, prevRest);\n        }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(manySepProd, currRest, prevRest);\n        }\n    }\n}\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    }\n}\nfunction initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    let keys = [\"\"];\n    for (let i = 0; i < path.length; i++) {\n        const tokType = path[i];\n        const longerKeys = [];\n        for (let j = 0; j < keys.length; j++) {\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (let t = 0; t < tokType.categoryMatches.length; t++) {\n                const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n    const finalResult = initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n        const dict = {};\n        forEach(currAltPaths, (item) => {\n            const keys = pathToHashKeys(item.partialPath);\n            forEach(keys, (currKey) => {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n        const currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        // alternatives loop\n        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = pathToHashKeys(currPathPrefix);\n                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (let j = 0; j < prefixKeys.length; j++) {\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, (item) => {\n                        const prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, (key) => {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new AlternativeGAST({ definition: insideDef });\n    const afterFlat = new AlternativeGAST({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (let j = 0; j < otherPath.length; j++) {\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, (tokType, idx) => {\n            const otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) => every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))));\n}\n//# sourceMappingURL=lookahead.js.map","import { clone, drop, dropRight, first as _first, forEach, isEmpty, last, } from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nexport class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = \"\";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        // stop scanning once we found the path\n        if (!this.found) {\n            super.walk(prod, prevRest);\n        }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n}\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = \"\";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    }\n}\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined,\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n}\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            super.walkMany(manyProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            super.walkManySep(manySepProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n        }\n    }\n}\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n        }\n    }\n}\nexport function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath);\n    let result = [];\n    let i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        const prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, (currAlt) => {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i),\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: [],\n    });\n    while (!isEmpty(possiblePaths)) {\n        const currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        const prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack),\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack,\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            const newRuleStack = clone(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = clone(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            const nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (let i = prod.definition.length - 1; i >= 0; i--) {\n                const currAlt = prod.definition[i];\n                const currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = clone(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack,\n    };\n}\n//# sourceMappingURL=interpreter.js.map","import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values, } from \"lodash-es\";\nimport { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath, } from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\nexport function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName,\n    });\n    return map(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));\n}\nexport function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = map(values(duplicates), (currDuplicates) => {\n        const firstProd = first(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx,\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nexport class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = reduce(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className,\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name,\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!includes(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName,\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path,\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName,\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n            const newPath = clone(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    let result = [];\n    if (isEmpty(definition)) {\n        return result;\n    }\n    const firstProd = first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    const isFirstOptional = isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nclass OrCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        const exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n            if (isEmpty(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx,\n                        }),\n                        type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1,\n                    },\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = flatMap(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexport class RepetitionCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                    }),\n                    type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                },\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    forEach(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, (currProd) => {\n            const prodType = getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd,\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name,\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath,\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path,\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts,\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path,\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices,\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n    forEach(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName,\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map","import { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport { defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, } from \"../../errors_public.js\";\nexport function resolveGrammar(options) {\n    const actualOptions = defaults(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider,\n    });\n    const topRulesTable = {};\n    forEach(options.rules, (rule) => {\n        topRulesTable[rule.name] = rule;\n    });\n    return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nexport function validateGrammar(options) {\n    options = defaults(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider,\n    });\n    return orgValidateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n//# sourceMappingURL=gast_resolver_public.js.map","import { includes } from \"lodash-es\";\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nconst RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n    constructor(message, token) {\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(this, new.target.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexport class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = MISMATCHED_TOKEN_EXCEPTION;\n    }\n}\nexport class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = NO_VIABLE_ALT_EXCEPTION;\n    }\n}\nexport class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n        super(message, token);\n        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n}\nexport class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = EARLY_EXIT_EXCEPTION;\n    }\n}\n//# sourceMappingURL=exceptions_public.js.map","import { createTokenInstance, EOF, tokenMatcher, } from \"../../../scan/tokens_public.js\";\nimport { clone, dropRight, find, flatten, has, includes, isEmpty, map, } from \"lodash-es\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nexport const EOF_FOLLOW_KEY = {};\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport class InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return includes(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName),\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return map(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule,\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map","// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map","import { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport { validateAmbiguousAlternationAlternatives, validateEmptyOrAlternative, validateNoLeftRecursion, validateSomeNonEmptyLookaheadPath, } from \"./checks.js\";\nimport { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, getProdType, } from \"./lookahead.js\";\nexport class LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if (isEmpty(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors,\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n    }\n}\n//# sourceMappingURL=llk_lookahead.js.map","import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { GAstVisitor, getProductionDslName, } from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = has(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        forEach(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);\n                forEach(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled,\n                        });\n                        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                forEach(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence,\n                rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType,\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=looksahead.js.map","/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map","const NAME = \"name\";\nexport function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue,\n    });\n}\n//# sourceMappingURL=lang_extensions.js.map","import { compact, filter, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map, } from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nexport function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n            }\n        },\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n        return isFunction(visitorInstance[currRuleName]) === false;\n    });\n    const errors = map(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName,\n        };\n    });\n    return compact(errors);\n}\n//# sourceMappingURL=cst_visitor.js.map","import { forEach, has, isArray, isFunction, last as peek, some, } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport { augmentTokenTypes, hasShortKeyProperty, } from \"../../../scan/tokens.js\";\nimport { createToken, createTokenInstance, } from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nconst RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {},\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", () => {\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                this[`CONSUME${idx}`] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            // DSL methods with the idx(suffix) as an argument\n            this[`consume`] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", () => {\n            const that = this;\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n        // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return () => true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    const hasOptions = isArray(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    });\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, (currAlt) => {\n        const currAltFlat = new Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map","import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport { defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, } from \"../errors_public.js\";\nimport { resolveGrammar, validateGrammar, } from \"../grammar/gast/gast_resolver_public.js\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\nexport const END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nexport const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false,\n});\nexport const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n});\nexport var ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nexport function EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nexport class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                toFastProperties(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    forEach(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", () => {\n                resolverErrors = resolveGrammar({\n                    rules: values(this.gastProductionsCache),\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if (isEmpty(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = validateGrammar({\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        errMsgProvider: defaultGrammarValidatorErrorProvider,\n                        grammarName: className,\n                    });\n                    const lookaheadValidationErrors = validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        grammarName: className,\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if (isEmpty(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n                        const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: values(this.gastProductionsCache),\n                    });\n                    this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !isEmpty(this.definitionErrors)) {\n                defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n}\n// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n]);\nexport class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nexport class EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\n//# sourceMappingURL=parser.js.map","export function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n            if (propName === \"constructor\") {\n                return;\n            }\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n//# sourceMappingURL=apply_mixins.js.map","import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset, } from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, } from \"../../cst/cst_visitor.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = noop;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null),\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\n//# sourceMappingURL=tree_builder.js.map","import { END_OF_FILE } from \"../parser.js\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\n//# sourceMappingURL=lexer_adapter.js.map","import { clone, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values, } from \"lodash-es\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException, } from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker, } from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../../scan/tokens.js\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            const allTokenTypes = flatten(values(tokenVocabulary.modes));\n            const uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = EOF;\n        const allTokenTypes = has(tokenVocabulary, \"modes\")\n            ? flatten(values(tokenVocabulary.modes))\n            : values(tokenVocabulary);\n        const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        }\n        const resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker,\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker,\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker,\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = clone(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\n//# sourceMappingURL=recognizer_engine.js.map","import { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { serializeGrammar } from \"@chevrotain/gast\";\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n        if (includes(this.definedRulesNames, name)) {\n            const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className,\n            });\n            const error = {\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name,\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (isRecognitionException(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return serializeGrammar(values(this.gastProductionsCache));\n    }\n}\n//# sourceMappingURL=recognizer_api.js.map","import { EarlyExitException, isRecognitionException, NoViableAltException, } from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, } from \"../../grammar/lookahead.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    }\n    get errors() {\n        return clone(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName,\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName(),\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\n//# sourceMappingURL=error_handler.js.map","import { NextAfterTokenWalker, nextPossibleTokensAfter, } from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nexport class ContentAssist {\n    initContentAssist() { }\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if (isUndefined(startRuleGast)) {\n            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        }\n        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = first(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n}\n//# sourceMappingURL=context_assist.js.map","import { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n    initPerformanceTracer(config) {\n        if (has(config, \"traceInitPerf\")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(`${indent}--> <${phaseDesc}>`);\n            }\n            const { time, value } = timer(phaseImpl);\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    }\n}\n//# sourceMappingURL=perf_tracer.js.map","import baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport baseUniq from './_baseUniq.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2], [1, 2]);\n * // => [2, 1]\n */\nvar union = baseRest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nexport default union;\n","import * as _ from 'lodash-es';\n\nvar DEFAULT_EDGE_NAME = '\\x00';\nvar GRAPH_NODE = '\\x00';\nvar EDGE_KEY_DELIM = '\\x01';\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\nexport class Graph {\n  constructor(opts = {}) {\n    this._isDirected = Object.prototype.hasOwnProperty.call(opts, 'directed')\n      ? opts.directed\n      : true;\n    this._isMultigraph = Object.prototype.hasOwnProperty.call(opts, 'multigraph')\n      ? opts.multigraph\n      : false;\n    this._isCompound = Object.prototype.hasOwnProperty.call(opts, 'compound')\n      ? opts.compound\n      : false;\n\n    // Label for the graph itself\n    this._label = undefined;\n\n    // Defaults to be set when creating a new node\n    this._defaultNodeLabelFn = _.constant(undefined);\n\n    // Defaults to be set when creating a new edge\n    this._defaultEdgeLabelFn = _.constant(undefined);\n\n    // v -> label\n    this._nodes = {};\n\n    if (this._isCompound) {\n      // v -> parent\n      this._parent = {};\n\n      // v -> children\n      this._children = {};\n      this._children[GRAPH_NODE] = {};\n    }\n\n    // v -> edgeObj\n    this._in = {};\n\n    // u -> v -> Number\n    this._preds = {};\n\n    // v -> edgeObj\n    this._out = {};\n\n    // v -> w -> Number\n    this._sucs = {};\n\n    // e -> edgeObj\n    this._edgeObjs = {};\n\n    // e -> label\n    this._edgeLabels = {};\n  }\n  /* === Graph functions ========= */\n  isDirected() {\n    return this._isDirected;\n  }\n  isMultigraph() {\n    return this._isMultigraph;\n  }\n  isCompound() {\n    return this._isCompound;\n  }\n  setGraph(label) {\n    this._label = label;\n    return this;\n  }\n  graph() {\n    return this._label;\n  }\n  /* === Node functions ========== */\n  setDefaultNodeLabel(newDefault) {\n    if (!_.isFunction(newDefault)) {\n      newDefault = _.constant(newDefault);\n    }\n    this._defaultNodeLabelFn = newDefault;\n    return this;\n  }\n  nodeCount() {\n    return this._nodeCount;\n  }\n  nodes() {\n    return _.keys(this._nodes);\n  }\n  sources() {\n    var self = this;\n    return _.filter(this.nodes(), function (v) {\n      return _.isEmpty(self._in[v]);\n    });\n  }\n  sinks() {\n    var self = this;\n    return _.filter(this.nodes(), function (v) {\n      return _.isEmpty(self._out[v]);\n    });\n  }\n  setNodes(vs, value) {\n    var args = arguments;\n    var self = this;\n    _.each(vs, function (v) {\n      if (args.length > 1) {\n        self.setNode(v, value);\n      } else {\n        self.setNode(v);\n      }\n    });\n    return this;\n  }\n  setNode(v, value) {\n    if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {\n      if (arguments.length > 1) {\n        this._nodes[v] = value;\n      }\n      return this;\n    }\n\n    // @ts-expect-error\n    this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n    if (this._isCompound) {\n      this._parent[v] = GRAPH_NODE;\n      this._children[v] = {};\n      this._children[GRAPH_NODE][v] = true;\n    }\n    this._in[v] = {};\n    this._preds[v] = {};\n    this._out[v] = {};\n    this._sucs[v] = {};\n    ++this._nodeCount;\n    return this;\n  }\n  node(v) {\n    return this._nodes[v];\n  }\n  hasNode(v) {\n    return Object.prototype.hasOwnProperty.call(this._nodes, v);\n  }\n  removeNode(v) {\n    if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {\n      var removeEdge = (e) => this.removeEdge(this._edgeObjs[e]);\n      delete this._nodes[v];\n      if (this._isCompound) {\n        this._removeFromParentsChildList(v);\n        delete this._parent[v];\n        _.each(this.children(v), (child) => {\n          this.setParent(child);\n        });\n        delete this._children[v];\n      }\n      _.each(_.keys(this._in[v]), removeEdge);\n      delete this._in[v];\n      delete this._preds[v];\n      _.each(_.keys(this._out[v]), removeEdge);\n      delete this._out[v];\n      delete this._sucs[v];\n      --this._nodeCount;\n    }\n    return this;\n  }\n  setParent(v, parent) {\n    if (!this._isCompound) {\n      throw new Error('Cannot set parent in a non-compound graph');\n    }\n\n    if (_.isUndefined(parent)) {\n      parent = GRAPH_NODE;\n    } else {\n      // Coerce parent to string\n      parent += '';\n      for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {\n        if (ancestor === v) {\n          throw new Error('Setting ' + parent + ' as parent of ' + v + ' would create a cycle');\n        }\n      }\n\n      this.setNode(parent);\n    }\n\n    this.setNode(v);\n    this._removeFromParentsChildList(v);\n    this._parent[v] = parent;\n    this._children[parent][v] = true;\n    return this;\n  }\n  _removeFromParentsChildList(v) {\n    delete this._children[this._parent[v]][v];\n  }\n  parent(v) {\n    if (this._isCompound) {\n      var parent = this._parent[v];\n      if (parent !== GRAPH_NODE) {\n        return parent;\n      }\n    }\n  }\n  children(v) {\n    if (_.isUndefined(v)) {\n      v = GRAPH_NODE;\n    }\n\n    if (this._isCompound) {\n      var children = this._children[v];\n      if (children) {\n        return _.keys(children);\n      }\n    } else if (v === GRAPH_NODE) {\n      return this.nodes();\n    } else if (this.hasNode(v)) {\n      return [];\n    }\n  }\n  predecessors(v) {\n    var predsV = this._preds[v];\n    if (predsV) {\n      return _.keys(predsV);\n    }\n  }\n  successors(v) {\n    var sucsV = this._sucs[v];\n    if (sucsV) {\n      return _.keys(sucsV);\n    }\n  }\n  neighbors(v) {\n    var preds = this.predecessors(v);\n    if (preds) {\n      return _.union(preds, this.successors(v));\n    }\n  }\n  isLeaf(v) {\n    var neighbors;\n    if (this.isDirected()) {\n      neighbors = this.successors(v);\n    } else {\n      neighbors = this.neighbors(v);\n    }\n    return neighbors.length === 0;\n  }\n  filterNodes(filter) {\n    // @ts-expect-error\n    var copy = new this.constructor({\n      directed: this._isDirected,\n      multigraph: this._isMultigraph,\n      compound: this._isCompound,\n    });\n\n    copy.setGraph(this.graph());\n\n    var self = this;\n    _.each(this._nodes, function (value, v) {\n      if (filter(v)) {\n        copy.setNode(v, value);\n      }\n    });\n\n    _.each(this._edgeObjs, function (e) {\n      // @ts-expect-error\n      if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n        copy.setEdge(e, self.edge(e));\n      }\n    });\n\n    var parents = {};\n    function findParent(v) {\n      var parent = self.parent(v);\n      if (parent === undefined || copy.hasNode(parent)) {\n        parents[v] = parent;\n        return parent;\n      } else if (parent in parents) {\n        return parents[parent];\n      } else {\n        return findParent(parent);\n      }\n    }\n\n    if (this._isCompound) {\n      _.each(copy.nodes(), function (v) {\n        copy.setParent(v, findParent(v));\n      });\n    }\n\n    return copy;\n  }\n  /* === Edge functions ========== */\n  setDefaultEdgeLabel(newDefault) {\n    if (!_.isFunction(newDefault)) {\n      newDefault = _.constant(newDefault);\n    }\n    this._defaultEdgeLabelFn = newDefault;\n    return this;\n  }\n  edgeCount() {\n    return this._edgeCount;\n  }\n  edges() {\n    return _.values(this._edgeObjs);\n  }\n  setPath(vs, value) {\n    var self = this;\n    var args = arguments;\n    _.reduce(vs, function (v, w) {\n      if (args.length > 1) {\n        self.setEdge(v, w, value);\n      } else {\n        self.setEdge(v, w);\n      }\n      return w;\n    });\n    return this;\n  }\n  /*\n   * setEdge(v, w, [value, [name]])\n   * setEdge({ v, w, [name] }, [value])\n   */\n  setEdge() {\n    var v, w, name, value;\n    var valueSpecified = false;\n    var arg0 = arguments[0];\n\n    if (typeof arg0 === 'object' && arg0 !== null && 'v' in arg0) {\n      v = arg0.v;\n      w = arg0.w;\n      name = arg0.name;\n      if (arguments.length === 2) {\n        value = arguments[1];\n        valueSpecified = true;\n      }\n    } else {\n      v = arg0;\n      w = arguments[1];\n      name = arguments[3];\n      if (arguments.length > 2) {\n        value = arguments[2];\n        valueSpecified = true;\n      }\n    }\n\n    v = '' + v;\n    w = '' + w;\n    if (!_.isUndefined(name)) {\n      name = '' + name;\n    }\n\n    var e = edgeArgsToId(this._isDirected, v, w, name);\n    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, e)) {\n      if (valueSpecified) {\n        this._edgeLabels[e] = value;\n      }\n      return this;\n    }\n\n    if (!_.isUndefined(name) && !this._isMultigraph) {\n      throw new Error('Cannot set a named edge when isMultigraph = false');\n    }\n\n    // It didn't exist, so we need to create it.\n    // First ensure the nodes exist.\n    this.setNode(v);\n    this.setNode(w);\n\n    // @ts-expect-error\n    this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n\n    var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n    // Ensure we add undirected edges in a consistent way.\n    v = edgeObj.v;\n    w = edgeObj.w;\n\n    Object.freeze(edgeObj);\n    this._edgeObjs[e] = edgeObj;\n    incrementOrInitEntry(this._preds[w], v);\n    incrementOrInitEntry(this._sucs[v], w);\n    this._in[w][e] = edgeObj;\n    this._out[v][e] = edgeObj;\n    this._edgeCount++;\n    return this;\n  }\n  edge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    return this._edgeLabels[e];\n  }\n  hasEdge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    return Object.prototype.hasOwnProperty.call(this._edgeLabels, e);\n  }\n  removeEdge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    var edge = this._edgeObjs[e];\n    if (edge) {\n      v = edge.v;\n      w = edge.w;\n      delete this._edgeLabels[e];\n      delete this._edgeObjs[e];\n      decrementOrRemoveEntry(this._preds[w], v);\n      decrementOrRemoveEntry(this._sucs[v], w);\n      delete this._in[w][e];\n      delete this._out[v][e];\n      this._edgeCount--;\n    }\n    return this;\n  }\n  inEdges(v, u) {\n    var inV = this._in[v];\n    if (inV) {\n      var edges = _.values(inV);\n      if (!u) {\n        return edges;\n      }\n      return _.filter(edges, function (edge) {\n        return edge.v === u;\n      });\n    }\n  }\n  outEdges(v, w) {\n    var outV = this._out[v];\n    if (outV) {\n      var edges = _.values(outV);\n      if (!w) {\n        return edges;\n      }\n      return _.filter(edges, function (edge) {\n        return edge.w === w;\n      });\n    }\n  }\n  nodeEdges(v, w) {\n    var inEdges = this.inEdges(v, w);\n    if (inEdges) {\n      return inEdges.concat(this.outEdges(v, w));\n    }\n  }\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\n\nfunction decrementOrRemoveEntry(map, k) {\n  if (!--map[k]) {\n    delete map[k];\n  }\n}\n\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = '' + v_;\n  var w = '' + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = '' + v_;\n  var w = '' + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj = { v: v, w: w };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\n\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class ErrorWithLocation extends Error {\n    constructor(node, message) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\nexport function assertUnreachable(_) {\n    throw new Error('Error! The input value was not handled.');\n}\n//# sourceMappingURL=errors.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nexport class StreamImpl {\n    constructor(startFn, nextFn) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map(element => [\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state => {\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = state.iterator.next();\n                if (!result.done) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    join(separator = ',') {\n        const iterator = this.iterator();\n        let value = '';\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new StreamImpl(this.startFn, (state) => {\n            const { done, value } = this.nextFn(state);\n            if (done) {\n                return DONE_RESULT;\n            }\n            else {\n                return { done: false, value: callbackfn(value) };\n            }\n        });\n    }\n    filter(predicate) {\n        return new StreamImpl(this.startFn, state => {\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter(e => e !== undefined && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            }\n            else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if (isIterable(mapped)) {\n                        state.iterator = mapped[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: mapped };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === undefined) {\n            depth = 1;\n        }\n        if (depth <= 0) {\n            return this;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) : this;\n        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = stream.nextFn(state.this);\n                if (!done) {\n                    if (isIterable(value)) {\n                        state.iterator = value[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: value };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new StreamImpl(() => {\n            const state = this.startFn();\n            for (let i = 0; i < skipCount; i++) {\n                const next = this.nextFn(state);\n                if (next.done) {\n                    return state;\n                }\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {\n            state.size++;\n            if (state.size > maxSize) {\n                return DONE_RESULT;\n            }\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        return new StreamImpl(() => ({ set: new Set(), internalState: this.startFn() }), state => {\n            let result;\n            do {\n                result = this.nextFn(state.internalState);\n                if (!result.done) {\n                    const value = by ? by(result.value) : result.value;\n                    if (!state.set.has(value)) {\n                        state.set.add(value);\n                        return result;\n                    }\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = new Set();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\nfunction toString(item) {\n    if (typeof item === 'string') {\n        return item;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof item.toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return item.toString();\n    }\n    return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\n}\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nexport const DONE_RESULT = Object.freeze({ done: true, value: undefined });\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nexport function stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl(() => ({ index: 0 }), (state) => {\n                if (state.index < collection.length) {\n                    return { done: false, value: collection[state.index++] };\n                }\n                else {\n                    return DONE_RESULT;\n                }\n            });\n        }\n    }\n    if (collections.length > 1) {\n        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (!next.done) {\n                        return next;\n                    }\n                    state.iterator = undefined;\n                }\n                if (state.array) {\n                    if (state.arrIndex < state.array.length) {\n                        return { done: false, value: state.array[state.arrIndex++] };\n                    }\n                    state.array = undefined;\n                    state.arrIndex = 0;\n                }\n                if (state.collIndex < collections.length) {\n                    const collection = collections[state.collIndex++];\n                    if (isIterable(collection)) {\n                        state.iterator = collection[Symbol.iterator]();\n                    }\n                    else if (collection && typeof collection.length === 'number') {\n                        state.array = collection;\n                    }\n                }\n            } while (state.iterator || state.array || state.collIndex < collections.length);\n            return DONE_RESULT;\n        });\n    }\n    return EMPTY_STREAM;\n}\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nexport class TreeStreamImpl extends StreamImpl {\n    constructor(root, children, options) {\n        super(() => ({\n            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n            pruned: false\n        }), state => {\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while (state.iterators.length > 0) {\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) {\n                    state.iterators.pop();\n                }\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nexport var Reduction;\n(function (Reduction) {\n    /**\n     * Compute the sum of a number stream.\n     */\n    function sum(stream) {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n    Reduction.sum = sum;\n    /**\n     * Compute the product of a number stream.\n     */\n    function product(stream) {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n    Reduction.product = product;\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function min(stream) {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n    Reduction.min = min;\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function max(stream) {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n    Reduction.max = max;\n})(Reduction || (Reduction = {}));\n//# sourceMappingURL=stream.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer } from 'chevrotain';\nimport { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';\nimport { streamAllContents } from '../utils/ast-utils.js';\nimport { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';\nimport { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';\nimport { stream } from '../utils/stream.js';\nexport class DefaultTokenBuilder {\n    constructor() {\n        /**\n         * The list of diagnostics stored during the lexing process of a single text.\n         */\n        this.diagnostics = [];\n    }\n    buildTokens(grammar, options) {\n        const reachableRules = stream(getAllReachableRules(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespace(pattern)) {\n                tokens.unshift(terminalToken);\n            }\n            else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don't need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flushLexingReport(text) {\n        return { diagnostics: this.popDiagnostics() };\n    }\n    popDiagnostics() {\n        const diagnostics = [...this.diagnostics];\n        this.diagnostics = [];\n        return diagnostics;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n        };\n        if (typeof pattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';\n        }\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes('u') || regex.flags.includes('s')) {\n            // Unicode and dotall regexes are not supported by Chevrotain.\n            return true;\n        }\n        else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(isParserRule)\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\n        const tokenType = {\n            name: keyword.value,\n            PATTERN: keywordPattern,\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n        if (typeof keywordPattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        return tokenType;\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ?\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\n            keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token) => {\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches('^' + pattern.source + '$', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n//# sourceMappingURL=token-builder.js.map","import {\n  getDiagramElement,\n  setupViewPortForSVG\n} from \"./chunk-RZ5BOZE2.mjs\";\nimport {\n  render\n} from \"./chunk-TYCBKAJE.mjs\";\nimport {\n  generateId,\n  utils_default\n} from \"./chunk-O4NI6UNU.mjs\";\nimport {\n  __name,\n  clear,\n  common_default,\n  getAccDescription,\n  getAccTitle,\n  getConfig2 as getConfig,\n  getDiagramTitle,\n  log,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/diagrams/state/parser/stateDiagram.jison\nvar parser = function() {\n  var o = /* @__PURE__ */ __name(function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;\n    return o2;\n  }, \"o\"), $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 4], $V3 = [2, 4], $V4 = [1, 9], $V5 = [1, 11], $V6 = [1, 16], $V7 = [1, 17], $V8 = [1, 18], $V9 = [1, 19], $Va = [1, 32], $Vb = [1, 20], $Vc = [1, 21], $Vd = [1, 22], $Ve = [1, 23], $Vf = [1, 24], $Vg = [1, 26], $Vh = [1, 27], $Vi = [1, 28], $Vj = [1, 29], $Vk = [1, 30], $Vl = [1, 31], $Vm = [1, 34], $Vn = [1, 35], $Vo = [1, 36], $Vp = [1, 37], $Vq = [1, 33], $Vr = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $Vs = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $Vt = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54];\n  var parser2 = {\n    trace: /* @__PURE__ */ __name(function trace() {\n    }, \"trace\"),\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"SPACE\": 4, \"NL\": 5, \"SD\": 6, \"document\": 7, \"line\": 8, \"statement\": 9, \"classDefStatement\": 10, \"styleStatement\": 11, \"cssClassStatement\": 12, \"idStatement\": 13, \"DESCR\": 14, \"-->\": 15, \"HIDE_EMPTY\": 16, \"scale\": 17, \"WIDTH\": 18, \"COMPOSIT_STATE\": 19, \"STRUCT_START\": 20, \"STRUCT_STOP\": 21, \"STATE_DESCR\": 22, \"AS\": 23, \"ID\": 24, \"FORK\": 25, \"JOIN\": 26, \"CHOICE\": 27, \"CONCURRENT\": 28, \"note\": 29, \"notePosition\": 30, \"NOTE_TEXT\": 31, \"direction\": 32, \"acc_title\": 33, \"acc_title_value\": 34, \"acc_descr\": 35, \"acc_descr_value\": 36, \"acc_descr_multiline_value\": 37, \"classDef\": 38, \"CLASSDEF_ID\": 39, \"CLASSDEF_STYLEOPTS\": 40, \"DEFAULT\": 41, \"style\": 42, \"STYLE_IDS\": 43, \"STYLEDEF_STYLEOPTS\": 44, \"class\": 45, \"CLASSENTITY_IDS\": 46, \"STYLECLASS\": 47, \"direction_tb\": 48, \"direction_bt\": 49, \"direction_rl\": 50, \"direction_lr\": 51, \"eol\": 52, \";\": 53, \"EDGE_STATE\": 54, \"STYLE_SEPARATOR\": 55, \"left_of\": 56, \"right_of\": 57, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 4: \"SPACE\", 5: \"NL\", 6: \"SD\", 14: \"DESCR\", 15: \"-->\", 16: \"HIDE_EMPTY\", 17: \"scale\", 18: \"WIDTH\", 19: \"COMPOSIT_STATE\", 20: \"STRUCT_START\", 21: \"STRUCT_STOP\", 22: \"STATE_DESCR\", 23: \"AS\", 24: \"ID\", 25: \"FORK\", 26: \"JOIN\", 27: \"CHOICE\", 28: \"CONCURRENT\", 29: \"note\", 31: \"NOTE_TEXT\", 33: \"acc_title\", 34: \"acc_title_value\", 35: \"acc_descr\", 36: \"acc_descr_value\", 37: \"acc_descr_multiline_value\", 38: \"classDef\", 39: \"CLASSDEF_ID\", 40: \"CLASSDEF_STYLEOPTS\", 41: \"DEFAULT\", 42: \"style\", 43: \"STYLE_IDS\", 44: \"STYLEDEF_STYLEOPTS\", 45: \"class\", 46: \"CLASSENTITY_IDS\", 47: \"STYLECLASS\", 48: \"direction_tb\", 49: \"direction_bt\", 50: \"direction_rl\", 51: \"direction_lr\", 53: \";\", 54: \"EDGE_STATE\", 55: \"STYLE_SEPARATOR\", 56: \"left_of\", 57: \"right_of\" },\n    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 3], [9, 4], [9, 1], [9, 2], [9, 1], [9, 4], [9, 3], [9, 6], [9, 1], [9, 1], [9, 1], [9, 1], [9, 4], [9, 4], [9, 1], [9, 2], [9, 2], [9, 1], [10, 3], [10, 3], [11, 3], [12, 3], [32, 1], [32, 1], [32, 1], [32, 1], [52, 1], [52, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1]],\n    performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 3:\n          yy.setRootDoc($$[$0]);\n          return $$[$0];\n          break;\n        case 4:\n          this.$ = [];\n          break;\n        case 5:\n          if ($$[$0] != \"nl\") {\n            $$[$0 - 1].push($$[$0]);\n            this.$ = $$[$0 - 1];\n          }\n          break;\n        case 6:\n        case 7:\n          this.$ = $$[$0];\n          break;\n        case 8:\n          this.$ = \"nl\";\n          break;\n        case 12:\n          this.$ = $$[$0];\n          break;\n        case 13:\n          const stateStmt = $$[$0 - 1];\n          stateStmt.description = yy.trimColon($$[$0]);\n          this.$ = stateStmt;\n          break;\n        case 14:\n          this.$ = { stmt: \"relation\", state1: $$[$0 - 2], state2: $$[$0] };\n          break;\n        case 15:\n          const relDescription = yy.trimColon($$[$0]);\n          this.$ = { stmt: \"relation\", state1: $$[$0 - 3], state2: $$[$0 - 1], description: relDescription };\n          break;\n        case 19:\n          this.$ = { stmt: \"state\", id: $$[$0 - 3], type: \"default\", description: \"\", doc: $$[$0 - 1] };\n          break;\n        case 20:\n          var id = $$[$0];\n          var description = $$[$0 - 2].trim();\n          if ($$[$0].match(\":\")) {\n            var parts = $$[$0].split(\":\");\n            id = parts[0];\n            description = [description, parts[1]];\n          }\n          this.$ = { stmt: \"state\", id, type: \"default\", description };\n          break;\n        case 21:\n          this.$ = { stmt: \"state\", id: $$[$0 - 3], type: \"default\", description: $$[$0 - 5], doc: $$[$0 - 1] };\n          break;\n        case 22:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"fork\" };\n          break;\n        case 23:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"join\" };\n          break;\n        case 24:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"choice\" };\n          break;\n        case 25:\n          this.$ = { stmt: \"state\", id: yy.getDividerId(), type: \"divider\" };\n          break;\n        case 26:\n          this.$ = { stmt: \"state\", id: $$[$0 - 1].trim(), note: { position: $$[$0 - 2].trim(), text: $$[$0].trim() } };\n          break;\n        case 29:\n          this.$ = $$[$0].trim();\n          yy.setAccTitle(this.$);\n          break;\n        case 30:\n        case 31:\n          this.$ = $$[$0].trim();\n          yy.setAccDescription(this.$);\n          break;\n        case 32:\n        case 33:\n          this.$ = { stmt: \"classDef\", id: $$[$0 - 1].trim(), classes: $$[$0].trim() };\n          break;\n        case 34:\n          this.$ = { stmt: \"style\", id: $$[$0 - 1].trim(), styleClass: $$[$0].trim() };\n          break;\n        case 35:\n          this.$ = { stmt: \"applyClass\", id: $$[$0 - 1].trim(), styleClass: $$[$0].trim() };\n          break;\n        case 36:\n          yy.setDirection(\"TB\");\n          this.$ = { stmt: \"dir\", value: \"TB\" };\n          break;\n        case 37:\n          yy.setDirection(\"BT\");\n          this.$ = { stmt: \"dir\", value: \"BT\" };\n          break;\n        case 38:\n          yy.setDirection(\"RL\");\n          this.$ = { stmt: \"dir\", value: \"RL\" };\n          break;\n        case 39:\n          yy.setDirection(\"LR\");\n          this.$ = { stmt: \"dir\", value: \"LR\" };\n          break;\n        case 42:\n        case 43:\n          this.$ = { stmt: \"state\", id: $$[$0].trim(), type: \"default\", description: \"\" };\n          break;\n        case 44:\n          this.$ = { stmt: \"state\", id: $$[$0 - 2].trim(), classes: [$$[$0].trim()], type: \"default\", description: \"\" };\n          break;\n        case 45:\n          this.$ = { stmt: \"state\", id: $$[$0 - 2].trim(), classes: [$$[$0].trim()], type: \"default\", description: \"\" };\n          break;\n      }\n    }, \"anonymous\"),\n    table: [{ 3: 1, 4: $V0, 5: $V1, 6: $V2 }, { 1: [3] }, { 3: 5, 4: $V0, 5: $V1, 6: $V2 }, { 3: 6, 4: $V0, 5: $V1, 6: $V2 }, o([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $V3, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 5]), { 9: 38, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 7]), o($Vr, [2, 8]), o($Vr, [2, 9]), o($Vr, [2, 10]), o($Vr, [2, 11]), o($Vr, [2, 12], { 14: [1, 39], 15: [1, 40] }), o($Vr, [2, 16]), { 18: [1, 41] }, o($Vr, [2, 18], { 20: [1, 42] }), { 23: [1, 43] }, o($Vr, [2, 22]), o($Vr, [2, 23]), o($Vr, [2, 24]), o($Vr, [2, 25]), { 30: 44, 31: [1, 45], 56: [1, 46], 57: [1, 47] }, o($Vr, [2, 28]), { 34: [1, 48] }, { 36: [1, 49] }, o($Vr, [2, 31]), { 39: [1, 50], 41: [1, 51] }, { 43: [1, 52] }, { 46: [1, 53] }, o($Vs, [2, 42], { 55: [1, 54] }), o($Vs, [2, 43], { 55: [1, 55] }), o($Vr, [2, 36]), o($Vr, [2, 37]), o($Vr, [2, 38]), o($Vr, [2, 39]), o($Vr, [2, 6]), o($Vr, [2, 13]), { 13: 56, 24: $Va, 54: $Vq }, o($Vr, [2, 17]), o($Vt, $V3, { 7: 57 }), { 24: [1, 58] }, { 24: [1, 59] }, { 23: [1, 60] }, { 24: [2, 46] }, { 24: [2, 47] }, o($Vr, [2, 29]), o($Vr, [2, 30]), { 40: [1, 61] }, { 40: [1, 62] }, { 44: [1, 63] }, { 47: [1, 64] }, { 24: [1, 65] }, { 24: [1, 66] }, o($Vr, [2, 14], { 14: [1, 67] }), { 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 21: [1, 68], 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 20], { 20: [1, 69] }), { 31: [1, 70] }, { 24: [1, 71] }, o($Vr, [2, 32]), o($Vr, [2, 33]), o($Vr, [2, 34]), o($Vr, [2, 35]), o($Vs, [2, 44]), o($Vs, [2, 45]), o($Vr, [2, 15]), o($Vr, [2, 19]), o($Vt, $V3, { 7: 72 }), o($Vr, [2, 26]), o($Vr, [2, 27]), { 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 21: [1, 73], 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 21])],\n    defaultActions: { 5: [2, 1], 6: [2, 2], 46: [2, 46], 47: [2, 47] },\n    parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    }, \"parseError\"),\n    parse: /* @__PURE__ */ __name(function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n      }\n      __name(popStack, \"popStack\");\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      __name(lex, \"lex\");\n      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n              if (recovering > 0) {\n                recovering--;\n              }\n            } else {\n              symbol = preErrorSymbol;\n              preErrorSymbol = null;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }, \"parse\")\n  };\n  var lexer = /* @__PURE__ */ function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      }, \"parseError\"),\n      // resets the lexer, sets new input\n      setInput: /* @__PURE__ */ __name(function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      }, \"setInput\"),\n      // consumes and returns one char from the input\n      input: /* @__PURE__ */ __name(function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      }, \"input\"),\n      // unshifts one char (or a string) into the input\n      unput: /* @__PURE__ */ __name(function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      }, \"unput\"),\n      // When called from action, caches matched text and appends it on next action\n      more: /* @__PURE__ */ __name(function() {\n        this._more = true;\n        return this;\n      }, \"more\"),\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: /* @__PURE__ */ __name(function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      }, \"reject\"),\n      // retain first n characters of the match\n      less: /* @__PURE__ */ __name(function(n) {\n        this.unput(this.match.slice(n));\n      }, \"less\"),\n      // displays already matched input, i.e. for error messages\n      pastInput: /* @__PURE__ */ __name(function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      }, \"pastInput\"),\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: /* @__PURE__ */ __name(function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      }, \"upcomingInput\"),\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: /* @__PURE__ */ __name(function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      }, \"showPosition\"),\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      }, \"test_match\"),\n      // return next match in input\n      next: /* @__PURE__ */ __name(function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      }, \"next\"),\n      // return next match that has a token\n      lex: /* @__PURE__ */ __name(function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      }, \"lex\"),\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: /* @__PURE__ */ __name(function begin(condition) {\n        this.conditionStack.push(condition);\n      }, \"begin\"),\n      // pop the previously active lexer condition state off the condition stack\n      popState: /* @__PURE__ */ __name(function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      }, \"popState\"),\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: /* @__PURE__ */ __name(function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      }, \"_currentRules\"),\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: /* @__PURE__ */ __name(function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      }, \"topState\"),\n      // alias for begin(condition)\n      pushState: /* @__PURE__ */ __name(function pushState(condition) {\n        this.begin(condition);\n      }, \"pushState\"),\n      // return the number of states currently on the stack\n      stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {\n        return this.conditionStack.length;\n      }, \"stateStackSize\"),\n      options: { \"case-insensitive\": true },\n      performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        var YYSTATE = YY_START;\n        switch ($avoiding_name_collisions) {\n          case 0:\n            return 41;\n            break;\n          case 1:\n            return 48;\n            break;\n          case 2:\n            return 49;\n            break;\n          case 3:\n            return 50;\n            break;\n          case 4:\n            return 51;\n            break;\n          case 5:\n            break;\n          case 6:\n            {\n            }\n            break;\n          case 7:\n            return 5;\n            break;\n          case 8:\n            break;\n          case 9:\n            break;\n          case 10:\n            break;\n          case 11:\n            break;\n          case 12:\n            this.pushState(\"SCALE\");\n            return 17;\n            break;\n          case 13:\n            return 18;\n            break;\n          case 14:\n            this.popState();\n            break;\n          case 15:\n            this.begin(\"acc_title\");\n            return 33;\n            break;\n          case 16:\n            this.popState();\n            return \"acc_title_value\";\n            break;\n          case 17:\n            this.begin(\"acc_descr\");\n            return 35;\n            break;\n          case 18:\n            this.popState();\n            return \"acc_descr_value\";\n            break;\n          case 19:\n            this.begin(\"acc_descr_multiline\");\n            break;\n          case 20:\n            this.popState();\n            break;\n          case 21:\n            return \"acc_descr_multiline_value\";\n            break;\n          case 22:\n            this.pushState(\"CLASSDEF\");\n            return 38;\n            break;\n          case 23:\n            this.popState();\n            this.pushState(\"CLASSDEFID\");\n            return \"DEFAULT_CLASSDEF_ID\";\n            break;\n          case 24:\n            this.popState();\n            this.pushState(\"CLASSDEFID\");\n            return 39;\n            break;\n          case 25:\n            this.popState();\n            return 40;\n            break;\n          case 26:\n            this.pushState(\"CLASS\");\n            return 45;\n            break;\n          case 27:\n            this.popState();\n            this.pushState(\"CLASS_STYLE\");\n            return 46;\n            break;\n          case 28:\n            this.popState();\n            return 47;\n            break;\n          case 29:\n            this.pushState(\"STYLE\");\n            return 42;\n            break;\n          case 30:\n            this.popState();\n            this.pushState(\"STYLEDEF_STYLES\");\n            return 43;\n            break;\n          case 31:\n            this.popState();\n            return 44;\n            break;\n          case 32:\n            this.pushState(\"SCALE\");\n            return 17;\n            break;\n          case 33:\n            return 18;\n            break;\n          case 34:\n            this.popState();\n            break;\n          case 35:\n            this.pushState(\"STATE\");\n            break;\n          case 36:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 25;\n            break;\n          case 37:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 26;\n            break;\n          case 38:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -10).trim();\n            return 27;\n            break;\n          case 39:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 25;\n            break;\n          case 40:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 26;\n            break;\n          case 41:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -10).trim();\n            return 27;\n            break;\n          case 42:\n            return 48;\n            break;\n          case 43:\n            return 49;\n            break;\n          case 44:\n            return 50;\n            break;\n          case 45:\n            return 51;\n            break;\n          case 46:\n            this.pushState(\"STATE_STRING\");\n            break;\n          case 47:\n            this.pushState(\"STATE_ID\");\n            return \"AS\";\n            break;\n          case 48:\n            this.popState();\n            return \"ID\";\n            break;\n          case 49:\n            this.popState();\n            break;\n          case 50:\n            return \"STATE_DESCR\";\n            break;\n          case 51:\n            return 19;\n            break;\n          case 52:\n            this.popState();\n            break;\n          case 53:\n            this.popState();\n            this.pushState(\"struct\");\n            return 20;\n            break;\n          case 54:\n            break;\n          case 55:\n            this.popState();\n            return 21;\n            break;\n          case 56:\n            break;\n          case 57:\n            this.begin(\"NOTE\");\n            return 29;\n            break;\n          case 58:\n            this.popState();\n            this.pushState(\"NOTE_ID\");\n            return 56;\n            break;\n          case 59:\n            this.popState();\n            this.pushState(\"NOTE_ID\");\n            return 57;\n            break;\n          case 60:\n            this.popState();\n            this.pushState(\"FLOATING_NOTE\");\n            break;\n          case 61:\n            this.popState();\n            this.pushState(\"FLOATING_NOTE_ID\");\n            return \"AS\";\n            break;\n          case 62:\n            break;\n          case 63:\n            return \"NOTE_TEXT\";\n            break;\n          case 64:\n            this.popState();\n            return \"ID\";\n            break;\n          case 65:\n            this.popState();\n            this.pushState(\"NOTE_TEXT\");\n            return 24;\n            break;\n          case 66:\n            this.popState();\n            yy_.yytext = yy_.yytext.substr(2).trim();\n            return 31;\n            break;\n          case 67:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 31;\n            break;\n          case 68:\n            return 6;\n            break;\n          case 69:\n            return 6;\n            break;\n          case 70:\n            return 16;\n            break;\n          case 71:\n            return 54;\n            break;\n          case 72:\n            return 24;\n            break;\n          case 73:\n            yy_.yytext = yy_.yytext.trim();\n            return 14;\n            break;\n          case 74:\n            return 15;\n            break;\n          case 75:\n            return 28;\n            break;\n          case 76:\n            return 55;\n            break;\n          case 77:\n            return 5;\n            break;\n          case 78:\n            return \"INVALID\";\n            break;\n        }\n      }, \"anonymous\"),\n      rules: [/^(?:default\\b)/i, /^(?:.*direction\\s+TB[^\\n]*)/i, /^(?:.*direction\\s+BT[^\\n]*)/i, /^(?:.*direction\\s+RL[^\\n]*)/i, /^(?:.*direction\\s+LR[^\\n]*)/i, /^(?:%%(?!\\{)[^\\n]*)/i, /^(?:[^\\}]%%[^\\n]*)/i, /^(?:[\\n]+)/i, /^(?:[\\s]+)/i, /^(?:((?!\\n)\\s)+)/i, /^(?:#[^\\n]*)/i, /^(?:%[^\\n]*)/i, /^(?:scale\\s+)/i, /^(?:\\d+)/i, /^(?:\\s+width\\b)/i, /^(?:accTitle\\s*:\\s*)/i, /^(?:(?!\\n||)*[^\\n]*)/i, /^(?:accDescr\\s*:\\s*)/i, /^(?:(?!\\n||)*[^\\n]*)/i, /^(?:accDescr\\s*\\{\\s*)/i, /^(?:[\\}])/i, /^(?:[^\\}]*)/i, /^(?:classDef\\s+)/i, /^(?:DEFAULT\\s+)/i, /^(?:\\w+\\s+)/i, /^(?:[^\\n]*)/i, /^(?:class\\s+)/i, /^(?:(\\w+)+((,\\s*\\w+)*))/i, /^(?:[^\\n]*)/i, /^(?:style\\s+)/i, /^(?:[\\w,]+\\s+)/i, /^(?:[^\\n]*)/i, /^(?:scale\\s+)/i, /^(?:\\d+)/i, /^(?:\\s+width\\b)/i, /^(?:state\\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\\[\\[fork\\]\\])/i, /^(?:.*\\[\\[join\\]\\])/i, /^(?:.*\\[\\[choice\\]\\])/i, /^(?:.*direction\\s+TB[^\\n]*)/i, /^(?:.*direction\\s+BT[^\\n]*)/i, /^(?:.*direction\\s+RL[^\\n]*)/i, /^(?:.*direction\\s+LR[^\\n]*)/i, /^(?:[\"])/i, /^(?:\\s*as\\s+)/i, /^(?:[^\\n\\{]*)/i, /^(?:[\"])/i, /^(?:[^\"]*)/i, /^(?:[^\\n\\s\\{]+)/i, /^(?:\\n)/i, /^(?:\\{)/i, /^(?:%%(?!\\{)[^\\n]*)/i, /^(?:\\})/i, /^(?:[\\n])/i, /^(?:note\\s+)/i, /^(?:left of\\b)/i, /^(?:right of\\b)/i, /^(?:\")/i, /^(?:\\s*as\\s*)/i, /^(?:[\"])/i, /^(?:[^\"]*)/i, /^(?:[^\\n]*)/i, /^(?:\\s*[^:\\n\\s\\-]+)/i, /^(?:\\s*:[^:\\n;]+)/i, /^(?:[\\s\\S]*?end note\\b)/i, /^(?:stateDiagram\\s+)/i, /^(?:stateDiagram-v2\\s+)/i, /^(?:hide empty description\\b)/i, /^(?:\\[\\*\\])/i, /^(?:[^:\\n\\s\\-\\{]+)/i, /^(?:\\s*:[^:\\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],\n      conditions: { \"LINE\": { \"rules\": [9, 10], \"inclusive\": false }, \"struct\": { \"rules\": [9, 10, 22, 26, 29, 35, 42, 43, 44, 45, 54, 55, 56, 57, 71, 72, 73, 74, 75], \"inclusive\": false }, \"FLOATING_NOTE_ID\": { \"rules\": [64], \"inclusive\": false }, \"FLOATING_NOTE\": { \"rules\": [61, 62, 63], \"inclusive\": false }, \"NOTE_TEXT\": { \"rules\": [66, 67], \"inclusive\": false }, \"NOTE_ID\": { \"rules\": [65], \"inclusive\": false }, \"NOTE\": { \"rules\": [58, 59, 60], \"inclusive\": false }, \"STYLEDEF_STYLEOPTS\": { \"rules\": [], \"inclusive\": false }, \"STYLEDEF_STYLES\": { \"rules\": [31], \"inclusive\": false }, \"STYLE_IDS\": { \"rules\": [], \"inclusive\": false }, \"STYLE\": { \"rules\": [30], \"inclusive\": false }, \"CLASS_STYLE\": { \"rules\": [28], \"inclusive\": false }, \"CLASS\": { \"rules\": [27], \"inclusive\": false }, \"CLASSDEFID\": { \"rules\": [25], \"inclusive\": false }, \"CLASSDEF\": { \"rules\": [23, 24], \"inclusive\": false }, \"acc_descr_multiline\": { \"rules\": [20, 21], \"inclusive\": false }, \"acc_descr\": { \"rules\": [18], \"inclusive\": false }, \"acc_title\": { \"rules\": [16], \"inclusive\": false }, \"SCALE\": { \"rules\": [13, 14, 33, 34], \"inclusive\": false }, \"ALIAS\": { \"rules\": [], \"inclusive\": false }, \"STATE_ID\": { \"rules\": [48], \"inclusive\": false }, \"STATE_STRING\": { \"rules\": [49, 50], \"inclusive\": false }, \"FORK_STATE\": { \"rules\": [], \"inclusive\": false }, \"STATE\": { \"rules\": [9, 10, 36, 37, 38, 39, 40, 41, 46, 47, 51, 52, 53], \"inclusive\": false }, \"ID\": { \"rules\": [9, 10], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 15, 17, 19, 22, 26, 29, 32, 35, 53, 57, 68, 69, 70, 71, 72, 73, 74, 76, 77, 78], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  __name(Parser, \"Parser\");\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nvar stateDiagram_default = parser;\n\n// src/diagrams/state/stateCommon.ts\nvar DEFAULT_DIAGRAM_DIRECTION = \"TB\";\nvar DEFAULT_NESTED_DOC_DIR = \"TB\";\nvar STMT_DIRECTION = \"dir\";\nvar STMT_STATE = \"state\";\nvar STMT_RELATION = \"relation\";\nvar STMT_CLASSDEF = \"classDef\";\nvar STMT_STYLEDEF = \"style\";\nvar STMT_APPLYCLASS = \"applyClass\";\nvar DEFAULT_STATE_TYPE = \"default\";\nvar DIVIDER_TYPE = \"divider\";\nvar G_EDGE_STYLE = \"fill:none\";\nvar G_EDGE_ARROWHEADSTYLE = \"fill: #333\";\nvar G_EDGE_LABELPOS = \"c\";\nvar G_EDGE_LABELTYPE = \"text\";\nvar G_EDGE_THICKNESS = \"normal\";\nvar SHAPE_STATE = \"rect\";\nvar SHAPE_STATE_WITH_DESC = \"rectWithTitle\";\nvar SHAPE_START = \"stateStart\";\nvar SHAPE_END = \"stateEnd\";\nvar SHAPE_DIVIDER = \"divider\";\nvar SHAPE_GROUP = \"roundedWithTitle\";\nvar SHAPE_NOTE = \"note\";\nvar SHAPE_NOTEGROUP = \"noteGroup\";\nvar CSS_DIAGRAM = \"statediagram\";\nvar CSS_STATE = \"state\";\nvar CSS_DIAGRAM_STATE = `${CSS_DIAGRAM}-${CSS_STATE}`;\nvar CSS_EDGE = \"transition\";\nvar CSS_NOTE = \"note\";\nvar CSS_NOTE_EDGE = \"note-edge\";\nvar CSS_EDGE_NOTE_EDGE = `${CSS_EDGE} ${CSS_NOTE_EDGE}`;\nvar CSS_DIAGRAM_NOTE = `${CSS_DIAGRAM}-${CSS_NOTE}`;\nvar CSS_CLUSTER = \"cluster\";\nvar CSS_DIAGRAM_CLUSTER = `${CSS_DIAGRAM}-${CSS_CLUSTER}`;\nvar CSS_CLUSTER_ALT = \"cluster-alt\";\nvar CSS_DIAGRAM_CLUSTER_ALT = `${CSS_DIAGRAM}-${CSS_CLUSTER_ALT}`;\nvar PARENT = \"parent\";\nvar NOTE = \"note\";\nvar DOMID_STATE = \"state\";\nvar DOMID_TYPE_SPACER = \"----\";\nvar NOTE_ID = `${DOMID_TYPE_SPACER}${NOTE}`;\nvar PARENT_ID = `${DOMID_TYPE_SPACER}${PARENT}`;\n\n// src/diagrams/state/stateRenderer-v3-unified.ts\nvar getDir = /* @__PURE__ */ __name((parsedItem, defaultDir = DEFAULT_NESTED_DOC_DIR) => {\n  if (!parsedItem.doc) {\n    return defaultDir;\n  }\n  let dir = defaultDir;\n  for (const parsedItemDoc of parsedItem.doc) {\n    if (parsedItemDoc.stmt === \"dir\") {\n      dir = parsedItemDoc.value;\n    }\n  }\n  return dir;\n}, \"getDir\");\nvar getClasses = /* @__PURE__ */ __name(function(text, diagramObj) {\n  return diagramObj.db.getClasses();\n}, \"getClasses\");\nvar draw = /* @__PURE__ */ __name(async function(text, id, _version, diag) {\n  log.info(\"REF0:\");\n  log.info(\"Drawing state diagram (v2)\", id);\n  const { securityLevel, state: conf, layout } = getConfig();\n  diag.db.extract(diag.db.getRootDocV2());\n  const data4Layout = diag.db.getData();\n  const svg = getDiagramElement(id, securityLevel);\n  data4Layout.type = diag.type;\n  data4Layout.layoutAlgorithm = layout;\n  data4Layout.nodeSpacing = conf?.nodeSpacing || 50;\n  data4Layout.rankSpacing = conf?.rankSpacing || 50;\n  data4Layout.markers = [\"barb\"];\n  data4Layout.diagramId = id;\n  await render(data4Layout, svg);\n  const padding = 8;\n  utils_default.insertTitle(\n    svg,\n    \"statediagramTitleText\",\n    conf?.titleTopMargin ?? 25,\n    diag.db.getDiagramTitle()\n  );\n  setupViewPortForSVG(svg, padding, CSS_DIAGRAM, conf?.useMaxWidth ?? true);\n}, \"draw\");\nvar stateRenderer_v3_unified_default = {\n  getClasses,\n  draw,\n  getDir\n};\n\n// src/diagrams/state/dataFetcher.js\nvar nodeDb = /* @__PURE__ */ new Map();\nvar graphItemCount = 0;\nfunction stateDomId(itemId = \"\", counter = 0, type = \"\", typeSpacer = DOMID_TYPE_SPACER) {\n  const typeStr = type !== null && type.length > 0 ? `${typeSpacer}${type}` : \"\";\n  return `${DOMID_STATE}-${itemId}${typeStr}-${counter}`;\n}\n__name(stateDomId, \"stateDomId\");\nvar setupDoc = /* @__PURE__ */ __name((parentParsedItem, doc, diagramStates, nodes, edges, altFlag, look, classes) => {\n  log.trace(\"items\", doc);\n  doc.forEach((item) => {\n    switch (item.stmt) {\n      case STMT_STATE:\n        dataFetcher(parentParsedItem, item, diagramStates, nodes, edges, altFlag, look, classes);\n        break;\n      case DEFAULT_STATE_TYPE:\n        dataFetcher(parentParsedItem, item, diagramStates, nodes, edges, altFlag, look, classes);\n        break;\n      case STMT_RELATION:\n        {\n          dataFetcher(\n            parentParsedItem,\n            item.state1,\n            diagramStates,\n            nodes,\n            edges,\n            altFlag,\n            look,\n            classes\n          );\n          dataFetcher(\n            parentParsedItem,\n            item.state2,\n            diagramStates,\n            nodes,\n            edges,\n            altFlag,\n            look,\n            classes\n          );\n          const edgeData = {\n            id: \"edge\" + graphItemCount,\n            start: item.state1.id,\n            end: item.state2.id,\n            arrowhead: \"normal\",\n            arrowTypeEnd: \"arrow_barb\",\n            style: G_EDGE_STYLE,\n            labelStyle: \"\",\n            label: common_default.sanitizeText(item.description, getConfig()),\n            arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n            labelpos: G_EDGE_LABELPOS,\n            labelType: G_EDGE_LABELTYPE,\n            thickness: G_EDGE_THICKNESS,\n            classes: CSS_EDGE,\n            look\n          };\n          edges.push(edgeData);\n          graphItemCount++;\n        }\n        break;\n    }\n  });\n}, \"setupDoc\");\nvar getDir2 = /* @__PURE__ */ __name((parsedItem, defaultDir = DEFAULT_NESTED_DOC_DIR) => {\n  let dir = defaultDir;\n  if (parsedItem.doc) {\n    for (const parsedItemDoc of parsedItem.doc) {\n      if (parsedItemDoc.stmt === \"dir\") {\n        dir = parsedItemDoc.value;\n      }\n    }\n  }\n  return dir;\n}, \"getDir\");\nfunction insertOrUpdateNode(nodes, nodeData, classes) {\n  if (!nodeData.id || nodeData.id === \"</join></fork>\" || nodeData.id === \"</choice>\") {\n    return;\n  }\n  if (nodeData.cssClasses) {\n    if (!Array.isArray(nodeData.cssCompiledStyles)) {\n      nodeData.cssCompiledStyles = [];\n    }\n    nodeData.cssClasses.split(\" \").forEach((cssClass) => {\n      if (classes.get(cssClass)) {\n        const classDef = classes.get(cssClass);\n        nodeData.cssCompiledStyles = [...nodeData.cssCompiledStyles, ...classDef.styles];\n      }\n    });\n  }\n  const existingNodeData = nodes.find((node) => node.id === nodeData.id);\n  if (existingNodeData) {\n    Object.assign(existingNodeData, nodeData);\n  } else {\n    nodes.push(nodeData);\n  }\n}\n__name(insertOrUpdateNode, \"insertOrUpdateNode\");\nfunction getClassesFromDbInfo(dbInfoItem) {\n  return dbInfoItem?.classes?.join(\" \") ?? \"\";\n}\n__name(getClassesFromDbInfo, \"getClassesFromDbInfo\");\nfunction getStylesFromDbInfo(dbInfoItem) {\n  return dbInfoItem?.styles ?? [];\n}\n__name(getStylesFromDbInfo, \"getStylesFromDbInfo\");\nvar dataFetcher = /* @__PURE__ */ __name((parent, parsedItem, diagramStates, nodes, edges, altFlag, look, classes) => {\n  const itemId = parsedItem.id;\n  const dbState = diagramStates.get(itemId);\n  const classStr = getClassesFromDbInfo(dbState);\n  const style = getStylesFromDbInfo(dbState);\n  log.info(\"dataFetcher parsedItem\", parsedItem, dbState, style);\n  if (itemId !== \"root\") {\n    let shape = SHAPE_STATE;\n    if (parsedItem.start === true) {\n      shape = SHAPE_START;\n    } else if (parsedItem.start === false) {\n      shape = SHAPE_END;\n    }\n    if (parsedItem.type !== DEFAULT_STATE_TYPE) {\n      shape = parsedItem.type;\n    }\n    if (!nodeDb.get(itemId)) {\n      nodeDb.set(itemId, {\n        id: itemId,\n        shape,\n        description: common_default.sanitizeText(itemId, getConfig()),\n        cssClasses: `${classStr} ${CSS_DIAGRAM_STATE}`,\n        cssStyles: style\n      });\n    }\n    const newNode = nodeDb.get(itemId);\n    if (parsedItem.description) {\n      if (Array.isArray(newNode.description)) {\n        newNode.shape = SHAPE_STATE_WITH_DESC;\n        newNode.description.push(parsedItem.description);\n      } else {\n        if (newNode.description?.length > 0) {\n          newNode.shape = SHAPE_STATE_WITH_DESC;\n          if (newNode.description === itemId) {\n            newNode.description = [parsedItem.description];\n          } else {\n            newNode.description = [newNode.description, parsedItem.description];\n          }\n        } else {\n          newNode.shape = SHAPE_STATE;\n          newNode.description = parsedItem.description;\n        }\n      }\n      newNode.description = common_default.sanitizeTextOrArray(newNode.description, getConfig());\n    }\n    if (newNode.description?.length === 1 && newNode.shape === SHAPE_STATE_WITH_DESC) {\n      if (newNode.type === \"group\") {\n        newNode.shape = SHAPE_GROUP;\n      } else {\n        newNode.shape = SHAPE_STATE;\n      }\n    }\n    if (!newNode.type && parsedItem.doc) {\n      log.info(\"Setting cluster for XCX\", itemId, getDir2(parsedItem));\n      newNode.type = \"group\";\n      newNode.isGroup = true;\n      newNode.dir = getDir2(parsedItem);\n      newNode.shape = parsedItem.type === DIVIDER_TYPE ? SHAPE_DIVIDER : SHAPE_GROUP;\n      newNode.cssClasses = `${newNode.cssClasses} ${CSS_DIAGRAM_CLUSTER} ${altFlag ? CSS_DIAGRAM_CLUSTER_ALT : \"\"}`;\n    }\n    const nodeData = {\n      labelStyle: \"\",\n      shape: newNode.shape,\n      label: newNode.description,\n      cssClasses: newNode.cssClasses,\n      cssCompiledStyles: [],\n      cssStyles: newNode.cssStyles,\n      id: itemId,\n      dir: newNode.dir,\n      domId: stateDomId(itemId, graphItemCount),\n      type: newNode.type,\n      isGroup: newNode.type === \"group\",\n      padding: 8,\n      rx: 10,\n      ry: 10,\n      look\n    };\n    if (nodeData.shape === SHAPE_DIVIDER) {\n      nodeData.label = \"\";\n    }\n    if (parent && parent.id !== \"root\") {\n      log.trace(\"Setting node \", itemId, \" to be child of its parent \", parent.id);\n      nodeData.parentId = parent.id;\n    }\n    nodeData.centerLabel = true;\n    if (parsedItem.note) {\n      const noteData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTE,\n        label: parsedItem.note.text,\n        cssClasses: CSS_DIAGRAM_NOTE,\n        // useHtmlLabels: false,\n        cssStyles: [],\n        cssCompilesStyles: [],\n        id: itemId + NOTE_ID + \"-\" + graphItemCount,\n        domId: stateDomId(itemId, graphItemCount, NOTE),\n        type: newNode.type,\n        isGroup: newNode.type === \"group\",\n        padding: getConfig().flowchart.padding,\n        look,\n        position: parsedItem.note.position\n      };\n      const parentNodeId = itemId + PARENT_ID;\n      const groupData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTEGROUP,\n        label: parsedItem.note.text,\n        cssClasses: newNode.cssClasses,\n        cssStyles: [],\n        id: itemId + PARENT_ID,\n        domId: stateDomId(itemId, graphItemCount, PARENT),\n        type: \"group\",\n        isGroup: true,\n        padding: 16,\n        //getConfig().flowchart.padding\n        look,\n        position: parsedItem.note.position\n      };\n      graphItemCount++;\n      groupData.id = parentNodeId;\n      noteData.parentId = parentNodeId;\n      insertOrUpdateNode(nodes, groupData, classes);\n      insertOrUpdateNode(nodes, noteData, classes);\n      insertOrUpdateNode(nodes, nodeData, classes);\n      let from = itemId;\n      let to = noteData.id;\n      if (parsedItem.note.position === \"left of\") {\n        from = noteData.id;\n        to = itemId;\n      }\n      edges.push({\n        id: from + \"-\" + to,\n        start: from,\n        end: to,\n        arrowhead: \"none\",\n        arrowTypeEnd: \"\",\n        style: G_EDGE_STYLE,\n        labelStyle: \"\",\n        classes: CSS_EDGE_NOTE_EDGE,\n        arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n        labelpos: G_EDGE_LABELPOS,\n        labelType: G_EDGE_LABELTYPE,\n        thickness: G_EDGE_THICKNESS,\n        look\n      });\n    } else {\n      insertOrUpdateNode(nodes, nodeData, classes);\n    }\n  }\n  if (parsedItem.doc) {\n    log.trace(\"Adding nodes children \");\n    setupDoc(parsedItem, parsedItem.doc, diagramStates, nodes, edges, !altFlag, look, classes);\n  }\n}, \"dataFetcher\");\nvar reset = /* @__PURE__ */ __name(() => {\n  nodeDb.clear();\n  graphItemCount = 0;\n}, \"reset\");\n\n// src/diagrams/state/stateDb.js\nvar START_NODE = \"[*]\";\nvar START_TYPE = \"start\";\nvar END_NODE = START_NODE;\nvar END_TYPE = \"end\";\nvar COLOR_KEYWORD = \"color\";\nvar FILL_KEYWORD = \"fill\";\nvar BG_FILL = \"bgFill\";\nvar STYLECLASS_SEP = \",\";\nfunction newClassesList() {\n  return /* @__PURE__ */ new Map();\n}\n__name(newClassesList, \"newClassesList\");\nvar newDoc = /* @__PURE__ */ __name(() => {\n  return {\n    /** @type {{ id1: string, id2: string, relationTitle: string }[]} */\n    relations: [],\n    states: /* @__PURE__ */ new Map(),\n    documents: {}\n  };\n}, \"newDoc\");\nvar clone = /* @__PURE__ */ __name((o) => JSON.parse(JSON.stringify(o)), \"clone\");\nvar StateDB = class {\n  static {\n    __name(this, \"StateDB\");\n  }\n  /**\n   * @param {1 | 2} version - v1 renderer or v2 renderer.\n   */\n  constructor(version) {\n    this.clear();\n    this.version = version;\n    this.setRootDoc = this.setRootDoc.bind(this);\n    this.getDividerId = this.getDividerId.bind(this);\n    this.setDirection = this.setDirection.bind(this);\n    this.trimColon = this.trimColon.bind(this);\n  }\n  /**\n   * @private\n   * @type {1 | 2}\n   */\n  version;\n  /**\n   * @private\n   * @type {Array}\n   */\n  nodes = [];\n  /**\n   * @private\n   * @type {Array}\n   */\n  edges = [];\n  /**\n   * @private\n   * @type {Array}\n   */\n  rootDoc = [];\n  /**\n   * @private\n   * @type {Map<string, any>}\n   */\n  classes = newClassesList();\n  // style classes defined by a classDef\n  /**\n   * @private\n   * @type {Object}\n   */\n  documents = {\n    root: newDoc()\n  };\n  /**\n   * @private\n   * @type {Object}\n   */\n  currentDocument = this.documents.root;\n  /**\n   * @private\n   * @type {number}\n   */\n  startEndCount = 0;\n  /**\n   * @private\n   * @type {number}\n   */\n  dividerCnt = 0;\n  static relationType = {\n    AGGREGATION: 0,\n    EXTENSION: 1,\n    COMPOSITION: 2,\n    DEPENDENCY: 3\n  };\n  setRootDoc(o) {\n    log.info(\"Setting root doc\", o);\n    this.rootDoc = o;\n    if (this.version === 1) {\n      this.extract(o);\n    } else {\n      this.extract(this.getRootDocV2());\n    }\n  }\n  getRootDoc() {\n    return this.rootDoc;\n  }\n  /**\n   * @private\n   * @param {Object} parent\n   * @param {Object} node\n   * @param {boolean} first\n   */\n  docTranslator(parent, node, first) {\n    if (node.stmt === STMT_RELATION) {\n      this.docTranslator(parent, node.state1, true);\n      this.docTranslator(parent, node.state2, false);\n    } else {\n      if (node.stmt === STMT_STATE) {\n        if (node.id === \"[*]\") {\n          node.id = first ? parent.id + \"_start\" : parent.id + \"_end\";\n          node.start = first;\n        } else {\n          node.id = node.id.trim();\n        }\n      }\n      if (node.doc) {\n        const doc = [];\n        let currentDoc = [];\n        let i;\n        for (i = 0; i < node.doc.length; i++) {\n          if (node.doc[i].type === DIVIDER_TYPE) {\n            const newNode = clone(node.doc[i]);\n            newNode.doc = clone(currentDoc);\n            doc.push(newNode);\n            currentDoc = [];\n          } else {\n            currentDoc.push(node.doc[i]);\n          }\n        }\n        if (doc.length > 0 && currentDoc.length > 0) {\n          const newNode = {\n            stmt: STMT_STATE,\n            id: generateId(),\n            type: \"divider\",\n            doc: clone(currentDoc)\n          };\n          doc.push(clone(newNode));\n          node.doc = doc;\n        }\n        node.doc.forEach((docNode) => this.docTranslator(node, docNode, true));\n      }\n    }\n  }\n  /**\n   * @private\n   */\n  getRootDocV2() {\n    this.docTranslator({ id: \"root\" }, { id: \"root\", doc: this.rootDoc }, true);\n    return { id: \"root\", doc: this.rootDoc };\n  }\n  /**\n   * Convert all of the statements (stmts) that were parsed into states and relationships.\n   * This is done because a state diagram may have nested sections,\n   * where each section is a 'document' and has its own set of statements.\n   * Ex: the section within a fork has its own statements, and incoming and outgoing statements\n   * refer to the fork as a whole (document).\n   * See the parser grammar:  the definition of a document is a document then a 'line', where a line can be a statement.\n   * This will push the statement into the list of statements for the current document.\n   * @private\n   * @param _doc\n   */\n  extract(_doc) {\n    let doc;\n    if (_doc.doc) {\n      doc = _doc.doc;\n    } else {\n      doc = _doc;\n    }\n    log.info(doc);\n    this.clear(true);\n    log.info(\"Extract initial document:\", doc);\n    doc.forEach((item) => {\n      log.warn(\"Statement\", item.stmt);\n      switch (item.stmt) {\n        case STMT_STATE:\n          this.addState(\n            item.id.trim(),\n            item.type,\n            item.doc,\n            item.description,\n            item.note,\n            item.classes,\n            item.styles,\n            item.textStyles\n          );\n          break;\n        case STMT_RELATION:\n          this.addRelation(item.state1, item.state2, item.description);\n          break;\n        case STMT_CLASSDEF:\n          this.addStyleClass(item.id.trim(), item.classes);\n          break;\n        case STMT_STYLEDEF:\n          {\n            const ids = item.id.trim().split(\",\");\n            const styles = item.styleClass.split(\",\");\n            ids.forEach((id) => {\n              let foundState = this.getState(id);\n              if (foundState === void 0) {\n                const trimmedId = id.trim();\n                this.addState(trimmedId);\n                foundState = this.getState(trimmedId);\n              }\n              foundState.styles = styles.map((s) => s.replace(/;/g, \"\")?.trim());\n            });\n          }\n          break;\n        case STMT_APPLYCLASS:\n          this.setCssClass(item.id.trim(), item.styleClass);\n          break;\n      }\n    });\n    const diagramStates = this.getStates();\n    const config = getConfig();\n    const look = config.look;\n    reset();\n    dataFetcher(\n      void 0,\n      this.getRootDocV2(),\n      diagramStates,\n      this.nodes,\n      this.edges,\n      true,\n      look,\n      this.classes\n    );\n    this.nodes.forEach((node) => {\n      if (Array.isArray(node.label)) {\n        node.description = node.label.slice(1);\n        if (node.isGroup && node.description.length > 0) {\n          throw new Error(\n            \"Group nodes can only have label. Remove the additional description for node [\" + node.id + \"]\"\n          );\n        }\n        node.label = node.label[0];\n      }\n    });\n  }\n  /**\n   * Function called by parser when a node definition has been found.\n   *\n   * @param {null | string} id\n   * @param {null | string} type\n   * @param {null | string} doc\n   * @param {null | string | string[]} descr - description for the state. Can be a string or a list or strings\n   * @param {null | string} note\n   * @param {null | string | string[]} classes - class styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 class, convert it to an array of that 1 class.\n   * @param {null | string | string[]} styles - styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 style, convert it to an array of that 1 style.\n   * @param {null | string | string[]} textStyles - text styles to apply to this state. Can be a string (1 text test) or an array of text styles. If it's just 1 text style, convert it to an array of that 1 text style.\n   */\n  addState(id, type = DEFAULT_STATE_TYPE, doc = null, descr = null, note = null, classes = null, styles = null, textStyles = null) {\n    const trimmedId = id?.trim();\n    if (!this.currentDocument.states.has(trimmedId)) {\n      log.info(\"Adding state \", trimmedId, descr);\n      this.currentDocument.states.set(trimmedId, {\n        id: trimmedId,\n        descriptions: [],\n        type,\n        doc,\n        note,\n        classes: [],\n        styles: [],\n        textStyles: []\n      });\n    } else {\n      if (!this.currentDocument.states.get(trimmedId).doc) {\n        this.currentDocument.states.get(trimmedId).doc = doc;\n      }\n      if (!this.currentDocument.states.get(trimmedId).type) {\n        this.currentDocument.states.get(trimmedId).type = type;\n      }\n    }\n    if (descr) {\n      log.info(\"Setting state description\", trimmedId, descr);\n      if (typeof descr === \"string\") {\n        this.addDescription(trimmedId, descr.trim());\n      }\n      if (typeof descr === \"object\") {\n        descr.forEach((des) => this.addDescription(trimmedId, des.trim()));\n      }\n    }\n    if (note) {\n      const doc2 = this.currentDocument.states.get(trimmedId);\n      doc2.note = note;\n      doc2.note.text = common_default.sanitizeText(doc2.note.text, getConfig());\n    }\n    if (classes) {\n      log.info(\"Setting state classes\", trimmedId, classes);\n      const classesList = typeof classes === \"string\" ? [classes] : classes;\n      classesList.forEach((cssClass) => this.setCssClass(trimmedId, cssClass.trim()));\n    }\n    if (styles) {\n      log.info(\"Setting state styles\", trimmedId, styles);\n      const stylesList = typeof styles === \"string\" ? [styles] : styles;\n      stylesList.forEach((style) => this.setStyle(trimmedId, style.trim()));\n    }\n    if (textStyles) {\n      log.info(\"Setting state styles\", trimmedId, styles);\n      const textStylesList = typeof textStyles === \"string\" ? [textStyles] : textStyles;\n      textStylesList.forEach((textStyle) => this.setTextStyle(trimmedId, textStyle.trim()));\n    }\n  }\n  clear(saveCommon) {\n    this.nodes = [];\n    this.edges = [];\n    this.documents = {\n      root: newDoc()\n    };\n    this.currentDocument = this.documents.root;\n    this.startEndCount = 0;\n    this.classes = newClassesList();\n    if (!saveCommon) {\n      clear();\n    }\n  }\n  getState(id) {\n    return this.currentDocument.states.get(id);\n  }\n  getStates() {\n    return this.currentDocument.states;\n  }\n  logDocuments() {\n    log.info(\"Documents = \", this.documents);\n  }\n  getRelations() {\n    return this.currentDocument.relations;\n  }\n  /**\n   * If the id is a start node ( [*] ), then return a new id constructed from\n   * the start node name and the current start node count.\n   * else return the given id\n   *\n   * @param {string} id\n   * @returns {string} - the id (original or constructed)\n   * @private\n   */\n  startIdIfNeeded(id = \"\") {\n    let fixedId = id;\n    if (id === START_NODE) {\n      this.startEndCount++;\n      fixedId = `${START_TYPE}${this.startEndCount}`;\n    }\n    return fixedId;\n  }\n  /**\n   * If the id is a start node ( [*] ), then return the start type ('start')\n   * else return the given type\n   *\n   * @param {string} id\n   * @param {string} type\n   * @returns {string} - the type that should be used\n   * @private\n   */\n  startTypeIfNeeded(id = \"\", type = DEFAULT_STATE_TYPE) {\n    return id === START_NODE ? START_TYPE : type;\n  }\n  /**\n   * If the id is an end node ( [*] ), then return a new id constructed from\n   * the end node name and the current start_end node count.\n   * else return the given id\n   *\n   * @param {string} id\n   * @returns {string} - the id (original or constructed)\n   * @private\n   */\n  endIdIfNeeded(id = \"\") {\n    let fixedId = id;\n    if (id === END_NODE) {\n      this.startEndCount++;\n      fixedId = `${END_TYPE}${this.startEndCount}`;\n    }\n    return fixedId;\n  }\n  /**\n   * If the id is an end node ( [*] ), then return the end type\n   * else return the given type\n   *\n   * @param {string} id\n   * @param {string} type\n   * @returns {string} - the type that should be used\n   * @private\n   */\n  endTypeIfNeeded(id = \"\", type = DEFAULT_STATE_TYPE) {\n    return id === END_NODE ? END_TYPE : type;\n  }\n  /**\n   *\n   * @param item1\n   * @param item2\n   * @param relationTitle\n   */\n  addRelationObjs(item1, item2, relationTitle) {\n    let id1 = this.startIdIfNeeded(item1.id.trim());\n    let type1 = this.startTypeIfNeeded(item1.id.trim(), item1.type);\n    let id2 = this.startIdIfNeeded(item2.id.trim());\n    let type2 = this.startTypeIfNeeded(item2.id.trim(), item2.type);\n    this.addState(\n      id1,\n      type1,\n      item1.doc,\n      item1.description,\n      item1.note,\n      item1.classes,\n      item1.styles,\n      item1.textStyles\n    );\n    this.addState(\n      id2,\n      type2,\n      item2.doc,\n      item2.description,\n      item2.note,\n      item2.classes,\n      item2.styles,\n      item2.textStyles\n    );\n    this.currentDocument.relations.push({\n      id1,\n      id2,\n      relationTitle: common_default.sanitizeText(relationTitle, getConfig())\n    });\n  }\n  /**\n   * Add a relation between two items.  The items may be full objects or just the string id of a state.\n   *\n   * @param {string | object} item1\n   * @param {string | object} item2\n   * @param {string} title\n   */\n  addRelation(item1, item2, title) {\n    if (typeof item1 === \"object\") {\n      this.addRelationObjs(item1, item2, title);\n    } else {\n      const id1 = this.startIdIfNeeded(item1.trim());\n      const type1 = this.startTypeIfNeeded(item1);\n      const id2 = this.endIdIfNeeded(item2.trim());\n      const type2 = this.endTypeIfNeeded(item2);\n      this.addState(id1, type1);\n      this.addState(id2, type2);\n      this.currentDocument.relations.push({\n        id1,\n        id2,\n        title: common_default.sanitizeText(title, getConfig())\n      });\n    }\n  }\n  addDescription(id, descr) {\n    const theState = this.currentDocument.states.get(id);\n    const _descr = descr.startsWith(\":\") ? descr.replace(\":\", \"\").trim() : descr;\n    theState.descriptions.push(common_default.sanitizeText(_descr, getConfig()));\n  }\n  cleanupLabel(label) {\n    if (label.substring(0, 1) === \":\") {\n      return label.substr(2).trim();\n    } else {\n      return label.trim();\n    }\n  }\n  getDividerId() {\n    this.dividerCnt++;\n    return \"divider-id-\" + this.dividerCnt;\n  }\n  /**\n   * Called when the parser comes across a (style) class definition\n   * @example classDef my-style fill:#f96;\n   *\n   * @param {string} id - the id of this (style) class\n   * @param  {string | null} styleAttributes - the string with 1 or more style attributes (each separated by a comma)\n   */\n  addStyleClass(id, styleAttributes = \"\") {\n    if (!this.classes.has(id)) {\n      this.classes.set(id, { id, styles: [], textStyles: [] });\n    }\n    const foundClass = this.classes.get(id);\n    if (styleAttributes !== void 0 && styleAttributes !== null) {\n      styleAttributes.split(STYLECLASS_SEP).forEach((attrib) => {\n        const fixedAttrib = attrib.replace(/([^;]*);/, \"$1\").trim();\n        if (RegExp(COLOR_KEYWORD).exec(attrib)) {\n          const newStyle1 = fixedAttrib.replace(FILL_KEYWORD, BG_FILL);\n          const newStyle2 = newStyle1.replace(COLOR_KEYWORD, FILL_KEYWORD);\n          foundClass.textStyles.push(newStyle2);\n        }\n        foundClass.styles.push(fixedAttrib);\n      });\n    }\n  }\n  /**\n   * Return all of the style classes\n   * @returns {{} | any | classes}\n   */\n  getClasses() {\n    return this.classes;\n  }\n  /**\n   * Add a (style) class or css class to a state with the given id.\n   * If the state isn't already in the list of known states, add it.\n   * Might be called by parser when a style class or CSS class should be applied to a state\n   *\n   * @param {string | string[]} itemIds The id or a list of ids of the item(s) to apply the css class to\n   * @param {string} cssClassName CSS class name\n   */\n  setCssClass(itemIds, cssClassName) {\n    itemIds.split(\",\").forEach((id) => {\n      let foundState = this.getState(id);\n      if (foundState === void 0) {\n        const trimmedId = id.trim();\n        this.addState(trimmedId);\n        foundState = this.getState(trimmedId);\n      }\n      foundState.classes.push(cssClassName);\n    });\n  }\n  /**\n   * Add a style to a state with the given id.\n   * @example style stateId fill:#f9f,stroke:#333,stroke-width:4px\n   *   where 'style' is the keyword\n   *   stateId is the id of a state\n   *   the rest of the string is the styleText (all of the attributes to be applied to the state)\n   *\n   * @param itemId The id of item to apply the style to\n   * @param styleText - the text of the attributes for the style\n   */\n  setStyle(itemId, styleText) {\n    const item = this.getState(itemId);\n    if (item !== void 0) {\n      item.styles.push(styleText);\n    }\n  }\n  /**\n   * Add a text style to a state with the given id\n   *\n   * @param itemId The id of item to apply the css class to\n   * @param cssClassName CSS class name\n   */\n  setTextStyle(itemId, cssClassName) {\n    const item = this.getState(itemId);\n    if (item !== void 0) {\n      item.textStyles.push(cssClassName);\n    }\n  }\n  /**\n   * Finds the direction statement in the root document.\n   * @private\n   * @returns {{ value: string } | undefined} - the direction statement if present\n   */\n  getDirectionStatement() {\n    return this.rootDoc.find((doc) => doc.stmt === STMT_DIRECTION);\n  }\n  getDirection() {\n    return this.getDirectionStatement()?.value ?? DEFAULT_DIAGRAM_DIRECTION;\n  }\n  setDirection(dir) {\n    const doc = this.getDirectionStatement();\n    if (doc) {\n      doc.value = dir;\n    } else {\n      this.rootDoc.unshift({ stmt: STMT_DIRECTION, value: dir });\n    }\n  }\n  trimColon(str) {\n    return str && str[0] === \":\" ? str.substr(1).trim() : str.trim();\n  }\n  getData() {\n    const config = getConfig();\n    return {\n      nodes: this.nodes,\n      edges: this.edges,\n      other: {},\n      config,\n      direction: getDir(this.getRootDocV2())\n    };\n  }\n  getConfig() {\n    return getConfig().state;\n  }\n  getAccTitle = getAccTitle;\n  setAccTitle = setAccTitle;\n  getAccDescription = getAccDescription;\n  setAccDescription = setAccDescription;\n  setDiagramTitle = setDiagramTitle;\n  getDiagramTitle = getDiagramTitle;\n};\n\n// src/diagrams/state/styles.js\nvar getStyles = /* @__PURE__ */ __name((options) => `\ndefs #statediagram-barbEnd {\n    fill: ${options.transitionColor};\n    stroke: ${options.transitionColor};\n  }\ng.stateGroup text {\n  fill: ${options.nodeBorder};\n  stroke: none;\n  font-size: 10px;\n}\ng.stateGroup text {\n  fill: ${options.textColor};\n  stroke: none;\n  font-size: 10px;\n\n}\ng.stateGroup .state-title {\n  font-weight: bolder;\n  fill: ${options.stateLabelColor};\n}\n\ng.stateGroup rect {\n  fill: ${options.mainBkg};\n  stroke: ${options.nodeBorder};\n}\n\ng.stateGroup line {\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n}\n\n.transition {\n  stroke: ${options.transitionColor};\n  stroke-width: 1;\n  fill: none;\n}\n\n.stateGroup .composit {\n  fill: ${options.background};\n  border-bottom: 1px\n}\n\n.stateGroup .alt-composit {\n  fill: #e0e0e0;\n  border-bottom: 1px\n}\n\n.state-note {\n  stroke: ${options.noteBorderColor};\n  fill: ${options.noteBkgColor};\n\n  text {\n    fill: ${options.noteTextColor};\n    stroke: none;\n    font-size: 10px;\n  }\n}\n\n.stateLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ${options.mainBkg};\n  opacity: 0.5;\n}\n\n.edgeLabel .label rect {\n  fill: ${options.labelBackgroundColor};\n  opacity: 0.5;\n}\n.edgeLabel {\n  background-color: ${options.edgeLabelBackground};\n  p {\n    background-color: ${options.edgeLabelBackground};\n  }\n  rect {\n    opacity: 0.5;\n    background-color: ${options.edgeLabelBackground};\n    fill: ${options.edgeLabelBackground};\n  }\n  text-align: center;\n}\n.edgeLabel .label text {\n  fill: ${options.transitionLabelColor || options.tertiaryTextColor};\n}\n.label div .edgeLabel {\n  color: ${options.transitionLabelColor || options.tertiaryTextColor};\n}\n\n.stateLabel text {\n  fill: ${options.stateLabelColor};\n  font-size: 10px;\n  font-weight: bold;\n}\n\n.node circle.state-start {\n  fill: ${options.specialStateColor};\n  stroke: ${options.specialStateColor};\n}\n\n.node .fork-join {\n  fill: ${options.specialStateColor};\n  stroke: ${options.specialStateColor};\n}\n\n.node circle.state-end {\n  fill: ${options.innerEndBackground};\n  stroke: ${options.background};\n  stroke-width: 1.5\n}\n.end-state-inner {\n  fill: ${options.compositeBackground || options.background};\n  // stroke: ${options.background};\n  stroke-width: 1.5\n}\n\n.node rect {\n  fill: ${options.stateBkg || options.mainBkg};\n  stroke: ${options.stateBorder || options.nodeBorder};\n  stroke-width: 1px;\n}\n.node polygon {\n  fill: ${options.mainBkg};\n  stroke: ${options.stateBorder || options.nodeBorder};;\n  stroke-width: 1px;\n}\n#statediagram-barbEnd {\n  fill: ${options.lineColor};\n}\n\n.statediagram-cluster rect {\n  fill: ${options.compositeTitleBackground};\n  stroke: ${options.stateBorder || options.nodeBorder};\n  stroke-width: 1px;\n}\n\n.cluster-label, .nodeLabel {\n  color: ${options.stateLabelColor};\n  // line-height: 1;\n}\n\n.statediagram-cluster rect.outer {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state .divider {\n  stroke: ${options.stateBorder || options.nodeBorder};\n}\n\n.statediagram-state .title-state {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-cluster.statediagram-cluster .inner {\n  fill: ${options.compositeBackground || options.background};\n}\n.statediagram-cluster.statediagram-cluster-alt .inner {\n  fill: ${options.altBackground ? options.altBackground : \"#efefef\"};\n}\n\n.statediagram-cluster .inner {\n  rx:0;\n  ry:0;\n}\n\n.statediagram-state rect.basic {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state rect.divider {\n  stroke-dasharray: 10,10;\n  fill: ${options.altBackground ? options.altBackground : \"#efefef\"};\n}\n\n.note-edge {\n  stroke-dasharray: 5;\n}\n\n.statediagram-note rect {\n  fill: ${options.noteBkgColor};\n  stroke: ${options.noteBorderColor};\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n.statediagram-note rect {\n  fill: ${options.noteBkgColor};\n  stroke: ${options.noteBorderColor};\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n\n.statediagram-note text {\n  fill: ${options.noteTextColor};\n}\n\n.statediagram-note .nodeLabel {\n  color: ${options.noteTextColor};\n}\n.statediagram .edgeLabel {\n  color: red; // ${options.noteTextColor};\n}\n\n#dependencyStart, #dependencyEnd {\n  fill: ${options.lineColor};\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n}\n\n.statediagramTitleText {\n  text-anchor: middle;\n  font-size: 18px;\n  fill: ${options.textColor};\n}\n`, \"getStyles\");\nvar styles_default = getStyles;\n\nexport {\n  stateDiagram_default,\n  stateRenderer_v3_unified_default,\n  StateDB,\n  styles_default\n};\n","/******************************************************************************\n * This file was generated by langium-cli 3.3.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\nimport { AbstractAstReflection } from '../../syntax-tree.js';\nexport const LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\nexport const AbstractRule = 'AbstractRule';\nexport function isAbstractRule(item) {\n    return reflection.isInstance(item, AbstractRule);\n}\nexport const AbstractType = 'AbstractType';\nexport function isAbstractType(item) {\n    return reflection.isInstance(item, AbstractType);\n}\nexport const Condition = 'Condition';\nexport function isCondition(item) {\n    return reflection.isInstance(item, Condition);\n}\nexport function isFeatureName(item) {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\nexport function isPrimitiveType(item) {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\nexport const TypeDefinition = 'TypeDefinition';\nexport function isTypeDefinition(item) {\n    return reflection.isInstance(item, TypeDefinition);\n}\nexport const ValueLiteral = 'ValueLiteral';\nexport function isValueLiteral(item) {\n    return reflection.isInstance(item, ValueLiteral);\n}\nexport const AbstractElement = 'AbstractElement';\nexport function isAbstractElement(item) {\n    return reflection.isInstance(item, AbstractElement);\n}\nexport const ArrayLiteral = 'ArrayLiteral';\nexport function isArrayLiteral(item) {\n    return reflection.isInstance(item, ArrayLiteral);\n}\nexport const ArrayType = 'ArrayType';\nexport function isArrayType(item) {\n    return reflection.isInstance(item, ArrayType);\n}\nexport const BooleanLiteral = 'BooleanLiteral';\nexport function isBooleanLiteral(item) {\n    return reflection.isInstance(item, BooleanLiteral);\n}\nexport const Conjunction = 'Conjunction';\nexport function isConjunction(item) {\n    return reflection.isInstance(item, Conjunction);\n}\nexport const Disjunction = 'Disjunction';\nexport function isDisjunction(item) {\n    return reflection.isInstance(item, Disjunction);\n}\nexport const Grammar = 'Grammar';\nexport function isGrammar(item) {\n    return reflection.isInstance(item, Grammar);\n}\nexport const GrammarImport = 'GrammarImport';\nexport function isGrammarImport(item) {\n    return reflection.isInstance(item, GrammarImport);\n}\nexport const InferredType = 'InferredType';\nexport function isInferredType(item) {\n    return reflection.isInstance(item, InferredType);\n}\nexport const Interface = 'Interface';\nexport function isInterface(item) {\n    return reflection.isInstance(item, Interface);\n}\nexport const NamedArgument = 'NamedArgument';\nexport function isNamedArgument(item) {\n    return reflection.isInstance(item, NamedArgument);\n}\nexport const Negation = 'Negation';\nexport function isNegation(item) {\n    return reflection.isInstance(item, Negation);\n}\nexport const NumberLiteral = 'NumberLiteral';\nexport function isNumberLiteral(item) {\n    return reflection.isInstance(item, NumberLiteral);\n}\nexport const Parameter = 'Parameter';\nexport function isParameter(item) {\n    return reflection.isInstance(item, Parameter);\n}\nexport const ParameterReference = 'ParameterReference';\nexport function isParameterReference(item) {\n    return reflection.isInstance(item, ParameterReference);\n}\nexport const ParserRule = 'ParserRule';\nexport function isParserRule(item) {\n    return reflection.isInstance(item, ParserRule);\n}\nexport const ReferenceType = 'ReferenceType';\nexport function isReferenceType(item) {\n    return reflection.isInstance(item, ReferenceType);\n}\nexport const ReturnType = 'ReturnType';\nexport function isReturnType(item) {\n    return reflection.isInstance(item, ReturnType);\n}\nexport const SimpleType = 'SimpleType';\nexport function isSimpleType(item) {\n    return reflection.isInstance(item, SimpleType);\n}\nexport const StringLiteral = 'StringLiteral';\nexport function isStringLiteral(item) {\n    return reflection.isInstance(item, StringLiteral);\n}\nexport const TerminalRule = 'TerminalRule';\nexport function isTerminalRule(item) {\n    return reflection.isInstance(item, TerminalRule);\n}\nexport const Type = 'Type';\nexport function isType(item) {\n    return reflection.isInstance(item, Type);\n}\nexport const TypeAttribute = 'TypeAttribute';\nexport function isTypeAttribute(item) {\n    return reflection.isInstance(item, TypeAttribute);\n}\nexport const UnionType = 'UnionType';\nexport function isUnionType(item) {\n    return reflection.isInstance(item, UnionType);\n}\nexport const Action = 'Action';\nexport function isAction(item) {\n    return reflection.isInstance(item, Action);\n}\nexport const Alternatives = 'Alternatives';\nexport function isAlternatives(item) {\n    return reflection.isInstance(item, Alternatives);\n}\nexport const Assignment = 'Assignment';\nexport function isAssignment(item) {\n    return reflection.isInstance(item, Assignment);\n}\nexport const CharacterRange = 'CharacterRange';\nexport function isCharacterRange(item) {\n    return reflection.isInstance(item, CharacterRange);\n}\nexport const CrossReference = 'CrossReference';\nexport function isCrossReference(item) {\n    return reflection.isInstance(item, CrossReference);\n}\nexport const EndOfFile = 'EndOfFile';\nexport function isEndOfFile(item) {\n    return reflection.isInstance(item, EndOfFile);\n}\nexport const Group = 'Group';\nexport function isGroup(item) {\n    return reflection.isInstance(item, Group);\n}\nexport const Keyword = 'Keyword';\nexport function isKeyword(item) {\n    return reflection.isInstance(item, Keyword);\n}\nexport const NegatedToken = 'NegatedToken';\nexport function isNegatedToken(item) {\n    return reflection.isInstance(item, NegatedToken);\n}\nexport const RegexToken = 'RegexToken';\nexport function isRegexToken(item) {\n    return reflection.isInstance(item, RegexToken);\n}\nexport const RuleCall = 'RuleCall';\nexport function isRuleCall(item) {\n    return reflection.isInstance(item, RuleCall);\n}\nexport const TerminalAlternatives = 'TerminalAlternatives';\nexport function isTerminalAlternatives(item) {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\nexport const TerminalGroup = 'TerminalGroup';\nexport function isTerminalGroup(item) {\n    return reflection.isInstance(item, TerminalGroup);\n}\nexport const TerminalRuleCall = 'TerminalRuleCall';\nexport function isTerminalRuleCall(item) {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\nexport const UnorderedGroup = 'UnorderedGroup';\nexport function isUnorderedGroup(item) {\n    return reflection.isInstance(item, UnorderedGroup);\n}\nexport const UntilToken = 'UntilToken';\nexport function isUntilToken(item) {\n    return reflection.isInstance(item, UntilToken);\n}\nexport const Wildcard = 'Wildcard';\nexport function isWildcard(item) {\n    return reflection.isInstance(item, Wildcard);\n}\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n    getAllTypes() {\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n    getTypeMetaData(type) {\n        switch (type) {\n            case AbstractElement: {\n                return {\n                    name: AbstractElement,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case ArrayLiteral: {\n                return {\n                    name: ArrayLiteral,\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case ArrayType: {\n                return {\n                    name: ArrayType,\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case BooleanLiteral: {\n                return {\n                    name: BooleanLiteral,\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case Conjunction: {\n                return {\n                    name: Conjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Disjunction: {\n                return {\n                    name: Disjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Grammar: {\n                return {\n                    name: Grammar,\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case GrammarImport: {\n                return {\n                    name: GrammarImport,\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case InferredType: {\n                return {\n                    name: InferredType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case Interface: {\n                return {\n                    name: Interface,\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case NamedArgument: {\n                return {\n                    name: NamedArgument,\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Negation: {\n                return {\n                    name: Negation,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NumberLiteral: {\n                return {\n                    name: NumberLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Parameter: {\n                return {\n                    name: Parameter,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case ParameterReference: {\n                return {\n                    name: ParameterReference,\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case ParserRule: {\n                return {\n                    name: ParserRule,\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case ReferenceType: {\n                return {\n                    name: ReferenceType,\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case ReturnType: {\n                return {\n                    name: ReturnType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case SimpleType: {\n                return {\n                    name: SimpleType,\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case StringLiteral: {\n                return {\n                    name: StringLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case TerminalRule: {\n                return {\n                    name: TerminalRule,\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Type: {\n                return {\n                    name: Type,\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case TypeAttribute: {\n                return {\n                    name: TypeAttribute,\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case UnionType: {\n                return {\n                    name: UnionType,\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case Action: {\n                return {\n                    name: Action,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Alternatives: {\n                return {\n                    name: Alternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Assignment: {\n                return {\n                    name: Assignment,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case CharacterRange: {\n                return {\n                    name: CharacterRange,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case CrossReference: {\n                return {\n                    name: CrossReference,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case EndOfFile: {\n                return {\n                    name: EndOfFile,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Group: {\n                return {\n                    name: Group,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Keyword: {\n                return {\n                    name: Keyword,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NegatedToken: {\n                return {\n                    name: NegatedToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case RegexToken: {\n                return {\n                    name: RegexToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case RuleCall: {\n                return {\n                    name: RuleCall,\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case TerminalAlternatives: {\n                return {\n                    name: TerminalAlternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalGroup: {\n                return {\n                    name: TerminalGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalRuleCall: {\n                return {\n                    name: TerminalRuleCall,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case UnorderedGroup: {\n                return {\n                    name: UnorderedGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case UntilToken: {\n                return {\n                    name: UntilToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case Wildcard: {\n                return {\n                    name: Wildcard,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\nexport const reflection = new LangiumGrammarAstReflection();\n//# sourceMappingURL=ast.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport function isAstNode(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';\n}\nexport function isReference(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';\n}\nexport function isAstNodeDescription(obj) {\n    return typeof obj === 'object' && obj !== null\n        && typeof obj.name === 'string'\n        && typeof obj.type === 'string'\n        && typeof obj.path === 'string';\n}\nexport function isLinkingError(obj) {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode(obj.container)\n        && isReference(obj.reference)\n        && typeof obj.message === 'string';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport class AbstractAstReflection {\n    constructor() {\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        }\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\nexport function isCompositeCstNode(node) {\n    return typeof node === 'object' && node !== null && Array.isArray(node.content);\n}\nexport function isLeafCstNode(node) {\n    return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';\n}\nexport function isRootCstNode(node) {\n    return isCompositeCstNode(node) && typeof node.fullText === 'string';\n}\n//# sourceMappingURL=syntax-tree.js.map","import isSymbol from './isSymbol.js';\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nexport default baseExtremum;\n","import baseEach from './_baseEach.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nexport default baseMap;\n","export function cc(char) {\n    return char.charCodeAt(0);\n}\nexport function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n            set.push(subItem);\n        });\n    }\n    else {\n        set.push(item);\n    }\n}\nexport function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n    }\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\nexport function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n        throw Error(\"Internal Error - Should never get here!\");\n    }\n    return true;\n}\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n}\nexport function isCharacter(obj) {\n    return obj[\"type\"] === \"Character\";\n}\n//# sourceMappingURL=utils.js.map","import { cc } from \"./utils.js\";\nexport const digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n}\nexport const wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes = [\n    cc(\" \"),\n    cc(\"\\f\"),\n    cc(\"\\n\"),\n    cc(\"\\r\"),\n    cc(\"\\t\"),\n    cc(\"\\v\"),\n    cc(\"\\t\"),\n    cc(\"\\u00a0\"),\n    cc(\"\\u1680\"),\n    cc(\"\\u2000\"),\n    cc(\"\\u2001\"),\n    cc(\"\\u2002\"),\n    cc(\"\\u2003\"),\n    cc(\"\\u2004\"),\n    cc(\"\\u2005\"),\n    cc(\"\\u2006\"),\n    cc(\"\\u2007\"),\n    cc(\"\\u2008\"),\n    cc(\"\\u2009\"),\n    cc(\"\\u200a\"),\n    cc(\"\\u2028\"),\n    cc(\"\\u2029\"),\n    cc(\"\\u202f\"),\n    cc(\"\\u205f\"),\n    cc(\"\\u3000\"),\n    cc(\"\\ufeff\"),\n];\n//# sourceMappingURL=character-classes.js.map","import { addFlag, ASSERT_EXISTS, ASSERT_NEVER_REACH_HERE, cc, insertToSet, isCharacter, } from \"./utils.js\";\nimport { digitsCharCodes, whitespaceCodes, wordCharCodes, } from \"./character-classes.js\";\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n    constructor() {\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx,\n        };\n    }\n    restoreState(newState) {\n        this.idx = newState.idx;\n        this.input = newState.input;\n        this.groupIdx = newState.groupIdx;\n    }\n    pattern(input) {\n        // parser state\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar(\"/\");\n        const value = this.disjunction();\n        this.consumeChar(\"/\");\n        const flags = {\n            type: \"Flags\",\n            loc: { begin: this.idx, end: input.length },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false,\n        };\n        while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n                case \"g\":\n                    addFlag(flags, \"global\");\n                    break;\n                case \"i\":\n                    addFlag(flags, \"ignoreCase\");\n                    break;\n                case \"m\":\n                    addFlag(flags, \"multiLine\");\n                    break;\n                case \"u\":\n                    addFlag(flags, \"unicode\");\n                    break;\n                case \"y\":\n                    addFlag(flags, \"sticky\");\n                    break;\n            }\n        }\n        if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n        }\n        return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0),\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n        }\n        return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while (this.isTerm()) {\n            terms.push(this.term());\n        }\n        return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n    }\n    term() {\n        if (this.isAssertion()) {\n            return this.assertion();\n        }\n        else {\n            return this.atom();\n        }\n    }\n    assertion() {\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"^\":\n                return {\n                    type: \"StartAnchor\",\n                    loc: this.loc(begin),\n                };\n            case \"$\":\n                return { type: \"EndAnchor\", loc: this.loc(begin) };\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.popChar()) {\n                    case \"b\":\n                        return {\n                            type: \"WordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                    case \"B\":\n                        return {\n                            type: \"NonWordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                }\n                // istanbul ignore next\n                throw Error(\"Invalid Assertion Escape\");\n            // '(?=' or '(?!'\n            case \"(\":\n                this.consumeChar(\"?\");\n                let type;\n                switch (this.popChar()) {\n                    case \"=\":\n                        type = \"Lookahead\";\n                        break;\n                    case \"!\":\n                        type = \"NegativeLookahead\";\n                        break;\n                }\n                ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(\")\");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin),\n                };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = undefined;\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"*\":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity,\n                };\n                break;\n            case \"+\":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity,\n                };\n                break;\n            case \"?\":\n                range = {\n                    atLeast: 0,\n                    atMost: 1,\n                };\n                break;\n            case \"{\":\n                const atLeast = this.integerIncludingZero();\n                switch (this.popChar()) {\n                    case \"}\":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast,\n                        };\n                        break;\n                    case \",\":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost,\n                            };\n                        }\n                        else {\n                            range = {\n                                atLeast: atLeast,\n                                atMost: Infinity,\n                            };\n                        }\n                        this.consumeChar(\"}\");\n                        break;\n                }\n                // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                // causes severe performance degradations\n                if (isBacktracking === true && range === undefined) {\n                    return undefined;\n                }\n                ASSERT_EXISTS(range);\n                break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n            return undefined;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\");\n                range.greedy = false;\n            }\n            else {\n                range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom;\n        const begin = this.idx;\n        switch (this.peekChar()) {\n            case \".\":\n                atom = this.dotAll();\n                break;\n            case \"\\\\\":\n                atom = this.atomEscape();\n                break;\n            case \"[\":\n                atom = this.characterClass();\n                break;\n            case \"(\":\n                atom = this.group();\n                break;\n        }\n        if (atom === undefined && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier();\n            }\n            return atom;\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(\".\");\n        return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n        };\n    }\n    atomEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return { type: \"GroupBackReference\", value: value };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch (this.popChar()) {\n            case \"d\":\n                set = digitsCharCodes;\n                break;\n            case \"D\":\n                set = digitsCharCodes;\n                complement = true;\n                break;\n            case \"s\":\n                set = whitespaceCodes;\n                break;\n            case \"S\":\n                set = whitespaceCodes;\n                complement = true;\n                break;\n            case \"w\":\n                set = wordCharCodes;\n                break;\n            case \"W\":\n                set = wordCharCodes;\n                complement = true;\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(set)) {\n            return { type: \"Set\", value: set, complement: complement };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch (this.popChar()) {\n            case \"f\":\n                escapeCode = cc(\"\\f\");\n                break;\n            case \"n\":\n                escapeCode = cc(\"\\n\");\n                break;\n            case \"r\":\n                escapeCode = cc(\"\\r\");\n                break;\n            case \"t\":\n                escapeCode = cc(\"\\t\");\n                break;\n            case \"v\":\n                escapeCode = cc(\"\\v\");\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(escapeCode)) {\n            return { type: \"Character\", value: escapeCode };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar(\"c\");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n        }\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return { type: \"Character\", value: letterCode };\n    }\n    nulCharacterAtom() {\n        // TODO implement '[lookahead ∉ DecimalDigit]'\n        // TODO: for the deprecated octal escape sequence\n        this.consumeChar(\"0\");\n        return { type: \"Character\", value: cc(\"\\0\") };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar(\"x\");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar(\"u\");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n        const escapedChar = this.popChar();\n        return { type: \"Character\", value: cc(escapedChar) };\n    }\n    classPatternCharacterAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \"]\":\n                throw Error(\"TBD\");\n            default:\n                const nextChar = this.popChar();\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar(\"[\");\n        if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n        }\n        while (this.isClassAtom()) {\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar(\"-\");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === \"Character\";\n                // a range can only be used when both sides are single characters\n                if (isCharacter(to)) {\n                    if (to.value < from.value) {\n                        throw Error(\"Range out of order in character class\");\n                    }\n                    set.push({ from: from.value, to: to.value });\n                }\n                else {\n                    // literal dash\n                    insertToSet(from.value, set);\n                    set.push(cc(\"-\"));\n                    insertToSet(to.value, set);\n                }\n            }\n            else {\n                insertToSet(from.value, set);\n            }\n        }\n        this.consumeChar(\"]\");\n        return { type: \"Set\", complement: complement, value: set };\n    }\n    classAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"]\":\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n                throw Error(\"TBD\");\n            case \"\\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            // Matches a backspace.\n            // (Not to be confused with \\b word boundary outside characterClass)\n            case \"b\":\n                this.consumeChar(\"b\");\n                return { type: \"Character\", value: cc(\"\\u0008\") };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar(\"(\");\n        switch (this.peekChar(0)) {\n            case \"?\":\n                this.consumeChar(\"?\");\n                this.consumeChar(\":\");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(\")\");\n        const groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value,\n        };\n        if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n        }\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        // istanbul ignore next - can't ever get here due to previous lookahead checks\n        // still implementing this error checking in case this ever changes.\n        if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch (nextChar) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"^\":\n            // istanbul ignore next\n            case \"$\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \".\":\n            // istanbul ignore next\n            case \"*\":\n            // istanbul ignore next\n            case \"+\":\n            // istanbul ignore next\n            case \"?\":\n            // istanbul ignore next\n            case \"(\":\n            // istanbul ignore next\n            case \")\":\n            // istanbul ignore next\n            case \"[\":\n            // istanbul ignore next\n            case \"|\":\n                // istanbul ignore next\n                throw Error(\"TBD\");\n            default:\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    isRegExpFlag() {\n        switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === \"-\" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) {\n            return true;\n        }\n        switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\": // atomEscape\n            case \"[\": // characterClass\n            // TODO: isAtom must be called before isAssertion - disambiguate\n            case \"(\": // group\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n                return true;\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.peekChar(1)) {\n                    case \"b\":\n                    case \"B\":\n                        return true;\n                    default:\n                        return false;\n                }\n            // '(?=' or '(?!'\n            case \"(\":\n                return (this.peekChar(1) === \"?\" &&\n                    (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\"));\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== undefined;\n        }\n        catch (e) {\n            return false;\n        }\n        finally {\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = \"\";\n        for (let i = 0; i < howMany; i++) {\n            const hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n                throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return { type: \"Character\", value: charCode };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(undefined);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== undefined && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" +\n                char +\n                \"' but found: '\" +\n                this.input[this.idx] +\n                \"' at offset: \" +\n                this.idx);\n        }\n        if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n        }\n        this.idx++;\n    }\n    loc(begin) {\n        return { begin: begin, end: this.idx };\n    }\n}\n//# sourceMappingURL=regexp-parser.js.map","export class BaseRegExpVisitor {\n    visitChildren(node) {\n        for (const key in node) {\n            const child = node[key];\n            /* istanbul ignore else */\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== undefined) {\n                    this.visit(child);\n                }\n                else if (Array.isArray(child)) {\n                    child.forEach((subChild) => {\n                        this.visit(subChild);\n                    }, this);\n                }\n            }\n        }\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Disjunction\":\n                this.visitDisjunction(node);\n                break;\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"StartAnchor\":\n                this.visitStartAnchor(node);\n                break;\n            case \"EndAnchor\":\n                this.visitEndAnchor(node);\n                break;\n            case \"WordBoundary\":\n                this.visitWordBoundary(node);\n                break;\n            case \"NonWordBoundary\":\n                this.visitNonWordBoundary(node);\n                break;\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                break;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"Set\":\n                this.visitSet(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"GroupBackReference\":\n                this.visitGroupBackReference(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) { }\n    visitFlags(node) { }\n    visitDisjunction(node) { }\n    visitAlternative(node) { }\n    // Assertion\n    visitStartAnchor(node) { }\n    visitEndAnchor(node) { }\n    visitWordBoundary(node) { }\n    visitNonWordBoundary(node) { }\n    visitLookahead(node) { }\n    visitNegativeLookahead(node) { }\n    // atoms\n    visitCharacter(node) { }\n    visitSet(node) { }\n    visitGroup(node) { }\n    visitGroupBackReference(node) { }\n    visitQuantifier(node) { }\n}\n//# sourceMappingURL=base-regexp-visitor.js.map","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new RegExpParser();\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n    constructor() {\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join('');\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n    visitChildren(node) {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\nconst visitor = new TerminalRegExpVisitor();\nexport function getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    }\n    catch (_a) {\n        return [];\n    }\n}\nexport function isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * A set of all characters that are considered whitespace by the '\\s' RegExp character class.\n * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\n */\nexport const whitespaceCharacters = ('\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007' +\n    '\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').split('');\nexport function isWhitespace(value) {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return whitespaceCharacters.some((ws) => regexp.test(ws));\n}\nexport function escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nexport function getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, letter => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');\n}\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nexport function partialMatches(regex, input) {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nexport function partialRegExp(regex) {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process() {\n        let result = '', tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        function appendOptional(nbChars) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                }\n                                else {\n                                    appendOptional(6);\n                                }\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n                case '[':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n                case '|':\n                case '^':\n                case '$':\n                case '*':\n                case '+':\n                case '?':\n                    appendRaw(1);\n                    break;\n                case '{':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    }\n                    else {\n                        appendOptional(1);\n                    }\n                    break;\n                case '(':\n                    if (source[i + 1] === '?') {\n                        switch (source[i + 2]) {\n                            case ':':\n                                result += '(?:';\n                                i += 3;\n                                result += process() + '|$)';\n                                break;\n                            case '=':\n                                result += '(?=';\n                                i += 3;\n                                result += process() + ')';\n                                break;\n                            case '!':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case '<':\n                                switch (source[i + 3]) {\n                                    case '=':\n                                    case '!':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf('>', i) - i + 1);\n                                        result += process() + '|$)';\n                                        break;\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        appendRaw(1);\n                        result += process() + '|$)';\n                    }\n                    break;\n                case ')':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n        return result;\n    }\n    return new RegExp(process(), regex.flags);\n}\n//# sourceMappingURL=regexp-utils.js.map","import baseRest from './_baseRest.js';\nimport eq from './eq.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport keysIn from './keysIn.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nexport default defaults;\n","import {\n  __name,\n  configureSvgSize,\n  log\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/rendering-util/insertElementsForSize.js\nimport { select } from \"d3\";\nvar getDiagramElement = /* @__PURE__ */ __name((id, securityLevel) => {\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const svg = root.select(`[id=\"${id}\"]`);\n  return svg;\n}, \"getDiagramElement\");\n\n// src/rendering-util/setupViewPortForSVG.ts\nvar setupViewPortForSVG = /* @__PURE__ */ __name((svg, padding, cssDiagram, useMaxWidth) => {\n  svg.attr(\"class\", cssDiagram);\n  const { width, height, x, y } = calculateDimensionsWithPadding(svg, padding);\n  configureSvgSize(svg, height, width, useMaxWidth);\n  const viewBox = createViewBox(x, y, width, height, padding);\n  svg.attr(\"viewBox\", viewBox);\n  log.debug(`viewBox configured: ${viewBox} with padding: ${padding}`);\n}, \"setupViewPortForSVG\");\nvar calculateDimensionsWithPadding = /* @__PURE__ */ __name((svg, padding) => {\n  const bounds = svg.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 };\n  return {\n    width: bounds.width + padding * 2,\n    height: bounds.height + padding * 2,\n    x: bounds.x,\n    y: bounds.y\n  };\n}, \"calculateDimensionsWithPadding\");\nvar createViewBox = /* @__PURE__ */ __name((x, y, width, height, padding) => {\n  return `${x - padding} ${y - padding} ${width} ${height}`;\n}, \"createViewBox\");\n\nexport {\n  getDiagramElement,\n  setupViewPortForSVG\n};\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import toNumber from './toNumber.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class EmptyFileSystemProvider {\n    readFile() {\n        throw new Error('No file system is available.');\n    }\n    async readDirectory() {\n        return [];\n    }\n}\nexport const EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n//# sourceMappingURL=file-system-provider.js.map","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseMap from './_baseMap.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nexport default map;\n","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';\nimport { inject } from '../dependency-injection.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\nimport { URI } from './uri-utils.js';\nconst minimalGrammarModule = {\n    Grammar: () => undefined,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: ['.langium'],\n        languageId: 'langium'\n    })\n};\nconst minimalSharedGrammarModule = {\n    AstReflection: () => new ast.LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n    const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n    const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nexport function loadGrammarFromJson(json) {\n    var _a;\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));\n    return astNode;\n}\n//# sourceMappingURL=grammar-loader.js.map","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/language/generated/ast.ts\nimport { AbstractAstReflection } from \"langium\";\nvar Statement = \"Statement\";\nvar Architecture = \"Architecture\";\nfunction isArchitecture(item) {\n  return reflection.isInstance(item, Architecture);\n}\n__name(isArchitecture, \"isArchitecture\");\nvar Axis = \"Axis\";\nvar Branch = \"Branch\";\nfunction isBranch(item) {\n  return reflection.isInstance(item, Branch);\n}\n__name(isBranch, \"isBranch\");\nvar Checkout = \"Checkout\";\nvar CherryPicking = \"CherryPicking\";\nvar Commit = \"Commit\";\nfunction isCommit(item) {\n  return reflection.isInstance(item, Commit);\n}\n__name(isCommit, \"isCommit\");\nvar Common = \"Common\";\nfunction isCommon(item) {\n  return reflection.isInstance(item, Common);\n}\n__name(isCommon, \"isCommon\");\nvar Curve = \"Curve\";\nvar Edge = \"Edge\";\nvar Entry = \"Entry\";\nvar GitGraph = \"GitGraph\";\nfunction isGitGraph(item) {\n  return reflection.isInstance(item, GitGraph);\n}\n__name(isGitGraph, \"isGitGraph\");\nvar Group = \"Group\";\nvar Info = \"Info\";\nfunction isInfo(item) {\n  return reflection.isInstance(item, Info);\n}\n__name(isInfo, \"isInfo\");\nvar Junction = \"Junction\";\nvar Merge = \"Merge\";\nfunction isMerge(item) {\n  return reflection.isInstance(item, Merge);\n}\n__name(isMerge, \"isMerge\");\nvar Option = \"Option\";\nvar Packet = \"Packet\";\nfunction isPacket(item) {\n  return reflection.isInstance(item, Packet);\n}\n__name(isPacket, \"isPacket\");\nvar PacketBlock = \"PacketBlock\";\nfunction isPacketBlock(item) {\n  return reflection.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, \"isPacketBlock\");\nvar Pie = \"Pie\";\nfunction isPie(item) {\n  return reflection.isInstance(item, Pie);\n}\n__name(isPie, \"isPie\");\nvar PieSection = \"PieSection\";\nfunction isPieSection(item) {\n  return reflection.isInstance(item, PieSection);\n}\n__name(isPieSection, \"isPieSection\");\nvar Radar = \"Radar\";\nvar Service = \"Service\";\nvar Direction = \"Direction\";\nvar MermaidAstReflection = class extends AbstractAstReflection {\n  static {\n    __name(this, \"MermaidAstReflection\");\n  }\n  getAllTypes() {\n    return [Architecture, Axis, Branch, Checkout, CherryPicking, Commit, Common, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Junction, Merge, Option, Packet, PacketBlock, Pie, PieSection, Radar, Service, Statement];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Entry:axis\": {\n        return Axis;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case Architecture: {\n        return {\n          name: Architecture,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"edges\", defaultValue: [] },\n            { name: \"groups\", defaultValue: [] },\n            { name: \"junctions\", defaultValue: [] },\n            { name: \"services\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Axis: {\n        return {\n          name: Axis,\n          properties: [\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Branch: {\n        return {\n          name: Branch,\n          properties: [\n            { name: \"name\" },\n            { name: \"order\" }\n          ]\n        };\n      }\n      case Checkout: {\n        return {\n          name: Checkout,\n          properties: [\n            { name: \"branch\" }\n          ]\n        };\n      }\n      case CherryPicking: {\n        return {\n          name: CherryPicking,\n          properties: [\n            { name: \"id\" },\n            { name: \"parent\" },\n            { name: \"tags\", defaultValue: [] }\n          ]\n        };\n      }\n      case Commit: {\n        return {\n          name: Commit,\n          properties: [\n            { name: \"id\" },\n            { name: \"message\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Common: {\n        return {\n          name: Common,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Curve: {\n        return {\n          name: Curve,\n          properties: [\n            { name: \"entries\", defaultValue: [] },\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Edge: {\n        return {\n          name: Edge,\n          properties: [\n            { name: \"lhsDir\" },\n            { name: \"lhsGroup\", defaultValue: false },\n            { name: \"lhsId\" },\n            { name: \"lhsInto\", defaultValue: false },\n            { name: \"rhsDir\" },\n            { name: \"rhsGroup\", defaultValue: false },\n            { name: \"rhsId\" },\n            { name: \"rhsInto\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Entry: {\n        return {\n          name: Entry,\n          properties: [\n            { name: \"axis\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case GitGraph: {\n        return {\n          name: GitGraph,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Group: {\n        return {\n          name: Group,\n          properties: [\n            { name: \"icon\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Info: {\n        return {\n          name: Info,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Junction: {\n        return {\n          name: Junction,\n          properties: [\n            { name: \"id\" },\n            { name: \"in\" }\n          ]\n        };\n      }\n      case Merge: {\n        return {\n          name: Merge,\n          properties: [\n            { name: \"branch\" },\n            { name: \"id\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Option: {\n        return {\n          name: Option,\n          properties: [\n            { name: \"name\" },\n            { name: \"value\", defaultValue: false }\n          ]\n        };\n      }\n      case Packet: {\n        return {\n          name: Packet,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"blocks\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PacketBlock: {\n        return {\n          name: PacketBlock,\n          properties: [\n            { name: \"end\" },\n            { name: \"label\" },\n            { name: \"start\" }\n          ]\n        };\n      }\n      case Pie: {\n        return {\n          name: Pie,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"sections\", defaultValue: [] },\n            { name: \"showData\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PieSection: {\n        return {\n          name: PieSection,\n          properties: [\n            { name: \"label\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Radar: {\n        return {\n          name: Radar,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"axes\", defaultValue: [] },\n            { name: \"curves\", defaultValue: [] },\n            { name: \"options\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Service: {\n        return {\n          name: Service,\n          properties: [\n            { name: \"icon\" },\n            { name: \"iconText\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Direction: {\n        return {\n          name: Direction,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"dir\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection = new MermaidAstReflection();\n\n// src/language/generated/grammar.ts\nimport { loadGrammarFromJson } from \"langium\";\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Info\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"InfoGrammar\");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Packet\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Pie\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"PieGrammar\");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Architecture\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"LeftPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"RightPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Arrow\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TEXT_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\(\\\\\"[^\\\\\"]+\\\\\"\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"ArchitectureGrammar\");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"GitGraph\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+(?=\\\\\\\\s)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar loadedRadarGrammar;\nvar RadarGrammar = /* @__PURE__ */ __name(() => loadedRadarGrammar ?? (loadedRadarGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Radar\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]},{\"$type\":\"Interface\",\"name\":\"Entry\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"axis\",\"isOptional\":true,\"type\":{\"$type\":\"ReferenceType\",\"referenceType\":{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@12\"}}}},{\"$type\":\"TypeAttribute\",\"name\":\"value\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"number\"},\"isOptional\":false}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Radar\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\"radar-beta:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"axis\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"curve\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Label\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"]\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Axis\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Curve\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\"}\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Entries\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"DetailedEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"axis\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@12\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Keyword\",\"value\":\":\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NumberEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Option\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showLegend\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"ticks\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"max\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"min\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"graticule\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"GRATICULE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"circle\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"polygon\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[a-zA-Z_][a-zA-Z0-9\\\\\\\\-_]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"RadarGrammar\");\n\n// src/language/generated/module.ts\nvar InfoLanguageMetaData = {\n  languageId: \"info\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PacketLanguageMetaData = {\n  languageId: \"packet\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PieLanguageMetaData = {\n  languageId: \"pie\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: \"architecture\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar GitGraphLanguageMetaData = {\n  languageId: \"gitGraph\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar RadarLanguageMetaData = {\n  languageId: \"radar\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), \"AstReflection\")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar RadarGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => RadarGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => RadarLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\n\n// src/language/common/valueConverter.ts\nimport { DefaultValueConverter } from \"langium\";\n\n// src/language/common/matcher.ts\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\n\n// src/language/common/valueConverter.ts\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = class extends DefaultValueConverter {\n  static {\n    __name(this, \"AbstractMermaidValueConverter\");\n  }\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n    }\n    return void 0;\n  }\n};\nvar CommonValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"CommonValueConverter\");\n  }\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n};\n\n// src/language/common/tokenBuilder.ts\nimport { DefaultTokenBuilder } from \"langium\";\nvar AbstractMermaidTokenBuilder = class extends DefaultTokenBuilder {\n  static {\n    __name(this, \"AbstractMermaidTokenBuilder\");\n  }\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n      }\n    });\n    return tokenTypes;\n  }\n};\nvar CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"CommonTokenBuilder\");\n  }\n};\n\nexport {\n  __name,\n  Statement,\n  Architecture,\n  isArchitecture,\n  Branch,\n  isBranch,\n  Commit,\n  isCommit,\n  isCommon,\n  GitGraph,\n  isGitGraph,\n  Info,\n  isInfo,\n  Merge,\n  isMerge,\n  Packet,\n  isPacket,\n  PacketBlock,\n  isPacketBlock,\n  Pie,\n  isPie,\n  PieSection,\n  isPieSection,\n  Radar,\n  MermaidGeneratedSharedModule,\n  InfoGeneratedModule,\n  PacketGeneratedModule,\n  PieGeneratedModule,\n  ArchitectureGeneratedModule,\n  GitGraphGeneratedModule,\n  RadarGeneratedModule,\n  AbstractMermaidValueConverter,\n  CommonValueConverter,\n  AbstractMermaidTokenBuilder,\n  CommonTokenBuilder\n};\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCrossReference, isRuleCall } from '../languages/generated/ast.js';\nimport { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';\nexport class DefaultValueConverter {\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if (isCrossReference(feature)) {\n            feature = getCrossReferenceTerminal(feature);\n        }\n        if (isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error('This cst node was not parsed by a rule.');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch (rule.name.toUpperCase()) {\n            case 'INT': return ValueConverter.convertInt(input);\n            case 'STRING': return ValueConverter.convertString(input);\n            case 'ID': return ValueConverter.convertID(input);\n        }\n        switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case 'number': return ValueConverter.convertNumber(input);\n            case 'boolean': return ValueConverter.convertBoolean(input);\n            case 'bigint': return ValueConverter.convertBigint(input);\n            case 'date': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\nexport var ValueConverter;\n(function (ValueConverter) {\n    function convertString(input) {\n        let result = '';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === '\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            }\n            else {\n                result += c;\n            }\n        }\n        return result;\n    }\n    ValueConverter.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch (char) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            case '0': return '\\0';\n            default: return char;\n        }\n    }\n    function convertID(input) {\n        if (input.charAt(0) === '^') {\n            return input.substring(1);\n        }\n        else {\n            return input;\n        }\n    }\n    ValueConverter.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    ValueConverter.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    ValueConverter.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    ValueConverter.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    ValueConverter.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === 'true';\n    }\n    ValueConverter.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n//# sourceMappingURL=value-converter.js.map","import assignValue from './_assignValue.js';\nimport castPath from './_castPath.js';\nimport isIndex from './_isIndex.js';\nimport isObject from './isObject.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nexport default baseSet;\n","import baseGet from './_baseGet.js';\nimport baseSet from './_baseSet.js';\nimport castPath from './_castPath.js';\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nexport default basePickBy;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nexport default baseLt;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node) {\n    return new TreeStreamImpl(node, element => {\n        if (isCompositeCstNode(element)) {\n            return element.content;\n        }\n        else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node) {\n    return streamCst(node).filter(isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child, parent) {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tokenToRange(token) {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn, // endColumn uses the correct index\n            line: token.endLine - 1\n        }\n    };\n}\nexport function toDocumentSegment(node) {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\nexport var RangeComparison;\n(function (RangeComparison) {\n    RangeComparison[RangeComparison[\"Before\"] = 0] = \"Before\";\n    RangeComparison[RangeComparison[\"After\"] = 1] = \"After\";\n    RangeComparison[RangeComparison[\"OverlapFront\"] = 2] = \"OverlapFront\";\n    RangeComparison[RangeComparison[\"OverlapBack\"] = 3] = \"OverlapBack\";\n    RangeComparison[RangeComparison[\"Inside\"] = 4] = \"Inside\";\n    RangeComparison[RangeComparison[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nexport function compareRange(range, to) {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\n        return RangeComparison.Before;\n    }\n    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    }\n    else if (startInside) {\n        return RangeComparison.OverlapBack;\n    }\n    else if (endInside) {\n        return RangeComparison.OverlapFront;\n    }\n    else {\n        return RangeComparison.Outside;\n    }\n}\nexport function inRange(range, to) {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\nexport function findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nexport function isCommentNode(cstNode, commentNames) {\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = undefined;\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        }\n        else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n    return closestNode;\n}\nexport function getPreviousNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getNextNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getStartlineNode(node) {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        }\n        else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\nexport function getInteriorNodes(start, end) {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        }\n        else {\n            break;\n        }\n    }\n    return current;\n}\nfunction getParentChain(node) {\n    const chain = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n//# sourceMappingURL=cst-utils.js.map","import baseExtremum from './_baseExtremum.js';\nimport baseLt from './_baseLt.js';\nimport identity from './identity.js';\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nexport default min;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  GitGraphGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/gitGraph/module.ts\nimport {\n  inject,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  EmptyFileSystem\n} from \"langium\";\n\n// src/language/gitGraph/tokenBuilder.ts\nvar GitGraphTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"GitGraphTokenBuilder\");\n  }\n  constructor() {\n    super([\"gitGraph\"]);\n  }\n};\n\n// src/language/gitGraph/module.ts\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new GitGraphTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createGitGraphServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const GitGraph = inject(\n    createDefaultCoreModule({ shared }),\n    GitGraphGeneratedModule,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph);\n  return { shared, GitGraph };\n}\n__name(createGitGraphServices, \"createGitGraphServices\");\n\nexport {\n  GitGraphModule,\n  createGitGraphServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  MermaidGeneratedSharedModule,\n  PieGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/pie/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/pie/tokenBuilder.ts\nvar PieTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PieTokenBuilder\");\n  }\n  constructor() {\n    super([\"pie\", \"showData\"]);\n  }\n};\n\n// src/language/pie/valueConverter.ts\nvar PieValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"PieValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== \"PIE_SECTION_LABEL\") {\n      return void 0;\n    }\n    return input.replace(/\"/g, \"\").trim();\n  }\n};\n\n// src/language/pie/module.ts\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PieTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new PieValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPieServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Pie = inject(\n    createDefaultCoreModule({ shared }),\n    PieGeneratedModule,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie);\n  return { shared, Pie };\n}\n__name(createPieServices, \"createPieServices\");\n\nexport {\n  PieModule,\n  createPieServices\n};\n","var LIB;(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf(\"/\");if(a!==n.length-1){-1===a?(n=\"\",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf(\"/\"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=h,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+=\"..\":g+=\"/..\");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),\"object\"==typeof process)t=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let e=navigator.userAgent;t=e.indexOf(\"Windows\")>=0}const e=/^\\w[\\w\\d+.-]*$/,i=/^\\//,o=/^\\/\\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!e.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",a=\"/\",c=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l(\"file\",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&\"file\"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,\"\\\\\")),n}function y(t,e){const r=e?p:d;let n=\"\",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=a,n+=a),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+=\"?\",n+=r(h,!1,!1)),c&&(n+=\"#\",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x=\"/\";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();export const{URI,Utils}=LIB;\n//# sourceMappingURL=index.mjs.map","import baseFlatten from './_baseFlatten.js';\nimport map from './map.js';\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  InfoGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/info/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/info/tokenBuilder.ts\nvar InfoTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"InfoTokenBuilder\");\n  }\n  constructor() {\n    super([\"info\", \"showInfo\"]);\n  }\n};\n\n// src/language/info/module.ts\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new InfoTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createInfoServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Info = inject(\n    createDefaultCoreModule({ shared }),\n    InfoGeneratedModule,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info);\n  return { shared, Info };\n}\n__name(createInfoServices, \"createInfoServices\");\n\nexport {\n  InfoModule,\n  createInfoServices\n};\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n","import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","import {\n  GitGraphModule,\n  createGitGraphServices\n} from \"./chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs\";\nimport {\n  InfoModule,\n  createInfoServices\n} from \"./chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs\";\nimport {\n  PacketModule,\n  createPacketServices\n} from \"./chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs\";\nimport {\n  PieModule,\n  createPieServices\n} from \"./chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs\";\nimport {\n  ArchitectureModule,\n  createArchitectureServices\n} from \"./chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs\";\nimport {\n  RadarModule,\n  createRadarServices\n} from \"./chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs\";\nimport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  Info,\n  InfoGeneratedModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  Pie,\n  PieGeneratedModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  Statement,\n  __name,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isCommon,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection\n} from \"./chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs\";\n\n// src/parse.ts\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ __name(async () => {\n    const { createInfoServices: createInfoServices2 } = await import(\"./chunks/mermaid-parser.core/info-4N47QTOZ.mjs\");\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, \"info\"),\n  packet: /* @__PURE__ */ __name(async () => {\n    const { createPacketServices: createPacketServices2 } = await import(\"./chunks/mermaid-parser.core/packet-KVYON367.mjs\");\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, \"packet\"),\n  pie: /* @__PURE__ */ __name(async () => {\n    const { createPieServices: createPieServices2 } = await import(\"./chunks/mermaid-parser.core/pie-R6RNRRYF.mjs\");\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, \"pie\"),\n  architecture: /* @__PURE__ */ __name(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await import(\"./chunks/mermaid-parser.core/architecture-4AB2E3PP.mjs\");\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, \"architecture\"),\n  gitGraph: /* @__PURE__ */ __name(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await import(\"./chunks/mermaid-parser.core/gitGraph-O2Q2CXLX.mjs\");\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, \"gitGraph\"),\n  radar: /* @__PURE__ */ __name(async () => {\n    const { createRadarServices: createRadarServices2 } = await import(\"./chunks/mermaid-parser.core/radar-MK3ICKWK.mjs\");\n    const parser = createRadarServices2().Radar.parser.LangiumParser;\n    parsers.radar = parser;\n  }, \"radar\")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n__name(parse, \"parse\");\nvar MermaidParseError = class extends Error {\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join(\"\\n\");\n    const parserErrors = result.parserErrors.map((err) => err.message).join(\"\\n\");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n  static {\n    __name(this, \"MermaidParseError\");\n  }\n};\nexport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  ArchitectureModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  GitGraphModule,\n  Info,\n  InfoGeneratedModule,\n  InfoModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  MermaidParseError,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  PacketModule,\n  Pie,\n  PieGeneratedModule,\n  PieModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  RadarModule,\n  Statement,\n  createArchitectureServices,\n  createGitGraphServices,\n  createInfoServices,\n  createPacketServices,\n  createPieServices,\n  createRadarServices,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isCommon,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection,\n  parse\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  ArchitectureGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/architecture/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/architecture/tokenBuilder.ts\nvar ArchitectureTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"ArchitectureTokenBuilder\");\n  }\n  constructor() {\n    super([\"architecture\"]);\n  }\n};\n\n// src/language/architecture/valueConverter.ts\nvar ArchitectureValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"ArchitectureValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"ARCH_ICON\") {\n      return input.replace(/[()]/g, \"\").trim();\n    } else if (rule.name === \"ARCH_TEXT_ICON\") {\n      return input.replace(/[\"()]/g, \"\");\n    } else if (rule.name === \"ARCH_TITLE\") {\n      return input.replace(/[[\\]]/g, \"\").trim();\n    }\n    return void 0;\n  }\n};\n\n// src/language/architecture/module.ts\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new ArchitectureTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new ArchitectureValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createArchitectureServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Architecture = inject(\n    createDefaultCoreModule({ shared }),\n    ArchitectureGeneratedModule,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture);\n  return { shared, Architecture };\n}\n__name(createArchitectureServices, \"createArchitectureServices\");\n\nexport {\n  ArchitectureModule,\n  createArchitectureServices\n};\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nimport filter from \"lodash-es/filter.js\";\nimport { Alternation, NonTerminal, Option, RepetitionMandatory, Repetition, Terminal, RepetitionWithSeparator, RepetitionMandatoryWithSeparator } from \"chevrotain\";\nexport function buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\nexport const ATN_INVALID_TYPE = 0;\nexport const ATN_BASIC = 1;\nexport const ATN_RULE_START = 2;\nexport const ATN_PLUS_BLOCK_START = 4;\nexport const ATN_STAR_BLOCK_START = 5;\n// Currently unused as the ATN is not used for lexing\nexport const ATN_TOKEN_START = 6;\nexport const ATN_RULE_STOP = 7;\nexport const ATN_BLOCK_END = 8;\nexport const ATN_STAR_LOOP_BACK = 9;\nexport const ATN_STAR_LOOP_ENTRY = 10;\nexport const ATN_PLUS_LOOP_BACK = 11;\nexport const ATN_LOOP_END = 12;\nexport class AbstractTransition {\n    constructor(target) {\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n}\nexport class AtomTransition extends AbstractTransition {\n    constructor(target, tokenType) {\n        super(target);\n        this.tokenType = tokenType;\n    }\n}\nexport class EpsilonTransition extends AbstractTransition {\n    constructor(target) {\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport class RuleTransition extends AbstractTransition {\n    constructor(ruleStart, rule, followState) {\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport function createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: new Map(),\n        ruleToStopState: new Map(),\n        states: []\n    };\n    createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const ruleBlock = block(atn, rule, rule);\n        if (ruleBlock === undefined) {\n            continue;\n        }\n        buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const start = newState(atn, rule, undefined, {\n            type: ATN_RULE_START\n        });\n        const stop = newState(atn, rule, undefined, {\n            type: ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\nfunction atom(atn, rule, production) {\n    if (production instanceof Terminal) {\n        return tokenRef(atn, rule, production.terminalType, production);\n    }\n    else if (production instanceof NonTerminal) {\n        return ruleRef(atn, rule, production);\n    }\n    else if (production instanceof Alternation) {\n        return alternation(atn, rule, production);\n    }\n    else if (production instanceof Option) {\n        return option(atn, rule, production);\n    }\n    else if (production instanceof Repetition) {\n        return repetition(atn, rule, production);\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return repetitionSep(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return repetitionMandatory(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return repetitionMandatorySep(atn, rule, production);\n    }\n    else {\n        return block(atn, rule, production);\n    }\n}\nfunction repetition(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    return star(atn, rule, repetition, handle);\n}\nfunction repetitionSep(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return star(atn, rule, repetition, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    return plus(atn, rule, repetition, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return plus(atn, rule, repetition, handle, sep);\n}\nfunction alternation(atn, rule, alternation) {\n    const start = newState(atn, rule, alternation, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const alts = map(alternation.definition, (e) => atom(atn, rule, e));\n    const handle = makeAlts(atn, rule, start, alternation, ...alts);\n    return handle;\n}\nfunction option(atn, rule, option) {\n    const start = newState(atn, rule, option, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));\n    return optional(atn, rule, option, handle);\n}\nfunction block(atn, rule, block) {\n    const handles = filter(map(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);\n    if (handles.length === 1) {\n        return handles[0];\n    }\n    else if (handles.length === 0) {\n        return undefined;\n    }\n    else {\n        return makeBlock(atn, handles);\n    }\n}\nfunction plus(atn, rule, plus, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = newState(atn, rule, plus, {\n        type: ATN_PLUS_LOOP_BACK\n    });\n    defineDecisionState(atn, loop);\n    const end = newState(atn, rule, plus, {\n        type: ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;\n    epsilon(blkEnd, loop); // block can see loop back\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\n    // This influences the chosen option in the lookahead DFA\n    if (sep === undefined) {\n        epsilon(loop, blkStart); // loop back to start\n        epsilon(loop, end); // exit\n    }\n    else {\n        epsilon(loop, end); // exit\n        // loop back to start with separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\nfunction star(atn, rule, star, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_ENTRY\n    });\n    defineDecisionState(atn, entry);\n    const loopEnd = newState(atn, rule, star, {\n        type: ATN_LOOP_END\n    });\n    const loop = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    epsilon(entry, start); // loop enter edge (alt 2)\n    epsilon(entry, loopEnd); // bypass loop edge (alt 1)\n    epsilon(end, loop); // block end hits loop back\n    if (sep !== undefined) {\n        epsilon(loop, loopEnd); // end loop\n        // loop back to start of handle using separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, start);\n    }\n    else {\n        epsilon(loop, entry); // loop back to entry/exit decision\n    }\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\nfunction optional(atn, rule, optional, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    epsilon(start, end);\n    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;\n    return handle;\n}\nfunction defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n    const end = newState(atn, rule, production, {\n        type: ATN_BLOCK_END,\n        start\n    });\n    start.end = end;\n    for (const alt of alts) {\n        if (alt !== undefined) {\n            // hook alts up to decision block\n            epsilon(start, alt.left);\n            epsilon(alt.right, end);\n        }\n        else {\n            epsilon(start, end);\n        }\n    }\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;\n    return handle;\n}\nfunction getProdType(production) {\n    if (production instanceof Alternation) {\n        return 'Alternation';\n    }\n    else if (production instanceof Option) {\n        return 'Option';\n    }\n    else if (production instanceof Repetition) {\n        return 'Repetition';\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return 'RepetitionWithSeparator';\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return 'RepetitionMandatory';\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return 'RepetitionMandatoryWithSeparator';\n    }\n    else {\n        throw new Error('Invalid production type encountered');\n    }\n}\nfunction makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for (let i = 0; i < altsLength - 1; i++) {\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) {\n            transition = handle.left.transitions[0];\n        }\n        const isRuleTransition = transition instanceof RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === ATN_BASIC &&\n            handle.right.type === ATN_BASIC &&\n            transition !== undefined &&\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\n                transition.target === handle.right)) {\n            // we can avoid epsilon edge to next element\n            if (isRuleTransition) {\n                ruleTransition.followState = next;\n            }\n            else {\n                transition.target = next;\n            }\n            removeState(atn, handle.right); // we skipped over this state\n        }\n        else {\n            // need epsilon if previous block's right end node is complex\n            epsilon(handle.right, next);\n        }\n    }\n    const first = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first.left,\n        right: last.right\n    };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n    const left = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    addTransition(left, new AtomTransition(right, tokenType));\n    return {\n        left,\n        right\n    };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const call = new RuleTransition(start, rule, right);\n    addTransition(left, call);\n    return {\n        left,\n        right\n    };\n}\nfunction buildRuleHandle(atn, rule, block) {\n    const start = atn.ruleToStartState.get(rule);\n    epsilon(start, block.left);\n    const stop = atn.ruleToStopState.get(rule);\n    epsilon(block.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\nfunction epsilon(a, b) {\n    const transition = new EpsilonTransition(b);\n    addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n    const t = Object.assign({ atn,\n        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);\n    atn.states.push(t);\n    return t;\n}\nfunction addTransition(state, transition) {\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\n    // Because they are never mixed, only setting the property for the first transition is fine\n    if (state.transitions.length === 0) {\n        state.epsilonOnlyTransitions = transition.isEpsilon();\n    }\n    state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n//# sourceMappingURL=atn.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nexport const DFA_ERROR = {};\nexport class ATNConfigSet {\n    constructor() {\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        // Empties the map to free up memory\n        this.map = {};\n    }\n    add(config) {\n        const key = getATNConfigKey(config);\n        // Only add configs which don't exist in our map already\n        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return map(this.configs, (e) => e.alt);\n    }\n    get key() {\n        let value = \"\";\n        for (const k in this.map) {\n            value += k + \":\";\n        }\n        return value;\n    }\n}\nexport function getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\n//# sourceMappingURL=dfa.js.map","import baseIteratee from './_baseIteratee.js';\nimport baseUniq from './_baseUniq.js';\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nexport default uniqBy;\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { tokenMatcher, tokenLabel, NonTerminal, Alternation, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Repetition, Terminal, LLkLookaheadStrategy, getLookaheadPaths } from \"chevrotain\";\nimport { ATN_RULE_STOP, AtomTransition, buildATNKey, createATN, EpsilonTransition, RuleTransition } from \"./atn.js\";\nimport { ATNConfigSet, DFA_ERROR, getATNConfigKey } from \"./dfa.js\";\nimport min from \"lodash-es/min.js\";\nimport flatMap from \"lodash-es/flatMap.js\";\nimport uniqBy from \"lodash-es/uniqBy.js\";\nimport map from \"lodash-es/map.js\";\nimport flatten from \"lodash-es/flatten.js\";\nimport forEach from \"lodash-es/forEach.js\";\nimport isEmpty from \"lodash-es/isEmpty.js\";\nimport reduce from \"lodash-es/reduce.js\";\nfunction createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet) => {\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            existing = {\n                atnStartState: startState,\n                decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\nclass PredicateSet {\n    constructor() {\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = \"\";\n        const size = this.predicates.length;\n        for (let i = 0; i < size; i++) {\n            value += this.predicates[i] === true ? \"1\" : \"0\";\n        }\n        return value;\n    }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nexport class LLStarLookaheadStrategy extends LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));\n    }\n    initialize(options) {\n        this.atn = createATN(options.rules);\n        this.dfas = initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, 'Alternation', prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: \"Alternation\",\n            rule: rule\n        }), (currAlt) => map(currAlt, (path) => path[0]));\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = reduce(partialAlts, (result, currAlt, idx) => {\n                forEach(currAlt, (currTokType) => {\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) {\n                return function (orAlts) {\n                    var _a;\n                    const nextToken = this.LA(1);\n                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                    if (orAlts !== undefined && prediction !== undefined) {\n                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                        if (gate !== undefined && gate.call(this) === false) {\n                            return undefined;\n                        }\n                    }\n                    return prediction;\n                };\n            }\n            else {\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx];\n                };\n            }\n        }\n        else if (hasPredicates) {\n            return function (orAlts) {\n                const predicates = new PredicateSet();\n                const length = orAlts === undefined ? 0 : orAlts.length;\n                for (let i = 0; i < length; i++) {\n                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                    predicates.set(i, gate === undefined || gate.call(this));\n                }\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n        else {\n            return function () {\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType,\n            rule\n        }), (e) => {\n            return map(e, (g) => g[0]);\n        });\n        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = flatten(alt);\n            if (singleTokensTypes.length === 1 &&\n                isEmpty(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function () {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            }\n            else {\n                const choiceToAlt = reduce(singleTokensTypes, (result, currTokType) => {\n                    if (currTokType !== undefined) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function () {\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n            return typeof result === \"object\" ? false : result === 0;\n        };\n    }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = new Set();\n    for (const alt of sequences) {\n        const altSet = new Set();\n        for (const tokType of alt) {\n            if (tokType === undefined) {\n                if (allowEmpty) {\n                    // Epsilon production encountered\n                    break;\n                }\n                else {\n                    return false;\n                }\n            }\n            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n            for (const index of indices) {\n                if (fullSet.has(index)) {\n                    if (!altSet.has(index)) {\n                        return false;\n                    }\n                }\n                else {\n                    fullSet.add(index);\n                    altSet.add(index);\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for (let i = 0; i < decisionLength; i++) {\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n    }\n    return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === undefined) {\n        const closure = computeStartState(dfa.atnStartState);\n        start = addDFAState(dfa, newDFAState(closure));\n        dfa.start = start;\n    }\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n    return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while (true) {\n        let d = getExistingTargetState(previousD, t);\n        if (d === undefined) {\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n        }\n        if (d === DFA_ERROR) {\n            return buildAdaptivePredictError(path, previousD, t);\n        }\n        if (d.isAcceptState === true) {\n            return d.prediction;\n        }\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        addDFAEdge(dfa, previousD, token, DFA_ERROR);\n        return DFA_ERROR;\n    }\n    let newState = newDFAState(reach);\n    const predictedAlt = getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== undefined) {\n        newState.isAcceptState = true;\n        newState.prediction = predictedAlt;\n        newState.configs.uniqueAlt = predictedAlt;\n    }\n    else if (hasConflictTerminatingPrediction(reach)) {\n        const prediction = min(reach.alts);\n        newState.isAcceptState = true;\n        newState.prediction = prediction;\n        newState.configs.uniqueAlt = prediction;\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n    }\n    newState = addDFAEdge(dfa, previousD, token, newState);\n    return newState;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for (let i = 1; i <= lookahead; i++) {\n        prefixPath.push(this.LA(i).tokenType);\n    }\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = buildAmbiguityError({\n        topLevelRule,\n        ambiguityIndices,\n        production,\n        prefixPath\n    });\n    logging(message);\n}\nfunction buildAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n    const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName(options.production)}${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage =\n        currMessage +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n            `For Further details.`;\n    return currMessage;\n}\nfunction getProductionDslName(prod) {\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = flatMap(previous.configs.elements, (e) => e.state.transitions);\n    const nextTokenTypes = uniqBy(nextTransitions\n        .filter((e) => e instanceof AtomTransition)\n        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\nfunction getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n    const intermediate = new ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === false) {\n            continue;\n        }\n        if (c.state.type === ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for (let i = 0; i < transitionLength; i++) {\n            const transition = c.state.transitions[i];\n            const target = getReachableTarget(transition, token);\n            if (target !== undefined) {\n                intermediate.add({\n                    state: target,\n                    alt: c.alt,\n                    stack: c.stack\n                });\n            }\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\n        reach = intermediate;\n    }\n    if (reach === undefined) {\n        reach = new ATNConfigSet();\n        for (const c of intermediate.elements) {\n            closure(c, reach);\n        }\n    }\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n        for (const c of skippedStopStates) {\n            reach.add(c);\n        }\n    }\n    return reach;\n}\nfunction getReachableTarget(transition, token) {\n    if (transition instanceof AtomTransition &&\n        tokenMatcher(token, transition.tokenType)) {\n        return transition.target;\n    }\n    return undefined;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === true) {\n            if (alt === undefined) {\n                alt = c.alt;\n            }\n            else if (alt !== c.alt) {\n                return undefined;\n            }\n        }\n    }\n    return alt;\n}\nfunction newDFAState(closure) {\n    return {\n        configs: closure,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n    to = addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\nfunction addDFAState(dfa, state) {\n    if (state === DFA_ERROR) {\n        return state;\n    }\n    // Repetitions have the same config set\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== undefined) {\n        return existing;\n    }\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\nfunction computeStartState(atnState) {\n    const configs = new ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for (let i = 0; i < numberOfTransitions; i++) {\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        closure(config, configs);\n    }\n    return configs;\n}\nfunction closure(config, configs) {\n    const p = config.state;\n    if (p.type === ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [...config.stack];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            closure(followConfig, configs);\n        }\n        else {\n            // Dipping into outer context, simply add the config\n            // This will stop computation once every config is at the rule stop state\n            configs.add(config);\n        }\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) {\n        configs.add(config);\n    }\n    const transitionLength = p.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n        const transition = p.transitions[i];\n        const c = getEpsilonTarget(config, transition);\n        if (c !== undefined) {\n            closure(c, configs);\n        }\n    }\n}\nfunction getEpsilonTarget(config, transition) {\n    if (transition instanceof EpsilonTransition) {\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: config.stack\n        };\n    }\n    else if (transition instanceof RuleTransition) {\n        const stack = [...config.stack, transition.followState];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack\n        };\n    }\n    return undefined;\n}\nfunction hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type === ATN_RULE_STOP) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type !== ATN_RULE_STOP) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n    if (allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    const altSets = getConflictingAltSets(configs.elements);\n    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n    const configToAlts = new Map();\n    for (const c of configs) {\n        const key = getATNConfigKey(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === undefined) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length > 1) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length === 1) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=all-star-lookahead.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line, character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri, range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range,\n            color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = { range, message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command, ...args) {\n        let result = { title, command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range, newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = { label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument, edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'create',\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: 'rename',\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'delete',\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */\nclass ChangeAnnotations {\n    constructor(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nexport class WorkspaceChange {\n    constructor(workspaceEdit) {\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change) => {\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key) => {\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */\n    get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            }\n            else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            const textDocument = { uri: key.uri, version: key.version };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri, languageId, version, text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText, insert, replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label, documentation } : { label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = { label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        let result = { range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: { uri, range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name, kind, location: { uri, range } }\n            : { name, kind, location: { uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        let result = { diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = { title };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        let result = { range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize, insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range, target, data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range, parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range, text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range, variableName, caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range, expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId, stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        const result = { position, label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var StringValue;\n(function (StringValue) {\n    function createSnippet(value) {\n        return { kind: 'snippet', value };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nexport var InlineCompletionItem;\n(function (InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return { insertText, filterText, range, command };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nexport var InlineCompletionList;\n(function (InlineCompletionList) {\n    function create(items) {\n        return { items };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */\n    InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */\n    InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SelectedCompletionInfo;\n(function (SelectedCompletionInfo) {\n    function create(range, text) {\n        return { range, text };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nexport var InlineCompletionContext;\n(function (InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return { triggerKind, selectedCompletionInfo };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport const EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = (data.length / 2) | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for (let i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function (Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position } from 'vscode-languageserver-types';\nimport { tokenToRange } from '../utils/cst-utils.js';\nexport class CstNodeBuilder {\n    constructor() {\n        this.nodeStack = [];\n    }\n    get current() {\n        var _a;\n        return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;\n    }\n    buildRootNode(input) {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n    addHiddenNodes(tokens) {\n        const nodes = [];\n        for (const token of tokens) {\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n            leafNode.root = this.rootNode;\n            nodes.push(leafNode);\n        }\n        let current = this.current;\n        let added = false;\n        // If we are within a composite node, we add the hidden nodes to the content\n        if (current.content.length > 0) {\n            current.content.push(...nodes);\n            return;\n        }\n        // Otherwise we are at a newly created node\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\n        while (current.container) {\n            const index = current.container.content.indexOf(current);\n            if (index > 0) {\n                // Add the hidden nodes before the current node\n                current.container.content.splice(index, 0, ...nodes);\n                added = true;\n                break;\n            }\n            current = current.container;\n        }\n        // If we arrive at the root node, we add the hidden nodes at the beginning\n        // This is the case if the hidden nodes are the first nodes in the tree\n        if (!added) {\n            this.rootNode.content.unshift(...nodes);\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === 'string') {\n            this.current.astNode = item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n            this.removeNode(node);\n        }\n    }\n}\nexport class AbstractCstNode {\n    /** @deprecated use `container` instead. */\n    get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */\n    get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) {\n            throw new Error('This node has no associated AST element');\n        }\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */\n    get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\nexport class LeafCstNodeImpl extends AbstractCstNode {\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\nexport class CompositeCstNodeImpl extends AbstractCstNode {\n    constructor() {\n        super(...arguments);\n        this.content = new CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */\n    get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        }\n        else {\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\n        }\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\nclass CstNodeContainer extends Array {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items) {\n            item.container = this.parent;\n        }\n    }\n}\nexport class RootCstNodeImpl extends CompositeCstNodeImpl {\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input) {\n        super();\n        this._text = '';\n        this._text = input !== null && input !== void 0 ? input : '';\n    }\n}\n//# sourceMappingURL=cst-node-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\nimport { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';\nimport { getExplicitRuleType, isDataTypeRule } from '../utils/grammar-utils.js';\nimport { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';\nimport { CstNodeBuilder } from './cst-node-builder.js';\nexport const DatatypeSymbol = Symbol('Datatype');\nfunction isDataTypeNode(node) {\n    return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = '\\u200B';\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nexport class AbstractLangiumParser {\n    constructor(services) {\n        this._unorderedGroups = new Map();\n        this.allRules = new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    getRule(name) {\n        return this.allRules.get(name);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\nexport class LangiumParser extends AbstractLangiumParser {\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services) {\n        super(services);\n        this.nodeBuilder = new CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = this.computeRuleType(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    computeRuleType(rule) {\n        if (rule.fragment) {\n            return undefined;\n        }\n        else if (isDataTypeRule(rule)) {\n            return DatatypeSymbol;\n        }\n        else {\n            const explicit = getExplicitRuleType(rule);\n            return explicit !== null && explicit !== void 0 ? explicit : rule.name;\n        }\n    }\n    parse(input, options = {}) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\n        if (!ruleMethod) {\n            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');\n        }\n        const result = ruleMethod.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        this.lexerResult = undefined;\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            lexerReport: lexerResult.report,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args) => {\n            // Only create a new AST node in case the calling rule is not a fragment rule\n            const createNode = !this.isRecording() && $type !== undefined;\n            if (createNode) {\n                const node = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = '';\n                }\n            }\n            let result;\n            try {\n                result = implementation(args);\n            }\n            catch (err) {\n                result = undefined;\n            }\n            if (result === undefined && createNode) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n    extractHiddenTokens(token) {\n        const hiddenTokens = this.lexerResult.hidden;\n        if (!hiddenTokens.length) {\n            return [];\n        }\n        const offset = token.startOffset;\n        for (let i = 0; i < hiddenTokens.length; i++) {\n            const token = hiddenTokens[i];\n            if (token.startOffset > offset) {\n                return hiddenTokens.splice(0, i);\n            }\n        }\n        return hiddenTokens.splice(0, hiddenTokens.length);\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const hiddenTokens = this.extractHiddenTokens(token);\n            this.nodeBuilder.addHiddenNodes(hiddenTokens);\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            }\n            else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!isKeyword(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        let cstNode;\n        if (!this.isRecording() && !fragment) {\n            // We only want to create a new CST node if the subrule actually creates a new AST node.\n            // In other cases like calls of fragment rules the current CST/AST is populated further.\n            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.\n            // This is intended, as fragment rules only enrich the current AST node\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        }\n        else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            }\n            else if (typeof result === 'object' && result) {\n                const object = this.assignWithoutOverride(result, current);\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            if (action.feature && action.operator) {\n                last = this.construct();\n                this.nodeBuilder.removeNode(last.$cstNode);\n                const node = this.nodeBuilder.buildCompositeNode(action);\n                node.content.push(last.$cstNode);\n                const newItem = { $type };\n                this.stack.push(newItem);\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n            else {\n                last.$type = $type;\n            }\n        }\n    }\n    construct() {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        this.stack.pop();\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        }\n        else {\n            assignMandatoryProperties(this.astReflection, obj);\n        }\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = getContainerOfType(feature, isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === 'string') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        }\n        else {\n            item = value;\n        }\n        switch (operator) {\n            case '=': {\n                obj[feature] = item;\n                break;\n            }\n            case '?=': {\n                obj[feature] = true;\n                break;\n            }\n            case '+=': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            }\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        // The target was parsed from a unassigned subrule\n        // After the subrule construction, it received a cst node\n        // This CST node will later be overriden by the cst node builder\n        // To prevent references to stale AST nodes in the CST,\n        // we need to remove the reference here\n        const targetCstNode = target.$cstNode;\n        if (targetCstNode) {\n            targetCstNode.astNode = undefined;\n            target.$cstNode = undefined;\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n}\nexport class AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage(options) {\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage({ expected, actual }) {\n        const expectedMsg = expected.LABEL\n            ? '`' + expected.LABEL + '`'\n            : expected.name.endsWith(':KW')\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\n                : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\nexport class LangiumCompletionParser extends AbstractLangiumParser {\n    constructor() {\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {\n        // NOOP\n    }\n    construct() {\n        // NOOP\n        return undefined;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input, { mode: 'partial' });\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            }\n            finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n}\nconst defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: 'full',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n    constructor(tokens, config) {\n        const useDefaultLookahead = config && 'maxLookahead' in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new LLStarLookaheadStrategy({\n                    // If validations are skipped, don't log the lookahead warnings\n                    logging: config.skipValidations ? () => { } : undefined\n                }) }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n}\n//# sourceMappingURL=langium-parser.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\nexport function createParser(grammar, parser, tokens) {\n    const parserContext = {\n        parser,\n        tokens,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\nfunction buildRules(parserContext, grammar) {\n    const reachable = getAllReachableRules(grammar, false);\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n    }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if (isKeyword(element)) {\n        method = buildKeyword(ctx, element);\n    }\n    else if (isAction(element)) {\n        method = buildAction(ctx, element);\n    }\n    else if (isAssignment(element)) {\n        method = buildElement(ctx, element.terminal);\n    }\n    else if (isCrossReference(element)) {\n        method = buildCrossReference(ctx, element);\n    }\n    else if (isRuleCall(element)) {\n        method = buildRuleCall(ctx, element);\n    }\n    else if (isAlternatives(element)) {\n        method = buildAlternatives(ctx, element);\n    }\n    else if (isUnorderedGroup(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    }\n    else if (isGroup(element)) {\n        method = buildGroup(ctx, element);\n    }\n    else if (isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, EOF, element);\n    }\n    else {\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n    const actionType = getTypeName(action);\n    return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if (isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const fragment = rule.fragment;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n    }\n    else if (isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    }\n    else if (!rule) {\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n    }\n    else {\n        assertUnreachable(rule);\n    }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\nfunction buildPredicate(condition) {\n    if (isDisjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    }\n    else if (isConjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    }\n    else if (isNegation(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    }\n    else if (isParameterReference(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args) => args !== undefined && args[name] === true;\n    }\n    else if (isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    }\n    else {\n        const methods = [];\n        for (const element of alternatives.elements) {\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\nfunction buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods = [];\n    for (const element of group.elements) {\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = (groupIdx, lParser) => {\n        const stackId = lParser.getRuleStack().join('-');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key);\n                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        }\n        else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\nfunction buildGroup(ctx, group) {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n    if (isGroup(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n        }\n        const assignment = findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) {\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    }\n    else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n        // The terminal is a data type rule here. Everything else will result in a validation error.\n        const rule = terminal.rule.ref;\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n    }\n    else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    }\n    else if (isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error('Could not build cross reference parser');\n    }\n}\nfunction buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error('Could not find token for keyword: ' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n    const gate = guard && buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return method;\n        }\n    }\n    if (cardinality === '*') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else if (cardinality === '+') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    }\n    else if (cardinality === '?') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else {\n        assertUnreachable(cardinality);\n    }\n}\nfunction getRule(ctx, element) {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.parser.getRule(name);\n    if (!rule)\n        throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\nfunction getRuleName(ctx, element) {\n    if (isParserRule(element)) {\n        return element.name;\n    }\n    else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element);\n    }\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while (!isParserRule(parent)) {\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + ':' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + ':' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\nfunction getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token)\n        throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n//# sourceMappingURL=parser-builder-base.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nexport function createLangiumParser(services) {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nexport function prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumParser(services);\n    return createParser(grammar, parser, lexer.definition);\n}\n//# sourceMappingURL=langium-parser-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\n */\nexport function delayNextTick() {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === 'undefined') {\n            setTimeout(resolve, 0);\n        }\n        else {\n            setImmediate(resolve);\n        }\n    });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nexport function startCancelableOperation() {\n    lastTick = performance.now();\n    return new CancellationTokenSource();\n}\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nexport function setInterruptionPeriod(period) {\n    globalInterruptionPeriod = period;\n}\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nexport const OperationCancelled = Symbol('OperationCancelled');\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nexport function isOperationCancelled(err) {\n    return err === OperationCancelled;\n}\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nexport async function interruptAndCheck(token) {\n    if (token === CancellationToken.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = performance.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n        // prevent calling delayNextTick every iteration of loop\n        // where delayNextTick takes up the majority or all of the\n        // globalInterruptionPeriod itself\n        lastTick = performance.now();\n    }\n    if (token.isCancellationRequested) {\n        throw OperationCancelled;\n    }\n}\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nexport class Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (arg) => {\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err) => {\n                reject(err);\n                return this;\n            };\n        });\n    }\n}\n//# sourceMappingURL=promise-utils.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) {\n            return lineOffset;\n        }\n        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n            offset--;\n        }\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charCodeAt(i);\n        if (isEOL(ch)) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction isEOL(char) {\n    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\nexport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { TextDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { URI } from '../utils/uri-utils.js';\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nexport var DocumentState;\n(function (DocumentState) {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    DocumentState[DocumentState[\"Changed\"] = 0] = \"Changed\";\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    DocumentState[DocumentState[\"Parsed\"] = 1] = \"Parsed\";\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    DocumentState[DocumentState[\"IndexedContent\"] = 2] = \"IndexedContent\";\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    DocumentState[DocumentState[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    DocumentState[DocumentState[\"Linked\"] = 4] = \"Linked\";\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    DocumentState[DocumentState[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    DocumentState[DocumentState[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nexport class DefaultLangiumDocumentFactory {\n    constructor(services) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = CancellationToken.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, token) {\n        uri = uri !== null && uri !== void 0 ? uri : URI.parse(textDocument.uri);\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, textDocument, token);\n        }\n        else {\n            return this.create(uri, textDocument, token);\n        }\n    }\n    fromString(text, uri, token) {\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, text, token);\n        }\n        else {\n            return this.create(uri, text, token);\n        }\n    }\n    fromModel(model, uri) {\n        return this.create(uri, { $model: model });\n    }\n    create(uri, content, options) {\n        if (typeof content === 'string') {\n            const parseResult = this.parse(uri, content, options);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else if ('$model' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument(parseResult, uri);\n        }\n        else {\n            const parseResult = this.parse(uri, content.getText(), options);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === 'string') {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) {\n            Object.defineProperty(document, 'textDocument', {\n                value: textDocument\n            });\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, 'textDocument', {\n                get: textDocumentGetter\n            });\n        }\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text, options) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text, options);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = undefined;\n        return () => {\n            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : ''));\n        };\n    }\n}\nexport class DefaultLangiumDocuments {\n    constructor(services) {\n        this.documentMap = new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get all() {\n        return stream(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        }\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\n            linker.unlink(langiumDoc);\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n//# sourceMappingURL=documents.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { DocumentState } from '../workspace/documents.js';\nconst ref_resolving = Symbol('ref_resolving');\nexport class DefaultLinker {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = CancellationToken.None) {\n        for (const node of streamAst(document.parseResult.value)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        var _a;\n        const ref = refInfo.reference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            ref._ref = ref_resolving;\n            try {\n                const description = this.getCandidate(refInfo);\n                if (isLinkingError(description)) {\n                    ref._ref = description;\n                }\n                else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                    }\n                    else {\n                        // Try to load the target AST node later using the already provided description\n                        ref._ref = undefined;\n                    }\n                }\n            }\n            catch (err) {\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\n                const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });\n            }\n            // Add the reference to the document's array of references\n            // Only add if the reference has been not been resolved earlier\n            // Otherwise we end up with duplicates\n            // See also implementation of `buildReference`\n            document.references.push(ref);\n        }\n    }\n    unlink(document) {\n        for (const ref of document.references) {\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref() {\n                var _a;\n                if (isAstNode(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                }\n                else if (isAstNodeDescription(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                }\n                else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    this._ref = ref_resolving;\n                    const document = findRootNode(node).$document;\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && document && document.state < DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\n                        return this._ref = undefined;\n                    }\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                    document === null || document === void 0 ? void 0 : document.references.push(this);\n                }\n                else if (this._ref === ref_resolving) {\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\n                }\n                return isAstNode(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return isLinkingError(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        var _a;\n        try {\n            const description = this.getCandidate(refInfo);\n            if (isLinkingError(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error: this.createLinkingError(refInfo, description)\n                };\n            }\n        }\n        catch (err) {\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\n            const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n            return {\n                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = findRootNode(refInfo.container).$document;\n        if (document && document.state < DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n    }\n}\n//# sourceMappingURL=linker.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findNodeForProperty } from '../utils/grammar-utils.js';\nexport function isNamed(node) {\n    return typeof node.name === 'string';\n}\nexport class DefaultNameProvider {\n    getName(node) {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n    getNameNode(node) {\n        return findNodeForProperty(node.$cstNode, 'name');\n    }\n}\n//# sourceMappingURL=name-provider.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI, Utils } from 'vscode-uri';\nexport { URI };\nexport var UriUtils;\n(function (UriUtils) {\n    UriUtils.basename = Utils.basename;\n    UriUtils.dirname = Utils.dirname;\n    UriUtils.extname = Utils.extname;\n    UriUtils.joinPath = Utils.joinPath;\n    UriUtils.resolvePath = Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    UriUtils.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === 'string' ? from : from.path;\n        const toPath = typeof to === 'string' ? to : to.path;\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\n        const toParts = toPath.split('/').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = '../'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join('/');\n        return backPart + toPart;\n    }\n    UriUtils.relative = relative;\n    function normalize(uri) {\n        return URI.parse(uri.toString()).toString();\n    }\n    UriUtils.normalize = normalize;\n})(UriUtils || (UriUtils = {}));\n//# sourceMappingURL=uri-utils.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findAssignment } from '../utils/grammar-utils.js';\nimport { isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultReferences {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if (isReference(reference)) {\n                    return reference.ref;\n                }\n                else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if (isReference(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return undefined;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return stream(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=references.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Reduction, stream } from './stream.js';\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nexport class MultiMap {\n    constructor(elements) {\n        this.map = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n    /**\n     * The total number of values in the multimap.\n     */\n    get size() {\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\n    }\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear() {\n        this.map.clear();\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key, value) {\n        if (value === undefined) {\n            return this.map.delete(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    }\n                    else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key, value) {\n        if (value === undefined) {\n            return this.map.has(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key, value) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(value);\n        }\n        else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key, values) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(...values);\n        }\n        else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn) {\n        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));\n    }\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries() {\n        return stream(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value]));\n    }\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys() {\n        return stream(this.map.keys());\n    }\n    /**\n     * Returns a stream of values in the map.\n     */\n    values() {\n        return stream(this.map.values()).flat();\n    }\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey() {\n        return stream(this.map.entries());\n    }\n}\nexport class BiMap {\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements) {\n        this.map = new Map();\n        this.inverse = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=collections.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { streamAllContents, streamContents } from '../utils/ast-utils.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nexport class DefaultScopeComputation {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = CancellationToken.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCancelled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = CancellationToken.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n    async computeLocalScopes(document, cancelToken = CancellationToken.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new MultiMap();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of streamAllContents(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n}\n//# sourceMappingURL=scope-computation.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nexport class StreamScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        }\n        else {\n            return this.elements;\n        }\n    }\n    getElement(name) {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\nexport class MapScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n    getAllElements() {\n        let elementStream = stream(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n}\nexport const EMPTY_SCOPE = {\n    getElement() {\n        return undefined;\n    },\n    getAllElements() {\n        return EMPTY_STREAM;\n    }\n};\n//# sourceMappingURL=scope.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DisposableCache {\n    constructor() {\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error('This cache has already been disposed');\n        }\n    }\n}\nexport class SimpleCache extends DisposableCache {\n    constructor() {\n        super(...arguments);\n        this.cache = new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\nexport class ContextCache extends DisposableCache {\n    constructor(converter) {\n        super();\n        this.cache = new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        }\n        else {\n            this.cache.clear();\n        }\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nexport class DocumentCache extends ContextCache {\n    /**\n     * Creates a new document cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     *\n     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,\n     * which triggers on all documents that have been affected by this change, assuming that the\n     * state is `DocumentState.Linked` or a later state.\n     */\n    constructor(sharedServices, state) {\n        super(uri => uri.toString());\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {\n                this.clear(document.uri.toString());\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                for (const uri of deleted) { // react only on deleted documents\n                    this.clear(uri);\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n                const allUris = changed.concat(deleted); // react on both changed and deleted documents\n                for (const uri of allUris) {\n                    this.clear(uri);\n                }\n            }));\n        }\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace is added, changed or deleted, the whole cache is evicted.\n */\nexport class WorkspaceCache extends SimpleCache {\n    /**\n     * Creates a new workspace cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     */\n    constructor(sharedServices, state) {\n        super();\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\n                this.clear();\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                if (deleted.length > 0) { // react only on deleted documents\n                    this.clear();\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n                this.clear();\n            }));\n        }\n    }\n}\n//# sourceMappingURL=caching.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\nexport class DefaultScopeProvider {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push(stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    createScope(elements, outerScope, options) {\n        return new StreamScope(stream(elements), outerScope, options);\n    }\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    createScopeForNodes(elements, outerScope, options) {\n        const s = stream(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new StreamScope(s, outerScope, options);\n    }\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n    }\n}\n//# sourceMappingURL=scope-provider.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI } from 'vscode-uri';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { findNodesForProperty } from '../utils/grammar-utils.js';\nexport function isAstNodeWithComment(node) {\n    return typeof node.$comment === 'string';\n}\nfunction isIntermediateReference(obj) {\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\n}\nexport class DefaultJsonSerializer {\n    constructor(services) {\n        /** The set of AstNode properties to be ignored by the serializer. */\n        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options) {\n        const serializeOptions = options !== null && options !== void 0 ? options : {};\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);\n        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = getDocument(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        }\n        finally {\n            this.currentDocument = undefined;\n        }\n    }\n    deserialize(content, options) {\n        const deserializeOptions = options !== null && options !== void 0 ? options : {};\n        const root = JSON.parse(content);\n        this.linkNode(root, root, deserializeOptions);\n        return root;\n    }\n    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        }\n        else if (isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = getDocument(refValue);\n                let targetUri = '';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    }\n                    else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                };\n            }\n            else {\n                return {\n                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference',\n                    $refText\n                };\n            }\n        }\n        else if (isAstNode(value)) {\n            let astNode = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    astNode.$comment = comment.replace(/\\r/g, '');\n                }\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        }\n        else {\n            return value;\n        }\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = cstNode => ({\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        });\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n            return node;\n        }\n        return undefined;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    }\n                    else if (isAstNode(element)) {\n                        this.linkNode(element, root, options, node, propertyName, index);\n                    }\n                }\n            }\n            else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            }\n            else if (isAstNode(item)) {\n                this.linkNode(item, root, options, node, propertyName);\n            }\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if (isAstNode(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : '',\n                    ref\n                };\n            }\n            else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : ''\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        }\n        else {\n            return undefined;\n        }\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf('#');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return 'Could not resolve path: ' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return 'Could not find document for URI: ' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return 'Could not find document for URI: ' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return 'Could not resolve URI: ' + uri;\n            }\n            return node;\n        }\n        catch (err) {\n            return String(err);\n        }\n    }\n}\n//# sourceMappingURL=json-serializer.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { UriUtils } from './utils/uri-utils.js';\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nexport class DefaultServiceRegistry {\n    /**\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n     */\n    get map() {\n        return this.fileExtensionMap;\n    }\n    constructor(services) {\n        this.languageIdMap = new Map();\n        this.fileExtensionMap = new Map();\n        this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n    }\n    register(language) {\n        const data = language.LanguageMetaData;\n        for (const ext of data.fileExtensions) {\n            if (this.fileExtensionMap.has(ext)) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\n            }\n            this.fileExtensionMap.set(ext, language);\n        }\n        this.languageIdMap.set(data.languageId, language);\n        if (this.languageIdMap.size === 1) {\n            this.singleton = language;\n        }\n        else {\n            this.singleton = undefined;\n        }\n    }\n    getServices(uri) {\n        var _a, _b;\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.languageIdMap.size === 0) {\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n        }\n        const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;\n        if (languageId !== undefined) {\n            const services = this.languageIdMap.get(languageId);\n            if (services) {\n                return services;\n            }\n        }\n        const ext = UriUtils.extname(uri);\n        const services = this.fileExtensionMap.get(ext);\n        if (!services) {\n            if (languageId) {\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n            }\n            else {\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n            }\n        }\n        return services;\n    }\n    hasServices(uri) {\n        try {\n            this.getServices(uri);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    get all() {\n        return Array.from(this.languageIdMap.values());\n    }\n}\n//# sourceMappingURL=service-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../index.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nexport function diagnosticData(code) {\n    return { code };\n}\nexport var ValidationCategory;\n(function (ValidationCategory) {\n    ValidationCategory.all = ['fast', 'slow', 'built-in'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nexport class ValidationRegistry {\n    constructor(services) {\n        this.entries = new MultiMap();\n        this.entriesBefore = [];\n        this.entriesAfter = [];\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register(checksRecord, thisObj = this, category = 'fast') {\n        if (category === 'built-in') {\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            }\n            else if (typeof callbacks === 'function') {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n            else {\n                assertUnreachable(callbacks);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\n        };\n    }\n    async handleException(functionality, messageContext, accept, node) {\n        try {\n            await functionality();\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error(`${messageContext}:`, err);\n            if (err instanceof Error && err.stack) {\n                console.error(err.stack);\n            }\n            const messageDetails = err instanceof Error ? err.message : String(err);\n            accept('error', `${messageContext}: ${messageDetails}`, { node });\n        }\n    }\n    addEntry(type, entry) {\n        if (type === 'AstNode') {\n            this.entries.add('AstNode', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n    getChecks(type, categories) {\n        let checks = stream(this.entries.get(type))\n            .concat(this.entries.get('AstNode'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n    /**\n     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map for mapping names to nodes could be established.\n     * During the usual checks on the nodes, they are put into this map with their name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerBeforeDocument(checkBefore, thisObj = this) {\n        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\n    }\n    /**\n     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n     * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map with all the collected nodes and their names is checked\n     * and validation hints are created for all nodes with the same name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerAfterDocument(checkAfter, thisObj = this) {\n        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\n    }\n    wrapPreparationException(check, messageContext, thisObj) {\n        return async (rootNode, accept, categories, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n        };\n    }\n    get checksBefore() {\n        return this.entriesBefore;\n    }\n    get checksAfter() {\n        return this.entriesAfter;\n    }\n}\n//# sourceMappingURL=validation-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { tokenToRange } from '../utils/cst-utils.js';\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { diagnosticData } from './validation-registry.js';\nexport class DefaultDocumentValidator {\n    constructor(services) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = CancellationToken.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await interruptAndCheck(cancelToken);\n        if (!options.categories || options.categories.includes('built-in')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {\n                return diagnostics;\n            }\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {\n                return diagnostics;\n            }\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {\n                return diagnostics;\n            }\n        }\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error('An error occurred during validation:', err);\n        }\n        await interruptAndCheck(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        var _a, _b, _c;\n        const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null && _b !== void 0 ? _b : []];\n        for (const lexerDiagnostic of lexerDiagnostics) {\n            const severity = (_c = lexerDiagnostic.severity) !== null && _c !== void 0 ? _c : 'error';\n            const diagnostic = {\n                severity: toDiagnosticSeverity(severity),\n                range: {\n                    start: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column - 1\n                    },\n                    end: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column + lexerDiagnostic.length - 1\n                    }\n                },\n                message: lexerDiagnostic.message,\n                data: toDiagnosticData(severity),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors) {\n            let range = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if ('previousToken' in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = { line: token.endLine - 1, character: token.endColumn };\n                        range = { start: position, end: position };\n                    }\n                    else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position = { line: 0, character: 0 };\n                        range = { start: position, end: position };\n                    }\n                }\n            }\n            else {\n                range = tokenToRange(parserError.token);\n            }\n            if (range) {\n                const diagnostic = {\n                    severity: toDiagnosticSeverity('error'),\n                    range,\n                    message: parserError.message,\n                    data: diagnosticData(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = CancellationToken.None) {\n        const validationItems = [];\n        const acceptor = (severity, message, info) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\n        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\n        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\n        return validationItems;\n    }\n    async validateAstBefore(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksBefore = this.validationRegistry.checksBefore;\n        for (const checkBefore of checksBefore) {\n            await interruptAndCheck(cancelToken);\n            await checkBefore(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    async validateAstNodes(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        await Promise.all(streamAst(rootNode).map(async (node) => {\n            await interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n    }\n    async validateAstAfter(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksAfter = this.validationRegistry.checksAfter;\n        for (const checkAfter of checksAfter) {\n            await interruptAndCheck(cancelToken);\n            await checkAfter(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n}\nexport function getDiagnosticRange(info) {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode;\n    if (typeof info.property === 'string') {\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    }\n    else if (typeof info.keyword === 'string') {\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\n/**\n * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.\n *\n * @param severity The lexing diagnostic severity\n * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`\n */\nexport function toDiagnosticSeverity(severity) {\n    switch (severity) {\n        case 'error':\n            return 1;\n        case 'warning':\n            return 2;\n        case 'info':\n            return 3;\n        case 'hint':\n            return 4;\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport function toDiagnosticData(severity) {\n    switch (severity) {\n        case 'error':\n            return diagnosticData(DocumentValidator.LexingError);\n        case 'warning':\n            return diagnosticData(DocumentValidator.LexingWarning);\n        case 'info':\n            return diagnosticData(DocumentValidator.LexingInfo);\n        case 'hint':\n            return diagnosticData(DocumentValidator.LexingHint);\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport var DocumentValidator;\n(function (DocumentValidator) {\n    DocumentValidator.LexingError = 'lexing-error';\n    DocumentValidator.LexingWarning = 'lexing-warning';\n    DocumentValidator.LexingInfo = 'lexing-info';\n    DocumentValidator.LexingHint = 'lexing-hint';\n    DocumentValidator.ParsingError = 'parsing-error';\n    DocumentValidator.LinkingError = 'linking-error';\n})(DocumentValidator || (DocumentValidator = {}));\n//# sourceMappingURL=document-validator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isLinkingError } from '../syntax-tree.js';\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { toDocumentSegment } from '../utils/cst-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultAstNodeDescriptionProvider {\n    constructor(services) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document) {\n        const doc = document !== null && document !== void 0 ? document : getDocument(node);\n        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment;\n        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: doc.uri,\n            path\n        };\n    }\n}\nexport class DefaultReferenceDescriptionProvider {\n    constructor(services) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = CancellationToken.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of streamAst(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: toDocumentSegment(refCstNode),\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n}\n//# sourceMappingURL=ast-descriptions.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DefaultAstNodeLocator {\n    constructor() {\n        this.segmentSeparator = '/';\n        this.indexSeparator = '@';\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return '';\n    }\n    getPathSegment({ $containerProperty, $containerIndex }) {\n        if (!$containerProperty) {\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n}\n//# sourceMappingURL=ast-node-locator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Disposable;\n(function (Disposable) {\n    function create(callback) {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (Disposable = {}));\n//# sourceMappingURL=disposable.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Emitter } from '../utils/event.js';\nimport { Deferred } from '../utils/promise-utils.js';\n/**\n * Base configuration provider for building up other configuration providers\n */\nexport class DefaultConfigurationProvider {\n    constructor(services) {\n        this._ready = new Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.onConfigurationSectionUpdateEmitter = new Emitter();\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => ({\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                }));\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change) {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            const configuration = change.settings[section];\n            this.updateSectionConfiguration(section, configuration);\n            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n    get onConfigurationSectionUpdate() {\n        return this.onConfigurationSectionUpdateEmitter.event;\n    }\n}\n//# sourceMappingURL=configuration.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Disposable } from '../utils/disposable.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { OperationCancelled, interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { ValidationCategory } from '../validation/validation-registry.js';\nimport { DocumentState } from './documents.js';\nexport class DefaultDocumentBuilder {\n    constructor(services) {\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: ['built-in', 'fast']\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new MultiMap();\n        this.documentPhaseListeners = new MultiMap();\n        this.buildState = new Map();\n        this.documentBuildWaiters = new Map();\n        this.currentState = DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = CancellationToken.None) {\n        var _a, _b;\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === DocumentState.Validated) {\n                if (typeof options.validation === 'boolean' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                }\n                else if (typeof options.validation === 'object') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), { categories })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            }\n            else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = CancellationToken.None) {\n        this.currentState = DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\n                newDocument.state = DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n            doc.diagnostics = undefined;\n        });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await interruptAndCheck(cancelToken);\n        // Collect and sort all documents that we should rebuild\n        const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all\n            .filter(doc => {\n            var _a;\n            // This includes those that were reported as changed and those that we selected for relinking\n            return doc.state < DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        })\n            .toArray());\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n    /**\n     * Sort the given documents by priority. By default, documents with an open text document are prioritized.\n     * This is useful to ensure that visible documents show their diagnostics before all other documents.\n     *\n     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\n     * in files that are currently not opened in the editor.\n     */\n    sortDocuments(documents) {\n        let left = 0;\n        let right = documents.length - 1;\n        while (left < right) {\n            while (left < documents.length && this.hasTextDocument(documents[left])) {\n                left++;\n            }\n            while (right >= 0 && !this.hasTextDocument(documents[right])) {\n                right--;\n            }\n            if (left < right) {\n                [documents[left], documents[right]] = [documents[right], documents[left]];\n            }\n        }\n        return documents;\n    }\n    hasTextDocument(doc) {\n        var _a;\n        return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));\n    }\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    shouldRelink(document, changedUris) {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n    /**\n     * Build the given documents by stepping through all build phases. If a document's state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     *\n     * @param documents The documents to build.\n     * @param options the {@link BuildOptions} to use.\n     * @param cancelToken A cancellation token that can be used to cancel the build.\n     * @returns A promise that resolves when the build is done.\n     */\n    async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));\n        // 1. Index content\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));\n        // 2. Compute scopes\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n    /**\n     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\n     *\n     * @param documents collection of documents to be built\n     * @param options the {@link BuildOptions} to use\n     */\n    prepareBuild(documents, options) {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state === null || state === void 0 ? void 0 : state.result\n                });\n            }\n        }\n    }\n    /**\n     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\n     *\n     * @param documents The array of documents to process.\n     * @param targetState The target {@link DocumentState} to bring the documents to.\n     * @param cancelToken A token that can be used to cancel the operation.\n     * @param callback A function to be called for each document.\n     * @returns A promise that resolves when all documents have been processed or the operation is canceled.\n     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\n     */\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter(doc => doc.state < targetState);\n        for (const document of filtered) {\n            await interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n            await this.notifyDocumentPhase(document, targetState, cancelToken);\n        }\n        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state\n        // For example, this happens in case the cancellation triggers between the processing of two documents\n        // Or files that were picked up during the workspace initialization\n        const targetStateDocs = documents.filter(doc => doc.state === targetState);\n        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    onDocumentPhase(targetState, callback) {\n        this.documentPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.documentPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = undefined;\n        if (uriOrToken && 'path' in uriOrToken) {\n            uri = uriOrToken;\n        }\n        else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = CancellationToken.None);\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        }\n        else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(OperationCancelled);\n            });\n        });\n    }\n    async notifyDocumentPhase(document, state, cancelToken) {\n        const listeners = this.documentPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            try {\n                await listener(document, cancelToken);\n            }\n            catch (err) {\n                // Ignore cancellation errors\n                // We want to finish the listeners before throwing\n                if (!isOperationCancelled(err)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) {\n            // Don't notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            await interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it's set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        }\n        else {\n            document.diagnostics = diagnostics;\n        }\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            }\n            else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n}\n//# sourceMappingURL=document-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { ContextCache } from '../utils/caching.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultIndexManager {\n    constructor(services) {\n        /**\n         * The symbol index stores all `AstNodeDescription` items exported by a document.\n         * The key used in this map is the string representation of the specific document URI.\n         */\n        this.symbolIndex = new Map();\n        /**\n         * This is a cache for the `allElements()` method.\n         * It caches the descriptions from `symbolIndex` grouped by types.\n         */\n        this.symbolByTypeIndex = new ContextCache();\n        /**\n         * This index keeps track of all `ReferenceDescription` items exported by a document.\n         * This is used to compute which elements are affected by a document change\n         * and for finding references to an AST node.\n         */\n        this.referenceIndex = new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = getDocument(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return stream(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = stream(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) {\n            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            var _a;\n            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n}\n//# sourceMappingURL=index-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Deferred, interruptAndCheck } from '../utils/promise-utils.js';\nimport { URI, UriUtils } from '../utils/uri-utils.js';\nexport class DefaultWorkspaceManager {\n    constructor(services) {\n        this.initialBuildOptions = {};\n        this._ready = new Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    get workspaceFolders() {\n        return this.folders;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;\n    }\n    initialized(_params) {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });\n    }\n    async initializeWorkspace(folders, cancelToken = CancellationToken.None) {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = (document) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don't await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])\n            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    getRootFolder(workspaceFolder) {\n        return URI.parse(workspaceFolder.uri);\n    }\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry) => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                }\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = UriUtils.basename(entry.uri);\n        if (name.startsWith('.')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== 'node_modules' && name !== 'out';\n        }\n        else if (entry.isFile) {\n            const extname = UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=workspace-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer as ChevrotainLexer, defaultLexerErrorProvider } from 'chevrotain';\nexport class DefaultLexerErrorMessageProvider {\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\n    }\n    buildUnableToPopLexerModeMessage(token) {\n        return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\n    }\n}\nexport const DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };\nexport class DefaultLexer {\n    constructor(services) {\n        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\n        this.tokenBuilder = services.parser.TokenBuilder;\n        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\n            positionTracking: 'full',\n            skipValidations: production,\n            errorMessageProvider: this.errorMessageProvider\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {\n        var _a, _b, _c;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : [],\n            report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if (isTokenTypeDictionary(buildTokens))\n            return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nexport function isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\n}\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nexport function isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nexport function isTokenTypeDictionary(tokenVocabulary) {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n//# sourceMappingURL=lexer.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position, Range } from 'vscode-languageserver-types';\nimport { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';\nimport { URI } from '../utils/uri-utils.js';\nexport function parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === 'string') {\n        position = start;\n        opts = options;\n    }\n    else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) {\n        position = Position.create(0, 0);\n    }\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\nexport function isJSDoc(node, options) {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\nfunction getLines(node) {\n    let content = '';\n    if (typeof node === 'string') {\n        content = node;\n    }\n    else {\n        content = node.text;\n    }\n    const lines = content.split(NEWLINE_REGEXP);\n    return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: 'break',\n                    content: '',\n                    range: Range.create(position, position)\n                });\n            }\n        }\n        else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = Position.create(currentLine, currentCharacter + index);\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: 'tag',\n                    content: value,\n                    range: Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\n        return tokens.slice(0, -1);\n    }\n    return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = Position.create(lineIndex, characterIndex);\n        const end = Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: 'text',\n            content: line,\n            range: Range.create(start, end)\n        });\n    }\n    else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: 'text',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: 'inline-tag',\n                content: tagName,\n                range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: 'text',\n                    content: value,\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            }\n            else {\n                tokens.push({\n                    type: 'text',\n                    content: '',\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: 'text',\n                content: endContent,\n                range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n            });\n        }\n    }\n    return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index;\n    }\n    else {\n        return line.length;\n    }\n}\nfunction lastCharacter(line) {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === 'number') {\n        return match.index;\n    }\n    return undefined;\n}\n// Parsing\nfunction parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n    }\n    const elements = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new JSDocCommentImpl(elements, Range.create(start, end));\n}\nfunction parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === 'tag') {\n        return parseJSDocTag(context, false);\n    }\n    else if (next.type === 'text' || next.type === 'inline-tag') {\n        return parseJSDocText(context);\n    }\n    else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\nfunction appendEmptyLine(token, element) {\n    if (element) {\n        const line = new JSDocLineImpl('', token.range);\n        if ('inlines' in element) {\n            element.inlines.push(line);\n        }\n        else {\n            element.content.inlines.push(line);\n        }\n    }\n}\nfunction parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while (token && token.type !== 'break' && token.type !== 'tag') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === 'inline-tag') {\n        return parseJSDocTag(context, true);\n    }\n    else {\n        return parseJSDocLine(context);\n    }\n}\nfunction parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n        }\n        else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    }\n    else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\nfunction parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n    if (!options) {\n        return normalizeOptions({\n            start: '/**',\n            end: '*/',\n            line: '*'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\nfunction normalizeOption(option, start) {\n    if (typeof option === 'string' || typeof option === 'object') {\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        }\n        else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    }\n    else {\n        return option;\n    }\n}\nclass JSDocCommentImpl {\n    constructor(elements, range) {\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find(e => e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e) => 'name' in e);\n    }\n    toString() {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            }\n            else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            }\n            else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\nclass JSDocTagImpl {\n    constructor(name, content, inline, range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === 'string') {\n                return rendered;\n            }\n        }\n        let marker = '';\n        if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {\n            marker = '*';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {\n            marker = '**';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {\n            marker = '***';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text} — ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n}\nfunction renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\n        const index = content.indexOf(' ');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\nfunction renderLinkDefault(content, display) {\n    try {\n        URI.parse(content, true);\n        return `[${display}](${content})`;\n    }\n    catch (_a) {\n        return content;\n    }\n}\nclass JSDocTextImpl {\n    constructor(lines, range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n}\nclass JSDocLineImpl {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n}\nfunction fillNewlines(text) {\n    if (text.endsWith('\\n')) {\n        return '\\n';\n    }\n    else {\n        return '\\n\\n';\n    }\n}\n//# sourceMappingURL=jsdoc.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\nexport class JSDocDocumentationProvider {\n    constructor(services) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && isJSDoc(comment)) {\n            const parsedJSDoc = parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        }\n        else {\n            return undefined;\n        }\n    }\n    documentationTagRenderer(_node, _tag) {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n        return undefined;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n//# sourceMappingURL=documentation-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\nimport { findCommentNode } from '../utils/cst-utils.js';\nexport class DefaultCommentProvider {\n    constructor(services) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if (isAstNodeWithComment(node)) {\n            return node.$comment;\n        }\n        return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n}\n//# sourceMappingURL=comment-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Deferred, OperationCancelled } from '../utils/promise-utils.js';\nimport { Emitter } from '../utils/event.js';\n/**\n * Default implementation of the async parser which simply wraps the sync parser in a promise.\n *\n * @remarks\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nexport class DefaultAsyncParser {\n    constructor(services) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text, _cancelToken) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n}\nexport class AbstractThreadedAsyncParser {\n    constructor(services) {\n        /**\n         * The thread count determines how many threads are used to parse files in parallel.\n         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n         */\n        this.threadCount = 8;\n        /**\n         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n         * The default value is 200(ms).\n         */\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new Deferred();\n        let timeout;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new Deferred();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n}\nexport class ParserWorker {\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate) {\n        this.onReadyEmitter = new Emitter();\n        this.deferred = new Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject(OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) {\n            throw new Error('Parser worker is busy');\n        }\n        this._parsing = true;\n        this.deferred = new Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n//# sourceMappingURL=async-parser.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\nimport { Deferred, isOperationCancelled, startCancelableOperation } from '../utils/promise-utils.js';\nexport class DefaultWorkspaceLock {\n    constructor() {\n        this.previousTokenSource = new CancellationTokenSource();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = startCancelableOperation();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken = CancellationToken.None) {\n        const deferred = new Deferred();\n        const entry = {\n            action,\n            deferred,\n            cancellationToken\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) {\n            return;\n        }\n        const entries = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift());\n        }\n        else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        }\n        else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            }\n            catch (err) {\n                if (isOperationCancelled(err)) {\n                    // If the operation was cancelled, we don't want to reject the promise\n                    deferred.resolve(undefined);\n                }\n                else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n}\n//# sourceMappingURL=workspace-lock.js.map","/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';\nimport { isAbstractElement } from '../languages/generated/ast.js';\nimport { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { BiMap } from '../utils/collections.js';\nimport { streamCst } from '../utils/cst-utils.js';\nexport class DefaultHydrator {\n    constructor(services) {\n        this.grammarElementIdMap = new BiMap();\n        this.tokenTypeIdMap = new BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            parserErrors: result.parserErrors.map(e => (Object.assign(Object.assign({}, e), { message: e.message }))),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    dehydrateLexerReport(lexerReport) {\n        // By default, lexer reports are serializable\n        return lexerReport;\n    }\n    createDehyrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            }\n            else if (isReference(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            }\n            else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if (isRootCstNode(node)) {\n            cstNode.fullText = node.fullText;\n        }\n        else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if (isCompositeCstNode(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        }\n        else if (isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if ('$cstNode' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        let root;\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                let cst;\n                if ('fullText' in cstNode) {\n                    cst = new RootCstNodeImpl(cstNode.fullText);\n                    root = cst;\n                }\n                else if ('content' in cstNode) {\n                    cst = new CompositeCstNodeImpl();\n                }\n                else if ('tokenType' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            }\n            else if (isReference(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            }\n            else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === 'number') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if (isCompositeCstNode(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (!node) {\n            return undefined;\n        }\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        return element;\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of streamAst(this.grammar)) {\n            if (isAbstractElement(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n}\n//# sourceMappingURL=hydrator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\nimport { createGrammarConfig } from './languages/grammar-config.js';\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\nimport { DefaultValueConverter } from './parser/value-converter.js';\nimport { DefaultLinker } from './references/linker.js';\nimport { DefaultNameProvider } from './references/name-provider.js';\nimport { DefaultReferences } from './references/references.js';\nimport { DefaultScopeComputation } from './references/scope-computation.js';\nimport { DefaultScopeProvider } from './references/scope-provider.js';\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\nimport { DefaultServiceRegistry } from './service-registry.js';\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\nimport { ValidationRegistry } from './validation/validation-registry.js';\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\nimport { DefaultIndexManager } from './workspace/index-manager.js';\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\nimport { DefaultLexer, DefaultLexerErrorMessageProvider } from './parser/lexer.js';\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\nimport { DefaultAsyncParser } from './parser/async-parser.js';\nimport { DefaultWorkspaceLock } from './workspace/workspace-lock.js';\nimport { DefaultHydrator } from './serializer/hydrator.js';\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nexport function createDefaultCoreModule(context) {\n    return {\n        documentation: {\n            CommentProvider: (services) => new DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new DefaultAsyncParser(services),\n            GrammarConfig: (services) => createGrammarConfig(services),\n            LangiumParser: (services) => createLangiumParser(services),\n            CompletionParser: (services) => createCompletionParser(services),\n            ValueConverter: () => new DefaultValueConverter(),\n            TokenBuilder: () => new DefaultTokenBuilder(),\n            Lexer: (services) => new DefaultLexer(services),\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider(),\n            LexerErrorMessageProvider: () => new DefaultLexerErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new DefaultLinker(services),\n            NameProvider: () => new DefaultNameProvider(),\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\n            References: (services) => new DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new DefaultHydrator(services),\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nexport function createDefaultSharedCoreModule(context) {\n    return {\n        ServiceRegistry: (services) => new DefaultServiceRegistry(services),\n        workspace: {\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n            IndexManager: (services) => new DefaultIndexManager(services),\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n        }\n    };\n}\n//# sourceMappingURL=default-module.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { DefaultNameRegexp } from '../utils/cst-utils.js';\nimport { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';\nimport { isMultilineComment } from '../utils/regexp-utils.js';\nimport { isTerminalRule } from './generated/ast.js';\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nexport function createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: DefaultNameRegexp\n    };\n}\n//# sourceMappingURL=grammar-config.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumCompletionParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\nexport function createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumCompletionParser(services);\n    createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n//# sourceMappingURL=completion-parser-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Module;\n(function (Module) {\n    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nexport function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n    return _inject(module);\n}\nconst isProxy = Symbol('isProxy');\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nexport function eagerLoad(item) {\n    if (item && item[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: () => false,\n        set: () => {\n            throw new Error('Cannot set property on injected service container');\n        },\n        get: (obj, prop) => {\n            if (prop === isProxy) {\n                return true;\n            }\n            else {\n                return _resolve(obj, prop, module, injector || proxy);\n            }\n        },\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\n        has: (_, prop) => prop in module, // used by ..in..\n        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in\n    });\n    return proxy;\n}\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\n        }\n        return obj[prop];\n    }\n    else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\n        }\n        catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\n                    target[key] = _merge(value1, value2);\n                }\n                else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=dependency-injection.js.map","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nexport default baseHas;\n","import baseHas from './_baseHas.js';\nimport hasPath from './_hasPath.js';\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nexport default has;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (isAstNode(item)) {\n                        item.$container = node;\n                        item.$containerProperty = name;\n                        item.$containerIndex = index;\n                    }\n                });\n            }\n            else if (isAstNode(value)) {\n                value.$container = node;\n                value.$containerProperty = name;\n            }\n        }\n    }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType(node, typePredicate) {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node, predicate) {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument(node) {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node) {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node, options) {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) {\n        return true;\n    }\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node) {\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection, node) {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\nfunction copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    }\n    else {\n        return propertyType;\n    }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode(node, buildReference) {\n    const copy = { $type: node.$type };\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            }\n            else if (isReference(value)) {\n                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n            }\n            else if (Array.isArray(value)) {\n                const copiedArray = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    }\n                    else if (isReference(element)) {\n                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                    }\n                    else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            }\n            else {\n                copy[name] = value;\n            }\n        }\n    }\n    linkContentToContainer(copy);\n    return copy;\n}\n//# sourceMappingURL=ast-utils.js.map","import baseGetTag from './_baseGetTag.js';\nimport isArray from './isArray.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nexport default isString;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  PacketGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/packet/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/packet/tokenBuilder.ts\nvar PacketTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PacketTokenBuilder\");\n  }\n  constructor() {\n    super([\"packet-beta\"]);\n  }\n};\n\n// src/language/packet/module.ts\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PacketTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPacketServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Packet = inject(\n    createDefaultCoreModule({ shared }),\n    PacketGeneratedModule,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet);\n  return { shared, Packet };\n}\n__name(createPacketServices, \"createPacketServices\");\n\nexport {\n  PacketModule,\n  createPacketServices\n};\n"],"names":["value","getAllReachableRules","grammar","allTerminals","ruleNames","Set","entryRule","rules","find","e","entry","getEntryRule","topMostRules","concat","filter","hidden","getHiddenRules","rule","ruleDfs","has","name","add","visitedSet","forEach","node","refRule","ref","getCrossReferenceTerminal","crossRef","terminal","type","nameAssigment","findNameAssignment","isCommentTerminal","terminalRule","terminalRegex","findNodesForProperty","property","findNodesForPropertyInternal","astNode","findNodeForProperty","index","nodes","length","undefined","Math","max","min","element","first","nodeFeature","grammarSource","feature","content","flatMap","findNodeForKeyword","keyword","findNodesForKeywordInternal","treeIterator","iterator","result","keywordNodes","next","done","childNode","push","prune","findAssignment","cstNode","_a","container","assignment","startNode","$container","findNameAssignmentInternal","Map","cache","go","refType","childAssignment","set","get","toLowerCase","typeRef","isDataTypeRule","isDataTypeRuleInternal","visited","Boolean","definition","getExplicitRuleType","inferredType","dataType","returnType","getTypeName","actionType","action","getActionType","Error","getRuleType","_b","_c","flags","s","i","u","source","abstractElementToRegex","flagText","Object","entries","map","join","RegExp","WILDCARD","withCardinality","alternatives","elements","cardinality","lookahead","group","range","right","keywordToRegex","left","wrap","characterRangeToRegex","negate","until","lastSlash","regex","lastIndexOf","substring","regexFlags","includes","$type","options","parser","o","k","v","o2","l","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","$Va","$Vb","$Vc","$Vd","$Ve","$Vf","$Vg","$Vh","$Vi","$Vj","$Vk","$Vl","$Vm","$Vn","$Vo","$Vp","$Vq","$Vr","$Vs","$Vt","$Vu","$Vv","$Vw","$Vx","$Vy","$Vz","$VA","$VB","$VC","$VD","$VE","$VF","$VG","$VH","$VI","$VJ","$VK","$VL","$VM","$VN","$VO","$VP","$VQ","$VR","$VS","$VT","$VU","parser2","trace","yy","symbols_","terminals_","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","$","addRelation","title","cleanupLabel","trim","setAccTitle","setAccDescription","addClassesToNamespace","addNamespace","unshift","setCssClass","addMembers","addClass","setClassLabel","addAnnotation","addMember","relation","relationTitle1","relationTitle2","id1","id2","addNote","defineClass","setDirection","type1","type2","lineType","relationType","AGGREGATION","EXTENSION","COMPOSITION","DEPENDENCY","LOLLIPOP","LINE","DOTTED_LINE","setClickEvent","setTooltip","setLink","setCssStyle","table","defaultActions","parseError","str","hash","recoverable","error","parse","input","self","stack","tstack","vstack","lstack","recovering","args","slice","call","arguments","lexer2","create","lexer","sharedState","prototype","hasOwnProperty","setInput","yylloc","yyloc","ranges","lex","token","pop","Array","getPrototypeOf","n","symbol","preErrorSymbol","state","r","p","len","newState","expected","yyval","errStr","showPosition","text","match","line","loc","first_line","last_line","first_column","last_column","apply","EOF","_input","_more","_backtrack","matched","conditionStack","offset","ch","unput","lines","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","replace","upcomingInput","pre","c","test_match","indexed_rule","backup","matches","tempMatch","_currentRules","flex","begin","condition","popState","conditions","topState","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","Parser","classDiagram_default","visibilityValues","ClassMember","constructor","memberType","visibility","classifier","sanitizedInput","parseMember","getDisplayDetails","displayText","id","parameters","cssStyle","parseClassifier","potentialClassifier","exec","detectedVisibility","lastChar","firstChar","startsWith","combinedText","replaceAll","MERMAID_DOM_ID_PREFIX","classCounter","sanitizeText2","txt","sanitizeText","ClassDB","relations","classes","styleClasses","notes","interfaces","namespaces","namespaceCounter","functions","setupToolTips","tooltipElem","_groups","append","attr","style","select","selectAll","on","event","el","currentTarget","rect","getBoundingClientRect","transition","duration","window","scrollX","scrollY","top","document","body","scrollTop","html","classed","direction","getAccTitle","getAccDescription","setDiagramTitle","getDiagramTitle","getConfig","class","bind","clear","bindFunctions","splitClassNameAndType","_id","genericType","className","indexOf","label","shape","cssClasses","methods","members","annotations","styles","domId","addInterface","classId","classInterface","lookUpDomId","getClass","getClasses","getRelations","getNotes","classRelation","debug","JSON","stringify","invalidTypes","annotation","validatedClassName","member","theClass","memberString","endsWith","isArray","reverse","note","ids","classNode","styleClass","textStyles","newStyle","tooltip","getTooltip","namespace","linkStr","target","config","link","formatUrl","securityLevel","linkTarget","functionName","functionArgs","setClickFunc","haveCallback","_domId","elemId","argList","item","elem","querySelector","addEventListener","runFunc","fun","getDirection","dir","children","getNamespace","getNamespaces","classNames","parent","thisClass","getArrowMarker","marker","getData","edges","namespaceKey","keys","isGroup","padding","cssStyles","look","classKey","parentId","cnt","noteNode","themeVariables","noteBkgColor","noteBorderColor","noteClassId","edge","start","end","thickness","arrowTypeStart","arrowTypeEnd","arrowheadStyle","labelStyle","pattern","_interface","interfaceNode","prefix","counter","labelpos","startLabelRight","endLabelLeft","other","styles_default","nodeBorder","classText","fontFamily","mainBkg","lineColor","textColor","getDir","parsedItem","defaultDir","doc","parsedItemDoc","stmt","classRenderer_v3_unified_default","diagramObj","db","draw","async","_version","diag","info","conf","layout","data4Layout","svg","layoutAlgorithm","nodeSpacing","rankSpacing","markers","diagramId","insertTitle","titleTopMargin","useMaxWidth","findIndexFunc","collection","predicate","fromIndex","iterable","isArrayLike","iteratee","key","nativeMax","array","toInteger","idCounter","nativeCeil","ceil","step","fromRight","toFinite","List","sentinel","_next","_prev","_sentinel","dequeue","unlink","enqueue","toString","strs","curr","filterOutLinks","DEFAULT_WEIGHT_FN","greedyFAS","g","weightFn","nodeCount","fasGraph","maxIn","maxOut","setNode","in","out","prevWeight","w","weight","edgeWeight","setEdge","buckets","zeroIdx","assignBucket","graph","buildState","results","sources","sinks","removeNode","doGreedyFAS","outEdges","collectPredecessors","inEdges","uEntry","wEntry","run","fas","acyclicer","dfs","dfsFAS","removeEdge","forwardName","reversed","object","paths","path","hasIn","func","flatten","identity","Date","now","addDummyNode","attrs","hasNode","dummy","asNonCompoundGraph","simplified","multigraph","isMultigraph","setGraph","intersectRect","point","sx","sy","x","y","dx","dy","width","h","height","buildLayerMatrix","layering","rank","order","addBorderNode","fn","console","log","notime","prop","sg","sgNode","borderType","prev","setParent","rankDir","rankdir","reverseYOne","points","reverseY","swapXYOne","swapXY","swapWidthHeight","swapWidthHeightOne","dummyChains","vRank","wRank","edgeLabel","labelRank","edgeObj","normalizeEdge","longestPath","minlen","Number","POSITIVE_INFINITY","slack","feasibleTree","delta","t","directed","size","tightTree","findMinSlackEdge","shiftRanks","nodeEdges","edgeV","rsAstral","rsCombo","rsFitz","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsOptVar","rsSeq","rsSymbol","vs","navigation","isDirected","successors","neighbors","acc","doDfs","postorder","networkSimplex","simpleLabel","simplify","initLowLimValues","initCutValues","leaveEdge","exchangeEdges","enterEdge","child","childLab","cutvalue","calcCutValue","assignCutValue","childIsTail","graphEdge","cutValue","isOutEdge","pointsToHead","otherWeight","hasEdge","otherCutValue","tree","root","dfsAssignLowLim","nextLim","low","lim","vLabel","wLabel","tailLabel","flip","candidates","isDescendant","f","flipped","updateRanks","rootLabel","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker","depths","depth","treeDepths","nodeSep","nestingRoot","sumWeights","nodeRankFactor","bottom","borderTop","borderBottom","childTop","childBottom","thisWeight","nestingEdge","CLONE_DEEP_FLAG","buildLayerGraph","relationship","createRootNode","compound","setDefaultNodeLabel","minRank","maxRank","borderLeft","borderRight","props","values","assignFunc","valsLength","comparer","sort","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","isSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","orders","objCriteria","criteria","othCriteria","ordersLength","iteratees","crossCount","cc","twoLayerCrossCount","northLayer","southLayer","southPos","southEntries","pos","firstIndex","treeSize","weightSum","resolveConflicts","cg","mappedEntries","tmp","indegree","barycenter","entryV","entryW","sourceSet","handleIn","vEntry","merged","sum","mergeEntries","handleOut","doResolveConflicts","biasRight","bias","parts","lhs","rhs","sortable","unsortable","vsIndex","consumeUnsortable","last","sortSubgraph","movable","bl","br","subgraphs","barycenters","inV","nodeU","subgraphResult","expandSubgraphs","predecessors","blPred","brPred","downLayerGraphs","buildLayerGraphs","upLayerGraphs","simpleNodes","layers","orderedVs","initOrder","assignOrder","best","bestCC","lastBest","sweepLayerGraphs","ranks","layerGraphs","lg","sorted","rootPrev","prevChild","addSubgraphConstraints","layer","parentDummyChains","postorderNums","pathData","lca","vPath","wPath","findPath","pathIdx","pathV","ascending","keysIn","findType1Conflicts","conflicts","prevLayer","k0","scanPos","prevLayerLength","lastNode","findOtherInnerSegmentNode","k1","scanNode","uLabel","uPos","addConflict","conflictsV","hasConflict","horizontalCompaction","align","reverseSep","xs","blockG","blockGraph","graphLabel","sepFn","edgeSep","sep","nodesep","edgesep","vRoot","uRoot","prevMax","buildBlockGraph","iterate","setXsFunc","nextNodesFunc","reduce","positionX","adjustedLayering","scan","south","southEnd","prevNorthBorder","nextNorthBorder","uNode","north","nextNorthPos","prevNorthPos","southLookahead","findType2Conflicts","xss","vert","horiz","inner","neighborFn","prevIdx","ws","mp","floor","il","verticalAlignment","smallestWidth","NEGATIVE_INFINITY","halfWidth","findSmallestWidthAlignment","alignTo","alignToVals","alignToMin","alignToMax","alignment","xsVals","alignCoordinates","ul","ignore","balance","position","rankSep","ranksep","prevY","maxHeight","positionY","opts","time","debugTiming","layoutGraph","inputGraph","canonicalize","graphDefaults","selectNumberAttrs","graphNumAttrs","graphAttrs","nodeNumAttrs","nodeDefaults","edgeDefaults","edgeNumAttrs","edgeAttrs","buildLayoutGraph","labeloffset","makeSpaceForEdgeLabels","selfEdges","removeSelfEdges","injectEdgeLabelProxies","assignRankMinMax","removeEdgeLabelProxies","addBorderSegments","orderShift","selfEdge","insertSelfEdges","selfNode","positionSelfEdges","b","removeBorderNodes","origLabel","fixupEdgeLabelCoords","minX","maxX","minY","maxY","marginX","marginx","marginY","marginy","getExtremes","translateGraph","p1","p2","nodeV","nodeW","assignNodeIntersects","reversePointsForReversedEdges","runLayout","inputLabel","layoutLabel","updateInputGraph","obj","newAttrs","RadarTokenBuilder","super","RadarModule","TokenBuilder","ValueConverter","createRadarServices","context","shared","Radar","ServiceRegistry","register","toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","bar","guard","isObjectLike","nodeIsRegExp","isRegExp","tokenLabel","tokType","isString","LABEL","AbstractProduction","_definition","accept","visitor","visit","prod","idx","referencedRule","Rule","orgText","Alternative","ignoreAmbiguities","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","hasPredicates","Terminal","serializeProduction","convertDefinition","serializedNonTerminal","nonTerminalName","separator","terminalType","serializedTerminal","terminalLabel","PATTERN","nodeAny","visitNonTerminal","visitAlternative","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","isOptionalProd","alreadyVisited","subProd","getProductionDslName","RestWalker","walk","prevRest","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","isSequenceProd","firstSet","seq","currSubProd","nextSubProdIdx","hasInnerProdsRemaining","isLastInnerProdOptional","firstForSequence","isBranchingProd","allAlternativesFirsts","innerProd","firstForBranching","ResyncFollowsWalker","topProd","follows","startWalking","followName","occurenceInParent","fullRest","t_in_topProd_follows","TypeError","comparator","isCommon","valuesLength","outer","computed","valuesIndex","isArrayLikeObject","resIndex","PRINT_ERROR","msg","PRINT_WARNING","warn","regExpAstCache","regExpParser","getRegExpAst","regExp","regExpStr","regExpAst","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","ensureOptimizations","ast","firstCharOptimizedIndices","ignoreCase","message","msgSuffix","terms","term","atom","addOptimizedIdxToResult","complement","code","rangeCode","from","to","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","atLeast","isWholeOptional","optimizedCharIdx","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","handleIgnoreCase","findCode","targetCharCodes","codeOrRange","targetCode","CharCodeFinder","found","visitChildren","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","canMatchCharCode","charCodes","charCodeFinder","DEFAULT_MODE","MODES","SUPPORT_STICKY","sticky","analyzeTokenTypes","tokenTypes","tracer","defaults","useSticky","safeMode","positionTracking","lineTerminatorCharacters","onlyRelevantTypes","isEmpty","charCodeToOptimizedIdxMap","initCharCodeToOptimizedIndexMap","currType","Lexer","NA","allTransformedPatterns","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","patternIdxToCanLineTerminator","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","hasCustom","currPattern","regExpSource","addStickyFlag","addStartOfInput","isFunction","escapedRegExpString","wrappedRegExp","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","isUndefined","longerAltType","LONGER_ALT","PUSH_MODE","lineTerminatorCharCodes","getCharCodes","LINE_BREAKS","checkLineBreaksIssues","isCustomPattern","isShortPattern","longerAlt","canLineTerminator","isCustom","short","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","currTokType","optimizedIdx","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx","charOrInt","currOptimizedIdx","unicode","optimizedCodes","validatePatterns","validModesNames","errors","missingResult","tokenTypesWithMissingPattern","LexerDefinitionErrorType","MISSING_PATTERN","valid","findMissingPatterns","invalidResult","tokenTypesWithInvalidPattern","INVALID_PATTERN","findInvalidPatterns","validTokenTypes","withRegExpPatterns","EndAnchorFinder","visitEndAnchor","invalidRegex","regexpAst","endAnchorVisitor","end_of_input","test","EOI_ANCHOR_FOUND","findEndOfInputAnchor","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","start_of_input","SOI_ANCHOR_FOUND","findStartOfInputAnchor","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","findUnsupportedFlags","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","DUPLICATE_PATTERNS_FOUND","findDuplicatePatterns","matchesEmptyString","EMPTY_MATCH_PATTERN","findEmptyMatchRegExps","validateRegExpPattern","INVALID_GROUP_TYPE_FOUND","findInvalidGroupType","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","findModesThatDoNotExist","canBeTested","metaChars","noMetaChar","testIdx","regExpArray","testTokenType","UNREACHABLE_PATTERN","findUnreachablePatterns","performWarningRuntimeChecks","lexerDefinition","trackLines","warnings","hasAnyLineBreak","allTokenTypes","modes","concreteTokenTypes","terminatorCharCodes","currIssue","details","issue","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","buildLineBreakIssueMessage","warningDescriptor","NO_LINE_BREAKS_FLAGS","LineTerminatorOptimizedTester","lastIndex","charsOrCodes","numOrString","charCode","timer","getTime","val","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypesAndParents","clone","categories","searching","CATEGORIES","newCategories","expandCategories","hasShortKeyProperty","hasCategoriesProperty","categoryMatches","hasExtendingTokensTypesMapProperty","assignTokenDefaultProps","singleAssignCategoriesToksMap","assignCategoriesMapProp","assignCategoriesTokensProp","nextNode","pathNode","nextCategory","newPath","isTokenType","defaultLexerErrorProvider","buildUnableToPopLexerModeMessage","image","buildUnexpectedCharactersMessage","fullText","startOffset","column","charAt","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","lineTerminatorsPattern","errorMessageProvider","traceInitPerf","skipValidations","recoveryEnabled","freeze","lexerDefinitionErrors","lexerDefinitionWarning","trackStartLines","trackEndLines","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","indent","traceInitMaxIdent","traceMethod","traceInitVal","Infinity","actualDefinition","hasOnlySingleMode","defaultMode","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","performRuntimeChecks","allModeNames","currModDef","currModName","currAnalyzeResult","allErrMessagesString","chopInput","matchWithTest","updateLastIndex","noop","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","tokenize","initialMode","tokenizeInternal","j","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","orgLength","matchedTokensIndex","guessedNumberOfTokens","matchedTokens","groups","clonedResult","groupKeys","currKey","currGroupValue","cloneEmptyGroups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","startLine","startColumn","newMode","modeCanBeOptimized","push_mode","currConfig","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","foundTerminator","lastLTEndOffset","numOfLTsInMatch","errorStartOffset","errorLine","errorColumn","foundResyncPoint","tokens","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","endOffset","tokenVector","tokenToAdd","PARENT","POP_MODE","createToken","createTokenInternal","tokenMatcher","defaultParserErrorProvider","buildMismatchTokenMessage","actual","previous","ruleName","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","itemMsg","buildEarlyExitMessage","expectedIterationPaths","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","topLevelName","duplicateProd","dslName","extraArgument","buildNamespaceConflictError","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","leftRecursionPath","currRule","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","GastRefResolverVisitor","nameToTopRule","errMsgProvider","resolveRefs","currTopLevel","ParserDefinitionErrorType","UNRESOLVED_SUBRULE_REF","unresolvedRefName","setter","accumulator","initializer","PROD_TYPE","AbstractNextPossibleTokensWalker","possibleTokTypes","nextProductionName","nextProductionOccurrence","isAtEndOfPath","ruleStack","occurrenceStack","updateExpectedNext","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","restProd","AbstractNextTerminalAfterProductionWalker","topRule","isEndOfRule","NextTerminalAfterManyWalker","firstAfterMany","NextTerminalAfterManySepWalker","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","getAlternativesForProd","newDef","currAlt","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currRuleStack","currOccurrenceStack","nextPath","nextIdx","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","getLookaheadPaths","prodType","maxLookahead","getLookaheadPathsForOr","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","dynamicTokensEnabled","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","currNumOfPaths","currPredicate","currPathLength","nextToken","LA","singleTokenAlts","choiceToAlt","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenUniqueKey","RestDefinitionFinderWalker","targetOccurrence","targetProdType","restDef","checkIsTarget","expectedProdType","InsideDefinitionFinderVisitor","targetRef","expectedProdName","initializeArrayOfArrays","pathToHashKeys","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","currAltResult","containsPath","newPartialPathsAndSuffixes","ruleGrammar","insideDefVisitor","insideDef","afterDef","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","areTokenCategoriesNotUsed","lookAheadPaths","singleAltPaths","singlePath","validateGrammar","topLevels","duplicateErrors","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","DUPLICATE_PRODUCTIONS","param","getExtraProductionArgument","parameter","validateDuplicateProductions","termsNamespaceConflictErrors","tokenNames","currToken","currRuleName","CONFLICT_TOKENS_RULES_NAMESPACE","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","orCollector","OrCollector","ors","alternations","currOr","TOO_MANY_ALTS","validateTooManyAlts","duplicateRulesError","allRules","occurrences","DUPLICATE_RULE_NAME","validateRuleDoesNotAlreadyExist","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","currSubDef","isFirstOptional","hasMore","rest","validateAmbiguousAlternationAlternatives","globalMaxLookahead","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currErrors","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","pathsAndIndices","currPathsAndIdx","currPathAndIdx","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","otherTokType","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","checkPrefixAlternativesAmbiguities","RepetitionCollector","actualOptions","topRulesTable","refResolver","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","RecognitionException","resyncedTokens","setPrototypeOf","captureStackTrace","MismatchedTokenException","previousToken","NoViableAltException","NotAllInputParsedException","EarlyExitException","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","attemptInRepetitionRecovery","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","notStuck","getKeyForAutomaticLookahead","firstAfterRepInfo","firstAfterRepMap","getCurrRuleFullName","getGAstProductions","expectTokAfterLastMatch","nextTokIdx","RULE_STACK","shouldInRepetitionRecoveryBeTried","tryInRepetitionRecovery","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","ruleIdx","LLkLookaheadStrategy","DEFAULT_PARSER_CONFIG","validate","leftRecursionErrors","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","currTopRule","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","validateEmptyOrAlternative","topLevelRules","currProd","pathsInsideProduction","NO_NON_EMPTY_LOOKAHEAD","buildLookaheadForAlternation","laFuncBuilder","buildLookaheadFuncForOr","buildLookaheadForOptional","lookaheadBuilder","buildLookaheadFuncForOptionalProd","dslMethods","repetitionWithSeparator","repetitionMandatory","repetitionMandatoryWithSeparator","reset","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","setNodeLocationFull","defineNameProp","nameValue","defineProperty","enumerable","configurable","writable","defaultVisit","ctx","childrenNames","childrenNamesLength","currChildArray","currChildArrayLength","currChild","createBaseSemanticVisitorConstructor","derivedConstructor","semanticProto","validateVisitor","semanticDefinitionErrors","visitorInstance","missingErrors","missingRuleNames","CstVisitorDefinitionError","MISSING_METHOD","methodName","validateMissingCstMethods","errorMessages","currDefError","_RULE_NAMES","RECORDING_NULL_OBJECT","description","HANDLE_SEPARATOR","MAX_METHOD_IDX","pow","RFT","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","recordProd","prodConstructor","mainProdArg","handleSep","assertMethodIdxIsValid","prevProd","recordingProdStack","grammarAction","DEF","newProd","SEP","MAX_LOOKAHEAD","recordOrProd","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","ALT","getIdxSuffix","KNOWN_RECORDER_ERROR","END_OF_FILE","NaN","outputCst","nodeLocationTracking","DEFAULT_RULE_CONFIG","recoveryValueFunc","resyncEnabled","derivedCtor","EMPTY_ALT","performSelfAnalysis","parserInstance","defErrorsMsgs","selfAnalysisDone","enableRecording","definedRulesNames","originalGrammarAction","recordedRuleGast","topLevelRuleRecord","gastProductionsCache","disableRecording","resolverErrors","definitionErrors","validationErrors","tokensMap","lookaheadValidationErrors","lookaheadValidationErrorMessages","lookaheadStrategy","errorMessage","assign","CUSTOM_LOOKAHEAD_VALIDATION","validateLookahead","allFollows","topProductions","reSyncFollows","currRefsFollow","computeAllProdsFollows","resyncFollows","initialize","preComputeLookaheadFunctions","DEFER_DEFINITION_ERRORS_HANDLING","tokenVocabulary","that","initErrorHandler","initLexerAdapter","initLooksAhead","initRecognizerEngine","initRecoverable","initTreeBuilder","initContentAssist","initGastRecorder","initPerformanceTracer","getTokenToInsert","tokToInsert","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","SAVE_ERROR","SKIP_TOKEN","addToResyncTokens","importLexerState","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","possibleFollowsTokType","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","followStack","resyncTokens","reSyncTo","getHumanReadableRuleStack","currShortName","lookAheadFuncsCache","collectMethods","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","getLaFuncFromCache","CST_STACK","setNodeLocationFromToken","setNodeLocationFromNode","cstPostRule","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","location","fullRuleName","ruleCstNode","prevToken","consumedToken","rootCst","tokenTypeName","ruleCstResult","preCstNode","ruleResult","addNoneTerminalToCst","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","baseConstructor","withDefaultsProto","createBaseVisitorConstructorWithDefaults","tokVector","tokVectorLength","newInput","howMuch","soughtIdx","resetLexerState","moveToTerminatedState","getLexerPosition","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","isBackTrackingStack","uniqueTokens","isObject","noTokenCategoriesUsed","tokenConstructor","defineRule","impl","shortName","invokeRuleWithTry","ruleInvocationStateUpdate","cst","invokeRuleCatch","ruleFinallyStateUpdate","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternal","actionORMethodDef","optionInternalLogic","orgLookaheadFunction","atLeastOneInternal","laKey","atLeastOneInternalLogic","raiseEarlyExitException","ERR_MSG","doSingleRepetition","atLeastOneSepFirstInternal","atLeastOneSepFirstInternalLogic","separatorLookAheadFunc","CONSUME","repetitionSepSecondInternal","manyInternal","manyInternalLogic","lookaheadFunction","manySepFirstInternal","manySepFirstInternalLogic","nextTerminalAfterWalker","beforeIteration","orInternal","altsOrOpts","altIdxToTake","raiseNoAltException","isAtEndOfInput","firstRedundantTok","subruleInternal","ruleToCall","ARGS","subruleInternalError","consumeInternal","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","saveRecogState","savedErrors","savedRuleStack","lexerState","reloadRecogState","fullName","ACTION","consume","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","ruleImplementation","OVERRIDE_RULE","ruleErrors","INVALID_RULE_OVERRIDE","validateRuleIsOverridden","BACKTRACK","orgState","getSerializedGastProductions","topRules","_errors","ruleOccurrenceStack","newErrors","userDefinedErrMsg","insideProdPaths","actualTokens","errMsgTypes","lookAheadPathsPerAlternative","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","topProduction","RECORDING_PHASE","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","newTopLevelRule","originalError","mutabilityError","newNoneTerminal","userTraceInitPerf","traceIsNumber","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","EmbeddedActionsParser","configClone","arrays","GRAPH_NODE","Graph","_isDirected","_isMultigraph","_isCompound","_label","_defaultNodeLabelFn","_defaultEdgeLabelFn","_nodes","_parent","_children","_in","_preds","_out","_sucs","_edgeObjs","_edgeLabels","isCompound","newDefault","_nodeCount","setNodes","_removeFromParentsChildList","ancestor","predsV","sucsV","preds","isLeaf","filterNodes","copy","parents","findParent","setDefaultEdgeLabel","edgeCount","_edgeCount","setPath","valueSpecified","arg0","edgeArgsToId","v_","w_","edgeArgsToObj","incrementOrInitEntry","edgeObjToId","decrementOrRemoveEntry","outV","ErrorWithLocation","character","assertUnreachable","_","StreamImpl","startFn","nextFn","Symbol","count","toArray","toSet","toMap","keyFn","valueFn","entryStream","firstDone","DONE_RESULT","addSeparator","searchElement","every","some","callbackfn","nonNullable","initialValue","previousValue","reduceRight","recursiveReduce","findIndex","mapped","isIterable","flat","stream","head","tail","skipCount","limit","maxSize","distinct","by","internalState","exclude","otherKeySet","ownKey","EMPTY_STREAM","collections","collIndex","arrIndex","TreeStreamImpl","iterators","includeRoot","pruned","Reduction","a","product","DefaultTokenBuilder","diagnostics","buildTokens","reachableRules","terminalTokens","buildTerminalTokens","buildKeywordTokens","terminalToken","flushLexingReport","popDiagnostics","fragment","buildTerminalToken","requiresCustomPattern","regexPatternFunction","stickyRegex","buildKeywordToken","caseInsensitive","keywordPattern","buildKeywordPattern","findLongerAlt","longerAlts","setRootDoc","stateStmt","trimColon","state1","state2","relDescription","getDividerId","stateDiagram_default","STMT_STATE","STMT_RELATION","DEFAULT_STATE_TYPE","DIVIDER_TYPE","G_EDGE_STYLE","G_EDGE_ARROWHEADSTYLE","G_EDGE_LABELTYPE","G_EDGE_THICKNESS","SHAPE_STATE","SHAPE_STATE_WITH_DESC","SHAPE_DIVIDER","SHAPE_GROUP","CSS_DIAGRAM","CSS_DIAGRAM_STATE","CSS_EDGE","CSS_EDGE_NOTE_EDGE","CSS_DIAGRAM_NOTE","CSS_DIAGRAM_CLUSTER","CSS_DIAGRAM_CLUSTER_ALT","NOTE","DOMID_TYPE_SPACER","NOTE_ID","PARENT_ID","stateRenderer_v3_unified_default","extract","getRootDocV2","nodeDb","graphItemCount","stateDomId","itemId","typeSpacer","setupDoc","parentParsedItem","diagramStates","altFlag","dataFetcher","edgeData","arrowhead","labelType","getDir2","insertOrUpdateNode","nodeData","cssCompiledStyles","cssClass","classDef","existingNodeData","getClassesFromDbInfo","dbInfoItem","getStylesFromDbInfo","dbState","classStr","newNode","sanitizeTextOrArray","rx","ry","centerLabel","noteData","cssCompilesStyles","flowchart","parentNodeId","groupData","START_NODE","START_TYPE","END_NODE","COLOR_KEYWORD","FILL_KEYWORD","newClassesList","newDoc","states","documents","StateDB","version","rootDoc","currentDocument","startEndCount","dividerCnt","static","getRootDoc","docTranslator","currentDoc","docNode","_doc","addState","addStyleClass","foundState","getState","trimmedId","getStates","descr","descriptions","addDescription","des","doc2","setStyle","textStyle","setTextStyle","saveCommon","logDocuments","startIdIfNeeded","fixedId","startTypeIfNeeded","endIdIfNeeded","endTypeIfNeeded","addRelationObjs","item1","item2","relationTitle","theState","_descr","styleAttributes","foundClass","attrib","fixedAttrib","newStyle2","itemIds","cssClassName","styleText","getDirectionStatement","transitionColor","stateLabelColor","background","noteTextColor","labelBackgroundColor","edgeLabelBackground","transitionLabelColor","tertiaryTextColor","specialStateColor","innerEndBackground","compositeBackground","stateBkg","stateBorder","compositeTitleBackground","altBackground","AbstractRule","AbstractType","Condition","TypeDefinition","ValueLiteral","AbstractElement","isAbstractElement","reflection","isInstance","ArrayLiteral","ArrayType","BooleanLiteral","isBooleanLiteral","Conjunction","isConjunction","Disjunction","isDisjunction","Grammar","GrammarImport","InferredType","isInferredType","Interface","isInterface","NamedArgument","Negation","isNegation","NumberLiteral","Parameter","ParameterReference","isParameterReference","ParserRule","isParserRule","ReferenceType","ReturnType","isReturnType","SimpleType","isSimpleType","StringLiteral","TerminalRule","isTerminalRule","Type","isType","TypeAttribute","UnionType","Action","isAction","Alternatives","isAlternatives","Assignment","isAssignment","CharacterRange","isCharacterRange","CrossReference","isCrossReference","EndOfFile","isEndOfFile","Group","Keyword","isKeyword","NegatedToken","isNegatedToken","RegexToken","isRegexToken","RuleCall","isRuleCall","TerminalAlternatives","isTerminalAlternatives","TerminalGroup","isTerminalGroup","TerminalRuleCall","isTerminalRuleCall","UnorderedGroup","isUnorderedGroup","UntilToken","isUntilToken","Wildcard","isWildcard","LangiumGrammarAstReflection","getAllTypes","computeIsSubtype","subtype","supertype","isSubtype","getReferenceType","refInfo","referenceId","getTypeMetaData","properties","defaultValue","isAstNode","isReference","$refText","isAstNodeDescription","isLinkingError","reference","AbstractAstReflection","subtypes","allSubtypes","nested","existing","getAllSubTypes","allTypes","types","possibleSubType","isCompositeCstNode","isLeafCstNode","isRootCstNode","current","insertToSet","subItem","addFlag","flagObj","flagKey","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","wordCharCodes","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","RegExpParser","groupIdx","saveState","restoreState","consumeChar","disjunction","multiLine","isRegExpFlag","popChar","peekChar","isTerm","isAssertion","assertion","isBacktracking","atMost","integerIncludingZero","isDigit","greedy","dotAll","atomEscape","characterClass","isPatternCharacter","patternCharacter","isQuantifier","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","letter","parseHexDigits","classPatternCharacterAtom","isClassAtom","classAtom","isRangeDash","classEscape","capturing","groupAst","number","parseInt","nextChar","isAtom","prevState","howMany","hexString","hexChar","BaseRegExpVisitor","subChild","visitPattern","visitFlags","visitDisjunction","visitWordBoundary","visitNonWordBoundary","visitGroup","visitGroupBackReference","visitQuantifier","exports","Emitter","Event","ral_1","_disposable","dispose","None","CallbackList","callback","bucket","_callbacks","_contexts","remove","foundCallbackWithDifferentContext","splice","invoke","ret","callbacks","contexts","default","_options","_event","listener","thisArgs","disposables","onFirstListenerAdd","_noop","onLastListenerRemove","fire","NEWLINE_REGEXP","regexpParser","TerminalRegExpVisitor","isStarting","endRegexpStack","endRegex","startRegexp","escapedChar","escapeRegExp","isMultilineComment","regexp","whitespaceCharacters","isWhitespace","getCaseInsensitivePattern","partialMatches","partial","re","process","appendRaw","nbChars","appendOptional","partialRegExp","objectProto","propsIndex","propsLength","getDiagramElement","sandboxElement","contentDocument","setupViewPortForSVG","cssDiagram","calculateDimensionsWithPadding","viewBox","createViewBox","bounds","getBBox","reWhitespace","string","reTrimStart","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","valueOf","isBinary","INFINITY","EmptyFileSystemProvider","readFile","readDirectory","EmptyFileSystem","fileSystemProvider","minimalGrammarModule","LanguageMetaData","fileExtensions","languageId","minimalSharedGrammarModule","AstReflection","loadGrammarFromJson","json","services","createMinimalGrammarServices","serializer","JsonSerializer","deserialize","workspace","LangiumDocumentFactory","fromModel","__defProp","__name","Statement","Architecture","Axis","Branch","Checkout","CherryPicking","Commit","Common","Curve","Edge","Entry","GitGraph","Info","Junction","Merge","Packet","PacketBlock","Pie","PieSection","loadedInfoGrammar","loadedPacketGrammar","loadedPieGrammar","loadedArchitectureGrammar","loadedGitGraphGrammar","loadedRadarGrammar","Service","Direction","MermaidAstReflection","InfoGrammar","PacketGrammar","PieGrammar","ArchitectureGrammar","GitGraphGrammar","RadarGrammar","InfoLanguageMetaData","mode","PacketLanguageMetaData","PieLanguageMetaData","ArchitectureLanguageMetaData","GitGraphLanguageMetaData","RadarLanguageMetaData","MermaidGeneratedSharedModule","InfoGeneratedModule","PacketGeneratedModule","PieGeneratedModule","ArchitectureGeneratedModule","GitGraphGeneratedModule","RadarGeneratedModule","rulesRegexes","ACC_DESCR","ACC_TITLE","TITLE","AbstractMermaidValueConverter","runConverter","runCommonConverter","runCustomConverter","_cstNode","CommonValueConverter","_rule","AbstractMermaidTokenBuilder","keywords","DefaultValueConverter","convert","convertInt","convertString","convertID","convertNumber","convertBoolean","convertBigint","convertDate","convertEscapeCharacter","BigInt","customizer","newValue","objValue","RangeComparison","streamCst","isChildNode","tokenToRange","toDocumentSegment","inRange","comparison","Before","After","startInside","endInside","Inside","OverlapBack","OverlapFront","Outside","compareRange","DefaultNameRegexp","findCommentNode","commentNames","getPreviousNode","isCommentNode","GitGraphTokenBuilder","GitGraphModule","createGitGraphServices","PieTokenBuilder","PieValueConverter","PieModule","createPieServices","LIB","resolve","cwd","normalize","isAbsolute","relative","_makeLong","dirname","basename","extname","format","base","ext","delimiter","win32","posix","d","toStringTag","URI","Utils","P","platform","navigator","userAgent","scheme","authority","query","isUri","fsPath","with","m","C","file","toJSON","revive","_formatted","external","_fsPath","_sep","$mid","encodeURIComponent","decodeURIComponent","A","joinPath","resolvePath","InfoTokenBuilder","InfoModule","createInfoServices","stringArray","boolean","remainder","parsers","initializers","createInfoServices2","LangiumParser","packet","createPacketServices","createPacketServices2","pie","createPieServices2","architecture","createArchitectureServices","createArchitectureServices2","gitGraph","createGitGraphServices2","radar","createRadarServices2","diagramType","lexerErrors","parserErrors","MermaidParseError","err","ArchitectureTokenBuilder","ArchitectureValueConverter","ArchitectureModule","buildATNKey","AbstractTransition","isEpsilon","AtomTransition","EpsilonTransition","RuleTransition","ruleStart","followState","createATN","atn","decisionMap","decisionStates","ruleToStartState","ruleToStopState","ruleLength","stop","createRuleStartAndStopATNStates","ruleBlock","block","buildRuleHandle","production","tokenRef","currentRule","nonTerminal","addTransition","ruleRef","defineDecisionState","handle","makeAlts","optional","epsilon","starState","star","repetitionSep","plusState","plus","repetitionMandatorySep","handles","altsLength","transitions","isRuleTransition","ruleTransition","removeState","makeBlock","blkStart","blkEnd","loop","loopback","loopEnd","decision","epsilonOnlyTransitions","nextTokenWithinRule","stateNumber","DFA_ERROR","ATNConfigSet","configs","finalize","getATNConfigKey","createDFACache","startState","predicateSet","atnStartState","PredicateSet","is","EMPTY_PREDICATES","LLStarLookaheadStrategy","logging","dfas","decisionLength","decisionToDFA","initATNSimulator","decisionIndex","isLL1Sequence","prediction","gate","adaptivePredict","sequences","allowEmpty","fullSet","altSet","indices","dfaCaches","dfa","addDFAState","newDFAState","computeStartState","performLookahead","s0","previousD","computeLookaheadTarget","buildAdaptivePredictError","isAcceptState","reach","intermediate","skippedStopStates","transitionLength","getReachableTarget","closure","hasConfigInRuleStopState","computeReachSet","addDFAEdge","predictedAlt","getUniqueAlt","uniqueAlt","allConfigsInRuleStopStates","altSets","configToAlts","getConflictingAltSets","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasConflictTerminatingPrediction","reportLookaheadAmbiguity","atnState","buildAmbiguityError","nextTransitions","actualToken","possibleTokenTypes","tokenPath","mapKey","numberOfTransitions","atnStack","getEpsilonTarget","DocumentUri","integer","uinteger","Position","Range","Location","LocationLink","Color","ColorInformation","ColorPresentation","FoldingRangeKind","FoldingRange","DiagnosticRelatedInformation","DiagnosticSeverity","DiagnosticTag","CodeDescription","Diagnostic","Command","TextEdit","ChangeAnnotation","ChangeAnnotationIdentifier","AnnotatedTextEdit","TextDocumentEdit","CreateFile","RenameFile","DeleteFile","WorkspaceEdit","TextDocumentIdentifier","VersionedTextDocumentIdentifier","OptionalVersionedTextDocumentIdentifier","TextDocumentItem","MarkupKind","MarkupContent","CompletionItemKind","InsertTextFormat","CompletionItemTag","InsertReplaceEdit","InsertTextMode","CompletionItemLabelDetails","CompletionItem","CompletionList","MarkedString","Hover","ParameterInformation","SignatureInformation","DocumentHighlightKind","DocumentHighlight","SymbolKind","SymbolTag","SymbolInformation","WorkspaceSymbol","DocumentSymbol","CodeActionKind","CodeActionTriggerKind","CodeActionContext","CodeAction","CodeLens","FormattingOptions","DocumentLink","SelectionRange","SemanticTokenTypes","SemanticTokenModifiers","SemanticTokens","InlineValueText","InlineValueVariableLookup","InlineValueEvaluatableExpression","InlineValueContext","InlayHintKind","InlayHintLabelPart","InlayHint","StringValue","InlineCompletionItem","InlineCompletionList","InlineCompletionTriggerKind","SelectedCompletionInfo","InlineCompletionContext","WorkspaceFolder","MIN_VALUE","MAX_VALUE","candidate","Is","objectLiteral","one","two","three","four","uri","targetUri","targetRange","targetSelectionRange","originSelectionRange","red","green","blue","alpha","numberRange","color","textEdit","additionalTextEdits","typedArray","Comment","Imports","Region","startCharacter","endCharacter","kind","collapsedText","defined","Warning","Information","Hint","Unnecessary","Deprecated","href","severity","relatedInformation","codeDescription","command","newText","insert","del","needsConfirmation","annotationId","textDocument","edits","overwrite","ignoreIfExists","oldUri","newUri","recursive","ignoreIfNotExists","changes","documentChanges","change","PlainText","Markdown","Text","Method","Function","Constructor","Field","Variable","Class","Module","Property","Unit","Value","Enum","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Operator","TypeParameter","asIs","adjustIndentation","detail","items","isIncomplete","fromPlainText","plainText","language","contents","documentation","Read","Write","Namespace","Package","Key","Null","containerName","selectionRange","deprecated","tags","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","Invoked","Automatic","only","triggerKind","kindOrCommandOrEdit","checkKind","edit","isPreferred","data","tabSize","insertSpaces","resultId","variableName","caseSensitiveLookup","expression","frameId","stoppedLocation","textEdits","paddingLeft","paddingRight","createSnippet","insertText","filterText","selectedCompletionInfo","TextDocument","mergeSort","compare","leftIdx","rightIdx","FullTextDocument","lineCount","getText","positionAt","offsetAt","applyEdits","sortedEdits","diff","lastModifiedOffset","_uri","_languageId","_content","_lineOffsets","update","getLineOffsets","lineOffsets","isLineStart","high","mid","lineOffset","nextLineOffset","check","CstNodeBuilder","nodeStack","rootNode","buildRootNode","RootCstNodeImpl","buildCompositeNode","compositeNode","CompositeCstNodeImpl","buildLeafNode","leafNode","LeafCstNodeImpl","addHiddenNodes","added","construct","$cstNode","AbstractCstNode","_astNode","_offset","_length","_hidden","_tokenType","_range","CstNodeContainer","firstNonHiddenNode","lastNonHiddenNode","firstNode","_rangeCache","firstRange","lastRange","addParents","_text","DatatypeSymbol","isDataTypeNode","withRuleSuffix","AbstractLangiumParser","_unorderedGroups","wrapper","ChevrotainWrapper","ParserConfig","ParserErrorMessageProvider","choices","wrapOr","wrapOption","wrapMany","wrapAtLeastOne","getRule","isRecording","IS_RECORDING","unorderedGroups","getRuleStack","wrapSelfAnalysis","nodeBuilder","assignmentMap","linker","references","Linker","converter","astReflection","computeRuleType","ruleMethod","DEFINE_RULE","startImplementation","mainRule","explicit","lexerResult","lexerReport","report","createNode","extractHiddenTokens","hiddenTokens","wrapConsume","isValidToken","isCrossRef","getAssignment","convertedValue","operator","subruleResult","wrapSubrule","performSubruleAssignment","newItem","assignWithoutOverride","buildReference","existingValue","targetCstNode","AbstractParserErrorMessageProvider","LangiumParserErrorMessageProvider","LangiumCompletionParser","elementStack","lastElementStack","nextTokenIndex","stackSize","resetState","tokenIndex","keepStackSize","resetStackSize","removeUnexpectedElements","before","after","defaultConfig","useDefaultLookahead","createParser","parserContext","reachable","parserRules","buildElement","buildRules","ignoreGuard","method","buildKeyword","buildAction","buildCrossReference","ruleCall","namedArgs","buildPredicate","ruleArgs","ruleTarget","buildRuleCallPredicate","getToken","buildRuleCall","predicatedMethod","getGuardCondition","buildAlternatives","orIdx","idFunc","lParser","groupState","trackedAlternatives","wrapped","delete","buildUnorderedGroup","buildGroup","true","guardCondition","assignTerminal","getRuleName","createLangiumParser","prepareLangiumParser","lastTick","globalInterruptionPeriod","isOperationCancelled","interruptAndCheck","performance","Promise","setImmediate","setTimeout","isCancellationRequested","promise","arg","isIncremental","getWellformedRange","addedLineOffsets","computeLineOffsets","isFull","ensureBeforeEOL","isEOL","rangeLength","isAtLineStart","textOffset","getWellformedEdit","spans","DocumentState","DefaultLangiumDocumentFactory","serviceRegistry","textDocuments","TextDocuments","FileSystemProvider","fromUri","cancellationToken","createAsync","fromTextDocument","fromString","model","$model","parseResult","createLangiumDocument","cancelToken","parseAsync","Parsed","textDocumentGetter","createTextDocumentGetter","$document","oldText","getServices","AsyncParser","textDoc","DefaultLangiumDocuments","documentMap","langiumDocumentFactory","all","addDocument","uriString","getDocument","getOrCreateDocument","createDocument","then","hasDocument","invalidateDocument","langiumDoc","Changed","precomputedScopes","deleteDocument","ref_resolving","DefaultLinker","langiumDocuments","LangiumDocuments","scopeProvider","ScopeProvider","astNodeLocator","AstNodeLocator","doLink","_ref","getCandidate","_nodeDescription","documentUri","linkedNode","loadAstNode","createLinkingError","getScope","getElement","refNode","refText","$refNode","refData","getLinkedNode","ComputedScopes","getAstNodePath","$nodeDescription","nodeDescription","getAstNode","targetDescription","referenceType","DefaultNameProvider","getName","isNamed","getNameNode","UriUtils","equals","fromPath","toPath","fromParts","toParts","repeat","DefaultReferences","nameProvider","NameProvider","IndexManager","nodeLocator","findDeclaration","sourceCstNode","nodeElem","nameNode","findDeclarationNode","targetNode","findReferences","refs","includeDeclaration","getReferenceToSelf","indexReferences","findAllReferences","sourceUri","sourcePath","segment","local","MultiMap","addAll","entriesGroupedByKey","BiMap","inverse","getKey","DefaultScopeComputation","AstNodeDescriptionProvider","computeExports","computeExportsForNode","parentNode","exportNode","createDescription","computeLocalScopes","scopes","processNode","StreamScope","outerScope","getAllElements","MapScope","localName","elementStream","DisposableCache","toDispose","isDisposed","onDispose","disposable","throwIfDisposed","SimpleCache","provider","ContextCache","contextKey","cacheForContext","contextCache","documentCache","WorkspaceCache","sharedServices","DocumentBuilder","onBuildPhase","onUpdate","_changed","deleted","DefaultScopeProvider","indexManager","globalScopeCache","precomputed","currentNode","allDescriptions","desc","getGlobalScope","createScope","createScopeForNodes","_context","allElements","isIntermediateReference","DefaultJsonSerializer","ignoreProperties","commentProvider","CommentProvider","serialize","serializeOptions","specificReplacer","replacer","defaultReplacer","space","deserializeOptions","linkNode","sourceText","textRegions","comments","uriConverter","_d","refValue","targetDocument","$ref","$error","addAstNodeRegionWithAssignmentsTo","$textRegion","documentURI","$sourceText","comment","getComment","$comment","createDocumentSegment","assignments","propertyAssignments","containerProperty","containerIndex","propertyName","reviveReference","mutable","$containerProperty","$containerIndex","getRefNode","fragmentIndex","DefaultServiceRegistry","fileExtensionMap","languageIdMap","singleton","hasServices","diagnosticData","ValidationCategory","DocumentValidator","ValidationRegistry","entriesBefore","entriesAfter","checksRecord","thisObj","category","wrapValidationException","addEntry","handleException","functionality","messageContext","getChecks","checks","registerBeforeDocument","checkBefore","wrapPreparationException","registerAfterDocument","checkAfter","checksBefore","checksAfter","DefaultDocumentValidator","validationRegistry","validation","metadata","validateDocument","processLexingErrors","stopAfterLexingErrors","LexingError","processParsingErrors","stopAfterParsingErrors","ParsingError","processLinkingErrors","stopAfterLinkingErrors","LinkingError","validateAst","lexerDiagnostics","lexerDiagnostic","diagnostic","toDiagnosticSeverity","toDiagnosticData","getSource","parserError","linkingError","containerType","toDiagnostic","validationItems","acceptor","validateAstBefore","validateAstNodes","validateAstAfter","getDiagnosticRange","LexingWarning","LexingInfo","LexingHint","DefaultAstNodeDescriptionProvider","nameNodeSegment","nameSegmentGetter","nameSegment","selectionSegment","DefaultReferenceDescriptionProvider","createDescriptions","targetNodeDescr","refCstNode","docUri","DefaultAstNodeLocator","segmentSeparator","indexSeparator","containerPath","newSegment","getPathSegment","currentValue","propertyIndex","arrayIndex","Disposable","DefaultConfigurationProvider","_ready","settings","workspaceConfig","onConfigurationSectionUpdateEmitter","ready","params","capabilities","configuration","initialized","languages","section","lang","toSectionName","fetchConfiguration","configToUpdate","updateSectionConfiguration","updateConfiguration","getConfiguration","sectionName","onConfigurationSectionUpdate","DefaultDocumentBuilder","updateBuildOptions","updateListeners","buildPhaseListeners","documentPhaseListeners","documentBuildWaiters","currentState","build","Validated","IndexedReferences","previousCategories","validationChecks","completed","emitUpdate","buildDocuments","changed","deletedUri","changedUri","newDocument","allChangedUris","shouldRelink","rebuildDocuments","sortDocuments","Linked","hasTextDocument","changedUris","isAffected","prepareBuild","runCancelable","IndexedContent","updateContent","scopeComputation","ScopeComputation","updateReferences","toBeValidated","shouldValidate","targetState","filtered","notifyDocumentPhase","targetStateDocs","notifyBuildPhase","onDocumentPhase","waitUntil","uriOrToken","buildDisposable","cancelDisposable","onCancellationRequested","listenersCopy","getBuildOptions","validator","validationSetting","DefaultIndexManager","symbolIndex","symbolByTypeIndex","referenceIndex","astNodePath","targetDocUri","docRefs","refDescr","nodeType","uris","documentUris","getFileDescriptions","indexData","ReferenceDescriptionProvider","DefaultWorkspaceManager","initialBuildOptions","documentBuilder","mutex","WorkspaceLock","workspaceFolders","folders","_params","write","initializeWorkspace","performStartup","collector","loadAdditionalDocuments","wf","getRootFolder","traverseFolder","_folders","_collector","workspaceFolder","folderPath","includeEntry","isDirectory","isFile","_workspaceFolder","DefaultLexerErrorMessageProvider","DEFAULT_TOKENIZE_OPTIONS","DefaultLexer","LexerErrorMessageProvider","tokenBuilder","toTokenTypeDictionary","lexerTokens","isTokenTypeDictionary","chevrotainLexer","chevrotainResult","isIMultiModeLexerDefinition","res","isTokenTypeArray","parseJSDoc","currentLine","currentCharacter","lastCharacter","skipWhitespace","tagRegex","tagMatch","fullMatch","inlineTagMatches","matchAll","inlineTagRegex","buildInlineTokens","getLines","normalizeOptions","startPosition","JSDocCommentImpl","parseJSDocElement","parseJSDocComment","lineIndex","characterIndex","matchIndex","startContent","tagName","endContent","nonWhitespaceRegex","whitespaceEndRegex","parseJSDocTag","parseJSDocText","JSDocLineImpl","inlines","appendEmptyLine","firstToken","lastToken","parseJSDocInline","JSDocTextImpl","parseJSDocLine","inline","tagToken","docLine","JSDocTagImpl","normalizeOption","escaped","getTag","getAllTags","getTags","fillNewlines","toMarkdown","renderTag","toMarkdownDefault","rendered","tag","display","displayStart","renderedLink","renderLink","renderLinkDefault","renderInlineTag","JSDocDocumentationProvider","getDocumentation","normalizedOptions","firstRegex","lastRegex","isJSDoc","documentationLinkRenderer","documentationTagRenderer","findNameInPrecomputedScopes","findNameInGlobalScope","_node","_tag","DefaultCommentProvider","grammarConfig","GrammarConfig","isAstNodeWithComment","multilineCommentRules","DefaultAsyncParser","syncParser","_cancelToken","DefaultWorkspaceLock","previousTokenSource","writeQueue","readQueue","cancelWrite","tokenSource","read","queue","deferred","performNextOperation","shift","cancel","DefaultHydrator","grammarElementIdMap","tokenTypeIdMap","dehydrate","dehydrateLexerReport","dehydrateAstNode","createDehyrationContext","astNodes","cstNodes","dehydrateCstNode","arr","dehydrateReference","getGrammarElementId","hydrate","createHydrationContext","hydrateCstNode","hydrateAstNode","hydrateCstLeafNode","hydrateReference","num","cstNodeObj","getGrammarElement","hydrated","getTokenType","createGrammarElementIdMap","createDefaultCoreModule","DocumentationProvider","nameRegexp","createGrammarConfig","CompletionParser","createCompletionParser","References","Hydrator","createDefaultSharedCoreModule","WorkspaceManager","ConfigurationProvider","inject","module1","module2","module3","module4","module5","module6","module7","module8","module9","_inject","_merge","merge","m1","m2","isProxy","module","injector","proxy","Proxy","deleteProperty","_resolve","ownKeys","__requested__","cause","value2","value1","_ral","RAL","install","ral","linkContentToContainer","getContainerOfType","typePredicate","findRootNode","streamContents","keyIndex","isAstNodeInRange","streamAllContents","streamAst","nodeRange","streamReferences","assignMandatoryProperties","typeMetaData","genericNode","copyDefaultValue","propertyType","events_1","CancellationToken","Cancelled","shortcutEvent","MutableToken","_isCancelled","_emitter","_token","PacketTokenBuilder","PacketModule"],"sourceRoot":""}