---
title: Navigating the Shift from Deterministic to Probabilistic Software Engineering
date: 2025-03-16
tags:
  - AI
  - Software Engineering
slug: "/deterministic-to-probabilistic"
---

Software engineering is at a crossroads. For decades, the craft has been built on deterministic foundations – where 2+2 always equals 4 and the same inputs reliably produce the same outputs. But as we advance into the era of AI agents, we're witnessing a fundamental shift toward probabilistic thinking that's changing what it means to be a software engineer.

## The Deterministic vs. Probabilistic Paradigm

Traditional software engineering operates in a binary world: good or bad, pass or fail. When 100% of the tests pass, you can ship your product. It's clean, predictable, and comfortably black and white.

Probabilistic software, on the other hand, abandons these binary outcomes in favour of statistical efficacy. The questions shift from "Will this work?" to "What's the likelihood of this working?" This reframing is crucial as we build and deploy increasingly autonomous AI systems.

This isn't entirely new territory – we've had machine learning systems for years. But with the advent of the agentic movement, probabilistic thinking is becoming less of a specialised skill and more of a fundamental requirement.

## Complexity and Uncertainty

As agents become more autonomous their non-deterministic aspects introduce new challenges:

- Increased variability in outputs
- Difficulty in comprehensive testing
- Complex security and consistency requirements

These complexities demand engineers to develop new mental models for designing, testing, and monitoring AI-based solutions.

## The Reality Behind the Hype: Why Coding Skills Still Matter
YouTube is filled with claims that you can "lay off your entire team" or "become a 10x developer" simply by combining tools like Cursor and some MCP servers. While these tools are powerful and impressive, there's still a substantial gap between flashy proof-of-concept and production-ready system. Not all generated code is correct or useful – you need discernment to evaluate it effectively.

Experienced software engineers understand that coding is just one part of the job. In reality, a substantial part of a senior engineer's role includes looking at systems holistically, anticipating potential failure points, analysing technical debt, aligning activities with product roadmaps, mentoring team members, and understanding how systems behave at scale. 

These skills become even more critical when dealing with complex, probabilistic AI systems. The value of software engineering isn't diminishing – what's changing is the additional skillset required to effectively leverage AI tools while still putting systems into production that manage the necessary trade-offs between latency, scale, and reliability.

## Finding the Right Balance

The first question when considering an agent should be: do I actually need one? Not everything requires a probabilistic approach. Sometimes deterministic software is perfectly sufficient – and an "agent" could still be running deterministic software under the hood.

## Adapting to the Agentic Age

For engineers who have determined they need to build agent-based systems, several approaches can help navigate the non-deterministic behaviour:

1. **Embrace Structured Outputs** – The goal isn't to coerce these models to become deterministic – their probabilistic nature is precisely what makes them powerful. Instead, we need to leverage that strength while building reliable systems. Tools like the Instructor library can be a great starting point in creating controllable structured outputs from LLM models. 

2. **Self-Validating Systems** – Increasingly, we'll use AI systems to verify results from other AI components, creating internal validation loops. See [LLM-as-a-judge](https://huggingface.co/learn/cookbook/llm_judge) for a practical example of using language models to evaluate other AI outputs.

3. **Learn from Existing Systems that Operate Under Uncertainty** – We're not starting from zero. Reinforcement learning and many machine learning techniques already operate under probabilistic uncertainty. We can and should apply these lessons to agent-based systems. Google's [ML Test Score](https://storage.googleapis.com/gweb-research2023-media/pubtools/4156.pdf) provides a fantastic checklist to assess production-readiness of ML systems.

4. **Focus on the Right Problems and Metrics** – Understand the problem you're solving first, not just input/output results or benchmark scores. Ensure your data and metrics accurately represent real-world conditions. Rather than chasing corner cases, evaluate performance across diverse test distributions to build systems that solve the actual problem, not just optimise for artificial metrics.

## The Hybrid Future

The future isn't probabilistic versus deterministic – it's both. We'll need all the strengths of traditional software development alongside these new approaches to probabilistic systems.

The complementary nature of these paradigms will produce the most powerful results as we build increasingly autonomous and capable systems. Great software engineers will be those who can navigate both worlds effectively, understanding when to apply each approach and how to combine them seamlessly.
