{"version":3,"file":"1c377de9871869784a9a644e97cd16155818224d-00cde8d32fff4b70ce11.js","mappings":"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AI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,GAAI,GA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","sources":["webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/grammar-utils.js","webpack://peter-wooldridge-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-A2AXSNBT.mjs","webpack://peter-wooldridge-blog/./node_modules/lodash-es/uniqueId.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseRange.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_createRange.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/range.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/data/list.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/greedy-fas.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/acyclic.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_basePick.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_flatRest.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/pick.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseGt.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/max.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/mapValues.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/now.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/util.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/add-border-segments.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/coordinate-system.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/normalize.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/minBy.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/rank/util.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/rank/feasible-tree.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/dijkstra.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/floyd-warshall.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_asciiSize.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_hasUnicode.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_unicodeSize.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/topsort.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/dfs.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/rank/network-simplex.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/postorder.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/alg/preorder.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/rank/index.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/nesting-graph.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/cloneDeep.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/build-layer-graph.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseZipObject.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/zipObject.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseSortBy.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_compareAscending.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_compareMultiple.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseOrderBy.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/sortBy.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/cross-count.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/resolve-conflicts.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/sort.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/sort-subgraph.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/barycenter.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/index.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/init-order.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/order/add-subgraph-constraints.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/parent-dummy-chains.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/forOwn.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/forIn.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/position/bk.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/position/index.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/dagre/layout.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseSlice.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/drop.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/assign.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/pickBy.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseIsRegExp.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/isRegExp.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/gast/lib/src/model.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/gast/lib/src/visitor.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseSome.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/some.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/includes.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_arrayEvery.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseEvery.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/every.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/gast/lib/src/helpers.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/rest.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/uniq.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/first.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/constants.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/follow.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/negate.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/reject.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/indexOf.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseDifference.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/difference.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/compact.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/head.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/utils/lib/src/print.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/reg_exp.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/lexer.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/utils/lib/src/timer.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/tokens.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/lexer_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/scan/tokens_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/errors_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_arrayAggregator.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_baseAggregator.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/_createAggregator.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/groupBy.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/dropRight.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/checks.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/exceptions_public.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/keys.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/cst/cst.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/lang/lang_extensions.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/parser.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/union.js","webpack://peter-wooldridge-blog/./node_modules/dagre-d3-es/src/graphlib/graph.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/errors.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/stream.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/token-builder.js","webpack://peter-wooldridge-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-AEK57VVT.mjs","webpack://peter-wooldridge-blog/./node_modules/langium/lib/languages/generated/ast.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/syntax-tree.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js","webpack://peter-wooldridge-blog/./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js","webpack://peter-wooldridge-blog/./node_modules/vscode-jsonrpc/lib/common/events.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/regexp-utils.js","webpack://peter-wooldridge-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-RZ5BOZE2.mjs","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/file-system-provider.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/grammar-loader.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/value-converter.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/cst-utils.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs","webpack://peter-wooldridge-blog/./node_modules/mermaid/dist/chunks/mermaid.core/chunk-4BMEZGHF.mjs","webpack://peter-wooldridge-blog/./node_modules/vscode-uri/lib/esm/index.mjs","webpack://peter-wooldridge-blog/./node_modules/lodash-es/flatMap.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs","webpack://peter-wooldridge-blog/./node_modules/vscode-jsonrpc/lib/common/is.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs","webpack://peter-wooldridge-blog/./node_modules/chevrotain-allstar/lib/atn.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain-allstar/lib/dfa.js","webpack://peter-wooldridge-blog/./node_modules/lodash-es/uniqBy.js","webpack://peter-wooldridge-blog/./node_modules/chevrotain-allstar/lib/all-star-lookahead.js","webpack://peter-wooldridge-blog/./node_modules/vscode-languageserver-types/lib/esm/main.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/cst-node-builder.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/langium-parser.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/parser-builder-base.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/langium-parser-builder.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/promise-utils.js","webpack://peter-wooldridge-blog/./node_modules/vscode-languageserver-textdocument/lib/esm/main.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/documents.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/linker.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/name-provider.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/uri-utils.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/references.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/collections.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/scope-computation.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/scope.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/caching.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/references/scope-provider.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/serializer/json-serializer.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/service-registry.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/validation/validation-registry.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/validation/document-validator.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/ast-descriptions.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/ast-node-locator.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/disposable.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/configuration.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/document-builder.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/index-manager.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/workspace-manager.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/lexer.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/documentation/jsdoc.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/documentation/documentation-provider.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/documentation/comment-provider.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/async-parser.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/workspace/workspace-lock.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/serializer/hydrator.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/default-module.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/languages/grammar-config.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/parser/completion-parser-builder.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/dependency-injection.js","webpack://peter-wooldridge-blog/./node_modules/vscode-jsonrpc/lib/common/ral.js","webpack://peter-wooldridge-blog/./node_modules/langium/lib/utils/ast-utils.js","webpack://peter-wooldridge-blog/./node_modules/vscode-jsonrpc/lib/common/cancellation.js","webpack://peter-wooldridge-blog/./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs"],"sourcesContent":["/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../utils/errors.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\nimport { streamCst } from './cst-utils.js';\nimport { escapeRegExp, isWhitespace } from './regexp-utils.js';\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nexport function getEntryRule(grammar) {\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry);\n}\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nexport function getHiddenRules(grammar) {\n    return grammar.rules.filter((e) => ast.isTerminalRule(e) && e.hidden);\n}\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nexport function getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = new Set();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n    const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n    const rules = new Set();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    streamAllContents(rule).forEach(node => {\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nexport function getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    }\n    else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return undefined;\n}\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nexport function isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !isWhitespace(terminalRegex(terminalRule));\n}\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nexport function findNodesForProperty(node, property) {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForProperty(node, property, index) {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first) {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nexport function findNodesForKeyword(node, keyword) {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForKeyword(node, keyword, index) {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nexport function findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            }\n            else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nexport function findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nexport function findNameAssignment(type) {\n    let startNode = type;\n    if (ast.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (ast.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container;\n        }\n        else if (ast.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        }\n        else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    // the cache is only required to prevent infinite loops\n    function go(node, refType) {\n        let childAssignment = undefined;\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of streamAllContents(startNode)) {\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        }\n        else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        }\n        else if (ast.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\nexport function getActionAtElement(element) {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            }\n            else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    }\n    else {\n        return undefined;\n    }\n}\nexport function isOptionalCardinality(cardinality, element) {\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\nexport function isArrayCardinality(cardinality) {\n    return cardinality === '*' || cardinality === '+';\n}\nexport function isArrayOperator(operator) {\n    return operator === '+=';\n}\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nexport function isDataTypeRule(rule) {\n    return isDataTypeRuleInternal(rule, new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) {\n        return true;\n    }\n    else {\n        visited.add(rule);\n    }\n    for (const node of streamAllContents(rule)) {\n        if (ast.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        }\n        else if (ast.isAssignment(node)) {\n            return false;\n        }\n        else if (ast.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\nexport function isDataType(type) {\n    return isDataTypeInternal(type.type, new Set());\n}\nfunction isDataTypeInternal(type, visited) {\n    if (visited.has(type)) {\n        return true;\n    }\n    else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    }\n    else if (ast.isReferenceType(type)) {\n        return false;\n    }\n    else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    }\n    else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        }\n        else if (type.stringType !== undefined) {\n            return true;\n        }\n        else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nexport function getExplicitRuleType(rule) {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    }\n    else if (rule.dataType) {\n        return rule.dataType;\n    }\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            // check if we need to check Action as return type\n            if (ast.isParserRule(refType)) {\n                return refType.name;\n            }\n            else if (ast.isInterface(refType) || ast.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\nexport function getTypeName(type) {\n    var _a;\n    if (ast.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    }\n    else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\n        return type.name;\n    }\n    else if (ast.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    }\n    else if (ast.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\nexport function getActionType(action) {\n    var _a;\n    if (action.inferredType) {\n        return action.inferredType.name;\n    }\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n/**\n * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.\n * For data type rules, the name of the rule is returned,\n * e.g. \"INT_value returns number: MY_INT;\" returns \"INT_value\".\n * @param rule the given rule\n * @returns the name of the AST node type of the rule\n */\nexport function getRuleTypeName(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\n/**\n * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.\n * For data type rules, the name of the declared return type of the rule is returned (if any),\n * e.g. \"INT_value returns number: MY_INT;\" returns \"number\".\n * @param rule the given rule\n * @returns the name of the type of the produced values of the rule at runtime\n */\nexport function getRuleType(rule) {\n    var _a, _b, _c;\n    if (ast.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\nexport function terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n    if (ast.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    }\n    else if (ast.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    }\n    else if (ast.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    }\n    else if (ast.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else if (ast.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    }\n    else if (ast.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    }\n    else if (ast.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    }\n    else if (ast.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else {\n        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n    }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\nfunction terminalGroupToRegex(group) {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\nfunction untilTokenToRegex(until) {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\nfunction negateTokenToRegex(negate) {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\nfunction characterRangeToRegex(range) {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\nfunction keywordToRegex(keyword) {\n    return escapeRegExp(keyword.value);\n}\nfunction withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n//# sourceMappingURL=grammar-utils.js.map","import {\n  getDiagramElement,\n  setupViewPortForSVG\n} from \"./chunk-RZ5BOZE2.mjs\";\nimport {\n  getRegisteredLayoutAlgorithm,\n  render\n} from \"./chunk-TYCBKAJE.mjs\";\nimport {\n  getEdgeId,\n  utils_default\n} from \"./chunk-O4NI6UNU.mjs\";\nimport {\n  __name,\n  clear,\n  common_default,\n  getAccDescription,\n  getAccTitle,\n  getConfig2 as getConfig,\n  getDiagramTitle,\n  log,\n  parseGenericTypes,\n  sanitizeText,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/diagrams/class/parser/classDiagram.jison\nvar parser = function() {\n  var o = /* @__PURE__ */ __name(function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;\n    return o2;\n  }, \"o\"), $V0 = [1, 18], $V1 = [1, 19], $V2 = [1, 20], $V3 = [1, 41], $V4 = [1, 42], $V5 = [1, 26], $V6 = [1, 24], $V7 = [1, 25], $V8 = [1, 32], $V9 = [1, 33], $Va = [1, 34], $Vb = [1, 45], $Vc = [1, 35], $Vd = [1, 36], $Ve = [1, 37], $Vf = [1, 38], $Vg = [1, 27], $Vh = [1, 28], $Vi = [1, 29], $Vj = [1, 30], $Vk = [1, 31], $Vl = [1, 44], $Vm = [1, 46], $Vn = [1, 43], $Vo = [1, 47], $Vp = [1, 9], $Vq = [1, 8, 9], $Vr = [1, 58], $Vs = [1, 59], $Vt = [1, 60], $Vu = [1, 61], $Vv = [1, 62], $Vw = [1, 63], $Vx = [1, 64], $Vy = [1, 8, 9, 41], $Vz = [1, 76], $VA = [1, 8, 9, 12, 13, 22, 39, 41, 44, 66, 67, 68, 69, 70, 71, 72, 77, 79], $VB = [1, 8, 9, 12, 13, 17, 20, 22, 39, 41, 44, 48, 58, 66, 67, 68, 69, 70, 71, 72, 77, 79, 84, 99, 101, 102], $VC = [13, 58, 84, 99, 101, 102], $VD = [13, 58, 71, 72, 84, 99, 101, 102], $VE = [13, 58, 66, 67, 68, 69, 70, 84, 99, 101, 102], $VF = [1, 98], $VG = [1, 115], $VH = [1, 107], $VI = [1, 113], $VJ = [1, 108], $VK = [1, 109], $VL = [1, 110], $VM = [1, 111], $VN = [1, 112], $VO = [1, 114], $VP = [22, 58, 59, 80, 84, 85, 86, 87, 88, 89], $VQ = [1, 8, 9, 39, 41, 44], $VR = [1, 8, 9, 22], $VS = [1, 143], $VT = [1, 8, 9, 59], $VU = [1, 8, 9, 22, 58, 59, 80, 84, 85, 86, 87, 88, 89];\n  var parser2 = {\n    trace: /* @__PURE__ */ __name(function trace() {\n    }, \"trace\"),\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"mermaidDoc\": 4, \"statements\": 5, \"graphConfig\": 6, \"CLASS_DIAGRAM\": 7, \"NEWLINE\": 8, \"EOF\": 9, \"statement\": 10, \"classLabel\": 11, \"SQS\": 12, \"STR\": 13, \"SQE\": 14, \"namespaceName\": 15, \"alphaNumToken\": 16, \"DOT\": 17, \"className\": 18, \"classLiteralName\": 19, \"GENERICTYPE\": 20, \"relationStatement\": 21, \"LABEL\": 22, \"namespaceStatement\": 23, \"classStatement\": 24, \"memberStatement\": 25, \"annotationStatement\": 26, \"clickStatement\": 27, \"styleStatement\": 28, \"cssClassStatement\": 29, \"noteStatement\": 30, \"classDefStatement\": 31, \"direction\": 32, \"acc_title\": 33, \"acc_title_value\": 34, \"acc_descr\": 35, \"acc_descr_value\": 36, \"acc_descr_multiline_value\": 37, \"namespaceIdentifier\": 38, \"STRUCT_START\": 39, \"classStatements\": 40, \"STRUCT_STOP\": 41, \"NAMESPACE\": 42, \"classIdentifier\": 43, \"STYLE_SEPARATOR\": 44, \"members\": 45, \"CLASS\": 46, \"ANNOTATION_START\": 47, \"ANNOTATION_END\": 48, \"MEMBER\": 49, \"SEPARATOR\": 50, \"relation\": 51, \"NOTE_FOR\": 52, \"noteText\": 53, \"NOTE\": 54, \"CLASSDEF\": 55, \"classList\": 56, \"stylesOpt\": 57, \"ALPHA\": 58, \"COMMA\": 59, \"direction_tb\": 60, \"direction_bt\": 61, \"direction_rl\": 62, \"direction_lr\": 63, \"relationType\": 64, \"lineType\": 65, \"AGGREGATION\": 66, \"EXTENSION\": 67, \"COMPOSITION\": 68, \"DEPENDENCY\": 69, \"LOLLIPOP\": 70, \"LINE\": 71, \"DOTTED_LINE\": 72, \"CALLBACK\": 73, \"LINK\": 74, \"LINK_TARGET\": 75, \"CLICK\": 76, \"CALLBACK_NAME\": 77, \"CALLBACK_ARGS\": 78, \"HREF\": 79, \"STYLE\": 80, \"CSSCLASS\": 81, \"style\": 82, \"styleComponent\": 83, \"NUM\": 84, \"COLON\": 85, \"UNIT\": 86, \"SPACE\": 87, \"BRKT\": 88, \"PCT\": 89, \"commentToken\": 90, \"textToken\": 91, \"graphCodeTokens\": 92, \"textNoTagsToken\": 93, \"TAGSTART\": 94, \"TAGEND\": 95, \"==\": 96, \"--\": 97, \"DEFAULT\": 98, \"MINUS\": 99, \"keywords\": 100, \"UNICODE_TEXT\": 101, \"BQUOTE_STR\": 102, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 7: \"CLASS_DIAGRAM\", 8: \"NEWLINE\", 9: \"EOF\", 12: \"SQS\", 13: \"STR\", 14: \"SQE\", 17: \"DOT\", 20: \"GENERICTYPE\", 22: \"LABEL\", 33: \"acc_title\", 34: \"acc_title_value\", 35: \"acc_descr\", 36: \"acc_descr_value\", 37: \"acc_descr_multiline_value\", 39: \"STRUCT_START\", 41: \"STRUCT_STOP\", 42: \"NAMESPACE\", 44: \"STYLE_SEPARATOR\", 46: \"CLASS\", 47: \"ANNOTATION_START\", 48: \"ANNOTATION_END\", 49: \"MEMBER\", 50: \"SEPARATOR\", 52: \"NOTE_FOR\", 54: \"NOTE\", 55: \"CLASSDEF\", 58: \"ALPHA\", 59: \"COMMA\", 60: \"direction_tb\", 61: \"direction_bt\", 62: \"direction_rl\", 63: \"direction_lr\", 66: \"AGGREGATION\", 67: \"EXTENSION\", 68: \"COMPOSITION\", 69: \"DEPENDENCY\", 70: \"LOLLIPOP\", 71: \"LINE\", 72: \"DOTTED_LINE\", 73: \"CALLBACK\", 74: \"LINK\", 75: \"LINK_TARGET\", 76: \"CLICK\", 77: \"CALLBACK_NAME\", 78: \"CALLBACK_ARGS\", 79: \"HREF\", 80: \"STYLE\", 81: \"CSSCLASS\", 84: \"NUM\", 85: \"COLON\", 86: \"UNIT\", 87: \"SPACE\", 88: \"BRKT\", 89: \"PCT\", 92: \"graphCodeTokens\", 94: \"TAGSTART\", 95: \"TAGEND\", 96: \"==\", 97: \"--\", 98: \"DEFAULT\", 99: \"MINUS\", 100: \"keywords\", 101: \"UNICODE_TEXT\", 102: \"BQUOTE_STR\" },\n    productions_: [0, [3, 1], [3, 1], [4, 1], [6, 4], [5, 1], [5, 2], [5, 3], [11, 3], [15, 1], [15, 3], [15, 2], [18, 1], [18, 3], [18, 1], [18, 2], [18, 2], [18, 2], [10, 1], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [23, 4], [23, 5], [38, 2], [40, 1], [40, 2], [40, 3], [24, 1], [24, 3], [24, 4], [24, 6], [43, 2], [43, 3], [26, 4], [45, 1], [45, 2], [25, 1], [25, 2], [25, 1], [25, 1], [21, 3], [21, 4], [21, 4], [21, 5], [30, 3], [30, 2], [31, 3], [56, 1], [56, 3], [32, 1], [32, 1], [32, 1], [32, 1], [51, 3], [51, 2], [51, 2], [51, 1], [64, 1], [64, 1], [64, 1], [64, 1], [64, 1], [65, 1], [65, 1], [27, 3], [27, 4], [27, 3], [27, 4], [27, 4], [27, 5], [27, 3], [27, 4], [27, 4], [27, 5], [27, 4], [27, 5], [27, 5], [27, 6], [28, 3], [29, 3], [57, 1], [57, 3], [82, 1], [82, 2], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [90, 1], [90, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [93, 1], [93, 1], [93, 1], [93, 1], [16, 1], [16, 1], [16, 1], [16, 1], [19, 1], [53, 1]],\n    performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 8:\n          this.$ = $$[$0 - 1];\n          break;\n        case 9:\n        case 12:\n        case 14:\n          this.$ = $$[$0];\n          break;\n        case 10:\n        case 13:\n          this.$ = $$[$0 - 2] + \".\" + $$[$0];\n          break;\n        case 11:\n        case 15:\n          this.$ = $$[$0 - 1] + $$[$0];\n          break;\n        case 16:\n        case 17:\n          this.$ = $$[$0 - 1] + \"~\" + $$[$0] + \"~\";\n          break;\n        case 18:\n          yy.addRelation($$[$0]);\n          break;\n        case 19:\n          $$[$0 - 1].title = yy.cleanupLabel($$[$0]);\n          yy.addRelation($$[$0 - 1]);\n          break;\n        case 30:\n          this.$ = $$[$0].trim();\n          yy.setAccTitle(this.$);\n          break;\n        case 31:\n        case 32:\n          this.$ = $$[$0].trim();\n          yy.setAccDescription(this.$);\n          break;\n        case 33:\n          yy.addClassesToNamespace($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 34:\n          yy.addClassesToNamespace($$[$0 - 4], $$[$0 - 1]);\n          break;\n        case 35:\n          this.$ = $$[$0];\n          yy.addNamespace($$[$0]);\n          break;\n        case 36:\n          this.$ = [$$[$0]];\n          break;\n        case 37:\n          this.$ = [$$[$0 - 1]];\n          break;\n        case 38:\n          $$[$0].unshift($$[$0 - 2]);\n          this.$ = $$[$0];\n          break;\n        case 40:\n          yy.setCssClass($$[$0 - 2], $$[$0]);\n          break;\n        case 41:\n          yy.addMembers($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 42:\n          yy.setCssClass($$[$0 - 5], $$[$0 - 3]);\n          yy.addMembers($$[$0 - 5], $$[$0 - 1]);\n          break;\n        case 43:\n          this.$ = $$[$0];\n          yy.addClass($$[$0]);\n          break;\n        case 44:\n          this.$ = $$[$0 - 1];\n          yy.addClass($$[$0 - 1]);\n          yy.setClassLabel($$[$0 - 1], $$[$0]);\n          break;\n        case 45:\n          yy.addAnnotation($$[$0], $$[$0 - 2]);\n          break;\n        case 46:\n        case 59:\n          this.$ = [$$[$0]];\n          break;\n        case 47:\n          $$[$0].push($$[$0 - 1]);\n          this.$ = $$[$0];\n          break;\n        case 48:\n          break;\n        case 49:\n          yy.addMember($$[$0 - 1], yy.cleanupLabel($$[$0]));\n          break;\n        case 50:\n          break;\n        case 51:\n          break;\n        case 52:\n          this.$ = { \"id1\": $$[$0 - 2], \"id2\": $$[$0], relation: $$[$0 - 1], relationTitle1: \"none\", relationTitle2: \"none\" };\n          break;\n        case 53:\n          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 1], relationTitle1: $$[$0 - 2], relationTitle2: \"none\" };\n          break;\n        case 54:\n          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: \"none\", relationTitle2: $$[$0 - 1] };\n          break;\n        case 55:\n          this.$ = { id1: $$[$0 - 4], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: $$[$0 - 3], relationTitle2: $$[$0 - 1] };\n          break;\n        case 56:\n          yy.addNote($$[$0], $$[$0 - 1]);\n          break;\n        case 57:\n          yy.addNote($$[$0]);\n          break;\n        case 58:\n          this.$ = $$[$0 - 2];\n          yy.defineClass($$[$0 - 1], $$[$0]);\n          break;\n        case 60:\n          this.$ = $$[$0 - 2].concat([$$[$0]]);\n          break;\n        case 61:\n          yy.setDirection(\"TB\");\n          break;\n        case 62:\n          yy.setDirection(\"BT\");\n          break;\n        case 63:\n          yy.setDirection(\"RL\");\n          break;\n        case 64:\n          yy.setDirection(\"LR\");\n          break;\n        case 65:\n          this.$ = { type1: $$[$0 - 2], type2: $$[$0], lineType: $$[$0 - 1] };\n          break;\n        case 66:\n          this.$ = { type1: \"none\", type2: $$[$0], lineType: $$[$0 - 1] };\n          break;\n        case 67:\n          this.$ = { type1: $$[$0 - 1], type2: \"none\", lineType: $$[$0] };\n          break;\n        case 68:\n          this.$ = { type1: \"none\", type2: \"none\", lineType: $$[$0] };\n          break;\n        case 69:\n          this.$ = yy.relationType.AGGREGATION;\n          break;\n        case 70:\n          this.$ = yy.relationType.EXTENSION;\n          break;\n        case 71:\n          this.$ = yy.relationType.COMPOSITION;\n          break;\n        case 72:\n          this.$ = yy.relationType.DEPENDENCY;\n          break;\n        case 73:\n          this.$ = yy.relationType.LOLLIPOP;\n          break;\n        case 74:\n          this.$ = yy.lineType.LINE;\n          break;\n        case 75:\n          this.$ = yy.lineType.DOTTED_LINE;\n          break;\n        case 76:\n        case 82:\n          this.$ = $$[$0 - 2];\n          yy.setClickEvent($$[$0 - 1], $$[$0]);\n          break;\n        case 77:\n        case 83:\n          this.$ = $$[$0 - 3];\n          yy.setClickEvent($$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 2], $$[$0]);\n          break;\n        case 78:\n          this.$ = $$[$0 - 2];\n          yy.setLink($$[$0 - 1], $$[$0]);\n          break;\n        case 79:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);\n          break;\n        case 80:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 2], $$[$0]);\n          break;\n        case 81:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);\n          yy.setTooltip($$[$0 - 3], $$[$0 - 1]);\n          break;\n        case 84:\n          this.$ = $$[$0 - 3];\n          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);\n          break;\n        case 85:\n          this.$ = $$[$0 - 4];\n          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 3], $$[$0]);\n          break;\n        case 86:\n          this.$ = $$[$0 - 3];\n          yy.setLink($$[$0 - 2], $$[$0]);\n          break;\n        case 87:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 1], $$[$0]);\n          break;\n        case 88:\n          this.$ = $$[$0 - 4];\n          yy.setLink($$[$0 - 3], $$[$0 - 1]);\n          yy.setTooltip($$[$0 - 3], $$[$0]);\n          break;\n        case 89:\n          this.$ = $$[$0 - 5];\n          yy.setLink($$[$0 - 4], $$[$0 - 2], $$[$0]);\n          yy.setTooltip($$[$0 - 4], $$[$0 - 1]);\n          break;\n        case 90:\n          this.$ = $$[$0 - 2];\n          yy.setCssStyle($$[$0 - 1], $$[$0]);\n          break;\n        case 91:\n          yy.setCssClass($$[$0 - 1], $$[$0]);\n          break;\n        case 92:\n          this.$ = [$$[$0]];\n          break;\n        case 93:\n          $$[$0 - 2].push($$[$0]);\n          this.$ = $$[$0 - 2];\n          break;\n        case 95:\n          this.$ = $$[$0 - 1] + $$[$0];\n          break;\n      }\n    }, \"anonymous\"),\n    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: [1, 6], 10: 5, 16: 39, 18: 21, 19: 40, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: $V0, 35: $V1, 37: $V2, 38: 22, 42: $V3, 43: 23, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, o($Vp, [2, 5], { 8: [1, 48] }), { 8: [1, 49] }, o($Vq, [2, 18], { 22: [1, 50] }), o($Vq, [2, 20]), o($Vq, [2, 21]), o($Vq, [2, 22]), o($Vq, [2, 23]), o($Vq, [2, 24]), o($Vq, [2, 25]), o($Vq, [2, 26]), o($Vq, [2, 27]), o($Vq, [2, 28]), o($Vq, [2, 29]), { 34: [1, 51] }, { 36: [1, 52] }, o($Vq, [2, 32]), o($Vq, [2, 48], { 51: 53, 64: 56, 65: 57, 13: [1, 54], 22: [1, 55], 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv, 71: $Vw, 72: $Vx }), { 39: [1, 65] }, o($Vy, [2, 39], { 39: [1, 67], 44: [1, 66] }), o($Vq, [2, 50]), o($Vq, [2, 51]), { 16: 68, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 16: 39, 18: 69, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 16: 39, 18: 70, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 16: 39, 18: 71, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 58: [1, 72] }, { 13: [1, 73] }, { 16: 39, 18: 74, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 13: $Vz, 53: 75 }, { 56: 77, 58: [1, 78] }, o($Vq, [2, 61]), o($Vq, [2, 62]), o($Vq, [2, 63]), o($Vq, [2, 64]), o($VA, [2, 12], { 16: 39, 19: 40, 18: 80, 17: [1, 79], 20: [1, 81], 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }), o($VA, [2, 14], { 20: [1, 82] }), { 15: 83, 16: 84, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 16: 39, 18: 85, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VB, [2, 118]), o($VB, [2, 119]), o($VB, [2, 120]), o($VB, [2, 121]), o([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 66, 67, 68, 69, 70, 71, 72, 77, 79], [2, 122]), o($Vp, [2, 6], { 10: 5, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 18: 21, 38: 22, 43: 23, 16: 39, 19: 40, 5: 86, 33: $V0, 35: $V1, 37: $V2, 42: $V3, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }), { 5: 87, 10: 5, 16: 39, 18: 21, 19: 40, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: $V0, 35: $V1, 37: $V2, 38: 22, 42: $V3, 43: 23, 46: $V4, 47: $V5, 49: $V6, 50: $V7, 52: $V8, 54: $V9, 55: $Va, 58: $Vb, 60: $Vc, 61: $Vd, 62: $Ve, 63: $Vf, 73: $Vg, 74: $Vh, 76: $Vi, 80: $Vj, 81: $Vk, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($Vq, [2, 19]), o($Vq, [2, 30]), o($Vq, [2, 31]), { 13: [1, 89], 16: 39, 18: 88, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 51: 90, 64: 56, 65: 57, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv, 71: $Vw, 72: $Vx }, o($Vq, [2, 49]), { 65: 91, 71: $Vw, 72: $Vx }, o($VC, [2, 68], { 64: 92, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv }), o($VD, [2, 69]), o($VD, [2, 70]), o($VD, [2, 71]), o($VD, [2, 72]), o($VD, [2, 73]), o($VE, [2, 74]), o($VE, [2, 75]), { 8: [1, 94], 24: 95, 40: 93, 43: 23, 46: $V4 }, { 16: 96, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 45: 97, 49: $VF }, { 48: [1, 99] }, { 13: [1, 100] }, { 13: [1, 101] }, { 77: [1, 102], 79: [1, 103] }, { 22: $VG, 57: 104, 58: $VH, 80: $VI, 82: 105, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, { 58: [1, 116] }, { 13: $Vz, 53: 117 }, o($Vq, [2, 57]), o($Vq, [2, 123]), { 22: $VG, 57: 118, 58: $VH, 59: [1, 119], 80: $VI, 82: 105, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, o($VP, [2, 59]), { 16: 39, 18: 120, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VA, [2, 15]), o($VA, [2, 16]), o($VA, [2, 17]), { 39: [2, 35] }, { 15: 122, 16: 84, 17: [1, 121], 39: [2, 9], 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, o($VQ, [2, 43], { 11: 123, 12: [1, 124] }), o($Vp, [2, 7]), { 9: [1, 125] }, o($VR, [2, 52]), { 16: 39, 18: 126, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, { 13: [1, 128], 16: 39, 18: 127, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VC, [2, 67], { 64: 129, 66: $Vr, 67: $Vs, 68: $Vt, 69: $Vu, 70: $Vv }), o($VC, [2, 66]), { 41: [1, 130] }, { 24: 95, 40: 131, 43: 23, 46: $V4 }, { 8: [1, 132], 41: [2, 36] }, o($Vy, [2, 40], { 39: [1, 133] }), { 41: [1, 134] }, { 41: [2, 46], 45: 135, 49: $VF }, { 16: 39, 18: 136, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($Vq, [2, 76], { 13: [1, 137] }), o($Vq, [2, 78], { 13: [1, 139], 75: [1, 138] }), o($Vq, [2, 82], { 13: [1, 140], 78: [1, 141] }), { 13: [1, 142] }, o($Vq, [2, 90], { 59: $VS }), o($VT, [2, 92], { 83: 144, 22: $VG, 58: $VH, 80: $VI, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }), o($VU, [2, 94]), o($VU, [2, 96]), o($VU, [2, 97]), o($VU, [2, 98]), o($VU, [2, 99]), o($VU, [2, 100]), o($VU, [2, 101]), o($VU, [2, 102]), o($VU, [2, 103]), o($VU, [2, 104]), o($Vq, [2, 91]), o($Vq, [2, 56]), o($Vq, [2, 58], { 59: $VS }), { 58: [1, 145] }, o($VA, [2, 13]), { 15: 146, 16: 84, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn }, { 39: [2, 11] }, o($VQ, [2, 44]), { 13: [1, 147] }, { 1: [2, 4] }, o($VR, [2, 54]), o($VR, [2, 53]), { 16: 39, 18: 148, 19: 40, 58: $Vb, 84: $Vl, 99: $Vm, 101: $Vn, 102: $Vo }, o($VC, [2, 65]), o($Vq, [2, 33]), { 41: [1, 149] }, { 24: 95, 40: 150, 41: [2, 37], 43: 23, 46: $V4 }, { 45: 151, 49: $VF }, o($Vy, [2, 41]), { 41: [2, 47] }, o($Vq, [2, 45]), o($Vq, [2, 77]), o($Vq, [2, 79]), o($Vq, [2, 80], { 75: [1, 152] }), o($Vq, [2, 83]), o($Vq, [2, 84], { 13: [1, 153] }), o($Vq, [2, 86], { 13: [1, 155], 75: [1, 154] }), { 22: $VG, 58: $VH, 80: $VI, 82: 156, 83: 106, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }, o($VU, [2, 95]), o($VP, [2, 60]), { 39: [2, 10] }, { 14: [1, 157] }, o($VR, [2, 55]), o($Vq, [2, 34]), { 41: [2, 38] }, { 41: [1, 158] }, o($Vq, [2, 81]), o($Vq, [2, 85]), o($Vq, [2, 87]), o($Vq, [2, 88], { 75: [1, 159] }), o($VT, [2, 93], { 83: 144, 22: $VG, 58: $VH, 80: $VI, 84: $VJ, 85: $VK, 86: $VL, 87: $VM, 88: $VN, 89: $VO }), o($VQ, [2, 8]), o($Vy, [2, 42]), o($Vq, [2, 89])],\n    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 83: [2, 35], 122: [2, 11], 125: [2, 4], 135: [2, 47], 146: [2, 10], 150: [2, 38] },\n    parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    }, \"parseError\"),\n    parse: /* @__PURE__ */ __name(function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n      }\n      __name(popStack, \"popStack\");\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      __name(lex, \"lex\");\n      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n              if (recovering > 0) {\n                recovering--;\n              }\n            } else {\n              symbol = preErrorSymbol;\n              preErrorSymbol = null;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }, \"parse\")\n  };\n  var lexer = /* @__PURE__ */ function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      }, \"parseError\"),\n      // resets the lexer, sets new input\n      setInput: /* @__PURE__ */ __name(function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      }, \"setInput\"),\n      // consumes and returns one char from the input\n      input: /* @__PURE__ */ __name(function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      }, \"input\"),\n      // unshifts one char (or a string) into the input\n      unput: /* @__PURE__ */ __name(function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      }, \"unput\"),\n      // When called from action, caches matched text and appends it on next action\n      more: /* @__PURE__ */ __name(function() {\n        this._more = true;\n        return this;\n      }, \"more\"),\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: /* @__PURE__ */ __name(function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      }, \"reject\"),\n      // retain first n characters of the match\n      less: /* @__PURE__ */ __name(function(n) {\n        this.unput(this.match.slice(n));\n      }, \"less\"),\n      // displays already matched input, i.e. for error messages\n      pastInput: /* @__PURE__ */ __name(function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      }, \"pastInput\"),\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: /* @__PURE__ */ __name(function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      }, \"upcomingInput\"),\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: /* @__PURE__ */ __name(function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      }, \"showPosition\"),\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      }, \"test_match\"),\n      // return next match in input\n      next: /* @__PURE__ */ __name(function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      }, \"next\"),\n      // return next match that has a token\n      lex: /* @__PURE__ */ __name(function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      }, \"lex\"),\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: /* @__PURE__ */ __name(function begin(condition) {\n        this.conditionStack.push(condition);\n      }, \"begin\"),\n      // pop the previously active lexer condition state off the condition stack\n      popState: /* @__PURE__ */ __name(function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      }, \"popState\"),\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: /* @__PURE__ */ __name(function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      }, \"_currentRules\"),\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: /* @__PURE__ */ __name(function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      }, \"topState\"),\n      // alias for begin(condition)\n      pushState: /* @__PURE__ */ __name(function pushState(condition) {\n        this.begin(condition);\n      }, \"pushState\"),\n      // return the number of states currently on the stack\n      stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {\n        return this.conditionStack.length;\n      }, \"stateStackSize\"),\n      options: {},\n      performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        var YYSTATE = YY_START;\n        switch ($avoiding_name_collisions) {\n          case 0:\n            return 60;\n            break;\n          case 1:\n            return 61;\n            break;\n          case 2:\n            return 62;\n            break;\n          case 3:\n            return 63;\n            break;\n          case 4:\n            break;\n          case 5:\n            break;\n          case 6:\n            this.begin(\"acc_title\");\n            return 33;\n            break;\n          case 7:\n            this.popState();\n            return \"acc_title_value\";\n            break;\n          case 8:\n            this.begin(\"acc_descr\");\n            return 35;\n            break;\n          case 9:\n            this.popState();\n            return \"acc_descr_value\";\n            break;\n          case 10:\n            this.begin(\"acc_descr_multiline\");\n            break;\n          case 11:\n            this.popState();\n            break;\n          case 12:\n            return \"acc_descr_multiline_value\";\n            break;\n          case 13:\n            return 8;\n            break;\n          case 14:\n            break;\n          case 15:\n            return 7;\n            break;\n          case 16:\n            return 7;\n            break;\n          case 17:\n            return \"EDGE_STATE\";\n            break;\n          case 18:\n            this.begin(\"callback_name\");\n            break;\n          case 19:\n            this.popState();\n            break;\n          case 20:\n            this.popState();\n            this.begin(\"callback_args\");\n            break;\n          case 21:\n            return 77;\n            break;\n          case 22:\n            this.popState();\n            break;\n          case 23:\n            return 78;\n            break;\n          case 24:\n            this.popState();\n            break;\n          case 25:\n            return \"STR\";\n            break;\n          case 26:\n            this.begin(\"string\");\n            break;\n          case 27:\n            return 80;\n            break;\n          case 28:\n            return 55;\n            break;\n          case 29:\n            this.begin(\"namespace\");\n            return 42;\n            break;\n          case 30:\n            this.popState();\n            return 8;\n            break;\n          case 31:\n            break;\n          case 32:\n            this.begin(\"namespace-body\");\n            return 39;\n            break;\n          case 33:\n            this.popState();\n            return 41;\n            break;\n          case 34:\n            return \"EOF_IN_STRUCT\";\n            break;\n          case 35:\n            return 8;\n            break;\n          case 36:\n            break;\n          case 37:\n            return \"EDGE_STATE\";\n            break;\n          case 38:\n            this.begin(\"class\");\n            return 46;\n            break;\n          case 39:\n            this.popState();\n            return 8;\n            break;\n          case 40:\n            break;\n          case 41:\n            this.popState();\n            this.popState();\n            return 41;\n            break;\n          case 42:\n            this.begin(\"class-body\");\n            return 39;\n            break;\n          case 43:\n            this.popState();\n            return 41;\n            break;\n          case 44:\n            return \"EOF_IN_STRUCT\";\n            break;\n          case 45:\n            return \"EDGE_STATE\";\n            break;\n          case 46:\n            return \"OPEN_IN_STRUCT\";\n            break;\n          case 47:\n            break;\n          case 48:\n            return \"MEMBER\";\n            break;\n          case 49:\n            return 81;\n            break;\n          case 50:\n            return 73;\n            break;\n          case 51:\n            return 74;\n            break;\n          case 52:\n            return 76;\n            break;\n          case 53:\n            return 52;\n            break;\n          case 54:\n            return 54;\n            break;\n          case 55:\n            return 47;\n            break;\n          case 56:\n            return 48;\n            break;\n          case 57:\n            return 79;\n            break;\n          case 58:\n            this.popState();\n            break;\n          case 59:\n            return \"GENERICTYPE\";\n            break;\n          case 60:\n            this.begin(\"generic\");\n            break;\n          case 61:\n            this.popState();\n            break;\n          case 62:\n            return \"BQUOTE_STR\";\n            break;\n          case 63:\n            this.begin(\"bqstring\");\n            break;\n          case 64:\n            return 75;\n            break;\n          case 65:\n            return 75;\n            break;\n          case 66:\n            return 75;\n            break;\n          case 67:\n            return 75;\n            break;\n          case 68:\n            return 67;\n            break;\n          case 69:\n            return 67;\n            break;\n          case 70:\n            return 69;\n            break;\n          case 71:\n            return 69;\n            break;\n          case 72:\n            return 68;\n            break;\n          case 73:\n            return 66;\n            break;\n          case 74:\n            return 70;\n            break;\n          case 75:\n            return 71;\n            break;\n          case 76:\n            return 72;\n            break;\n          case 77:\n            return 22;\n            break;\n          case 78:\n            return 44;\n            break;\n          case 79:\n            return 99;\n            break;\n          case 80:\n            return 17;\n            break;\n          case 81:\n            return \"PLUS\";\n            break;\n          case 82:\n            return 85;\n            break;\n          case 83:\n            return 59;\n            break;\n          case 84:\n            return 88;\n            break;\n          case 85:\n            return 88;\n            break;\n          case 86:\n            return 89;\n            break;\n          case 87:\n            return \"EQUALS\";\n            break;\n          case 88:\n            return \"EQUALS\";\n            break;\n          case 89:\n            return 58;\n            break;\n          case 90:\n            return 12;\n            break;\n          case 91:\n            return 14;\n            break;\n          case 92:\n            return \"PUNCTUATION\";\n            break;\n          case 93:\n            return 84;\n            break;\n          case 94:\n            return 101;\n            break;\n          case 95:\n            return 87;\n            break;\n          case 96:\n            return 87;\n            break;\n          case 97:\n            return 9;\n            break;\n        }\n      }, \"anonymous\"),\n      rules: [/^(?:.*direction\\s+TB[^\\n]*)/, /^(?:.*direction\\s+BT[^\\n]*)/, /^(?:.*direction\\s+RL[^\\n]*)/, /^(?:.*direction\\s+LR[^\\n]*)/, /^(?:%%(?!\\{)*[^\\n]*(\\r?\\n?)+)/, /^(?:%%[^\\n]*(\\r?\\n)*)/, /^(?:accTitle\\s*:\\s*)/, /^(?:(?!\\n||)*[^\\n]*)/, /^(?:accDescr\\s*:\\s*)/, /^(?:(?!\\n||)*[^\\n]*)/, /^(?:accDescr\\s*\\{\\s*)/, /^(?:[\\}])/, /^(?:[^\\}]*)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:classDiagram-v2\\b)/, /^(?:classDiagram\\b)/, /^(?:\\[\\*\\])/, /^(?:call[\\s]+)/, /^(?:\\([\\s]*\\))/, /^(?:\\()/, /^(?:[^(]*)/, /^(?:\\))/, /^(?:[^)]*)/, /^(?:[\"])/, /^(?:[^\"]*)/, /^(?:[\"])/, /^(?:style\\b)/, /^(?:classDef\\b)/, /^(?:namespace\\b)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:\\[\\*\\])/, /^(?:class\\b)/, /^(?:\\s*(\\r?\\n)+)/, /^(?:\\s+)/, /^(?:[}])/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\\[\\*\\])/, /^(?:[{])/, /^(?:[\\n])/, /^(?:[^{}\\n]*)/, /^(?:cssClass\\b)/, /^(?:callback\\b)/, /^(?:link\\b)/, /^(?:click\\b)/, /^(?:note for\\b)/, /^(?:note\\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:href\\b)/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:~)/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:[`])/, /^(?:_self\\b)/, /^(?:_blank\\b)/, /^(?:_parent\\b)/, /^(?:_top\\b)/, /^(?:\\s*<\\|)/, /^(?:\\s*\\|>)/, /^(?:\\s*>)/, /^(?:\\s*<)/, /^(?:\\s*\\*)/, /^(?:\\s*o\\b)/, /^(?:\\s*\\(\\))/, /^(?:--)/, /^(?:\\.\\.)/, /^(?::{1}[^:\\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\\.)/, /^(?:\\+)/, /^(?::)/, /^(?:,)/, /^(?:#)/, /^(?:#)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\\w+)/, /^(?:\\[)/, /^(?:\\])/, /^(?:[!\"#$%&'*+,-.`?\\\\/])/, /^(?:[0-9]+)/, /^(?:[\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6]|[\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377]|[\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5]|[\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA]|[\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE]|[\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA]|[\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0]|[\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977]|[\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2]|[\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A]|[\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39]|[\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8]|[\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C]|[\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C]|[\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99]|[\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0]|[\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D]|[\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3]|[\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10]|[\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1]|[\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81]|[\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3]|[\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6]|[\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A]|[\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081]|[\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D]|[\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0]|[\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310]|[\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C]|[\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711]|[\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7]|[\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C]|[\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16]|[\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF]|[\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC]|[\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D]|[\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D]|[\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3]|[\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F]|[\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128]|[\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184]|[\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3]|[\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6]|[\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE]|[\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C]|[\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D]|[\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC]|[\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B]|[\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788]|[\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805]|[\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB]|[\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28]|[\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5]|[\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4]|[\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E]|[\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D]|[\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36]|[\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D]|[\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC]|[\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF]|[\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC])/, /^(?:\\s)/, /^(?:\\s)/, /^(?:$)/],\n      conditions: { \"namespace-body\": { \"rules\": [26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"namespace\": { \"rules\": [26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"class-body\": { \"rules\": [26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"class\": { \"rules\": [26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_descr_multiline\": { \"rules\": [11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_descr\": { \"rules\": [9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"acc_title\": { \"rules\": [7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"callback_args\": { \"rules\": [22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"callback_name\": { \"rules\": [19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"href\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"struct\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"generic\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"bqstring\": { \"rules\": [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"string\": { \"rules\": [24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  __name(Parser, \"Parser\");\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nvar classDiagram_default = parser;\n\n// src/diagrams/class/classDb.ts\nimport { select } from \"d3\";\n\n// src/diagrams/class/classTypes.ts\nvar visibilityValues = [\"#\", \"+\", \"~\", \"-\", \"\"];\nvar ClassMember = class {\n  static {\n    __name(this, \"ClassMember\");\n  }\n  constructor(input, memberType) {\n    this.memberType = memberType;\n    this.visibility = \"\";\n    this.classifier = \"\";\n    this.text = \"\";\n    const sanitizedInput = sanitizeText(input, getConfig());\n    this.parseMember(sanitizedInput);\n  }\n  getDisplayDetails() {\n    let displayText = this.visibility + parseGenericTypes(this.id);\n    if (this.memberType === \"method\") {\n      displayText += `(${parseGenericTypes(this.parameters.trim())})`;\n      if (this.returnType) {\n        displayText += \" : \" + parseGenericTypes(this.returnType);\n      }\n    }\n    displayText = displayText.trim();\n    const cssStyle = this.parseClassifier();\n    return {\n      displayText,\n      cssStyle\n    };\n  }\n  parseMember(input) {\n    let potentialClassifier = \"\";\n    if (this.memberType === \"method\") {\n      const methodRegEx = /([#+~-])?(.+)\\((.*)\\)([\\s$*])?(.*)([$*])?/;\n      const match = methodRegEx.exec(input);\n      if (match) {\n        const detectedVisibility = match[1] ? match[1].trim() : \"\";\n        if (visibilityValues.includes(detectedVisibility)) {\n          this.visibility = detectedVisibility;\n        }\n        this.id = match[2];\n        this.parameters = match[3] ? match[3].trim() : \"\";\n        potentialClassifier = match[4] ? match[4].trim() : \"\";\n        this.returnType = match[5] ? match[5].trim() : \"\";\n        if (potentialClassifier === \"\") {\n          const lastChar = this.returnType.substring(this.returnType.length - 1);\n          if (/[$*]/.exec(lastChar)) {\n            potentialClassifier = lastChar;\n            this.returnType = this.returnType.substring(0, this.returnType.length - 1);\n          }\n        }\n      }\n    } else {\n      const length = input.length;\n      const firstChar = input.substring(0, 1);\n      const lastChar = input.substring(length - 1);\n      if (visibilityValues.includes(firstChar)) {\n        this.visibility = firstChar;\n      }\n      if (/[$*]/.exec(lastChar)) {\n        potentialClassifier = lastChar;\n      }\n      this.id = input.substring(\n        this.visibility === \"\" ? 0 : 1,\n        potentialClassifier === \"\" ? length : length - 1\n      );\n    }\n    this.classifier = potentialClassifier;\n    this.id = this.id.startsWith(\" \") ? \" \" + this.id.trim() : this.id.trim();\n    const combinedText = `${this.visibility ? \"\\\\\" + this.visibility : \"\"}${parseGenericTypes(this.id)}${this.memberType === \"method\" ? `(${parseGenericTypes(this.parameters)})${this.returnType ? \" : \" + parseGenericTypes(this.returnType) : \"\"}` : \"\"}`;\n    this.text = combinedText.replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\n    if (this.text.startsWith(\"\\\\&lt;\")) {\n      this.text = this.text.replace(\"\\\\&lt;\", \"~\");\n    }\n  }\n  parseClassifier() {\n    switch (this.classifier) {\n      case \"*\":\n        return \"font-style:italic;\";\n      case \"$\":\n        return \"text-decoration:underline;\";\n      default:\n        return \"\";\n    }\n  }\n};\n\n// src/diagrams/class/classDb.ts\nvar MERMAID_DOM_ID_PREFIX = \"classId-\";\nvar classCounter = 0;\nvar sanitizeText2 = /* @__PURE__ */ __name((txt) => common_default.sanitizeText(txt, getConfig()), \"sanitizeText\");\nvar ClassDB = class {\n  constructor() {\n    this.relations = [];\n    this.classes = /* @__PURE__ */ new Map();\n    this.styleClasses = /* @__PURE__ */ new Map();\n    this.notes = [];\n    this.interfaces = [];\n    // private static classCounter = 0;\n    this.namespaces = /* @__PURE__ */ new Map();\n    this.namespaceCounter = 0;\n    this.functions = [];\n    this.lineType = {\n      LINE: 0,\n      DOTTED_LINE: 1\n    };\n    this.relationType = {\n      AGGREGATION: 0,\n      EXTENSION: 1,\n      COMPOSITION: 2,\n      DEPENDENCY: 3,\n      LOLLIPOP: 4\n    };\n    this.setupToolTips = /* @__PURE__ */ __name((element) => {\n      let tooltipElem = select(\".mermaidTooltip\");\n      if ((tooltipElem._groups || tooltipElem)[0][0] === null) {\n        tooltipElem = select(\"body\").append(\"div\").attr(\"class\", \"mermaidTooltip\").style(\"opacity\", 0);\n      }\n      const svg = select(element).select(\"svg\");\n      const nodes = svg.selectAll(\"g.node\");\n      nodes.on(\"mouseover\", (event) => {\n        const el = select(event.currentTarget);\n        const title = el.attr(\"title\");\n        if (title === null) {\n          return;\n        }\n        const rect = this.getBoundingClientRect();\n        tooltipElem.transition().duration(200).style(\"opacity\", \".9\");\n        tooltipElem.text(el.attr(\"title\")).style(\"left\", window.scrollX + rect.left + (rect.right - rect.left) / 2 + \"px\").style(\"top\", window.scrollY + rect.top - 14 + document.body.scrollTop + \"px\");\n        tooltipElem.html(tooltipElem.html().replace(/&lt;br\\/&gt;/g, \"<br/>\"));\n        el.classed(\"hover\", true);\n      }).on(\"mouseout\", (event) => {\n        tooltipElem.transition().duration(500).style(\"opacity\", 0);\n        const el = select(event.currentTarget);\n        el.classed(\"hover\", false);\n      });\n    }, \"setupToolTips\");\n    this.direction = \"TB\";\n    this.setAccTitle = setAccTitle;\n    this.getAccTitle = getAccTitle;\n    this.setAccDescription = setAccDescription;\n    this.getAccDescription = getAccDescription;\n    this.setDiagramTitle = setDiagramTitle;\n    this.getDiagramTitle = getDiagramTitle;\n    this.getConfig = /* @__PURE__ */ __name(() => getConfig().class, \"getConfig\");\n    this.functions.push(this.setupToolTips.bind(this));\n    this.clear();\n    this.addRelation = this.addRelation.bind(this);\n    this.addClassesToNamespace = this.addClassesToNamespace.bind(this);\n    this.addNamespace = this.addNamespace.bind(this);\n    this.setCssClass = this.setCssClass.bind(this);\n    this.addMembers = this.addMembers.bind(this);\n    this.addClass = this.addClass.bind(this);\n    this.setClassLabel = this.setClassLabel.bind(this);\n    this.addAnnotation = this.addAnnotation.bind(this);\n    this.addMember = this.addMember.bind(this);\n    this.cleanupLabel = this.cleanupLabel.bind(this);\n    this.addNote = this.addNote.bind(this);\n    this.defineClass = this.defineClass.bind(this);\n    this.setDirection = this.setDirection.bind(this);\n    this.setLink = this.setLink.bind(this);\n    this.bindFunctions = this.bindFunctions.bind(this);\n    this.clear = this.clear.bind(this);\n    this.setTooltip = this.setTooltip.bind(this);\n    this.setClickEvent = this.setClickEvent.bind(this);\n    this.setCssStyle = this.setCssStyle.bind(this);\n  }\n  static {\n    __name(this, \"ClassDB\");\n  }\n  splitClassNameAndType(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    let genericType = \"\";\n    let className = id;\n    if (id.indexOf(\"~\") > 0) {\n      const split = id.split(\"~\");\n      className = sanitizeText2(split[0]);\n      genericType = sanitizeText2(split[1]);\n    }\n    return { className, type: genericType };\n  }\n  setClassLabel(_id, label) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    if (label) {\n      label = sanitizeText2(label);\n    }\n    const { className } = this.splitClassNameAndType(id);\n    this.classes.get(className).label = label;\n    this.classes.get(className).text = `${label}${this.classes.get(className).type ? `<${this.classes.get(className).type}>` : \"\"}`;\n  }\n  /**\n   * Function called by parser when a node definition has been found.\n   *\n   * @param id - Id of the class to add\n   * @public\n   */\n  addClass(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    const { className, type } = this.splitClassNameAndType(id);\n    if (this.classes.has(className)) {\n      return;\n    }\n    const name = common_default.sanitizeText(className, getConfig());\n    this.classes.set(name, {\n      id: name,\n      type,\n      label: name,\n      text: `${name}${type ? `&lt;${type}&gt;` : \"\"}`,\n      shape: \"classBox\",\n      cssClasses: \"default\",\n      methods: [],\n      members: [],\n      annotations: [],\n      styles: [],\n      domId: MERMAID_DOM_ID_PREFIX + name + \"-\" + classCounter\n    });\n    classCounter++;\n  }\n  addInterface(label, classId) {\n    const classInterface = {\n      id: `interface${this.interfaces.length}`,\n      label,\n      classId\n    };\n    this.interfaces.push(classInterface);\n  }\n  /**\n   * Function to lookup domId from id in the graph definition.\n   *\n   * @param id - class ID to lookup\n   * @public\n   */\n  lookUpDomId(_id) {\n    const id = common_default.sanitizeText(_id, getConfig());\n    if (this.classes.has(id)) {\n      return this.classes.get(id).domId;\n    }\n    throw new Error(\"Class not found: \" + id);\n  }\n  clear() {\n    this.relations = [];\n    this.classes = /* @__PURE__ */ new Map();\n    this.notes = [];\n    this.interfaces = [];\n    this.functions = [];\n    this.functions.push(this.setupToolTips.bind(this));\n    this.namespaces = /* @__PURE__ */ new Map();\n    this.namespaceCounter = 0;\n    this.direction = \"TB\";\n    clear();\n  }\n  getClass(id) {\n    return this.classes.get(id);\n  }\n  getClasses() {\n    return this.classes;\n  }\n  getRelations() {\n    return this.relations;\n  }\n  getNotes() {\n    return this.notes;\n  }\n  addRelation(classRelation) {\n    log.debug(\"Adding relation: \" + JSON.stringify(classRelation));\n    const invalidTypes = [\n      this.relationType.LOLLIPOP,\n      this.relationType.AGGREGATION,\n      this.relationType.COMPOSITION,\n      this.relationType.DEPENDENCY,\n      this.relationType.EXTENSION\n    ];\n    if (classRelation.relation.type1 === this.relationType.LOLLIPOP && !invalidTypes.includes(classRelation.relation.type2)) {\n      this.addClass(classRelation.id2);\n      this.addInterface(classRelation.id1, classRelation.id2);\n      classRelation.id1 = `interface${this.interfaces.length - 1}`;\n    } else if (classRelation.relation.type2 === this.relationType.LOLLIPOP && !invalidTypes.includes(classRelation.relation.type1)) {\n      this.addClass(classRelation.id1);\n      this.addInterface(classRelation.id2, classRelation.id1);\n      classRelation.id2 = `interface${this.interfaces.length - 1}`;\n    } else {\n      this.addClass(classRelation.id1);\n      this.addClass(classRelation.id2);\n    }\n    classRelation.id1 = this.splitClassNameAndType(classRelation.id1).className;\n    classRelation.id2 = this.splitClassNameAndType(classRelation.id2).className;\n    classRelation.relationTitle1 = common_default.sanitizeText(\n      classRelation.relationTitle1.trim(),\n      getConfig()\n    );\n    classRelation.relationTitle2 = common_default.sanitizeText(\n      classRelation.relationTitle2.trim(),\n      getConfig()\n    );\n    this.relations.push(classRelation);\n  }\n  /**\n   * Adds an annotation to the specified class Annotations mark special properties of the given type\n   * (like 'interface' or 'service')\n   *\n   * @param className - The class name\n   * @param annotation - The name of the annotation without any brackets\n   * @public\n   */\n  addAnnotation(className, annotation) {\n    const validatedClassName = this.splitClassNameAndType(className).className;\n    this.classes.get(validatedClassName).annotations.push(annotation);\n  }\n  /**\n   * Adds a member to the specified class\n   *\n   * @param className - The class name\n   * @param member - The full name of the member. If the member is enclosed in `<<brackets>>` it is\n   *   treated as an annotation If the member is ending with a closing bracket ) it is treated as a\n   *   method Otherwise the member will be treated as a normal property\n   * @public\n   */\n  addMember(className, member) {\n    this.addClass(className);\n    const validatedClassName = this.splitClassNameAndType(className).className;\n    const theClass = this.classes.get(validatedClassName);\n    if (typeof member === \"string\") {\n      const memberString = member.trim();\n      if (memberString.startsWith(\"<<\") && memberString.endsWith(\">>\")) {\n        theClass.annotations.push(sanitizeText2(memberString.substring(2, memberString.length - 2)));\n      } else if (memberString.indexOf(\")\") > 0) {\n        theClass.methods.push(new ClassMember(memberString, \"method\"));\n      } else if (memberString) {\n        theClass.members.push(new ClassMember(memberString, \"attribute\"));\n      }\n    }\n  }\n  addMembers(className, members) {\n    if (Array.isArray(members)) {\n      members.reverse();\n      members.forEach((member) => this.addMember(className, member));\n    }\n  }\n  addNote(text, className) {\n    const note = {\n      id: `note${this.notes.length}`,\n      class: className,\n      text\n    };\n    this.notes.push(note);\n  }\n  cleanupLabel(label) {\n    if (label.startsWith(\":\")) {\n      label = label.substring(1);\n    }\n    return sanitizeText2(label.trim());\n  }\n  /**\n   * Called by parser when assigning cssClass to a class\n   *\n   * @param ids - Comma separated list of ids\n   * @param className - Class to add\n   */\n  setCssClass(ids, className) {\n    ids.split(\",\").forEach((_id) => {\n      let id = _id;\n      if (/\\d/.exec(_id[0])) {\n        id = MERMAID_DOM_ID_PREFIX + id;\n      }\n      const classNode = this.classes.get(id);\n      if (classNode) {\n        classNode.cssClasses += \" \" + className;\n      }\n    });\n  }\n  defineClass(ids, style) {\n    for (const id of ids) {\n      let styleClass = this.styleClasses.get(id);\n      if (styleClass === void 0) {\n        styleClass = { id, styles: [], textStyles: [] };\n        this.styleClasses.set(id, styleClass);\n      }\n      if (style) {\n        style.forEach((s) => {\n          if (/color/.exec(s)) {\n            const newStyle = s.replace(\"fill\", \"bgFill\");\n            styleClass.textStyles.push(newStyle);\n          }\n          styleClass.styles.push(s);\n        });\n      }\n      this.classes.forEach((value) => {\n        if (value.cssClasses.includes(id)) {\n          value.styles.push(...style.flatMap((s) => s.split(\",\")));\n        }\n      });\n    }\n  }\n  /**\n   * Called by parser when a tooltip is found, e.g. a clickable element.\n   *\n   * @param ids - Comma separated list of ids\n   * @param tooltip - Tooltip to add\n   */\n  setTooltip(ids, tooltip) {\n    ids.split(\",\").forEach((id) => {\n      if (tooltip !== void 0) {\n        this.classes.get(id).tooltip = sanitizeText2(tooltip);\n      }\n    });\n  }\n  getTooltip(id, namespace) {\n    if (namespace && this.namespaces.has(namespace)) {\n      return this.namespaces.get(namespace).classes.get(id).tooltip;\n    }\n    return this.classes.get(id).tooltip;\n  }\n  /**\n   * Called by parser when a link is found. Adds the URL to the vertex data.\n   *\n   * @param ids - Comma separated list of ids\n   * @param linkStr - URL to create a link for\n   * @param target - Target of the link, _blank by default as originally defined in the svgDraw.js file\n   */\n  setLink(ids, linkStr, target) {\n    const config = getConfig();\n    ids.split(\",\").forEach((_id) => {\n      let id = _id;\n      if (/\\d/.exec(_id[0])) {\n        id = MERMAID_DOM_ID_PREFIX + id;\n      }\n      const theClass = this.classes.get(id);\n      if (theClass) {\n        theClass.link = utils_default.formatUrl(linkStr, config);\n        if (config.securityLevel === \"sandbox\") {\n          theClass.linkTarget = \"_top\";\n        } else if (typeof target === \"string\") {\n          theClass.linkTarget = sanitizeText2(target);\n        } else {\n          theClass.linkTarget = \"_blank\";\n        }\n      }\n    });\n    this.setCssClass(ids, \"clickable\");\n  }\n  /**\n   * Called by parser when a click definition is found. Registers an event handler.\n   *\n   * @param ids - Comma separated list of ids\n   * @param functionName - Function to be called on click\n   * @param functionArgs - Function args the function should be called with\n   */\n  setClickEvent(ids, functionName, functionArgs) {\n    ids.split(\",\").forEach((id) => {\n      this.setClickFunc(id, functionName, functionArgs);\n      this.classes.get(id).haveCallback = true;\n    });\n    this.setCssClass(ids, \"clickable\");\n  }\n  setClickFunc(_domId, functionName, functionArgs) {\n    const domId = common_default.sanitizeText(_domId, getConfig());\n    const config = getConfig();\n    if (config.securityLevel !== \"loose\") {\n      return;\n    }\n    if (functionName === void 0) {\n      return;\n    }\n    const id = domId;\n    if (this.classes.has(id)) {\n      const elemId = this.lookUpDomId(id);\n      let argList = [];\n      if (typeof functionArgs === \"string\") {\n        argList = functionArgs.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/);\n        for (let i = 0; i < argList.length; i++) {\n          let item = argList[i].trim();\n          if (item.startsWith('\"') && item.endsWith('\"')) {\n            item = item.substr(1, item.length - 2);\n          }\n          argList[i] = item;\n        }\n      }\n      if (argList.length === 0) {\n        argList.push(elemId);\n      }\n      this.functions.push(() => {\n        const elem = document.querySelector(`[id=\"${elemId}\"]`);\n        if (elem !== null) {\n          elem.addEventListener(\n            \"click\",\n            () => {\n              utils_default.runFunc(functionName, ...argList);\n            },\n            false\n          );\n        }\n      });\n    }\n  }\n  bindFunctions(element) {\n    this.functions.forEach((fun) => {\n      fun(element);\n    });\n  }\n  getDirection() {\n    return this.direction;\n  }\n  setDirection(dir) {\n    this.direction = dir;\n  }\n  /**\n   * Function called by parser when a namespace definition has been found.\n   *\n   * @param id - Id of the namespace to add\n   * @public\n   */\n  addNamespace(id) {\n    if (this.namespaces.has(id)) {\n      return;\n    }\n    this.namespaces.set(id, {\n      id,\n      classes: /* @__PURE__ */ new Map(),\n      children: {},\n      domId: MERMAID_DOM_ID_PREFIX + id + \"-\" + this.namespaceCounter\n    });\n    this.namespaceCounter++;\n  }\n  getNamespace(name) {\n    return this.namespaces.get(name);\n  }\n  getNamespaces() {\n    return this.namespaces;\n  }\n  /**\n   * Function called by parser when a namespace definition has been found.\n   *\n   * @param id - Id of the namespace to add\n   * @param classNames - Ids of the class to add\n   * @public\n   */\n  addClassesToNamespace(id, classNames) {\n    if (!this.namespaces.has(id)) {\n      return;\n    }\n    for (const name of classNames) {\n      const { className } = this.splitClassNameAndType(name);\n      this.classes.get(className).parent = id;\n      this.namespaces.get(id).classes.set(className, this.classes.get(className));\n    }\n  }\n  setCssStyle(id, styles) {\n    const thisClass = this.classes.get(id);\n    if (!styles || !thisClass) {\n      return;\n    }\n    for (const s of styles) {\n      if (s.includes(\",\")) {\n        thisClass.styles.push(...s.split(\",\"));\n      } else {\n        thisClass.styles.push(s);\n      }\n    }\n  }\n  /**\n   * Gets the arrow marker for a type index\n   *\n   * @param type - The type to look for\n   * @returns The arrow marker\n   */\n  getArrowMarker(type) {\n    let marker;\n    switch (type) {\n      case 0:\n        marker = \"aggregation\";\n        break;\n      case 1:\n        marker = \"extension\";\n        break;\n      case 2:\n        marker = \"composition\";\n        break;\n      case 3:\n        marker = \"dependency\";\n        break;\n      case 4:\n        marker = \"lollipop\";\n        break;\n      default:\n        marker = \"none\";\n    }\n    return marker;\n  }\n  getData() {\n    const nodes = [];\n    const edges = [];\n    const config = getConfig();\n    for (const namespaceKey of this.namespaces.keys()) {\n      const namespace = this.namespaces.get(namespaceKey);\n      if (namespace) {\n        const node = {\n          id: namespace.id,\n          label: namespace.id,\n          isGroup: true,\n          padding: config.class.padding ?? 16,\n          // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]\n          shape: \"rect\",\n          cssStyles: [\"fill: none\", \"stroke: black\"],\n          look: config.look\n        };\n        nodes.push(node);\n      }\n    }\n    for (const classKey of this.classes.keys()) {\n      const classNode = this.classes.get(classKey);\n      if (classNode) {\n        const node = classNode;\n        node.parentId = classNode.parent;\n        node.look = config.look;\n        nodes.push(node);\n      }\n    }\n    let cnt = 0;\n    for (const note of this.notes) {\n      cnt++;\n      const noteNode = {\n        id: note.id,\n        label: note.text,\n        isGroup: false,\n        shape: \"note\",\n        padding: config.class.padding ?? 6,\n        cssStyles: [\n          \"text-align: left\",\n          \"white-space: nowrap\",\n          `fill: ${config.themeVariables.noteBkgColor}`,\n          `stroke: ${config.themeVariables.noteBorderColor}`\n        ],\n        look: config.look\n      };\n      nodes.push(noteNode);\n      const noteClassId = this.classes.get(note.class)?.id ?? \"\";\n      if (noteClassId) {\n        const edge = {\n          id: `edgeNote${cnt}`,\n          start: note.id,\n          end: noteClassId,\n          type: \"normal\",\n          thickness: \"normal\",\n          classes: \"relation\",\n          arrowTypeStart: \"none\",\n          arrowTypeEnd: \"none\",\n          arrowheadStyle: \"\",\n          labelStyle: [\"\"],\n          style: [\"fill: none\"],\n          pattern: \"dotted\",\n          look: config.look\n        };\n        edges.push(edge);\n      }\n    }\n    for (const _interface of this.interfaces) {\n      const interfaceNode = {\n        id: _interface.id,\n        label: _interface.label,\n        isGroup: false,\n        shape: \"rect\",\n        cssStyles: [\"opacity: 0;\"],\n        look: config.look\n      };\n      nodes.push(interfaceNode);\n    }\n    cnt = 0;\n    for (const classRelation of this.relations) {\n      cnt++;\n      const edge = {\n        id: getEdgeId(classRelation.id1, classRelation.id2, {\n          prefix: \"id\",\n          counter: cnt\n        }),\n        start: classRelation.id1,\n        end: classRelation.id2,\n        type: \"normal\",\n        label: classRelation.title,\n        labelpos: \"c\",\n        thickness: \"normal\",\n        classes: \"relation\",\n        arrowTypeStart: this.getArrowMarker(classRelation.relation.type1),\n        arrowTypeEnd: this.getArrowMarker(classRelation.relation.type2),\n        startLabelRight: classRelation.relationTitle1 === \"none\" ? \"\" : classRelation.relationTitle1,\n        endLabelLeft: classRelation.relationTitle2 === \"none\" ? \"\" : classRelation.relationTitle2,\n        arrowheadStyle: \"\",\n        labelStyle: [\"display: inline-block\"],\n        style: classRelation.style || \"\",\n        pattern: classRelation.relation.lineType == 1 ? \"dashed\" : \"solid\",\n        look: config.look\n      };\n      edges.push(edge);\n    }\n    return { nodes, edges, other: {}, config, direction: this.getDirection() };\n  }\n};\n\n// src/diagrams/class/styles.js\nvar getStyles = /* @__PURE__ */ __name((options) => `g.classGroup text {\n  fill: ${options.nodeBorder || options.classText};\n  stroke: none;\n  font-family: ${options.fontFamily};\n  font-size: 10px;\n\n  .title {\n    font-weight: bolder;\n  }\n\n}\n\n.nodeLabel, .edgeLabel {\n  color: ${options.classText};\n}\n.edgeLabel .label rect {\n  fill: ${options.mainBkg};\n}\n.label text {\n  fill: ${options.classText};\n}\n\n.labelBkg {\n  background: ${options.mainBkg};\n}\n.edgeLabel .label span {\n  background: ${options.mainBkg};\n}\n\n.classTitle {\n  font-weight: bolder;\n}\n.node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n\n.divider {\n  stroke: ${options.nodeBorder};\n  stroke-width: 1;\n}\n\ng.clickable {\n  cursor: pointer;\n}\n\ng.classGroup rect {\n  fill: ${options.mainBkg};\n  stroke: ${options.nodeBorder};\n}\n\ng.classGroup line {\n  stroke: ${options.nodeBorder};\n  stroke-width: 1;\n}\n\n.classLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ${options.mainBkg};\n  opacity: 0.5;\n}\n\n.classLabel .label {\n  fill: ${options.nodeBorder};\n  font-size: 10px;\n}\n\n.relation {\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n  fill: none;\n}\n\n.dashed-line{\n  stroke-dasharray: 3;\n}\n\n.dotted-line{\n  stroke-dasharray: 1 2;\n}\n\n#compositionStart, .composition {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#compositionEnd, .composition {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ${options.lineColor} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#extensionStart, .extension {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#extensionEnd, .extension {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#aggregationStart, .aggregation {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#aggregationEnd, .aggregation {\n  fill: transparent !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#lollipopStart, .lollipop {\n  fill: ${options.mainBkg} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n#lollipopEnd, .lollipop {\n  fill: ${options.mainBkg} !important;\n  stroke: ${options.lineColor} !important;\n  stroke-width: 1;\n}\n\n.edgeTerminals {\n  font-size: 11px;\n  line-height: initial;\n}\n\n.classTitleText {\n  text-anchor: middle;\n  font-size: 18px;\n  fill: ${options.textColor};\n}\n`, \"getStyles\");\nvar styles_default = getStyles;\n\n// src/diagrams/class/classRenderer-v3-unified.ts\nvar getDir = /* @__PURE__ */ __name((parsedItem, defaultDir = \"TB\") => {\n  if (!parsedItem.doc) {\n    return defaultDir;\n  }\n  let dir = defaultDir;\n  for (const parsedItemDoc of parsedItem.doc) {\n    if (parsedItemDoc.stmt === \"dir\") {\n      dir = parsedItemDoc.value;\n    }\n  }\n  return dir;\n}, \"getDir\");\nvar getClasses = /* @__PURE__ */ __name(function(text, diagramObj) {\n  return diagramObj.db.getClasses();\n}, \"getClasses\");\nvar draw = /* @__PURE__ */ __name(async function(text, id, _version, diag) {\n  log.info(\"REF0:\");\n  log.info(\"Drawing class diagram (v3)\", id);\n  const { securityLevel, state: conf, layout } = getConfig();\n  const data4Layout = diag.db.getData();\n  const svg = getDiagramElement(id, securityLevel);\n  data4Layout.type = diag.type;\n  data4Layout.layoutAlgorithm = getRegisteredLayoutAlgorithm(layout);\n  data4Layout.nodeSpacing = conf?.nodeSpacing || 50;\n  data4Layout.rankSpacing = conf?.rankSpacing || 50;\n  data4Layout.markers = [\"aggregation\", \"extension\", \"composition\", \"dependency\", \"lollipop\"];\n  data4Layout.diagramId = id;\n  await render(data4Layout, svg);\n  const padding = 8;\n  utils_default.insertTitle(\n    svg,\n    \"classDiagramTitleText\",\n    conf?.titleTopMargin ?? 25,\n    diag.db.getDiagramTitle()\n  );\n  setupViewPortForSVG(svg, padding, \"classDiagram\", conf?.useMaxWidth ?? true);\n}, \"draw\");\nvar classRenderer_v3_unified_default = {\n  getClasses,\n  draw,\n  getDir\n};\n\nexport {\n  classDiagram_default,\n  ClassDB,\n  styles_default,\n  classRenderer_v3_unified_default\n};\n","import toString from './toString.js';\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nexport default uniqueId;\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nexport default baseRange;\n","import baseRange from './_baseRange.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toFinite from './toFinite.js';\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nexport default createRange;\n","import createRange from './_createRange.js';\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nexport default range;\n","/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nexport { List };\n\nclass List {\n  constructor() {\n    var sentinel = {};\n    sentinel._next = sentinel._prev = sentinel;\n    this._sentinel = sentinel;\n  }\n  dequeue() {\n    var sentinel = this._sentinel;\n    var entry = sentinel._prev;\n    if (entry !== sentinel) {\n      unlink(entry);\n      return entry;\n    }\n  }\n  enqueue(entry) {\n    var sentinel = this._sentinel;\n    if (entry._prev && entry._next) {\n      unlink(entry);\n    }\n    entry._next = sentinel._next;\n    sentinel._next._prev = entry;\n    sentinel._next = entry;\n    entry._prev = sentinel;\n  }\n  toString() {\n    var strs = [];\n    var sentinel = this._sentinel;\n    var curr = sentinel._prev;\n    while (curr !== sentinel) {\n      strs.push(JSON.stringify(curr, filterOutLinks));\n      curr = curr._prev;\n    }\n    return '[' + strs.join(', ') + ']';\n  }\n}\n\nfunction unlink(entry) {\n  entry._prev._next = entry._next;\n  entry._next._prev = entry._prev;\n  delete entry._next;\n  delete entry._prev;\n}\n\nfunction filterOutLinks(k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v;\n  }\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\nimport { List } from './data/list.js';\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nexport { greedyFAS };\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _.flatten(\n    _.map(results, function (e) {\n      return g.outEdges(e.v, e.w);\n    }),\n  );\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    while ((entry = sources.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry['in'] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, in: 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function (e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, (fasGraph.node(e.v).out += weight));\n    maxIn = Math.max(maxIn, (fasGraph.node(e.w)['in'] += weight));\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function () {\n    return new List();\n  });\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry);\n  }\n}\n","import * as _ from 'lodash-es';\nimport { greedyFAS } from './greedy-fas.js';\n\nexport { run, undo };\n\nfunction run(g) {\n  var fas = g.graph().acyclicer === 'greedy' ? greedyFAS(g, weightFn(g)) : dfsFAS(g);\n  _.forEach(fas, function (e) {\n    var label = g.edge(e);\n    g.removeEdge(e);\n    label.forwardName = e.name;\n    label.reversed = true;\n    g.setEdge(e.w, e.v, label, _.uniqueId('rev'));\n  });\n\n  function weightFn(g) {\n    return function (e) {\n      return g.edge(e).weight;\n    };\n  }\n}\n\nfunction dfsFAS(g) {\n  var fas = [];\n  var stack = {};\n  var visited = {};\n\n  function dfs(v) {\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return;\n    }\n    visited[v] = true;\n    stack[v] = true;\n    _.forEach(g.outEdges(v), function (e) {\n      if (Object.prototype.hasOwnProperty.call(stack, e.w)) {\n        fas.push(e);\n      } else {\n        dfs(e.w);\n      }\n    });\n    delete stack[v];\n  }\n\n  _.forEach(g.nodes(), dfs);\n  return fas;\n}\n\nfunction undo(g) {\n  _.forEach(g.edges(), function (e) {\n    var label = g.edge(e);\n    if (label.reversed) {\n      g.removeEdge(e);\n\n      var forwardName = label.forwardName;\n      delete label.reversed;\n      delete label.forwardName;\n      g.setEdge(e.w, e.v, label, forwardName);\n    }\n  });\n}\n","import basePickBy from './_basePickBy.js';\nimport hasIn from './hasIn.js';\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, paths) {\n  return basePickBy(object, paths, function(value, path) {\n    return hasIn(object, path);\n  });\n}\n\nexport default basePick;\n","import flatten from './flatten.js';\nimport overRest from './_overRest.js';\nimport setToString from './_setToString.js';\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nexport default flatRest;\n","import basePick from './_basePick.js';\nimport flatRest from './_flatRest.js';\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nexport default pick;\n","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nexport default baseGt;\n","import baseExtremum from './_baseExtremum.js';\nimport baseGt from './_baseGt.js';\nimport identity from './identity.js';\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nexport default max;\n","import baseAssignValue from './_baseAssignValue.js';\nimport baseForOwn from './_baseForOwn.js';\nimport baseIteratee from './_baseIteratee.js';\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nexport default mapValues;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\n\nexport {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime,\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function (v) {\n    simplified.setNode(v, g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen),\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function (v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function (v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle');\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = (h * dx) / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = (w * dy) / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function () {\n    return [];\n  });\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.min(\n    _.map(g.nodes(), function (v) {\n      return g.node(v).rank;\n    }),\n  );\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (_.has(node, 'rank')) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.min(\n    _.map(g.nodes(), function (v) {\n      return g.node(v).rank;\n    }),\n  );\n\n  var layers = [];\n  _.forEach(g.nodes(), function (v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function (vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function (v) {\n        g.node(v).rank += delta;\n      });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0,\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, 'border', node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(\n    _.map(g.nodes(), function (v) {\n      var rank = g.node(v).rank;\n      if (!_.isUndefined(rank)) {\n        return rank;\n      }\n    }),\n  );\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + ' time: ' + (_.now() - start) + 'ms');\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n","import * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { addBorderSegments };\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    var children = g.children(v);\n    var node = g.node(v);\n    if (children.length) {\n      _.forEach(children, dfs);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank);\n        addBorderNode(g, 'borderRight', '_br', v, node, rank);\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  var label = { width: 0, height: 0, rank: rank, borderType: prop };\n  var prev = sgNode[prop][rank - 1];\n  var curr = util.addDummyNode(g, 'border', label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n","import * as _ from 'lodash-es';\n\nexport { adjust, undo };\n\nfunction adjust(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g);\n  }\n}\n\nfunction undo(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g);\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g);\n    swapWidthHeight(g);\n  }\n}\n\nfunction swapWidthHeight(g) {\n  _.forEach(g.nodes(), function (v) {\n    swapWidthHeightOne(g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    swapWidthHeightOne(g.edge(e));\n  });\n}\n\nfunction swapWidthHeightOne(attrs) {\n  var w = attrs.width;\n  attrs.width = attrs.height;\n  attrs.height = w;\n}\n\nfunction reverseY(g) {\n  _.forEach(g.nodes(), function (v) {\n    reverseYOne(g.node(v));\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, reverseYOne);\n    if (Object.prototype.hasOwnProperty.call(edge, 'y')) {\n      reverseYOne(edge);\n    }\n  });\n}\n\nfunction reverseYOne(attrs) {\n  attrs.y = -attrs.y;\n}\n\nfunction swapXY(g) {\n  _.forEach(g.nodes(), function (v) {\n    swapXYOne(g.node(v));\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, swapXYOne);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      swapXYOne(edge);\n    }\n  });\n}\n\nfunction swapXYOne(attrs) {\n  var x = attrs.x;\n  attrs.x = attrs.y;\n  attrs.y = x;\n}\n","/**\n * TypeScript type imports:\n *\n * @import { Graph } from '../graphlib/graph.js';\n */\nimport * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { run, undo };\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _.forEach(g.edges(), function (edge) {\n    normalizeEdge(g, edge);\n  });\n}\n\n/**\n * @param {Graph} g\n */\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  /**\n   * @typedef {Object} Attrs\n   * @property {number} width\n   * @property {number} height\n   * @property {ReturnType<Graph[\"node\"]>} edgeLabel\n   * @property {any} edgeObj\n   * @property {ReturnType<Graph[\"node\"]>[\"rank\"]} rank\n   * @property {string} [dummy]\n   * @property {ReturnType<Graph[\"node\"]>[\"labelpos\"]} [labelpos]\n   */\n\n  /** @type {Attrs | undefined} */\n  var attrs = undefined;\n  var dummy, i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank,\n    };\n    dummy = util.addDummyNode(g, 'edge', attrs, '_d');\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = 'edge-label';\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n","import baseExtremum from './_baseExtremum.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseLt from './_baseLt.js';\n\n/**\n * This method is like `_.min` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * // The `_.property` iteratee shorthand.\n * _.minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nfunction minBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)\n    : undefined;\n}\n\nexport default minBy;\n","import * as _ from 'lodash-es';\n\nexport { longestPath, slack };\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(\n      _.map(g.outEdges(v), function (e) {\n        return dfs(e.w) - g.edge(e).minlen;\n      }),\n    );\n\n    if (\n      rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n      rank === undefined || // return value of _.map([]) for Lodash 4\n      rank === null\n    ) {\n      // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport { slack } from './util.js';\n\nexport { feasibleTree };\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree(g) {\n  var t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n\n  var edge, delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree(t, g) {\n  function dfs(v) {\n    _.forEach(g.nodeEdges(v), function (e) {\n      var edgeV = e.v,\n        w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  }\n\n  _.forEach(t.nodes(), dfs);\n  return t.nodeCount();\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge(t, g) {\n  return _.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n  });\n}\n\nfunction shiftRanks(t, g, delta) {\n  _.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta;\n  });\n}\n","import * as _ from 'lodash-es';\nimport { PriorityQueue } from '../data/priority-queue.js';\n\nexport { dijkstra };\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction dijkstra(g, source, weightFn, edgeFn) {\n  return runDijkstra(\n    g,\n    String(source),\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn ||\n      function (v) {\n        return g.outEdges(v);\n      },\n  );\n}\n\nfunction runDijkstra(g, source, weightFn, edgeFn) {\n  var results = {};\n  var pq = new PriorityQueue();\n  var v, vEntry;\n\n  var updateNeighbors = function (edge) {\n    var w = edge.v !== v ? edge.v : edge.w;\n    var wEntry = results[w];\n    var weight = weightFn(edge);\n    var distance = vEntry.distance + weight;\n\n    if (weight < 0) {\n      throw new Error(\n        'dijkstra does not allow negative edge weights. ' +\n          'Bad edge: ' +\n          edge +\n          ' Weight: ' +\n          weight,\n      );\n    }\n\n    if (distance < wEntry.distance) {\n      wEntry.distance = distance;\n      wEntry.predecessor = v;\n      pq.decrease(w, distance);\n    }\n  };\n\n  g.nodes().forEach(function (v) {\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n    results[v] = { distance: distance };\n    pq.add(v, distance);\n  });\n\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    vEntry = results[v];\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\n      break;\n    }\n\n    edgeFn(v).forEach(updateNeighbors);\n  }\n\n  return results;\n}\n","import * as _ from 'lodash-es';\n\nexport { floydWarshall };\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction floydWarshall(g, weightFn, edgeFn) {\n  return runFloydWarshall(\n    g,\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn ||\n      function (v) {\n        return g.outEdges(v);\n      },\n  );\n}\n\nfunction runFloydWarshall(g, weightFn, edgeFn) {\n  var results = {};\n  var nodes = g.nodes();\n\n  nodes.forEach(function (v) {\n    results[v] = {};\n    results[v][v] = { distance: 0 };\n    nodes.forEach(function (w) {\n      if (v !== w) {\n        results[v][w] = { distance: Number.POSITIVE_INFINITY };\n      }\n    });\n    edgeFn(v).forEach(function (edge) {\n      var w = edge.v === v ? edge.w : edge.v;\n      var d = weightFn(edge);\n      results[v][w] = { distance: d, predecessor: v };\n    });\n  });\n\n  nodes.forEach(function (k) {\n    var rowK = results[k];\n    nodes.forEach(function (i) {\n      var rowI = results[i];\n      nodes.forEach(function (j) {\n        var ik = rowI[k];\n        var kj = rowK[j];\n        var ij = rowI[j];\n        var altDistance = ik.distance + kj.distance;\n        if (altDistance < ij.distance) {\n          ij.distance = altDistance;\n          ij.predecessor = kj.predecessor;\n        }\n      });\n    });\n  });\n\n  return results;\n}\n","import baseProperty from './_baseProperty.js';\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = baseProperty('length');\n\nexport default asciiSize;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nexport default hasUnicode;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\n\nexport default unicodeSize;\n","import * as _ from 'lodash-es';\n\nexport { topsort, CycleException };\n\ntopsort.CycleException = CycleException;\n\nfunction topsort(g) {\n  var visited = {};\n  var stack = {};\n  var results = [];\n\n  function visit(node) {\n    if (Object.prototype.hasOwnProperty.call(stack, node)) {\n      throw new CycleException();\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(visited, node)) {\n      stack[node] = true;\n      visited[node] = true;\n      _.each(g.predecessors(node), visit);\n      delete stack[node];\n      results.push(node);\n    }\n  }\n\n  _.each(g.sinks(), visit);\n\n  if (_.size(visited) !== g.nodeCount()) {\n    throw new CycleException();\n  }\n\n  return results;\n}\n\nfunction CycleException() {}\nCycleException.prototype = new Error(); // must be an instance of Error to pass testing\n","import * as _ from 'lodash-es';\n\nexport { dfs };\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nfunction dfs(g, vs, order) {\n  if (!_.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);\n\n  var acc = [];\n  var visited = {};\n  _.each(vs, function (v) {\n    if (!g.hasNode(v)) {\n      throw new Error('Graph does not have node: ' + v);\n    }\n\n    doDfs(g, v, order === 'post', visited, navigation, acc);\n  });\n  return acc;\n}\n\nfunction doDfs(g, v, postorder, visited, navigation, acc) {\n  if (!Object.prototype.hasOwnProperty.call(visited, v)) {\n    visited[v] = true;\n\n    if (!postorder) {\n      acc.push(v);\n    }\n    _.each(navigation(v), function (w) {\n      doDfs(g, w, postorder, visited, navigation, acc);\n    });\n    if (postorder) {\n      acc.push(v);\n    }\n  }\n}\n","import * as _ from 'lodash-es';\nimport * as alg from '../../graphlib/alg/index.js';\nimport { simplify } from '../util.js';\nimport { feasibleTree } from './feasible-tree.js';\nimport { longestPath, slack } from './util.js';\n\nexport { networkSimplex };\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  longestPath(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = alg.postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!Object.prototype.hasOwnProperty.call(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function (edge) {\n    return (\n      flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n      flip !== isDescendant(t, t.node(edge.w), tailLabel)\n    );\n  });\n\n  return _.minBy(candidates, function (edge) {\n    return slack(g, edge);\n  });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n  var vs = alg.preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function (v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n","import { dfs } from './dfs.js';\n\nexport { postorder };\n\nfunction postorder(g, vs) {\n  return dfs(g, vs, 'post');\n}\n","import { dfs } from './dfs.js';\n\nexport { preorder };\n\nfunction preorder(g, vs) {\n  return dfs(g, vs, 'pre');\n}\n","import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\n\nexport { rank };\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n","import * as _ from 'lodash-es';\nimport * as util from './util.js';\n\nexport { run, cleanup };\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = util.addDummyNode(g, 'root', {}, '_root');\n  var depths = treeDepths(g);\n  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function (e) {\n    g.edge(e).minlen *= nodeSep;\n  });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = util.addBorderNode(g, '_bt');\n  var bottom = util.addBorderNode(g, '_bb');\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true,\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true,\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _.forEach(children, function (child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _.forEach(g.children(), function (v) {\n    dfs(v, 1);\n  });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _.reduce(\n    g.edges(),\n    function (acc, e) {\n      return acc + g.edge(e).weight;\n    },\n    0,\n  );\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nexport default cloneDeep;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\n\nexport { buildLayerGraph };\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true })\n      .setGraph({ root: root })\n      .setDefaultNodeLabel(function (v) {\n        return g.node(v);\n      });\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (Object.prototype.hasOwnProperty.call(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank],\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v;\n}\n","/**\n * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n *\n * @private\n * @param {Array} props The property identifiers.\n * @param {Array} values The property values.\n * @param {Function} assignFunc The function to assign values.\n * @returns {Object} Returns the new object.\n */\nfunction baseZipObject(props, values, assignFunc) {\n  var index = -1,\n      length = props.length,\n      valsLength = values.length,\n      result = {};\n\n  while (++index < length) {\n    var value = index < valsLength ? values[index] : undefined;\n    assignFunc(result, props[index], value);\n  }\n  return result;\n}\n\nexport default baseZipObject;\n","import assignValue from './_assignValue.js';\nimport baseZipObject from './_baseZipObject.js';\n\n/**\n * This method is like `_.fromPairs` except that it accepts two arrays,\n * one of property identifiers and one of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 0.4.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction zipObject(props, values) {\n  return baseZipObject(props || [], values || [], assignValue);\n}\n\nexport default zipObject;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nexport default baseSortBy;\n","import isSymbol from './isSymbol.js';\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nexport default compareAscending;\n","import compareAscending from './_compareAscending.js';\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nexport default compareMultiple;\n","import arrayMap from './_arrayMap.js';\nimport baseGet from './_baseGet.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseMap from './_baseMap.js';\nimport baseSortBy from './_baseSortBy.js';\nimport baseUnary from './_baseUnary.js';\nimport compareMultiple from './_compareMultiple.js';\nimport identity from './identity.js';\nimport isArray from './isArray.js';\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  if (iteratees.length) {\n    iteratees = arrayMap(iteratees, function(iteratee) {\n      if (isArray(iteratee)) {\n        return function(value) {\n          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n        }\n      }\n      return iteratee;\n    });\n  } else {\n    iteratees = [identity];\n  }\n\n  var index = -1;\n  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nexport default baseOrderBy;\n","import baseFlatten from './_baseFlatten.js';\nimport baseOrderBy from './_baseOrderBy.js';\nimport baseRest from './_baseRest.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nexport default sortBy;\n","import * as _ from 'lodash-es';\n\nexport { crossCount };\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(\n    southLayer,\n    _.map(southLayer, function (v, i) {\n      return i;\n    }),\n  );\n  var southEntries = _.flatten(\n    _.map(northLayer, function (v) {\n      return _.sortBy(\n        _.map(g.outEdges(v), function (e) {\n          return { pos: southPos[e.w], weight: g.edge(e).weight };\n        }),\n        'pos',\n      );\n    }),\n  );\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(\n    // @ts-expect-error\n    southEntries.forEach(function (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n      // @ts-expect-error\n      while (index > 0) {\n        // @ts-expect-error\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        // @ts-expect-error\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight * weightSum;\n    }),\n  );\n\n  return cc;\n}\n","import * as _ from 'lodash-es';\n\nexport { resolveConflicts };\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _.forEach(entries, function (entry, i) {\n    var tmp = (mappedEntries[entry.v] = {\n      indegree: 0,\n      in: [],\n      out: [],\n      vs: [entry.v],\n      i: i,\n    });\n    if (!_.isUndefined(entry.barycenter)) {\n      // @ts-expect-error\n      tmp.barycenter = entry.barycenter;\n      // @ts-expect-error\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function (e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function (entry) {\n    // @ts-expect-error\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (\n        _.isUndefined(uEntry.barycenter) ||\n        _.isUndefined(vEntry.barycenter) ||\n        uEntry.barycenter >= vEntry.barycenter\n      ) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _.forEach(entry['in'].reverse(), handleIn(entry));\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(\n    _.filter(entries, function (entry) {\n      return !entry.merged;\n    }),\n    function (entry) {\n      return _.pick(entry, ['vs', 'i', 'barycenter', 'weight']);\n    },\n  );\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n","import * as _ from 'lodash-es';\nimport * as util from '../util.js';\n\nexport { sort };\n\nfunction sort(entries, biasRight) {\n  var parts = util.partition(entries, function (entry) {\n    return Object.prototype.hasOwnProperty.call(entry, 'barycenter');\n  });\n  var sortable = parts.lhs,\n    unsortable = _.sortBy(parts.rhs, function (entry) {\n      return -entry.i;\n    }),\n    vs = [],\n    sum = 0,\n    weight = 0,\n    vsIndex = 0;\n\n  sortable.sort(compareWithBias(!!biasRight));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  var result = { vs: _.flatten(vs) };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n}\n\nfunction consumeUnsortable(vs, unsortable, index) {\n  var last;\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop();\n    vs.push(last.vs);\n    index++;\n  }\n  return index;\n}\n\nfunction compareWithBias(bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n}\n","import * as _ from 'lodash-es';\nimport { barycenter } from './barycenter.js';\nimport { resolveConflicts } from './resolve-conflicts.js';\nimport { sort } from './sort.js';\n\nexport { sortSubgraph };\n\nfunction sortSubgraph(g, v, cg, biasRight) {\n  var movable = g.children(v);\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight : undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = _.filter(movable, function (w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = barycenter(g, movable);\n  _.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (Object.prototype.hasOwnProperty.call(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  var entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  var result = sort(entries, biasRight);\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br]);\n    if (g.predecessors(bl).length) {\n      var blPred = g.node(g.predecessors(bl)[0]),\n        brPred = g.node(g.predecessors(br)[0]);\n      if (!Object.prototype.hasOwnProperty.call(result, 'barycenter')) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter =\n        (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n}\n\nfunction expandSubgraphs(entries, subgraphs) {\n  _.forEach(entries, function (entry) {\n    entry.vs = _.flatten(\n      entry.vs.map(function (v) {\n        if (subgraphs[v]) {\n          return subgraphs[v].vs;\n        }\n        return v;\n      }),\n    );\n  });\n}\n\nfunction mergeBarycenters(target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter =\n      (target.barycenter * target.weight + other.barycenter * other.weight) /\n      (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n}\n","import * as _ from 'lodash-es';\n\nexport { barycenter };\n\nfunction barycenter(g, movable) {\n  return _.map(movable, function (v) {\n    var inV = g.inEdges(v);\n    if (!inV.length) {\n      return { v: v };\n    } else {\n      var result = _.reduce(\n        inV,\n        function (acc, e) {\n          var edge = g.edge(e),\n            nodeU = g.node(e.v);\n          return {\n            sum: acc.sum + edge.weight * nodeU.order,\n            weight: acc.weight + edge.weight,\n          };\n        },\n        { sum: 0, weight: 0 },\n      );\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight,\n      };\n    }\n  });\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\nimport { addSubgraphConstraints } from './add-subgraph-constraints.js';\nimport { buildLayerGraph } from './build-layer-graph.js';\nimport { crossCount } from './cross-count.js';\nimport { initOrder } from './init-order.js';\nimport { sortSubgraph } from './sort-subgraph.js';\n\nexport { order };\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n","import * as _ from 'lodash-es';\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nexport function initOrder(g) {\n  var visited = {};\n  var simpleNodes = _.filter(g.nodes(), function (v) {\n    return !g.children(v).length;\n  });\n  var maxRank = _.max(\n    _.map(simpleNodes, function (v) {\n      return g.node(v).rank;\n    }),\n  );\n  var layers = _.map(_.range(maxRank + 1), function () {\n    return [];\n  });\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    layers[node.rank].push(v);\n    _.forEach(g.successors(v), dfs);\n  }\n\n  var orderedVs = _.sortBy(simpleNodes, function (v) {\n    return g.node(v).rank;\n  });\n  _.forEach(orderedVs, dfs);\n\n  return layers;\n}\n","import * as _ from 'lodash-es';\n\nexport { addSubgraphConstraints };\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {},\n    rootPrev;\n\n  _.forEach(vs, function (v) {\n    var child = g.parent(v),\n      parent,\n      prevChild;\n    while (child) {\n      parent = g.parent(child);\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n      child = parent;\n    }\n  });\n\n  /*\n  function dfs(v) {\n    var children = v ? g.children(v) : g.children();\n    if (children.length) {\n      var min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.each(children, function(child) {\n        var childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n","import * as _ from 'lodash-es';\n\nexport { parentDummyChains };\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (\n          pathIdx < path.length - 1 &&\n          g.node((pathV = path[pathIdx + 1])).minRank <= node.rank\n        ) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n","import baseForOwn from './_baseForOwn.js';\nimport castFunction from './_castFunction.js';\n\n/**\n * Iterates over own enumerable string keyed properties of an object and\n * invokes `iteratee` for each property. The iteratee is invoked with three\n * arguments: (value, key, object). Iteratee functions may exit iteration\n * early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forOwnRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forOwn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forOwn(object, iteratee) {\n  return object && baseForOwn(object, castFunction(iteratee));\n}\n\nexport default forOwn;\n","import baseFor from './_baseFor.js';\nimport castFunction from './_castFunction.js';\nimport keysIn from './keysIn.js';\n\n/**\n * Iterates over own and inherited enumerable string keyed properties of an\n * object and invokes `iteratee` for each property. The iteratee is invoked\n * with three arguments: (value, key, object). Iteratee functions may exit\n * iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forInRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forIn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n */\nfunction forIn(object, iteratee) {\n  return object == null\n    ? object\n    : baseFor(object, castFunction(iteratee), keysIn);\n}\n\nexport default forIn;\n","import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\n\n/*\n * This module provides coordinate assignment based on Brandes and Kpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nexport {\n  positionX,\n  findType1Conflicts,\n  findType2Conflicts,\n  addConflict,\n  hasConflict,\n  verticalAlignment,\n  horizontalCompaction,\n  alignCoordinates,\n  findSmallestWidthAlignment,\n  balance,\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function (v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        // @ts-expect-error\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          var uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          // @ts-expect-error\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return !!conflicts[v] && Object.prototype.hasOwnProperty.call(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function (layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function (v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) {\n          return pos[w];\n        });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? 'borderLeft' : 'borderRight';\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function (acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function (layer) {\n    var u;\n    _.forEach(layer, function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) {\n          return x + delta;\n        });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse();\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === 'u' ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r');\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) {\n          return -x;\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (Object.prototype.hasOwnProperty.call(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = -vLabel.width / 2;\n          break;\n        case 'r':\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (Object.prototype.hasOwnProperty.call(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = wLabel.width / 2;\n          break;\n        case 'r':\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n","import * as _ from 'lodash-es';\nimport * as util from '../util.js';\nimport { positionX } from './bk.js';\n\nexport { position };\n\nfunction position(g) {\n  g = util.asNonCompoundGraph(g);\n\n  positionY(g);\n  _.forOwn(positionX(g), function (x, v) {\n    g.node(v).x = x;\n  });\n}\n\nfunction positionY(g) {\n  var layering = util.buildLayerMatrix(g);\n  var rankSep = g.graph().ranksep;\n  var prevY = 0;\n  _.forEach(layering, function (layer) {\n    var maxHeight = _.max(\n      _.map(layer, function (v) {\n        return g.node(v).height;\n      }),\n    );\n    _.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2;\n    });\n    prevY += maxHeight + rankSep;\n  });\n}\n","import * as _ from 'lodash-es';\nimport { Graph } from '../graphlib/index.js';\nimport { addBorderSegments } from './add-border-segments.js';\nimport * as coordinateSystem from './coordinate-system.js';\nimport * as acyclic from './acyclic.js';\nimport * as normalize from './normalize.js';\nimport { rank } from './rank/index.js';\nimport * as nestingGraph from './nesting-graph.js';\nimport { order } from './order/index.js';\nimport { parentDummyChains } from './parent-dummy-chains.js';\nimport { position } from './position/index.js';\nimport * as util from './util.js';\n\nexport { layout };\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time('layout', () => {\n    var layoutGraph = time('  buildLayoutGraph', () => buildLayoutGraph(g));\n    time('  runLayout', () => runLayout(layoutGraph, time));\n    time('  updateInputGraph', () => updateInputGraph(g, layoutGraph));\n  });\n}\n\nfunction runLayout(g, time) {\n  time('    makeSpaceForEdgeLabels', () => makeSpaceForEdgeLabels(g));\n  time('    removeSelfEdges', () => removeSelfEdges(g));\n  time('    acyclic', () => acyclic.run(g));\n  time('    nestingGraph.run', () => nestingGraph.run(g));\n  time('    rank', () => rank(util.asNonCompoundGraph(g)));\n  time('    injectEdgeLabelProxies', () => injectEdgeLabelProxies(g));\n  time('    removeEmptyRanks', () => util.removeEmptyRanks(g));\n  time('    nestingGraph.cleanup', () => nestingGraph.cleanup(g));\n  time('    normalizeRanks', () => util.normalizeRanks(g));\n  time('    assignRankMinMax', () => assignRankMinMax(g));\n  time('    removeEdgeLabelProxies', () => removeEdgeLabelProxies(g));\n  time('    normalize.run', () => normalize.run(g));\n  time('    parentDummyChains', () => parentDummyChains(g));\n  time('    addBorderSegments', () => addBorderSegments(g));\n  time('    order', () => order(g));\n  time('    insertSelfEdges', () => insertSelfEdges(g));\n  time('    adjustCoordinateSystem', () => coordinateSystem.adjust(g));\n  time('    position', () => position(g));\n  time('    positionSelfEdges', () => positionSelfEdges(g));\n  time('    removeBorderNodes', () => removeBorderNodes(g));\n  time('    normalize.undo', () => normalize.undo(g));\n  time('    fixupEdgeLabelCoords', () => fixupEdgeLabelCoords(g));\n  time('    undoCoordinateSystem', () => coordinateSystem.undo(g));\n  time('    translateGraph', () => translateGraph(g));\n  time('    assignNodeIntersects', () => assignNodeIntersects(g));\n  time('    reversePoints', () => reversePointsForReversedEdges(g));\n  time('    acyclic.undo', () => acyclic.undo(g));\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (Object.prototype.hasOwnProperty.call(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' };\nvar graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align'];\nvar nodeNumAttrs = ['width', 'height'];\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset'];\nvar edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r',\n};\nvar edgeAttrs = ['labelpos'];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(\n    _.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _.pick(graph, graphAttrs)),\n  );\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(\n      e,\n      _.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _.pick(edge, edgeAttrs)),\n    );\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, 'edge-proxy', label, '_ep');\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      // @ts-expect-error\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function (v) {\n    getExtremes(g.node(v));\n  });\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, function (p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      edge.x -= minX;\n    }\n    if (Object.prototype.hasOwnProperty.call(edge, 'y')) {\n      edge.y -= minY;\n    }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (Object.prototype.hasOwnProperty.call(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n        case 'l':\n          edge.x -= edge.width / 2 + edge.labeloffset;\n          break;\n        case 'r':\n          edge.x += edge.width / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  _.forEach(layers, function (layer) {\n    var orderShift = 0;\n    _.forEach(layer, function (v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(\n          g,\n          'selfedge',\n          {\n            width: selfEdge.label.width,\n            height: selfEdge.label.height,\n            rank: node.rank,\n            order: i + ++orderShift,\n            e: selfEdge.e,\n            label: selfEdge.label,\n          },\n          '_se',\n        );\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'selfedge') {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + (2 * dx) / 3, y: y - dy },\n        { x: x + (5 * dx) / 6, y: y - dy },\n        { x: x + dx, y: y },\n        { x: x + (5 * dx) / 6, y: y + dy },\n        { x: x + (2 * dx) / 3, y: y + dy },\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  RadarGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/radar/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/radar/tokenBuilder.ts\nvar RadarTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"RadarTokenBuilder\");\n  }\n  constructor() {\n    super([\"radar-beta\"]);\n  }\n};\n\n// src/language/radar/module.ts\nvar RadarModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new RadarTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createRadarServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Radar = inject(\n    createDefaultCoreModule({ shared }),\n    RadarGeneratedModule,\n    RadarModule\n  );\n  shared.ServiceRegistry.register(Radar);\n  return { shared, Radar };\n}\n__name(createRadarServices, \"createRadarServices\");\n\nexport {\n  RadarModule,\n  createRadarServices\n};\n","// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    if (1)\n        return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    // - https://esbuild.github.io/content-types/#direct-eval\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    (0, eval)(toBecomeFast);\n}\n//# sourceMappingURL=to-fast-properties.js.map","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default drop;\n","import assignValue from './_assignValue.js';\nimport copyObject from './_copyObject.js';\nimport createAssigner from './_createAssigner.js';\nimport isArrayLike from './isArrayLike.js';\nimport isPrototype from './_isPrototype.js';\nimport keys from './keys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nexport default assign;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport basePickBy from './_basePickBy.js';\nimport getAllKeysIn from './_getAllKeysIn.js';\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nexport default pickBy;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nexport default baseIsRegExp;\n","import baseIsRegExp from './_baseIsRegExp.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nexport default isRegExp;\n","import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nexport class AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        forEach(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nexport class NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nexport class Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = \"\";\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Alternation extends AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n}\nexport class Terminal {\n    constructor(options) {\n        this.idx = 1;\n        assign(this, pickBy(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nexport function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction);\n}\nexport function serializeProduction(node) {\n    function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx,\n        };\n        if (isString(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = isRegExp(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition),\n        };\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=model.js.map","import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport class GAstVisitor {\n    visit(node) {\n        const nodeAny = node;\n        switch (nodeAny.constructor) {\n            case NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case Alternative:\n                return this.visitAlternative(nodeAny);\n            case Option:\n                return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n                return this.visitRepetition(nodeAny);\n            case Alternation:\n                return this.visitAlternation(nodeAny);\n            case Terminal:\n                return this.visitTerminal(nodeAny);\n            case Rule:\n                return this.visitRule(nodeAny);\n            /* c8 ignore next 2 */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) { }\n    /* c8 ignore next */\n    visitAlternative(node) { }\n    /* c8 ignore next */\n    visitOption(node) { }\n    /* c8 ignore next */\n    visitRepetition(node) { }\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) { }\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) { }\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) { }\n    /* c8 ignore next */\n    visitAlternation(node) { }\n    /* c8 ignore next */\n    visitTerminal(node) { }\n    /* c8 ignore next */\n    visitRule(node) { }\n}\n//# sourceMappingURL=visitor.js.map","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nexport default baseSome;\n","import arraySome from './_arraySome.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseSome from './_baseSome.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default some;\n","import baseIndexOf from './_baseIndexOf.js';\nimport isArrayLike from './isArrayLike.js';\nimport isString from './isString.js';\nimport toInteger from './toInteger.js';\nimport values from './values.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nexport default includes;\n","/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default arrayEvery;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nexport default baseEvery;\n","import arrayEvery from './_arrayEvery.js';\nimport baseEvery from './_baseEvery.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default every;\n","import { every, includes, some } from \"lodash-es\";\nimport { AbstractProduction, Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"./model.js\";\nexport function isSequenceProd(prod) {\n    return (prod instanceof Alternative ||\n        prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionMandatory ||\n        prod instanceof RepetitionMandatoryWithSeparator ||\n        prod instanceof RepetitionWithSeparator ||\n        prod instanceof Terminal ||\n        prod instanceof Rule);\n}\nexport function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return some(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return every(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nexport function isBranchingProd(prod) {\n    return prod instanceof Alternation;\n}\nexport function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { drop, forEach } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport class RestWalker {\n    walk(prod, prevRest = []) {\n        forEach(prod.definition, (subProd, index) => {\n            const currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new Option({ definition: manyProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            const prodWrapper = new Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator }),\n            ].concat(repSepProd.definition),\n        }),\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map","import baseUniq from './_baseUniq.js';\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nexport default uniq;\n","import { flatten, map, uniq } from \"lodash-es\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd, NonTerminal, Terminal, } from \"@chevrotain/gast\";\nexport function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n        return first(innerProd);\n    });\n    return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map","// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map","import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative } from \"@chevrotain/gast\";\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new Alternative({ definition: fullRest });\n        const t_in_topProd_follows = first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n}\nexport function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    forEach(topProductions, (topProd) => {\n        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nexport function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN;\n}\nexport function buildInProdFollowPrefix(terminal) {\n    const terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + IN;\n}\n//# sourceMappingURL=follow.js.map","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nexport default negate;\n","import arrayFilter from './_arrayFilter.js';\nimport baseFilter from './_baseFilter.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport negate from './negate.js';\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nexport default reject;\n","import baseIndexOf from './_baseIndexOf.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nexport default indexOf;\n","import SetCache from './_SetCache.js';\nimport arrayIncludes from './_arrayIncludes.js';\nimport arrayIncludesWith from './_arrayIncludesWith.js';\nimport arrayMap from './_arrayMap.js';\nimport baseUnary from './_baseUnary.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseDifference;\n","import baseDifference from './_baseDifference.js';\nimport baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nexport default difference;\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default compact;\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nexport default head;\n","export function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(`Error: ${msg}`);\n    }\n}\nexport function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(`Warning: ${msg}`);\n    }\n}\n//# sourceMappingURL=print.js.map","import { RegExpParser, } from \"@chevrotain/regexp-to-ast\";\nlet regExpAstCache = {};\nconst regExpParser = new RegExpParser();\nexport function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        const regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nexport function clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map","import { BaseRegExpVisitor, } from \"@chevrotain/regexp-to-ast\";\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\nconst complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n        const ast = getRegExpAst(regExp);\n        const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                PRINT_WARNING(`${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            let msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\\n` +\n                `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n                `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n                \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (let i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            const terms = ast.value;\n            for (let i = 0; i < terms.length; i++) {\n                const term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                const atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        forEach(atom.value, (code) => {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                const range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= minOptimizationVal) {\n                                        const minUnOptVal = range.from >= minOptimizationVal\n                                            ? range.from\n                                            : minOptimizationVal;\n                                        const maxUnOptVal = range.to;\n                                        const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                                        const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code);\n    const upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        const lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return find(setNode.value, (codeOrRange) => {\n        if (typeof codeOrRange === \"number\") {\n            return includes(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            const range = codeOrRange;\n            return (find(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    const quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return isArray(ast.value)\n        ? every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nclass CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n        super();\n        this.targetCharCodes = targetCharCodes;\n        this.found = false;\n    }\n    visitChildren(node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        super.visitChildren(node);\n    }\n    visitCharacter(node) {\n        if (includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    }\n    visitSet(node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    }\n}\nexport function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        const ast = getRegExpAst(pattern);\n        const charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (find(pattern, (char) => {\n            return includes(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map","import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType, } from \"./lexer_public.js\";\nimport { compact, defaults, difference, filter, find, first, flatten, forEach, has, includes, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, reduce, reject, values, } from \"lodash-es\";\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices, } from \"./reg_exp.js\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\nconst PATTERN = \"PATTERN\";\nexport const DEFAULT_MODE = \"defaultMode\";\nexport const MODES = \"modes\";\nexport let SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n    SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n    SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: (msg, action) => action(),\n    });\n    const tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n        initCharCodeToOptimizedIndexMap();\n    });\n    let onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", () => {\n        onlyRelevantTypes = reject(tokenTypes, (currType) => {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    let hasCustom = false;\n    let allTransformedPatterns;\n    tracer(\"Transform Patterns\", () => {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n            const currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (isRegExp(currPattern)) {\n                const regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\" &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !includes([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\",\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (isFunction(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (typeof currPattern === \"object\") {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    const wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    let patternIdxToType;\n    let patternIdxToGroup;\n    let patternIdxToLongerAltIdxArr;\n    let patternIdxToPushMode;\n    let patternIdxToPopMode;\n    tracer(\"misc mapping\", () => {\n        patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n        patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n            const groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if (isString(groupName)) {\n                return groupName;\n            }\n            else if (isUndefined(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n            const longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                const longerAltIdxArr = isArray(longerAltType)\n                    ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n                    : [indexOf(onlyRelevantTypes, longerAltType)];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n        patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, \"POP_MODE\"));\n    });\n    let patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", () => {\n        const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    return !!tokType.LINE_BREAKS;\n                }\n                else {\n                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n                        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN));\n                }\n            });\n        }\n    });\n    let patternIdxToIsCustom;\n    let patternIdxToShort;\n    let emptyGroups;\n    let patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", () => {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, (acc, clazz) => {\n            const groupName = clazz.GROUP;\n            if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx],\n            };\n        });\n    });\n    let canBeOptimized = true;\n    let charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", () => {\n            charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, (result, currTokType, idx) => {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    const charCode = currTokType.PATTERN.charCodeAt(0);\n                    const optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (isArray(currTokType.START_CHARS_HINT)) {\n                    let lastOptimizedIdx;\n                    forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                        const charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx !== currOptimizedIdx) {\n                            lastOptimizedIdx = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                                `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (isEmpty(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        forEach(optimizedCodes, (code) => {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                            `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized,\n    };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n    let errors = [];\n    const missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    const invalidResult = findInvalidPatterns(missingResult.valid);\n    const validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    let errors = [];\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp(currTokType[PATTERN]));\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nexport function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n        return !has(currType, PATTERN);\n    });\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors, valid };\n}\nexport function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return (!isRegExp(pattern) &&\n            !isFunction(pattern) &&\n            !has(pattern, \"exec\") &&\n            !isString(pattern));\n    });\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors, valid };\n}\nconst end_of_input = /[^\\\\][$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitEndAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        return pattern.test(\"\");\n    });\n    const errors = map(matchesEmptyString, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitStartAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    const errors = map(invalidRegex, (currType) => {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    const errors = map(invalidFlags, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(tokenTypes) {\n    const found = [];\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n        return reduce(tokenTypes, (result, innerType) => {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !includes(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = compact(identicalPatterns);\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n        return currIdenticalSet.length > 1;\n    });\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n        const tokenTypeNames = map(setOfIdentical, (currType) => {\n            return currType.name;\n        });\n        const dupPatternSrc = first(setOfIdentical).PATTERN;\n        return {\n            message: `The same RegExp pattern ->${dupPatternSrc}<-` +\n                `has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical,\n        };\n    });\n    return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n        if (!has(clazz, \"GROUP\")) {\n            return false;\n        }\n        const group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n    });\n    const errors = map(invalidTypes, (currType) => {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n        return (clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE));\n    });\n    const errors = map(invalidModes, (tokType) => {\n        const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n            `which does not exist`;\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType],\n        };\n    });\n    return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n    const errors = [];\n    const canBeTested = reduce(tokenTypes, (result, tokType, idx) => {\n        const pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n            result.push({ str: pattern, idx, tokenType: tokType });\n        }\n        else if (isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    forEach(tokenTypes, (tokType, testIdx) => {\n        forEach(canBeTested, ({ str, idx, tokenType }) => {\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                const msg = `Token: ->${tokenType.name}<- can never be matched.\\n` +\n                    `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n                    `in the lexer's definition.\\n` +\n                    `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType],\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        const regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (isFunction(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (has(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\",\n    ];\n    return (find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined);\n}\nexport function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags);\n}\nexport function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = [];\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n        });\n    }\n    if (!has(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n        });\n    }\n    if (has(lexerDefinition, MODES) &&\n        has(lexerDefinition, DEFAULT_MODE) &&\n        !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n                `which does not exist\\n`,\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n        });\n    }\n    if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n            forEach(currModeValue, (currTokType, currIdx) => {\n                if (isUndefined(currTokType)) {\n                    errors.push({\n                        message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                            `<${currModeName}> at index: <${currIdx}>\\n`,\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n                    });\n                }\n                else if (has(currTokType, \"LONGER_ALT\")) {\n                    const longerAlt = isArray(currTokType.LONGER_ALT)\n                        ? currTokType.LONGER_ALT\n                        : [currTokType.LONGER_ALT];\n                    forEach(longerAlt, (currLongerAlt) => {\n                        if (!isUndefined(currLongerAlt) &&\n                            !includes(currModeValue, currLongerAlt)) {\n                            errors.push({\n                                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = [];\n    let hasAnyLineBreak = false;\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        forEach(concreteTokenTypes, (tokType) => {\n            const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                const message = buildLineBreakIssueMessage(tokType, currIssue);\n                const warningDescriptor = {\n                    message,\n                    type: currIssue.issue,\n                    tokenType: tokType,\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (has(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n        });\n    }\n    return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {};\n    const groupKeys = keys(emptyGroups);\n    forEach(groupKeys, (currKey) => {\n        const currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (isArray(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (isRegExp(pattern)) {\n        return false;\n    }\n    else if (isFunction(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (has(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (isString(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        const len = text.length;\n        for (let i = this.lastIndex; i < len; i++) {\n            const c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0,\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (isRegExp(tokType.PATTERN)) {\n            try {\n                // TODO: why is the casting suddenly needed?\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message,\n                };\n            }\n            return false;\n        }\n        else if (isString(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nexport function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            `\\t Root cause: ${details.errMsg}.\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n        if (isString(numOrString)) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexport const minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap = [];\nexport function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (let i = 0; i < 65536; i++) {\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map","export function timer(func) {\n    const start = new Date().getTime();\n    const val = func();\n    const end = new Date().getTime();\n    const total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=timer.js.map","import { clone, compact, difference, flatten, forEach, has, includes, isArray, isEmpty, map, } from \"lodash-es\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport let tokenShortNameIdx = 1;\nexport const tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, (tokType) => {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes);\n    let categories = tokenTypes;\n    let searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)));\n        const newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, (val, key) => {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n        const newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!includes(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map","export const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return (`unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` + ` skipped ${length} characters.`);\n    },\n};\n//# sourceMappingURL=lexer_errors_public.js.map","import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns, } from \"./lexer.js\";\nimport { assign, clone, forEach, identity, isArray, isEmpty, isUndefined, keys, last, map, noop, reduce, reject, } from \"lodash-es\";\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\nimport { augmentTokenTypes } from \"./tokens.js\";\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\nexport var LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nconst DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nexport class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser's perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (this.traceInitPerf === true) {\n                this.traceInitIndent++;\n                const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    console.log(`${indent}--> <${phaseDesc}>`);\n                }\n                const { time, value } = timer(phaseImpl);\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                const traceMethod = time > 10 ? console.warn : console.log;\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n                }\n                this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = assign({}, DEFAULT_LEXER_CONFIG, config);\n        const traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", () => {\n            let actualDefinition;\n            let hasOnlySingleMode = true;\n            this.TRACE_INIT(\"Lexer Config handling\", () => {\n                if (this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n                this.trackEndLines = /full/i.test(this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (isArray(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: clone(lexerDefinition) },\n                        defaultMode: DEFAULT_MODE,\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = clone(lexerDefinition);\n                }\n            });\n            if (this.config.skipValidations === false) {\n                this.TRACE_INIT(\"performRuntimeChecks\", () => {\n                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n                this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n                actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType));\n            });\n            const allModeNames = keys(actualDefinition.modes);\n            forEach(actualDefinition.modes, (currModDef, currModName) => {\n                this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n                    this.modes.push(currModName);\n                    if (this.config.skipValidations === false) {\n                        this.TRACE_INIT(`validatePatterns`, () => {\n                            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (isEmpty(this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        let currAnalyzeResult;\n                        this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                            currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: this.TRACE_INIT,\n                            });\n                        });\n                        this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult.patternIdxToConfig;\n                        this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult.charCodeToPatternIdxToConfig;\n                        this.emptyGroups = assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n                        this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult.canBeOptimized;\n                    }\n                });\n            });\n            this.defaultMode = actualDefinition.defaultMode;\n            if (!isEmpty(this.lexerDefinitionErrors) &&\n                !this.config.deferDefinitionErrorsHandling) {\n                const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                    return error.message;\n                });\n                const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    this.chopInput = identity;\n                    this.match = this.matchWithTest;\n                }\n                else {\n                    this.updateLastIndex = noop;\n                    this.match = this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    this.handleModes = noop;\n                }\n                if (this.trackStartLines === false) {\n                    this.computeNewColumn = identity;\n                }\n                if (this.trackEndLines === false) {\n                    this.updateTokenEndLineColumnLocation = noop;\n                }\n                if (/full/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createFullToken;\n                }\n                else if (/onlyStart/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n                }\n                if (this.hasCustom) {\n                    this.addToken = this.addTokenUsingPush;\n                    this.handlePayload = this.handlePayloadWithCustom;\n                }\n                else {\n                    this.addToken = this.addTokenUsingMemberAccess;\n                    this.handlePayload = this.handlePayloadNoCustom;\n                }\n            });\n            this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n                const unOptimizedModes = reduce(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n                    throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\\n` +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n                clearRegExpParserCache();\n            });\n            this.TRACE_INIT(\"toFastProperties\", () => {\n                toFastProperties(this);\n            });\n        });\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n        if (!isEmpty(this.lexerDefinitionErrors)) {\n            const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n                return error.message;\n            });\n            const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        const orgText = text;\n        const orgLength = orgText.length;\n        let offset = 0;\n        let matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        const guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        const matchedTokens = new Array(guessedNumberOfTokens);\n        const errors = [];\n        let line = this.trackStartLines ? 1 : undefined;\n        let column = this.trackStartLines ? 1 : undefined;\n        const groups = cloneEmptyGroups(this.emptyGroups);\n        const trackLines = this.trackStartLines;\n        const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        let currModePatternsLength = 0;\n        let patternIdxToConfig = [];\n        let currCharCodeToPatternIdxToConfig = [];\n        const modeStack = [];\n        const emptyArray = [];\n        Object.freeze(emptyArray);\n        let getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        const pop_mode = (popToken) => {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg,\n                });\n            }\n            else {\n                modeStack.pop();\n                const newMode = last(modeStack);\n                patternIdxToConfig = this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        let currConfig;\n        const recoveryEnabled = this.config.recoveryEnabled;\n        while (offset < orgLength) {\n            matchedImage = null;\n            const nextCharCode = orgText.charCodeAt(offset);\n            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            const chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                const currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                const singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        const longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            const longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won't be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    let numOfLTsInMatch = 0;\n                    let foundTerminator;\n                    let lastLTEndOffset;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                const errorStartOffset = offset;\n                const errorLine = line;\n                const errorColumn = column;\n                let foundResyncPoint = recoveryEnabled === false;\n                while (foundResyncPoint === false && offset < orgLength) {\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        const currConfig = patternIdxToConfig[j];\n                        const currPattern = currConfig.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        const singleCharCode = currConfig.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                column = this.computeNewColumn(column, errLength);\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg,\n                });\n                if (recoveryEnabled === false) {\n                    break;\n                }\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors,\n        };\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            const pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    }\n    chopInput(text, length) {\n        return text.substring(length);\n    }\n    updateLastIndex(regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        let lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image,\n            startOffset,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image,\n            startOffset,\n            startLine,\n            startColumn,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image,\n            startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine,\n            endLine: startLine,\n            startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    }\n    handlePayloadNoCustom(token, payload) { }\n    handlePayloadWithCustom(token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    }\n    matchWithTest(pattern, text, offset) {\n        const found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    }\n    matchWithExec(pattern, text) {\n        const regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    }\n}\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\n//# sourceMappingURL=lexer_public.js.map","import { has, isString, isUndefined } from \"lodash-es\";\nimport { Lexer } from \"./lexer_public.js\";\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\nexport function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nexport function tokenName(tokType) {\n    return tokType.name;\n}\nexport function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\nexport function createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    const pattern = config.pattern;\n    const tokenType = {};\n    tokenType.name = config.name;\n    if (!isUndefined(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if (has(config, PARENT)) {\n        throw (\"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\");\n    }\n    if (has(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    augmentTokenTypes([tokenType]);\n    if (has(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if (has(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if (has(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if (has(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if (has(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if (has(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if (has(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nexport function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image,\n        startOffset,\n        endOffset,\n        startLine,\n        endLine,\n        startColumn,\n        endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType,\n    };\n}\nexport function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map","import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport { getProductionDslName, NonTerminal, Rule, Terminal, } from \"@chevrotain/gast\";\nexport const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = hasTokenLabel(expected);\n        const expectedMsg = hasLabel\n            ? `--> ${tokenLabel(expected)} <--`\n            : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = map(allLookAheadPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = first(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = map(expectedIterationPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n};\nObject.freeze(defaultParserErrorProvider);\nexport const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    },\n};\nexport const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = first(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames\n            .concat([ruleName])\n            .join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    },\n};\n//# sourceMappingURL=errors_public.js.map","import { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor } from \"@chevrotain/gast\";\nexport function resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nexport class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        forEach(values(this.nameToTopRule), (prod) => {\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName,\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    }\n}\n//# sourceMappingURL=resolver.js.map","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default dropRight;\n","import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../scan/tokens.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, } from \"@chevrotain/gast\";\nexport var PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nexport function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory ||\n        prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator ||\n        prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator ||\n        prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexport function getLookaheadPaths(options) {\n    const { occurrence, rule, prodType, maxLookahead } = options;\n    const type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n        return every(currAlt, (currPath) => {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            const predicates = map(orAlts, (currAlt) => currAlt.GATE);\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                const currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        const singleTokenAlts = map(alts, (currAlt) => {\n            return flatten(currAlt);\n        });\n        const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) => {\n            forEach(currAlt, (currTokType) => {\n                if (!has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    if (!has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            isEmpty(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        }\n        else {\n            const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) => {\n                result[currTokType.tokenTypeIdx] = true;\n                forEach(currTokType.categoryMatches, (currExtendingType) => {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (let j = 0; j < numOfPaths; j++) {\n                const currPath = alt[j];\n                const currPathLength = currPath.length;\n                for (let i = 0; i < currPathLength; i++) {\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            super.walkOption(optionProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            super.walkOption(atLeastOneProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(atLeastOneSepProd, currRest, prevRest);\n        }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            super.walkOption(manyProd, currRest, prevRest);\n        }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(manySepProd, currRest, prevRest);\n        }\n    }\n}\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    }\n}\nfunction initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    let keys = [\"\"];\n    for (let i = 0; i < path.length; i++) {\n        const tokType = path[i];\n        const longerKeys = [];\n        for (let j = 0; j < keys.length; j++) {\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (let t = 0; t < tokType.categoryMatches.length; t++) {\n                const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n    const finalResult = initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n        const dict = {};\n        forEach(currAltPaths, (item) => {\n            const keys = pathToHashKeys(item.partialPath);\n            forEach(keys, (currKey) => {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n        const currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        // alternatives loop\n        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = pathToHashKeys(currPathPrefix);\n                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (let j = 0; j < prefixKeys.length; j++) {\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    forEach(newPartialPathsAndSuffixes, (item) => {\n                        const prefixKeys = pathToHashKeys(item.partialPath);\n                        forEach(prefixKeys, (key) => {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new AlternativeGAST({ definition: insideDef });\n    const afterFlat = new AlternativeGAST({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (let j = 0; j < otherPath.length; j++) {\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        every(prefix, (tokType, idx) => {\n            const otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) => every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))));\n}\n//# sourceMappingURL=lookahead.js.map","import { clone, drop, dropRight, first as _first, forEach, isEmpty, last, } from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nexport class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = \"\";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        // stop scanning once we found the path\n        if (!this.found) {\n            super.walk(prod, prevRest);\n        }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        // need to consume the Terminal\n        if (isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n}\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = \"\";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    }\n}\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined,\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n}\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            super.walkMany(manyProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            super.walkManySep(manySepProd, currRest, prevRest);\n        }\n    }\n}\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n        }\n    }\n}\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n        }\n    }\n}\nexport function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath);\n    let result = [];\n    let i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        const prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            forEach(prod.definition, (currAlt) => {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i),\n    });\n    return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: [],\n    });\n    while (!isEmpty(possiblePaths)) {\n        const currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (isEmpty(currDef)) {\n            continue;\n        }\n        const prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: dropRight(currRuleStack),\n                occurrenceStack: dropRight(currOccurrenceStack),\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack,\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof NonTerminal) {\n            const newRuleStack = clone(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = clone(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            const nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (let i = prod.definition.length - 1; i >= 0; i--) {\n                const currAlt = prod.definition[i];\n                const currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = clone(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack,\n    };\n}\n//# sourceMappingURL=interpreter.js.map","import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values, } from \"lodash-es\";\nimport { ParserDefinitionErrorType, } from \"../parser/parser.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from \"@chevrotain/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath, } from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\nexport function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName,\n    });\n    return map(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));\n}\nexport function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = map(values(duplicates), (currDuplicates) => {\n        const firstProd = first(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx,\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nexport class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = reduce(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className,\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name,\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!includes(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName,\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path,\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName,\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n            const newPath = clone(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    let result = [];\n    if (isEmpty(definition)) {\n        return result;\n    }\n    const firstProd = first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    const isFirstOptional = isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nclass OrCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        const exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n            if (isEmpty(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx,\n                        }),\n                        type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1,\n                    },\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = flatMap(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexport class RepetitionCollector extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = flatMap(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                    }),\n                    type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                },\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    forEach(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, (currProd) => {\n            const prodType = getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd,\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name,\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath,\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path,\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts,\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path,\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices,\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n    forEach(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName,\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map","import { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport { defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, } from \"../../errors_public.js\";\nexport function resolveGrammar(options) {\n    const actualOptions = defaults(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider,\n    });\n    const topRulesTable = {};\n    forEach(options.rules, (rule) => {\n        topRulesTable[rule.name] = rule;\n    });\n    return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nexport function validateGrammar(options) {\n    options = defaults(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider,\n    });\n    return orgValidateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n//# sourceMappingURL=gast_resolver_public.js.map","import { includes } from \"lodash-es\";\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nconst RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n    constructor(message, token) {\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(this, new.target.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexport class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = MISMATCHED_TOKEN_EXCEPTION;\n    }\n}\nexport class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = NO_VIABLE_ALT_EXCEPTION;\n    }\n}\nexport class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n        super(message, token);\n        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n}\nexport class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = EARLY_EXIT_EXCEPTION;\n    }\n}\n//# sourceMappingURL=exceptions_public.js.map","import { createTokenInstance, EOF, tokenMatcher, } from \"../../../scan/tokens_public.js\";\nimport { clone, dropRight, find, flatten, has, includes, isEmpty, map, } from \"lodash-es\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nexport const EOF_FOLLOW_KEY = {};\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport class InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return includes(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName),\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return map(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule,\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map","// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map","import { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport { validateAmbiguousAlternationAlternatives, validateEmptyOrAlternative, validateNoLeftRecursion, validateSomeNonEmptyLookaheadPath, } from \"./checks.js\";\nimport { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, getProdType, } from \"./lookahead.js\";\nexport class LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if (isEmpty(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors,\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n    }\n}\n//# sourceMappingURL=llk_lookahead.js.map","import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { GAstVisitor, getProductionDslName, } from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = has(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        forEach(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);\n                forEach(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled,\n                        });\n                        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                forEach(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                forEach(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence,\n                rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType,\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=looksahead.js.map","/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map","const NAME = \"name\";\nexport function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue,\n    });\n}\n//# sourceMappingURL=lang_extensions.js.map","import { compact, filter, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map, } from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nexport function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n            }\n        },\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n        return isFunction(visitorInstance[currRuleName]) === false;\n    });\n    const errors = map(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName,\n        };\n    });\n    return compact(errors);\n}\n//# sourceMappingURL=cst_visitor.js.map","import { forEach, has, isArray, isFunction, last as peek, some, } from \"lodash-es\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport { augmentTokenTypes, hasShortKeyProperty, } from \"../../../scan/tokens.js\";\nimport { createToken, createTokenInstance, } from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nconst RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {},\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", () => {\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                this[`CONSUME${idx}`] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            // DSL methods with the idx(suffix) as an argument\n            this[`consume`] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", () => {\n            const that = this;\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : \"\";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n        // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return () => true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = peek(this.recordingProdStack);\n        const newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = peek(this.recordingProdStack);\n    // Only an array of alternatives\n    const hasOptions = isArray(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    });\n    if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    forEach(alts, (currAlt) => {\n        const currAltFlat = new Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map","import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport { defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, } from \"../errors_public.js\";\nimport { resolveGrammar, validateGrammar, } from \"../grammar/gast/gast_resolver_public.js\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\nexport const END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nexport const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false,\n});\nexport const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n});\nexport var ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nexport function EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nexport class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                toFastProperties(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    forEach(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", () => {\n                resolverErrors = resolveGrammar({\n                    rules: values(this.gastProductionsCache),\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if (isEmpty(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = validateGrammar({\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        errMsgProvider: defaultGrammarValidatorErrorProvider,\n                        grammarName: className,\n                    });\n                    const lookaheadValidationErrors = validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: values(this.gastProductionsCache),\n                        tokenTypes: values(this.tokensMap),\n                        grammarName: className,\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if (isEmpty(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n                        const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: values(this.gastProductionsCache),\n                    });\n                    this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !isEmpty(this.definitionErrors)) {\n                defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n}\n// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n]);\nexport class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nexport class EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = clone(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\n//# sourceMappingURL=parser.js.map","export function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n            if (propName === \"constructor\") {\n                return;\n            }\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n//# sourceMappingURL=apply_mixins.js.map","import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset, } from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, } from \"../../cst/cst_visitor.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop;\n                    this.setNodeLocationFromNode = noop;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = noop;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null),\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if (isUndefined(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\n//# sourceMappingURL=tree_builder.js.map","import { END_OF_FILE } from \"../parser.js\";\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\n//# sourceMappingURL=lexer_adapter.js.map","import { clone, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values, } from \"lodash-es\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from \"../../grammar/keys.js\";\nimport { isRecognitionException, MismatchedTokenException, NotAllInputParsedException, } from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker, } from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from \"../../../scan/tokens.js\";\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (isArray(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (has(tokenVocabulary, \"modes\") &&\n            every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            const allTokenTypes = flatten(values(tokenVocabulary.modes));\n            const uniqueTokens = uniq(allTokenTypes);\n            this.tokensMap = reduce(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = EOF;\n        const allTokenTypes = has(tokenVocabulary, \"modes\")\n            ? flatten(values(tokenVocabulary.modes))\n            : values(tokenVocabulary);\n        const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes(values(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        }\n        const resyncEnabled = has(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker,\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker,\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker,\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = clone(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\n//# sourceMappingURL=recognizer_engine.js.map","import { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { serializeGrammar } from \"@chevrotain/gast\";\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n        if (includes(this.definedRulesNames, name)) {\n            const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className,\n            });\n            const error = {\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name,\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (isRecognitionException(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return serializeGrammar(values(this.gastProductionsCache));\n    }\n}\n//# sourceMappingURL=recognizer_api.js.map","import { EarlyExitException, isRecognitionException, NoViableAltException, } from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, } from \"../../grammar/lookahead.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    }\n    get errors() {\n        return clone(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName,\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName(),\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\n//# sourceMappingURL=error_handler.js.map","import { NextAfterTokenWalker, nextPossibleTokensAfter, } from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nexport class ContentAssist {\n    initContentAssist() { }\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if (isUndefined(startRuleGast)) {\n            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        }\n        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = first(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n}\n//# sourceMappingURL=context_assist.js.map","import { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n    initPerformanceTracer(config) {\n        if (has(config, \"traceInitPerf\")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(`${indent}--> <${phaseDesc}>`);\n            }\n            const { time, value } = timer(phaseImpl);\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    }\n}\n//# sourceMappingURL=perf_tracer.js.map","import baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport baseUniq from './_baseUniq.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2], [1, 2]);\n * // => [2, 1]\n */\nvar union = baseRest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nexport default union;\n","import * as _ from 'lodash-es';\n\nvar DEFAULT_EDGE_NAME = '\\x00';\nvar GRAPH_NODE = '\\x00';\nvar EDGE_KEY_DELIM = '\\x01';\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\nexport class Graph {\n  constructor(opts = {}) {\n    this._isDirected = Object.prototype.hasOwnProperty.call(opts, 'directed')\n      ? opts.directed\n      : true;\n    this._isMultigraph = Object.prototype.hasOwnProperty.call(opts, 'multigraph')\n      ? opts.multigraph\n      : false;\n    this._isCompound = Object.prototype.hasOwnProperty.call(opts, 'compound')\n      ? opts.compound\n      : false;\n\n    // Label for the graph itself\n    this._label = undefined;\n\n    // Defaults to be set when creating a new node\n    this._defaultNodeLabelFn = _.constant(undefined);\n\n    // Defaults to be set when creating a new edge\n    this._defaultEdgeLabelFn = _.constant(undefined);\n\n    // v -> label\n    this._nodes = {};\n\n    if (this._isCompound) {\n      // v -> parent\n      this._parent = {};\n\n      // v -> children\n      this._children = {};\n      this._children[GRAPH_NODE] = {};\n    }\n\n    // v -> edgeObj\n    this._in = {};\n\n    // u -> v -> Number\n    this._preds = {};\n\n    // v -> edgeObj\n    this._out = {};\n\n    // v -> w -> Number\n    this._sucs = {};\n\n    // e -> edgeObj\n    this._edgeObjs = {};\n\n    // e -> label\n    this._edgeLabels = {};\n  }\n  /* === Graph functions ========= */\n  isDirected() {\n    return this._isDirected;\n  }\n  isMultigraph() {\n    return this._isMultigraph;\n  }\n  isCompound() {\n    return this._isCompound;\n  }\n  setGraph(label) {\n    this._label = label;\n    return this;\n  }\n  graph() {\n    return this._label;\n  }\n  /* === Node functions ========== */\n  setDefaultNodeLabel(newDefault) {\n    if (!_.isFunction(newDefault)) {\n      newDefault = _.constant(newDefault);\n    }\n    this._defaultNodeLabelFn = newDefault;\n    return this;\n  }\n  nodeCount() {\n    return this._nodeCount;\n  }\n  nodes() {\n    return _.keys(this._nodes);\n  }\n  sources() {\n    var self = this;\n    return _.filter(this.nodes(), function (v) {\n      return _.isEmpty(self._in[v]);\n    });\n  }\n  sinks() {\n    var self = this;\n    return _.filter(this.nodes(), function (v) {\n      return _.isEmpty(self._out[v]);\n    });\n  }\n  setNodes(vs, value) {\n    var args = arguments;\n    var self = this;\n    _.each(vs, function (v) {\n      if (args.length > 1) {\n        self.setNode(v, value);\n      } else {\n        self.setNode(v);\n      }\n    });\n    return this;\n  }\n  setNode(v, value) {\n    if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {\n      if (arguments.length > 1) {\n        this._nodes[v] = value;\n      }\n      return this;\n    }\n\n    // @ts-expect-error\n    this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n    if (this._isCompound) {\n      this._parent[v] = GRAPH_NODE;\n      this._children[v] = {};\n      this._children[GRAPH_NODE][v] = true;\n    }\n    this._in[v] = {};\n    this._preds[v] = {};\n    this._out[v] = {};\n    this._sucs[v] = {};\n    ++this._nodeCount;\n    return this;\n  }\n  node(v) {\n    return this._nodes[v];\n  }\n  hasNode(v) {\n    return Object.prototype.hasOwnProperty.call(this._nodes, v);\n  }\n  removeNode(v) {\n    if (Object.prototype.hasOwnProperty.call(this._nodes, v)) {\n      var removeEdge = (e) => this.removeEdge(this._edgeObjs[e]);\n      delete this._nodes[v];\n      if (this._isCompound) {\n        this._removeFromParentsChildList(v);\n        delete this._parent[v];\n        _.each(this.children(v), (child) => {\n          this.setParent(child);\n        });\n        delete this._children[v];\n      }\n      _.each(_.keys(this._in[v]), removeEdge);\n      delete this._in[v];\n      delete this._preds[v];\n      _.each(_.keys(this._out[v]), removeEdge);\n      delete this._out[v];\n      delete this._sucs[v];\n      --this._nodeCount;\n    }\n    return this;\n  }\n  setParent(v, parent) {\n    if (!this._isCompound) {\n      throw new Error('Cannot set parent in a non-compound graph');\n    }\n\n    if (_.isUndefined(parent)) {\n      parent = GRAPH_NODE;\n    } else {\n      // Coerce parent to string\n      parent += '';\n      for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {\n        if (ancestor === v) {\n          throw new Error('Setting ' + parent + ' as parent of ' + v + ' would create a cycle');\n        }\n      }\n\n      this.setNode(parent);\n    }\n\n    this.setNode(v);\n    this._removeFromParentsChildList(v);\n    this._parent[v] = parent;\n    this._children[parent][v] = true;\n    return this;\n  }\n  _removeFromParentsChildList(v) {\n    delete this._children[this._parent[v]][v];\n  }\n  parent(v) {\n    if (this._isCompound) {\n      var parent = this._parent[v];\n      if (parent !== GRAPH_NODE) {\n        return parent;\n      }\n    }\n  }\n  children(v) {\n    if (_.isUndefined(v)) {\n      v = GRAPH_NODE;\n    }\n\n    if (this._isCompound) {\n      var children = this._children[v];\n      if (children) {\n        return _.keys(children);\n      }\n    } else if (v === GRAPH_NODE) {\n      return this.nodes();\n    } else if (this.hasNode(v)) {\n      return [];\n    }\n  }\n  predecessors(v) {\n    var predsV = this._preds[v];\n    if (predsV) {\n      return _.keys(predsV);\n    }\n  }\n  successors(v) {\n    var sucsV = this._sucs[v];\n    if (sucsV) {\n      return _.keys(sucsV);\n    }\n  }\n  neighbors(v) {\n    var preds = this.predecessors(v);\n    if (preds) {\n      return _.union(preds, this.successors(v));\n    }\n  }\n  isLeaf(v) {\n    var neighbors;\n    if (this.isDirected()) {\n      neighbors = this.successors(v);\n    } else {\n      neighbors = this.neighbors(v);\n    }\n    return neighbors.length === 0;\n  }\n  filterNodes(filter) {\n    // @ts-expect-error\n    var copy = new this.constructor({\n      directed: this._isDirected,\n      multigraph: this._isMultigraph,\n      compound: this._isCompound,\n    });\n\n    copy.setGraph(this.graph());\n\n    var self = this;\n    _.each(this._nodes, function (value, v) {\n      if (filter(v)) {\n        copy.setNode(v, value);\n      }\n    });\n\n    _.each(this._edgeObjs, function (e) {\n      // @ts-expect-error\n      if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n        copy.setEdge(e, self.edge(e));\n      }\n    });\n\n    var parents = {};\n    function findParent(v) {\n      var parent = self.parent(v);\n      if (parent === undefined || copy.hasNode(parent)) {\n        parents[v] = parent;\n        return parent;\n      } else if (parent in parents) {\n        return parents[parent];\n      } else {\n        return findParent(parent);\n      }\n    }\n\n    if (this._isCompound) {\n      _.each(copy.nodes(), function (v) {\n        copy.setParent(v, findParent(v));\n      });\n    }\n\n    return copy;\n  }\n  /* === Edge functions ========== */\n  setDefaultEdgeLabel(newDefault) {\n    if (!_.isFunction(newDefault)) {\n      newDefault = _.constant(newDefault);\n    }\n    this._defaultEdgeLabelFn = newDefault;\n    return this;\n  }\n  edgeCount() {\n    return this._edgeCount;\n  }\n  edges() {\n    return _.values(this._edgeObjs);\n  }\n  setPath(vs, value) {\n    var self = this;\n    var args = arguments;\n    _.reduce(vs, function (v, w) {\n      if (args.length > 1) {\n        self.setEdge(v, w, value);\n      } else {\n        self.setEdge(v, w);\n      }\n      return w;\n    });\n    return this;\n  }\n  /*\n   * setEdge(v, w, [value, [name]])\n   * setEdge({ v, w, [name] }, [value])\n   */\n  setEdge() {\n    var v, w, name, value;\n    var valueSpecified = false;\n    var arg0 = arguments[0];\n\n    if (typeof arg0 === 'object' && arg0 !== null && 'v' in arg0) {\n      v = arg0.v;\n      w = arg0.w;\n      name = arg0.name;\n      if (arguments.length === 2) {\n        value = arguments[1];\n        valueSpecified = true;\n      }\n    } else {\n      v = arg0;\n      w = arguments[1];\n      name = arguments[3];\n      if (arguments.length > 2) {\n        value = arguments[2];\n        valueSpecified = true;\n      }\n    }\n\n    v = '' + v;\n    w = '' + w;\n    if (!_.isUndefined(name)) {\n      name = '' + name;\n    }\n\n    var e = edgeArgsToId(this._isDirected, v, w, name);\n    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, e)) {\n      if (valueSpecified) {\n        this._edgeLabels[e] = value;\n      }\n      return this;\n    }\n\n    if (!_.isUndefined(name) && !this._isMultigraph) {\n      throw new Error('Cannot set a named edge when isMultigraph = false');\n    }\n\n    // It didn't exist, so we need to create it.\n    // First ensure the nodes exist.\n    this.setNode(v);\n    this.setNode(w);\n\n    // @ts-expect-error\n    this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n\n    var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n    // Ensure we add undirected edges in a consistent way.\n    v = edgeObj.v;\n    w = edgeObj.w;\n\n    Object.freeze(edgeObj);\n    this._edgeObjs[e] = edgeObj;\n    incrementOrInitEntry(this._preds[w], v);\n    incrementOrInitEntry(this._sucs[v], w);\n    this._in[w][e] = edgeObj;\n    this._out[v][e] = edgeObj;\n    this._edgeCount++;\n    return this;\n  }\n  edge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    return this._edgeLabels[e];\n  }\n  hasEdge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    return Object.prototype.hasOwnProperty.call(this._edgeLabels, e);\n  }\n  removeEdge(v, w, name) {\n    var e =\n      arguments.length === 1\n        ? edgeObjToId(this._isDirected, arguments[0])\n        : edgeArgsToId(this._isDirected, v, w, name);\n    var edge = this._edgeObjs[e];\n    if (edge) {\n      v = edge.v;\n      w = edge.w;\n      delete this._edgeLabels[e];\n      delete this._edgeObjs[e];\n      decrementOrRemoveEntry(this._preds[w], v);\n      decrementOrRemoveEntry(this._sucs[v], w);\n      delete this._in[w][e];\n      delete this._out[v][e];\n      this._edgeCount--;\n    }\n    return this;\n  }\n  inEdges(v, u) {\n    var inV = this._in[v];\n    if (inV) {\n      var edges = _.values(inV);\n      if (!u) {\n        return edges;\n      }\n      return _.filter(edges, function (edge) {\n        return edge.v === u;\n      });\n    }\n  }\n  outEdges(v, w) {\n    var outV = this._out[v];\n    if (outV) {\n      var edges = _.values(outV);\n      if (!w) {\n        return edges;\n      }\n      return _.filter(edges, function (edge) {\n        return edge.w === w;\n      });\n    }\n  }\n  nodeEdges(v, w) {\n    var inEdges = this.inEdges(v, w);\n    if (inEdges) {\n      return inEdges.concat(this.outEdges(v, w));\n    }\n  }\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\n\nfunction decrementOrRemoveEntry(map, k) {\n  if (!--map[k]) {\n    delete map[k];\n  }\n}\n\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = '' + v_;\n  var w = '' + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = '' + v_;\n  var w = '' + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj = { v: v, w: w };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\n\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class ErrorWithLocation extends Error {\n    constructor(node, message) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\nexport function assertUnreachable(_) {\n    throw new Error('Error! The input value was not handled.');\n}\n//# sourceMappingURL=errors.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nexport class StreamImpl {\n    constructor(startFn, nextFn) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map(element => [\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state => {\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = state.iterator.next();\n                if (!result.done) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    join(separator = ',') {\n        const iterator = this.iterator();\n        let value = '';\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new StreamImpl(this.startFn, (state) => {\n            const { done, value } = this.nextFn(state);\n            if (done) {\n                return DONE_RESULT;\n            }\n            else {\n                return { done: false, value: callbackfn(value) };\n            }\n        });\n    }\n    filter(predicate) {\n        return new StreamImpl(this.startFn, state => {\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter(e => e !== undefined && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            }\n            else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if (isIterable(mapped)) {\n                        state.iterator = mapped[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: mapped };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === undefined) {\n            depth = 1;\n        }\n        if (depth <= 0) {\n            return this;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) : this;\n        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = stream.nextFn(state.this);\n                if (!done) {\n                    if (isIterable(value)) {\n                        state.iterator = value[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: value };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new StreamImpl(() => {\n            const state = this.startFn();\n            for (let i = 0; i < skipCount; i++) {\n                const next = this.nextFn(state);\n                if (next.done) {\n                    return state;\n                }\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {\n            state.size++;\n            if (state.size > maxSize) {\n                return DONE_RESULT;\n            }\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        return new StreamImpl(() => ({ set: new Set(), internalState: this.startFn() }), state => {\n            let result;\n            do {\n                result = this.nextFn(state.internalState);\n                if (!result.done) {\n                    const value = by ? by(result.value) : result.value;\n                    if (!state.set.has(value)) {\n                        state.set.add(value);\n                        return result;\n                    }\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = new Set();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\nfunction toString(item) {\n    if (typeof item === 'string') {\n        return item;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof item.toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return item.toString();\n    }\n    return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\n}\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nexport const DONE_RESULT = Object.freeze({ done: true, value: undefined });\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nexport function stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl(() => ({ index: 0 }), (state) => {\n                if (state.index < collection.length) {\n                    return { done: false, value: collection[state.index++] };\n                }\n                else {\n                    return DONE_RESULT;\n                }\n            });\n        }\n    }\n    if (collections.length > 1) {\n        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (!next.done) {\n                        return next;\n                    }\n                    state.iterator = undefined;\n                }\n                if (state.array) {\n                    if (state.arrIndex < state.array.length) {\n                        return { done: false, value: state.array[state.arrIndex++] };\n                    }\n                    state.array = undefined;\n                    state.arrIndex = 0;\n                }\n                if (state.collIndex < collections.length) {\n                    const collection = collections[state.collIndex++];\n                    if (isIterable(collection)) {\n                        state.iterator = collection[Symbol.iterator]();\n                    }\n                    else if (collection && typeof collection.length === 'number') {\n                        state.array = collection;\n                    }\n                }\n            } while (state.iterator || state.array || state.collIndex < collections.length);\n            return DONE_RESULT;\n        });\n    }\n    return EMPTY_STREAM;\n}\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nexport class TreeStreamImpl extends StreamImpl {\n    constructor(root, children, options) {\n        super(() => ({\n            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n            pruned: false\n        }), state => {\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while (state.iterators.length > 0) {\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) {\n                    state.iterators.pop();\n                }\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nexport var Reduction;\n(function (Reduction) {\n    /**\n     * Compute the sum of a number stream.\n     */\n    function sum(stream) {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n    Reduction.sum = sum;\n    /**\n     * Compute the product of a number stream.\n     */\n    function product(stream) {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n    Reduction.product = product;\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function min(stream) {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n    Reduction.min = min;\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function max(stream) {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n    Reduction.max = max;\n})(Reduction || (Reduction = {}));\n//# sourceMappingURL=stream.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer } from 'chevrotain';\nimport { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';\nimport { streamAllContents } from '../utils/ast-utils.js';\nimport { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';\nimport { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';\nimport { stream } from '../utils/stream.js';\nexport class DefaultTokenBuilder {\n    constructor() {\n        /**\n         * The list of diagnostics stored during the lexing process of a single text.\n         */\n        this.diagnostics = [];\n    }\n    buildTokens(grammar, options) {\n        const reachableRules = stream(getAllReachableRules(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespace(pattern)) {\n                tokens.unshift(terminalToken);\n            }\n            else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don't need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flushLexingReport(text) {\n        return { diagnostics: this.popDiagnostics() };\n    }\n    popDiagnostics() {\n        const diagnostics = [...this.diagnostics];\n        this.diagnostics = [];\n        return diagnostics;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n        };\n        if (typeof pattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';\n        }\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes('u') || regex.flags.includes('s')) {\n            // Unicode and dotall regexes are not supported by Chevrotain.\n            return true;\n        }\n        else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(isParserRule)\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\n        const tokenType = {\n            name: keyword.value,\n            PATTERN: keywordPattern,\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n        if (typeof keywordPattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        return tokenType;\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ?\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\n            keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token) => {\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches('^' + pattern.source + '$', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n//# sourceMappingURL=token-builder.js.map","import {\n  getDiagramElement,\n  setupViewPortForSVG\n} from \"./chunk-RZ5BOZE2.mjs\";\nimport {\n  render\n} from \"./chunk-TYCBKAJE.mjs\";\nimport {\n  generateId,\n  utils_default\n} from \"./chunk-O4NI6UNU.mjs\";\nimport {\n  __name,\n  clear,\n  common_default,\n  getAccDescription,\n  getAccTitle,\n  getConfig2 as getConfig,\n  getDiagramTitle,\n  log,\n  setAccDescription,\n  setAccTitle,\n  setDiagramTitle\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/diagrams/state/parser/stateDiagram.jison\nvar parser = function() {\n  var o = /* @__PURE__ */ __name(function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;\n    return o2;\n  }, \"o\"), $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 4], $V3 = [2, 4], $V4 = [1, 9], $V5 = [1, 11], $V6 = [1, 16], $V7 = [1, 17], $V8 = [1, 18], $V9 = [1, 19], $Va = [1, 32], $Vb = [1, 20], $Vc = [1, 21], $Vd = [1, 22], $Ve = [1, 23], $Vf = [1, 24], $Vg = [1, 26], $Vh = [1, 27], $Vi = [1, 28], $Vj = [1, 29], $Vk = [1, 30], $Vl = [1, 31], $Vm = [1, 34], $Vn = [1, 35], $Vo = [1, 36], $Vp = [1, 37], $Vq = [1, 33], $Vr = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $Vs = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $Vt = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54];\n  var parser2 = {\n    trace: /* @__PURE__ */ __name(function trace() {\n    }, \"trace\"),\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"SPACE\": 4, \"NL\": 5, \"SD\": 6, \"document\": 7, \"line\": 8, \"statement\": 9, \"classDefStatement\": 10, \"styleStatement\": 11, \"cssClassStatement\": 12, \"idStatement\": 13, \"DESCR\": 14, \"-->\": 15, \"HIDE_EMPTY\": 16, \"scale\": 17, \"WIDTH\": 18, \"COMPOSIT_STATE\": 19, \"STRUCT_START\": 20, \"STRUCT_STOP\": 21, \"STATE_DESCR\": 22, \"AS\": 23, \"ID\": 24, \"FORK\": 25, \"JOIN\": 26, \"CHOICE\": 27, \"CONCURRENT\": 28, \"note\": 29, \"notePosition\": 30, \"NOTE_TEXT\": 31, \"direction\": 32, \"acc_title\": 33, \"acc_title_value\": 34, \"acc_descr\": 35, \"acc_descr_value\": 36, \"acc_descr_multiline_value\": 37, \"classDef\": 38, \"CLASSDEF_ID\": 39, \"CLASSDEF_STYLEOPTS\": 40, \"DEFAULT\": 41, \"style\": 42, \"STYLE_IDS\": 43, \"STYLEDEF_STYLEOPTS\": 44, \"class\": 45, \"CLASSENTITY_IDS\": 46, \"STYLECLASS\": 47, \"direction_tb\": 48, \"direction_bt\": 49, \"direction_rl\": 50, \"direction_lr\": 51, \"eol\": 52, \";\": 53, \"EDGE_STATE\": 54, \"STYLE_SEPARATOR\": 55, \"left_of\": 56, \"right_of\": 57, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 4: \"SPACE\", 5: \"NL\", 6: \"SD\", 14: \"DESCR\", 15: \"-->\", 16: \"HIDE_EMPTY\", 17: \"scale\", 18: \"WIDTH\", 19: \"COMPOSIT_STATE\", 20: \"STRUCT_START\", 21: \"STRUCT_STOP\", 22: \"STATE_DESCR\", 23: \"AS\", 24: \"ID\", 25: \"FORK\", 26: \"JOIN\", 27: \"CHOICE\", 28: \"CONCURRENT\", 29: \"note\", 31: \"NOTE_TEXT\", 33: \"acc_title\", 34: \"acc_title_value\", 35: \"acc_descr\", 36: \"acc_descr_value\", 37: \"acc_descr_multiline_value\", 38: \"classDef\", 39: \"CLASSDEF_ID\", 40: \"CLASSDEF_STYLEOPTS\", 41: \"DEFAULT\", 42: \"style\", 43: \"STYLE_IDS\", 44: \"STYLEDEF_STYLEOPTS\", 45: \"class\", 46: \"CLASSENTITY_IDS\", 47: \"STYLECLASS\", 48: \"direction_tb\", 49: \"direction_bt\", 50: \"direction_rl\", 51: \"direction_lr\", 53: \";\", 54: \"EDGE_STATE\", 55: \"STYLE_SEPARATOR\", 56: \"left_of\", 57: \"right_of\" },\n    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 3], [9, 4], [9, 1], [9, 2], [9, 1], [9, 4], [9, 3], [9, 6], [9, 1], [9, 1], [9, 1], [9, 1], [9, 4], [9, 4], [9, 1], [9, 2], [9, 2], [9, 1], [10, 3], [10, 3], [11, 3], [12, 3], [32, 1], [32, 1], [32, 1], [32, 1], [52, 1], [52, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1]],\n    performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 3:\n          yy.setRootDoc($$[$0]);\n          return $$[$0];\n          break;\n        case 4:\n          this.$ = [];\n          break;\n        case 5:\n          if ($$[$0] != \"nl\") {\n            $$[$0 - 1].push($$[$0]);\n            this.$ = $$[$0 - 1];\n          }\n          break;\n        case 6:\n        case 7:\n          this.$ = $$[$0];\n          break;\n        case 8:\n          this.$ = \"nl\";\n          break;\n        case 12:\n          this.$ = $$[$0];\n          break;\n        case 13:\n          const stateStmt = $$[$0 - 1];\n          stateStmt.description = yy.trimColon($$[$0]);\n          this.$ = stateStmt;\n          break;\n        case 14:\n          this.$ = { stmt: \"relation\", state1: $$[$0 - 2], state2: $$[$0] };\n          break;\n        case 15:\n          const relDescription = yy.trimColon($$[$0]);\n          this.$ = { stmt: \"relation\", state1: $$[$0 - 3], state2: $$[$0 - 1], description: relDescription };\n          break;\n        case 19:\n          this.$ = { stmt: \"state\", id: $$[$0 - 3], type: \"default\", description: \"\", doc: $$[$0 - 1] };\n          break;\n        case 20:\n          var id = $$[$0];\n          var description = $$[$0 - 2].trim();\n          if ($$[$0].match(\":\")) {\n            var parts = $$[$0].split(\":\");\n            id = parts[0];\n            description = [description, parts[1]];\n          }\n          this.$ = { stmt: \"state\", id, type: \"default\", description };\n          break;\n        case 21:\n          this.$ = { stmt: \"state\", id: $$[$0 - 3], type: \"default\", description: $$[$0 - 5], doc: $$[$0 - 1] };\n          break;\n        case 22:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"fork\" };\n          break;\n        case 23:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"join\" };\n          break;\n        case 24:\n          this.$ = { stmt: \"state\", id: $$[$0], type: \"choice\" };\n          break;\n        case 25:\n          this.$ = { stmt: \"state\", id: yy.getDividerId(), type: \"divider\" };\n          break;\n        case 26:\n          this.$ = { stmt: \"state\", id: $$[$0 - 1].trim(), note: { position: $$[$0 - 2].trim(), text: $$[$0].trim() } };\n          break;\n        case 29:\n          this.$ = $$[$0].trim();\n          yy.setAccTitle(this.$);\n          break;\n        case 30:\n        case 31:\n          this.$ = $$[$0].trim();\n          yy.setAccDescription(this.$);\n          break;\n        case 32:\n        case 33:\n          this.$ = { stmt: \"classDef\", id: $$[$0 - 1].trim(), classes: $$[$0].trim() };\n          break;\n        case 34:\n          this.$ = { stmt: \"style\", id: $$[$0 - 1].trim(), styleClass: $$[$0].trim() };\n          break;\n        case 35:\n          this.$ = { stmt: \"applyClass\", id: $$[$0 - 1].trim(), styleClass: $$[$0].trim() };\n          break;\n        case 36:\n          yy.setDirection(\"TB\");\n          this.$ = { stmt: \"dir\", value: \"TB\" };\n          break;\n        case 37:\n          yy.setDirection(\"BT\");\n          this.$ = { stmt: \"dir\", value: \"BT\" };\n          break;\n        case 38:\n          yy.setDirection(\"RL\");\n          this.$ = { stmt: \"dir\", value: \"RL\" };\n          break;\n        case 39:\n          yy.setDirection(\"LR\");\n          this.$ = { stmt: \"dir\", value: \"LR\" };\n          break;\n        case 42:\n        case 43:\n          this.$ = { stmt: \"state\", id: $$[$0].trim(), type: \"default\", description: \"\" };\n          break;\n        case 44:\n          this.$ = { stmt: \"state\", id: $$[$0 - 2].trim(), classes: [$$[$0].trim()], type: \"default\", description: \"\" };\n          break;\n        case 45:\n          this.$ = { stmt: \"state\", id: $$[$0 - 2].trim(), classes: [$$[$0].trim()], type: \"default\", description: \"\" };\n          break;\n      }\n    }, \"anonymous\"),\n    table: [{ 3: 1, 4: $V0, 5: $V1, 6: $V2 }, { 1: [3] }, { 3: 5, 4: $V0, 5: $V1, 6: $V2 }, { 3: 6, 4: $V0, 5: $V1, 6: $V2 }, o([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 45, 48, 49, 50, 51, 54], $V3, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 5]), { 9: 38, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 7]), o($Vr, [2, 8]), o($Vr, [2, 9]), o($Vr, [2, 10]), o($Vr, [2, 11]), o($Vr, [2, 12], { 14: [1, 39], 15: [1, 40] }), o($Vr, [2, 16]), { 18: [1, 41] }, o($Vr, [2, 18], { 20: [1, 42] }), { 23: [1, 43] }, o($Vr, [2, 22]), o($Vr, [2, 23]), o($Vr, [2, 24]), o($Vr, [2, 25]), { 30: 44, 31: [1, 45], 56: [1, 46], 57: [1, 47] }, o($Vr, [2, 28]), { 34: [1, 48] }, { 36: [1, 49] }, o($Vr, [2, 31]), { 39: [1, 50], 41: [1, 51] }, { 43: [1, 52] }, { 46: [1, 53] }, o($Vs, [2, 42], { 55: [1, 54] }), o($Vs, [2, 43], { 55: [1, 55] }), o($Vr, [2, 36]), o($Vr, [2, 37]), o($Vr, [2, 38]), o($Vr, [2, 39]), o($Vr, [2, 6]), o($Vr, [2, 13]), { 13: 56, 24: $Va, 54: $Vq }, o($Vr, [2, 17]), o($Vt, $V3, { 7: 57 }), { 24: [1, 58] }, { 24: [1, 59] }, { 23: [1, 60] }, { 24: [2, 46] }, { 24: [2, 47] }, o($Vr, [2, 29]), o($Vr, [2, 30]), { 40: [1, 61] }, { 40: [1, 62] }, { 44: [1, 63] }, { 47: [1, 64] }, { 24: [1, 65] }, { 24: [1, 66] }, o($Vr, [2, 14], { 14: [1, 67] }), { 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 21: [1, 68], 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 20], { 20: [1, 69] }), { 31: [1, 70] }, { 24: [1, 71] }, o($Vr, [2, 32]), o($Vr, [2, 33]), o($Vr, [2, 34]), o($Vr, [2, 35]), o($Vs, [2, 44]), o($Vs, [2, 45]), o($Vr, [2, 15]), o($Vr, [2, 19]), o($Vt, $V3, { 7: 72 }), o($Vr, [2, 26]), o($Vr, [2, 27]), { 4: $V4, 5: $V5, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: $V6, 17: $V7, 19: $V8, 21: [1, 73], 22: $V9, 24: $Va, 25: $Vb, 26: $Vc, 27: $Vd, 28: $Ve, 29: $Vf, 32: 25, 33: $Vg, 35: $Vh, 37: $Vi, 38: $Vj, 42: $Vk, 45: $Vl, 48: $Vm, 49: $Vn, 50: $Vo, 51: $Vp, 54: $Vq }, o($Vr, [2, 21])],\n    defaultActions: { 5: [2, 1], 6: [2, 2], 46: [2, 46], 47: [2, 47] },\n    parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    }, \"parseError\"),\n    parse: /* @__PURE__ */ __name(function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n      }\n      __name(popStack, \"popStack\");\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      __name(lex, \"lex\");\n      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n              if (recovering > 0) {\n                recovering--;\n              }\n            } else {\n              symbol = preErrorSymbol;\n              preErrorSymbol = null;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }, \"parse\")\n  };\n  var lexer = /* @__PURE__ */ function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: /* @__PURE__ */ __name(function parseError(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      }, \"parseError\"),\n      // resets the lexer, sets new input\n      setInput: /* @__PURE__ */ __name(function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      }, \"setInput\"),\n      // consumes and returns one char from the input\n      input: /* @__PURE__ */ __name(function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      }, \"input\"),\n      // unshifts one char (or a string) into the input\n      unput: /* @__PURE__ */ __name(function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      }, \"unput\"),\n      // When called from action, caches matched text and appends it on next action\n      more: /* @__PURE__ */ __name(function() {\n        this._more = true;\n        return this;\n      }, \"more\"),\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: /* @__PURE__ */ __name(function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      }, \"reject\"),\n      // retain first n characters of the match\n      less: /* @__PURE__ */ __name(function(n) {\n        this.unput(this.match.slice(n));\n      }, \"less\"),\n      // displays already matched input, i.e. for error messages\n      pastInput: /* @__PURE__ */ __name(function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      }, \"pastInput\"),\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: /* @__PURE__ */ __name(function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      }, \"upcomingInput\"),\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: /* @__PURE__ */ __name(function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      }, \"showPosition\"),\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      }, \"test_match\"),\n      // return next match in input\n      next: /* @__PURE__ */ __name(function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      }, \"next\"),\n      // return next match that has a token\n      lex: /* @__PURE__ */ __name(function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      }, \"lex\"),\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: /* @__PURE__ */ __name(function begin(condition) {\n        this.conditionStack.push(condition);\n      }, \"begin\"),\n      // pop the previously active lexer condition state off the condition stack\n      popState: /* @__PURE__ */ __name(function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      }, \"popState\"),\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: /* @__PURE__ */ __name(function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      }, \"_currentRules\"),\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: /* @__PURE__ */ __name(function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      }, \"topState\"),\n      // alias for begin(condition)\n      pushState: /* @__PURE__ */ __name(function pushState(condition) {\n        this.begin(condition);\n      }, \"pushState\"),\n      // return the number of states currently on the stack\n      stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {\n        return this.conditionStack.length;\n      }, \"stateStackSize\"),\n      options: { \"case-insensitive\": true },\n      performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        var YYSTATE = YY_START;\n        switch ($avoiding_name_collisions) {\n          case 0:\n            return 41;\n            break;\n          case 1:\n            return 48;\n            break;\n          case 2:\n            return 49;\n            break;\n          case 3:\n            return 50;\n            break;\n          case 4:\n            return 51;\n            break;\n          case 5:\n            break;\n          case 6:\n            {\n            }\n            break;\n          case 7:\n            return 5;\n            break;\n          case 8:\n            break;\n          case 9:\n            break;\n          case 10:\n            break;\n          case 11:\n            break;\n          case 12:\n            this.pushState(\"SCALE\");\n            return 17;\n            break;\n          case 13:\n            return 18;\n            break;\n          case 14:\n            this.popState();\n            break;\n          case 15:\n            this.begin(\"acc_title\");\n            return 33;\n            break;\n          case 16:\n            this.popState();\n            return \"acc_title_value\";\n            break;\n          case 17:\n            this.begin(\"acc_descr\");\n            return 35;\n            break;\n          case 18:\n            this.popState();\n            return \"acc_descr_value\";\n            break;\n          case 19:\n            this.begin(\"acc_descr_multiline\");\n            break;\n          case 20:\n            this.popState();\n            break;\n          case 21:\n            return \"acc_descr_multiline_value\";\n            break;\n          case 22:\n            this.pushState(\"CLASSDEF\");\n            return 38;\n            break;\n          case 23:\n            this.popState();\n            this.pushState(\"CLASSDEFID\");\n            return \"DEFAULT_CLASSDEF_ID\";\n            break;\n          case 24:\n            this.popState();\n            this.pushState(\"CLASSDEFID\");\n            return 39;\n            break;\n          case 25:\n            this.popState();\n            return 40;\n            break;\n          case 26:\n            this.pushState(\"CLASS\");\n            return 45;\n            break;\n          case 27:\n            this.popState();\n            this.pushState(\"CLASS_STYLE\");\n            return 46;\n            break;\n          case 28:\n            this.popState();\n            return 47;\n            break;\n          case 29:\n            this.pushState(\"STYLE\");\n            return 42;\n            break;\n          case 30:\n            this.popState();\n            this.pushState(\"STYLEDEF_STYLES\");\n            return 43;\n            break;\n          case 31:\n            this.popState();\n            return 44;\n            break;\n          case 32:\n            this.pushState(\"SCALE\");\n            return 17;\n            break;\n          case 33:\n            return 18;\n            break;\n          case 34:\n            this.popState();\n            break;\n          case 35:\n            this.pushState(\"STATE\");\n            break;\n          case 36:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 25;\n            break;\n          case 37:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 26;\n            break;\n          case 38:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -10).trim();\n            return 27;\n            break;\n          case 39:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 25;\n            break;\n          case 40:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 26;\n            break;\n          case 41:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -10).trim();\n            return 27;\n            break;\n          case 42:\n            return 48;\n            break;\n          case 43:\n            return 49;\n            break;\n          case 44:\n            return 50;\n            break;\n          case 45:\n            return 51;\n            break;\n          case 46:\n            this.pushState(\"STATE_STRING\");\n            break;\n          case 47:\n            this.pushState(\"STATE_ID\");\n            return \"AS\";\n            break;\n          case 48:\n            this.popState();\n            return \"ID\";\n            break;\n          case 49:\n            this.popState();\n            break;\n          case 50:\n            return \"STATE_DESCR\";\n            break;\n          case 51:\n            return 19;\n            break;\n          case 52:\n            this.popState();\n            break;\n          case 53:\n            this.popState();\n            this.pushState(\"struct\");\n            return 20;\n            break;\n          case 54:\n            break;\n          case 55:\n            this.popState();\n            return 21;\n            break;\n          case 56:\n            break;\n          case 57:\n            this.begin(\"NOTE\");\n            return 29;\n            break;\n          case 58:\n            this.popState();\n            this.pushState(\"NOTE_ID\");\n            return 56;\n            break;\n          case 59:\n            this.popState();\n            this.pushState(\"NOTE_ID\");\n            return 57;\n            break;\n          case 60:\n            this.popState();\n            this.pushState(\"FLOATING_NOTE\");\n            break;\n          case 61:\n            this.popState();\n            this.pushState(\"FLOATING_NOTE_ID\");\n            return \"AS\";\n            break;\n          case 62:\n            break;\n          case 63:\n            return \"NOTE_TEXT\";\n            break;\n          case 64:\n            this.popState();\n            return \"ID\";\n            break;\n          case 65:\n            this.popState();\n            this.pushState(\"NOTE_TEXT\");\n            return 24;\n            break;\n          case 66:\n            this.popState();\n            yy_.yytext = yy_.yytext.substr(2).trim();\n            return 31;\n            break;\n          case 67:\n            this.popState();\n            yy_.yytext = yy_.yytext.slice(0, -8).trim();\n            return 31;\n            break;\n          case 68:\n            return 6;\n            break;\n          case 69:\n            return 6;\n            break;\n          case 70:\n            return 16;\n            break;\n          case 71:\n            return 54;\n            break;\n          case 72:\n            return 24;\n            break;\n          case 73:\n            yy_.yytext = yy_.yytext.trim();\n            return 14;\n            break;\n          case 74:\n            return 15;\n            break;\n          case 75:\n            return 28;\n            break;\n          case 76:\n            return 55;\n            break;\n          case 77:\n            return 5;\n            break;\n          case 78:\n            return \"INVALID\";\n            break;\n        }\n      }, \"anonymous\"),\n      rules: [/^(?:default\\b)/i, /^(?:.*direction\\s+TB[^\\n]*)/i, /^(?:.*direction\\s+BT[^\\n]*)/i, /^(?:.*direction\\s+RL[^\\n]*)/i, /^(?:.*direction\\s+LR[^\\n]*)/i, /^(?:%%(?!\\{)[^\\n]*)/i, /^(?:[^\\}]%%[^\\n]*)/i, /^(?:[\\n]+)/i, /^(?:[\\s]+)/i, /^(?:((?!\\n)\\s)+)/i, /^(?:#[^\\n]*)/i, /^(?:%[^\\n]*)/i, /^(?:scale\\s+)/i, /^(?:\\d+)/i, /^(?:\\s+width\\b)/i, /^(?:accTitle\\s*:\\s*)/i, /^(?:(?!\\n||)*[^\\n]*)/i, /^(?:accDescr\\s*:\\s*)/i, /^(?:(?!\\n||)*[^\\n]*)/i, /^(?:accDescr\\s*\\{\\s*)/i, /^(?:[\\}])/i, /^(?:[^\\}]*)/i, /^(?:classDef\\s+)/i, /^(?:DEFAULT\\s+)/i, /^(?:\\w+\\s+)/i, /^(?:[^\\n]*)/i, /^(?:class\\s+)/i, /^(?:(\\w+)+((,\\s*\\w+)*))/i, /^(?:[^\\n]*)/i, /^(?:style\\s+)/i, /^(?:[\\w,]+\\s+)/i, /^(?:[^\\n]*)/i, /^(?:scale\\s+)/i, /^(?:\\d+)/i, /^(?:\\s+width\\b)/i, /^(?:state\\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\\[\\[fork\\]\\])/i, /^(?:.*\\[\\[join\\]\\])/i, /^(?:.*\\[\\[choice\\]\\])/i, /^(?:.*direction\\s+TB[^\\n]*)/i, /^(?:.*direction\\s+BT[^\\n]*)/i, /^(?:.*direction\\s+RL[^\\n]*)/i, /^(?:.*direction\\s+LR[^\\n]*)/i, /^(?:[\"])/i, /^(?:\\s*as\\s+)/i, /^(?:[^\\n\\{]*)/i, /^(?:[\"])/i, /^(?:[^\"]*)/i, /^(?:[^\\n\\s\\{]+)/i, /^(?:\\n)/i, /^(?:\\{)/i, /^(?:%%(?!\\{)[^\\n]*)/i, /^(?:\\})/i, /^(?:[\\n])/i, /^(?:note\\s+)/i, /^(?:left of\\b)/i, /^(?:right of\\b)/i, /^(?:\")/i, /^(?:\\s*as\\s*)/i, /^(?:[\"])/i, /^(?:[^\"]*)/i, /^(?:[^\\n]*)/i, /^(?:\\s*[^:\\n\\s\\-]+)/i, /^(?:\\s*:[^:\\n;]+)/i, /^(?:[\\s\\S]*?end note\\b)/i, /^(?:stateDiagram\\s+)/i, /^(?:stateDiagram-v2\\s+)/i, /^(?:hide empty description\\b)/i, /^(?:\\[\\*\\])/i, /^(?:[^:\\n\\s\\-\\{]+)/i, /^(?:\\s*:[^:\\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],\n      conditions: { \"LINE\": { \"rules\": [9, 10], \"inclusive\": false }, \"struct\": { \"rules\": [9, 10, 22, 26, 29, 35, 42, 43, 44, 45, 54, 55, 56, 57, 71, 72, 73, 74, 75], \"inclusive\": false }, \"FLOATING_NOTE_ID\": { \"rules\": [64], \"inclusive\": false }, \"FLOATING_NOTE\": { \"rules\": [61, 62, 63], \"inclusive\": false }, \"NOTE_TEXT\": { \"rules\": [66, 67], \"inclusive\": false }, \"NOTE_ID\": { \"rules\": [65], \"inclusive\": false }, \"NOTE\": { \"rules\": [58, 59, 60], \"inclusive\": false }, \"STYLEDEF_STYLEOPTS\": { \"rules\": [], \"inclusive\": false }, \"STYLEDEF_STYLES\": { \"rules\": [31], \"inclusive\": false }, \"STYLE_IDS\": { \"rules\": [], \"inclusive\": false }, \"STYLE\": { \"rules\": [30], \"inclusive\": false }, \"CLASS_STYLE\": { \"rules\": [28], \"inclusive\": false }, \"CLASS\": { \"rules\": [27], \"inclusive\": false }, \"CLASSDEFID\": { \"rules\": [25], \"inclusive\": false }, \"CLASSDEF\": { \"rules\": [23, 24], \"inclusive\": false }, \"acc_descr_multiline\": { \"rules\": [20, 21], \"inclusive\": false }, \"acc_descr\": { \"rules\": [18], \"inclusive\": false }, \"acc_title\": { \"rules\": [16], \"inclusive\": false }, \"SCALE\": { \"rules\": [13, 14, 33, 34], \"inclusive\": false }, \"ALIAS\": { \"rules\": [], \"inclusive\": false }, \"STATE_ID\": { \"rules\": [48], \"inclusive\": false }, \"STATE_STRING\": { \"rules\": [49, 50], \"inclusive\": false }, \"FORK_STATE\": { \"rules\": [], \"inclusive\": false }, \"STATE\": { \"rules\": [9, 10, 36, 37, 38, 39, 40, 41, 46, 47, 51, 52, 53], \"inclusive\": false }, \"ID\": { \"rules\": [9, 10], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 15, 17, 19, 22, 26, 29, 32, 35, 53, 57, 68, 69, 70, 71, 72, 73, 74, 76, 77, 78], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  __name(Parser, \"Parser\");\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nvar stateDiagram_default = parser;\n\n// src/diagrams/state/stateCommon.ts\nvar DEFAULT_DIAGRAM_DIRECTION = \"TB\";\nvar DEFAULT_NESTED_DOC_DIR = \"TB\";\nvar STMT_DIRECTION = \"dir\";\nvar STMT_STATE = \"state\";\nvar STMT_RELATION = \"relation\";\nvar STMT_CLASSDEF = \"classDef\";\nvar STMT_STYLEDEF = \"style\";\nvar STMT_APPLYCLASS = \"applyClass\";\nvar DEFAULT_STATE_TYPE = \"default\";\nvar DIVIDER_TYPE = \"divider\";\nvar G_EDGE_STYLE = \"fill:none\";\nvar G_EDGE_ARROWHEADSTYLE = \"fill: #333\";\nvar G_EDGE_LABELPOS = \"c\";\nvar G_EDGE_LABELTYPE = \"text\";\nvar G_EDGE_THICKNESS = \"normal\";\nvar SHAPE_STATE = \"rect\";\nvar SHAPE_STATE_WITH_DESC = \"rectWithTitle\";\nvar SHAPE_START = \"stateStart\";\nvar SHAPE_END = \"stateEnd\";\nvar SHAPE_DIVIDER = \"divider\";\nvar SHAPE_GROUP = \"roundedWithTitle\";\nvar SHAPE_NOTE = \"note\";\nvar SHAPE_NOTEGROUP = \"noteGroup\";\nvar CSS_DIAGRAM = \"statediagram\";\nvar CSS_STATE = \"state\";\nvar CSS_DIAGRAM_STATE = `${CSS_DIAGRAM}-${CSS_STATE}`;\nvar CSS_EDGE = \"transition\";\nvar CSS_NOTE = \"note\";\nvar CSS_NOTE_EDGE = \"note-edge\";\nvar CSS_EDGE_NOTE_EDGE = `${CSS_EDGE} ${CSS_NOTE_EDGE}`;\nvar CSS_DIAGRAM_NOTE = `${CSS_DIAGRAM}-${CSS_NOTE}`;\nvar CSS_CLUSTER = \"cluster\";\nvar CSS_DIAGRAM_CLUSTER = `${CSS_DIAGRAM}-${CSS_CLUSTER}`;\nvar CSS_CLUSTER_ALT = \"cluster-alt\";\nvar CSS_DIAGRAM_CLUSTER_ALT = `${CSS_DIAGRAM}-${CSS_CLUSTER_ALT}`;\nvar PARENT = \"parent\";\nvar NOTE = \"note\";\nvar DOMID_STATE = \"state\";\nvar DOMID_TYPE_SPACER = \"----\";\nvar NOTE_ID = `${DOMID_TYPE_SPACER}${NOTE}`;\nvar PARENT_ID = `${DOMID_TYPE_SPACER}${PARENT}`;\n\n// src/diagrams/state/stateRenderer-v3-unified.ts\nvar getDir = /* @__PURE__ */ __name((parsedItem, defaultDir = DEFAULT_NESTED_DOC_DIR) => {\n  if (!parsedItem.doc) {\n    return defaultDir;\n  }\n  let dir = defaultDir;\n  for (const parsedItemDoc of parsedItem.doc) {\n    if (parsedItemDoc.stmt === \"dir\") {\n      dir = parsedItemDoc.value;\n    }\n  }\n  return dir;\n}, \"getDir\");\nvar getClasses = /* @__PURE__ */ __name(function(text, diagramObj) {\n  return diagramObj.db.getClasses();\n}, \"getClasses\");\nvar draw = /* @__PURE__ */ __name(async function(text, id, _version, diag) {\n  log.info(\"REF0:\");\n  log.info(\"Drawing state diagram (v2)\", id);\n  const { securityLevel, state: conf, layout } = getConfig();\n  diag.db.extract(diag.db.getRootDocV2());\n  const data4Layout = diag.db.getData();\n  const svg = getDiagramElement(id, securityLevel);\n  data4Layout.type = diag.type;\n  data4Layout.layoutAlgorithm = layout;\n  data4Layout.nodeSpacing = conf?.nodeSpacing || 50;\n  data4Layout.rankSpacing = conf?.rankSpacing || 50;\n  data4Layout.markers = [\"barb\"];\n  data4Layout.diagramId = id;\n  await render(data4Layout, svg);\n  const padding = 8;\n  utils_default.insertTitle(\n    svg,\n    \"statediagramTitleText\",\n    conf?.titleTopMargin ?? 25,\n    diag.db.getDiagramTitle()\n  );\n  setupViewPortForSVG(svg, padding, CSS_DIAGRAM, conf?.useMaxWidth ?? true);\n}, \"draw\");\nvar stateRenderer_v3_unified_default = {\n  getClasses,\n  draw,\n  getDir\n};\n\n// src/diagrams/state/dataFetcher.js\nvar nodeDb = /* @__PURE__ */ new Map();\nvar graphItemCount = 0;\nfunction stateDomId(itemId = \"\", counter = 0, type = \"\", typeSpacer = DOMID_TYPE_SPACER) {\n  const typeStr = type !== null && type.length > 0 ? `${typeSpacer}${type}` : \"\";\n  return `${DOMID_STATE}-${itemId}${typeStr}-${counter}`;\n}\n__name(stateDomId, \"stateDomId\");\nvar setupDoc = /* @__PURE__ */ __name((parentParsedItem, doc, diagramStates, nodes, edges, altFlag, look, classes) => {\n  log.trace(\"items\", doc);\n  doc.forEach((item) => {\n    switch (item.stmt) {\n      case STMT_STATE:\n        dataFetcher(parentParsedItem, item, diagramStates, nodes, edges, altFlag, look, classes);\n        break;\n      case DEFAULT_STATE_TYPE:\n        dataFetcher(parentParsedItem, item, diagramStates, nodes, edges, altFlag, look, classes);\n        break;\n      case STMT_RELATION:\n        {\n          dataFetcher(\n            parentParsedItem,\n            item.state1,\n            diagramStates,\n            nodes,\n            edges,\n            altFlag,\n            look,\n            classes\n          );\n          dataFetcher(\n            parentParsedItem,\n            item.state2,\n            diagramStates,\n            nodes,\n            edges,\n            altFlag,\n            look,\n            classes\n          );\n          const edgeData = {\n            id: \"edge\" + graphItemCount,\n            start: item.state1.id,\n            end: item.state2.id,\n            arrowhead: \"normal\",\n            arrowTypeEnd: \"arrow_barb\",\n            style: G_EDGE_STYLE,\n            labelStyle: \"\",\n            label: common_default.sanitizeText(item.description, getConfig()),\n            arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n            labelpos: G_EDGE_LABELPOS,\n            labelType: G_EDGE_LABELTYPE,\n            thickness: G_EDGE_THICKNESS,\n            classes: CSS_EDGE,\n            look\n          };\n          edges.push(edgeData);\n          graphItemCount++;\n        }\n        break;\n    }\n  });\n}, \"setupDoc\");\nvar getDir2 = /* @__PURE__ */ __name((parsedItem, defaultDir = DEFAULT_NESTED_DOC_DIR) => {\n  let dir = defaultDir;\n  if (parsedItem.doc) {\n    for (const parsedItemDoc of parsedItem.doc) {\n      if (parsedItemDoc.stmt === \"dir\") {\n        dir = parsedItemDoc.value;\n      }\n    }\n  }\n  return dir;\n}, \"getDir\");\nfunction insertOrUpdateNode(nodes, nodeData, classes) {\n  if (!nodeData.id || nodeData.id === \"</join></fork>\" || nodeData.id === \"</choice>\") {\n    return;\n  }\n  if (nodeData.cssClasses) {\n    if (!Array.isArray(nodeData.cssCompiledStyles)) {\n      nodeData.cssCompiledStyles = [];\n    }\n    nodeData.cssClasses.split(\" \").forEach((cssClass) => {\n      if (classes.get(cssClass)) {\n        const classDef = classes.get(cssClass);\n        nodeData.cssCompiledStyles = [...nodeData.cssCompiledStyles, ...classDef.styles];\n      }\n    });\n  }\n  const existingNodeData = nodes.find((node) => node.id === nodeData.id);\n  if (existingNodeData) {\n    Object.assign(existingNodeData, nodeData);\n  } else {\n    nodes.push(nodeData);\n  }\n}\n__name(insertOrUpdateNode, \"insertOrUpdateNode\");\nfunction getClassesFromDbInfo(dbInfoItem) {\n  return dbInfoItem?.classes?.join(\" \") ?? \"\";\n}\n__name(getClassesFromDbInfo, \"getClassesFromDbInfo\");\nfunction getStylesFromDbInfo(dbInfoItem) {\n  return dbInfoItem?.styles ?? [];\n}\n__name(getStylesFromDbInfo, \"getStylesFromDbInfo\");\nvar dataFetcher = /* @__PURE__ */ __name((parent, parsedItem, diagramStates, nodes, edges, altFlag, look, classes) => {\n  const itemId = parsedItem.id;\n  const dbState = diagramStates.get(itemId);\n  const classStr = getClassesFromDbInfo(dbState);\n  const style = getStylesFromDbInfo(dbState);\n  log.info(\"dataFetcher parsedItem\", parsedItem, dbState, style);\n  if (itemId !== \"root\") {\n    let shape = SHAPE_STATE;\n    if (parsedItem.start === true) {\n      shape = SHAPE_START;\n    } else if (parsedItem.start === false) {\n      shape = SHAPE_END;\n    }\n    if (parsedItem.type !== DEFAULT_STATE_TYPE) {\n      shape = parsedItem.type;\n    }\n    if (!nodeDb.get(itemId)) {\n      nodeDb.set(itemId, {\n        id: itemId,\n        shape,\n        description: common_default.sanitizeText(itemId, getConfig()),\n        cssClasses: `${classStr} ${CSS_DIAGRAM_STATE}`,\n        cssStyles: style\n      });\n    }\n    const newNode = nodeDb.get(itemId);\n    if (parsedItem.description) {\n      if (Array.isArray(newNode.description)) {\n        newNode.shape = SHAPE_STATE_WITH_DESC;\n        newNode.description.push(parsedItem.description);\n      } else {\n        if (newNode.description?.length > 0) {\n          newNode.shape = SHAPE_STATE_WITH_DESC;\n          if (newNode.description === itemId) {\n            newNode.description = [parsedItem.description];\n          } else {\n            newNode.description = [newNode.description, parsedItem.description];\n          }\n        } else {\n          newNode.shape = SHAPE_STATE;\n          newNode.description = parsedItem.description;\n        }\n      }\n      newNode.description = common_default.sanitizeTextOrArray(newNode.description, getConfig());\n    }\n    if (newNode.description?.length === 1 && newNode.shape === SHAPE_STATE_WITH_DESC) {\n      if (newNode.type === \"group\") {\n        newNode.shape = SHAPE_GROUP;\n      } else {\n        newNode.shape = SHAPE_STATE;\n      }\n    }\n    if (!newNode.type && parsedItem.doc) {\n      log.info(\"Setting cluster for XCX\", itemId, getDir2(parsedItem));\n      newNode.type = \"group\";\n      newNode.isGroup = true;\n      newNode.dir = getDir2(parsedItem);\n      newNode.shape = parsedItem.type === DIVIDER_TYPE ? SHAPE_DIVIDER : SHAPE_GROUP;\n      newNode.cssClasses = `${newNode.cssClasses} ${CSS_DIAGRAM_CLUSTER} ${altFlag ? CSS_DIAGRAM_CLUSTER_ALT : \"\"}`;\n    }\n    const nodeData = {\n      labelStyle: \"\",\n      shape: newNode.shape,\n      label: newNode.description,\n      cssClasses: newNode.cssClasses,\n      cssCompiledStyles: [],\n      cssStyles: newNode.cssStyles,\n      id: itemId,\n      dir: newNode.dir,\n      domId: stateDomId(itemId, graphItemCount),\n      type: newNode.type,\n      isGroup: newNode.type === \"group\",\n      padding: 8,\n      rx: 10,\n      ry: 10,\n      look\n    };\n    if (nodeData.shape === SHAPE_DIVIDER) {\n      nodeData.label = \"\";\n    }\n    if (parent && parent.id !== \"root\") {\n      log.trace(\"Setting node \", itemId, \" to be child of its parent \", parent.id);\n      nodeData.parentId = parent.id;\n    }\n    nodeData.centerLabel = true;\n    if (parsedItem.note) {\n      const noteData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTE,\n        label: parsedItem.note.text,\n        cssClasses: CSS_DIAGRAM_NOTE,\n        // useHtmlLabels: false,\n        cssStyles: [],\n        cssCompilesStyles: [],\n        id: itemId + NOTE_ID + \"-\" + graphItemCount,\n        domId: stateDomId(itemId, graphItemCount, NOTE),\n        type: newNode.type,\n        isGroup: newNode.type === \"group\",\n        padding: getConfig().flowchart.padding,\n        look,\n        position: parsedItem.note.position\n      };\n      const parentNodeId = itemId + PARENT_ID;\n      const groupData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTEGROUP,\n        label: parsedItem.note.text,\n        cssClasses: newNode.cssClasses,\n        cssStyles: [],\n        id: itemId + PARENT_ID,\n        domId: stateDomId(itemId, graphItemCount, PARENT),\n        type: \"group\",\n        isGroup: true,\n        padding: 16,\n        //getConfig().flowchart.padding\n        look,\n        position: parsedItem.note.position\n      };\n      graphItemCount++;\n      groupData.id = parentNodeId;\n      noteData.parentId = parentNodeId;\n      insertOrUpdateNode(nodes, groupData, classes);\n      insertOrUpdateNode(nodes, noteData, classes);\n      insertOrUpdateNode(nodes, nodeData, classes);\n      let from = itemId;\n      let to = noteData.id;\n      if (parsedItem.note.position === \"left of\") {\n        from = noteData.id;\n        to = itemId;\n      }\n      edges.push({\n        id: from + \"-\" + to,\n        start: from,\n        end: to,\n        arrowhead: \"none\",\n        arrowTypeEnd: \"\",\n        style: G_EDGE_STYLE,\n        labelStyle: \"\",\n        classes: CSS_EDGE_NOTE_EDGE,\n        arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n        labelpos: G_EDGE_LABELPOS,\n        labelType: G_EDGE_LABELTYPE,\n        thickness: G_EDGE_THICKNESS,\n        look\n      });\n    } else {\n      insertOrUpdateNode(nodes, nodeData, classes);\n    }\n  }\n  if (parsedItem.doc) {\n    log.trace(\"Adding nodes children \");\n    setupDoc(parsedItem, parsedItem.doc, diagramStates, nodes, edges, !altFlag, look, classes);\n  }\n}, \"dataFetcher\");\nvar reset = /* @__PURE__ */ __name(() => {\n  nodeDb.clear();\n  graphItemCount = 0;\n}, \"reset\");\n\n// src/diagrams/state/stateDb.js\nvar START_NODE = \"[*]\";\nvar START_TYPE = \"start\";\nvar END_NODE = START_NODE;\nvar END_TYPE = \"end\";\nvar COLOR_KEYWORD = \"color\";\nvar FILL_KEYWORD = \"fill\";\nvar BG_FILL = \"bgFill\";\nvar STYLECLASS_SEP = \",\";\nfunction newClassesList() {\n  return /* @__PURE__ */ new Map();\n}\n__name(newClassesList, \"newClassesList\");\nvar newDoc = /* @__PURE__ */ __name(() => {\n  return {\n    /** @type {{ id1: string, id2: string, relationTitle: string }[]} */\n    relations: [],\n    states: /* @__PURE__ */ new Map(),\n    documents: {}\n  };\n}, \"newDoc\");\nvar clone = /* @__PURE__ */ __name((o) => JSON.parse(JSON.stringify(o)), \"clone\");\nvar StateDB = class {\n  static {\n    __name(this, \"StateDB\");\n  }\n  /**\n   * @param {1 | 2} version - v1 renderer or v2 renderer.\n   */\n  constructor(version) {\n    this.clear();\n    this.version = version;\n    this.setRootDoc = this.setRootDoc.bind(this);\n    this.getDividerId = this.getDividerId.bind(this);\n    this.setDirection = this.setDirection.bind(this);\n    this.trimColon = this.trimColon.bind(this);\n  }\n  /**\n   * @private\n   * @type {1 | 2}\n   */\n  version;\n  /**\n   * @private\n   * @type {Array}\n   */\n  nodes = [];\n  /**\n   * @private\n   * @type {Array}\n   */\n  edges = [];\n  /**\n   * @private\n   * @type {Array}\n   */\n  rootDoc = [];\n  /**\n   * @private\n   * @type {Map<string, any>}\n   */\n  classes = newClassesList();\n  // style classes defined by a classDef\n  /**\n   * @private\n   * @type {Object}\n   */\n  documents = {\n    root: newDoc()\n  };\n  /**\n   * @private\n   * @type {Object}\n   */\n  currentDocument = this.documents.root;\n  /**\n   * @private\n   * @type {number}\n   */\n  startEndCount = 0;\n  /**\n   * @private\n   * @type {number}\n   */\n  dividerCnt = 0;\n  static relationType = {\n    AGGREGATION: 0,\n    EXTENSION: 1,\n    COMPOSITION: 2,\n    DEPENDENCY: 3\n  };\n  setRootDoc(o) {\n    log.info(\"Setting root doc\", o);\n    this.rootDoc = o;\n    if (this.version === 1) {\n      this.extract(o);\n    } else {\n      this.extract(this.getRootDocV2());\n    }\n  }\n  getRootDoc() {\n    return this.rootDoc;\n  }\n  /**\n   * @private\n   * @param {Object} parent\n   * @param {Object} node\n   * @param {boolean} first\n   */\n  docTranslator(parent, node, first) {\n    if (node.stmt === STMT_RELATION) {\n      this.docTranslator(parent, node.state1, true);\n      this.docTranslator(parent, node.state2, false);\n    } else {\n      if (node.stmt === STMT_STATE) {\n        if (node.id === \"[*]\") {\n          node.id = first ? parent.id + \"_start\" : parent.id + \"_end\";\n          node.start = first;\n        } else {\n          node.id = node.id.trim();\n        }\n      }\n      if (node.doc) {\n        const doc = [];\n        let currentDoc = [];\n        let i;\n        for (i = 0; i < node.doc.length; i++) {\n          if (node.doc[i].type === DIVIDER_TYPE) {\n            const newNode = clone(node.doc[i]);\n            newNode.doc = clone(currentDoc);\n            doc.push(newNode);\n            currentDoc = [];\n          } else {\n            currentDoc.push(node.doc[i]);\n          }\n        }\n        if (doc.length > 0 && currentDoc.length > 0) {\n          const newNode = {\n            stmt: STMT_STATE,\n            id: generateId(),\n            type: \"divider\",\n            doc: clone(currentDoc)\n          };\n          doc.push(clone(newNode));\n          node.doc = doc;\n        }\n        node.doc.forEach((docNode) => this.docTranslator(node, docNode, true));\n      }\n    }\n  }\n  /**\n   * @private\n   */\n  getRootDocV2() {\n    this.docTranslator({ id: \"root\" }, { id: \"root\", doc: this.rootDoc }, true);\n    return { id: \"root\", doc: this.rootDoc };\n  }\n  /**\n   * Convert all of the statements (stmts) that were parsed into states and relationships.\n   * This is done because a state diagram may have nested sections,\n   * where each section is a 'document' and has its own set of statements.\n   * Ex: the section within a fork has its own statements, and incoming and outgoing statements\n   * refer to the fork as a whole (document).\n   * See the parser grammar:  the definition of a document is a document then a 'line', where a line can be a statement.\n   * This will push the statement into the list of statements for the current document.\n   * @private\n   * @param _doc\n   */\n  extract(_doc) {\n    let doc;\n    if (_doc.doc) {\n      doc = _doc.doc;\n    } else {\n      doc = _doc;\n    }\n    log.info(doc);\n    this.clear(true);\n    log.info(\"Extract initial document:\", doc);\n    doc.forEach((item) => {\n      log.warn(\"Statement\", item.stmt);\n      switch (item.stmt) {\n        case STMT_STATE:\n          this.addState(\n            item.id.trim(),\n            item.type,\n            item.doc,\n            item.description,\n            item.note,\n            item.classes,\n            item.styles,\n            item.textStyles\n          );\n          break;\n        case STMT_RELATION:\n          this.addRelation(item.state1, item.state2, item.description);\n          break;\n        case STMT_CLASSDEF:\n          this.addStyleClass(item.id.trim(), item.classes);\n          break;\n        case STMT_STYLEDEF:\n          {\n            const ids = item.id.trim().split(\",\");\n            const styles = item.styleClass.split(\",\");\n            ids.forEach((id) => {\n              let foundState = this.getState(id);\n              if (foundState === void 0) {\n                const trimmedId = id.trim();\n                this.addState(trimmedId);\n                foundState = this.getState(trimmedId);\n              }\n              foundState.styles = styles.map((s) => s.replace(/;/g, \"\")?.trim());\n            });\n          }\n          break;\n        case STMT_APPLYCLASS:\n          this.setCssClass(item.id.trim(), item.styleClass);\n          break;\n      }\n    });\n    const diagramStates = this.getStates();\n    const config = getConfig();\n    const look = config.look;\n    reset();\n    dataFetcher(\n      void 0,\n      this.getRootDocV2(),\n      diagramStates,\n      this.nodes,\n      this.edges,\n      true,\n      look,\n      this.classes\n    );\n    this.nodes.forEach((node) => {\n      if (Array.isArray(node.label)) {\n        node.description = node.label.slice(1);\n        if (node.isGroup && node.description.length > 0) {\n          throw new Error(\n            \"Group nodes can only have label. Remove the additional description for node [\" + node.id + \"]\"\n          );\n        }\n        node.label = node.label[0];\n      }\n    });\n  }\n  /**\n   * Function called by parser when a node definition has been found.\n   *\n   * @param {null | string} id\n   * @param {null | string} type\n   * @param {null | string} doc\n   * @param {null | string | string[]} descr - description for the state. Can be a string or a list or strings\n   * @param {null | string} note\n   * @param {null | string | string[]} classes - class styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 class, convert it to an array of that 1 class.\n   * @param {null | string | string[]} styles - styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 style, convert it to an array of that 1 style.\n   * @param {null | string | string[]} textStyles - text styles to apply to this state. Can be a string (1 text test) or an array of text styles. If it's just 1 text style, convert it to an array of that 1 text style.\n   */\n  addState(id, type = DEFAULT_STATE_TYPE, doc = null, descr = null, note = null, classes = null, styles = null, textStyles = null) {\n    const trimmedId = id?.trim();\n    if (!this.currentDocument.states.has(trimmedId)) {\n      log.info(\"Adding state \", trimmedId, descr);\n      this.currentDocument.states.set(trimmedId, {\n        id: trimmedId,\n        descriptions: [],\n        type,\n        doc,\n        note,\n        classes: [],\n        styles: [],\n        textStyles: []\n      });\n    } else {\n      if (!this.currentDocument.states.get(trimmedId).doc) {\n        this.currentDocument.states.get(trimmedId).doc = doc;\n      }\n      if (!this.currentDocument.states.get(trimmedId).type) {\n        this.currentDocument.states.get(trimmedId).type = type;\n      }\n    }\n    if (descr) {\n      log.info(\"Setting state description\", trimmedId, descr);\n      if (typeof descr === \"string\") {\n        this.addDescription(trimmedId, descr.trim());\n      }\n      if (typeof descr === \"object\") {\n        descr.forEach((des) => this.addDescription(trimmedId, des.trim()));\n      }\n    }\n    if (note) {\n      const doc2 = this.currentDocument.states.get(trimmedId);\n      doc2.note = note;\n      doc2.note.text = common_default.sanitizeText(doc2.note.text, getConfig());\n    }\n    if (classes) {\n      log.info(\"Setting state classes\", trimmedId, classes);\n      const classesList = typeof classes === \"string\" ? [classes] : classes;\n      classesList.forEach((cssClass) => this.setCssClass(trimmedId, cssClass.trim()));\n    }\n    if (styles) {\n      log.info(\"Setting state styles\", trimmedId, styles);\n      const stylesList = typeof styles === \"string\" ? [styles] : styles;\n      stylesList.forEach((style) => this.setStyle(trimmedId, style.trim()));\n    }\n    if (textStyles) {\n      log.info(\"Setting state styles\", trimmedId, styles);\n      const textStylesList = typeof textStyles === \"string\" ? [textStyles] : textStyles;\n      textStylesList.forEach((textStyle) => this.setTextStyle(trimmedId, textStyle.trim()));\n    }\n  }\n  clear(saveCommon) {\n    this.nodes = [];\n    this.edges = [];\n    this.documents = {\n      root: newDoc()\n    };\n    this.currentDocument = this.documents.root;\n    this.startEndCount = 0;\n    this.classes = newClassesList();\n    if (!saveCommon) {\n      clear();\n    }\n  }\n  getState(id) {\n    return this.currentDocument.states.get(id);\n  }\n  getStates() {\n    return this.currentDocument.states;\n  }\n  logDocuments() {\n    log.info(\"Documents = \", this.documents);\n  }\n  getRelations() {\n    return this.currentDocument.relations;\n  }\n  /**\n   * If the id is a start node ( [*] ), then return a new id constructed from\n   * the start node name and the current start node count.\n   * else return the given id\n   *\n   * @param {string} id\n   * @returns {string} - the id (original or constructed)\n   * @private\n   */\n  startIdIfNeeded(id = \"\") {\n    let fixedId = id;\n    if (id === START_NODE) {\n      this.startEndCount++;\n      fixedId = `${START_TYPE}${this.startEndCount}`;\n    }\n    return fixedId;\n  }\n  /**\n   * If the id is a start node ( [*] ), then return the start type ('start')\n   * else return the given type\n   *\n   * @param {string} id\n   * @param {string} type\n   * @returns {string} - the type that should be used\n   * @private\n   */\n  startTypeIfNeeded(id = \"\", type = DEFAULT_STATE_TYPE) {\n    return id === START_NODE ? START_TYPE : type;\n  }\n  /**\n   * If the id is an end node ( [*] ), then return a new id constructed from\n   * the end node name and the current start_end node count.\n   * else return the given id\n   *\n   * @param {string} id\n   * @returns {string} - the id (original or constructed)\n   * @private\n   */\n  endIdIfNeeded(id = \"\") {\n    let fixedId = id;\n    if (id === END_NODE) {\n      this.startEndCount++;\n      fixedId = `${END_TYPE}${this.startEndCount}`;\n    }\n    return fixedId;\n  }\n  /**\n   * If the id is an end node ( [*] ), then return the end type\n   * else return the given type\n   *\n   * @param {string} id\n   * @param {string} type\n   * @returns {string} - the type that should be used\n   * @private\n   */\n  endTypeIfNeeded(id = \"\", type = DEFAULT_STATE_TYPE) {\n    return id === END_NODE ? END_TYPE : type;\n  }\n  /**\n   *\n   * @param item1\n   * @param item2\n   * @param relationTitle\n   */\n  addRelationObjs(item1, item2, relationTitle) {\n    let id1 = this.startIdIfNeeded(item1.id.trim());\n    let type1 = this.startTypeIfNeeded(item1.id.trim(), item1.type);\n    let id2 = this.startIdIfNeeded(item2.id.trim());\n    let type2 = this.startTypeIfNeeded(item2.id.trim(), item2.type);\n    this.addState(\n      id1,\n      type1,\n      item1.doc,\n      item1.description,\n      item1.note,\n      item1.classes,\n      item1.styles,\n      item1.textStyles\n    );\n    this.addState(\n      id2,\n      type2,\n      item2.doc,\n      item2.description,\n      item2.note,\n      item2.classes,\n      item2.styles,\n      item2.textStyles\n    );\n    this.currentDocument.relations.push({\n      id1,\n      id2,\n      relationTitle: common_default.sanitizeText(relationTitle, getConfig())\n    });\n  }\n  /**\n   * Add a relation between two items.  The items may be full objects or just the string id of a state.\n   *\n   * @param {string | object} item1\n   * @param {string | object} item2\n   * @param {string} title\n   */\n  addRelation(item1, item2, title) {\n    if (typeof item1 === \"object\") {\n      this.addRelationObjs(item1, item2, title);\n    } else {\n      const id1 = this.startIdIfNeeded(item1.trim());\n      const type1 = this.startTypeIfNeeded(item1);\n      const id2 = this.endIdIfNeeded(item2.trim());\n      const type2 = this.endTypeIfNeeded(item2);\n      this.addState(id1, type1);\n      this.addState(id2, type2);\n      this.currentDocument.relations.push({\n        id1,\n        id2,\n        title: common_default.sanitizeText(title, getConfig())\n      });\n    }\n  }\n  addDescription(id, descr) {\n    const theState = this.currentDocument.states.get(id);\n    const _descr = descr.startsWith(\":\") ? descr.replace(\":\", \"\").trim() : descr;\n    theState.descriptions.push(common_default.sanitizeText(_descr, getConfig()));\n  }\n  cleanupLabel(label) {\n    if (label.substring(0, 1) === \":\") {\n      return label.substr(2).trim();\n    } else {\n      return label.trim();\n    }\n  }\n  getDividerId() {\n    this.dividerCnt++;\n    return \"divider-id-\" + this.dividerCnt;\n  }\n  /**\n   * Called when the parser comes across a (style) class definition\n   * @example classDef my-style fill:#f96;\n   *\n   * @param {string} id - the id of this (style) class\n   * @param  {string | null} styleAttributes - the string with 1 or more style attributes (each separated by a comma)\n   */\n  addStyleClass(id, styleAttributes = \"\") {\n    if (!this.classes.has(id)) {\n      this.classes.set(id, { id, styles: [], textStyles: [] });\n    }\n    const foundClass = this.classes.get(id);\n    if (styleAttributes !== void 0 && styleAttributes !== null) {\n      styleAttributes.split(STYLECLASS_SEP).forEach((attrib) => {\n        const fixedAttrib = attrib.replace(/([^;]*);/, \"$1\").trim();\n        if (RegExp(COLOR_KEYWORD).exec(attrib)) {\n          const newStyle1 = fixedAttrib.replace(FILL_KEYWORD, BG_FILL);\n          const newStyle2 = newStyle1.replace(COLOR_KEYWORD, FILL_KEYWORD);\n          foundClass.textStyles.push(newStyle2);\n        }\n        foundClass.styles.push(fixedAttrib);\n      });\n    }\n  }\n  /**\n   * Return all of the style classes\n   * @returns {{} | any | classes}\n   */\n  getClasses() {\n    return this.classes;\n  }\n  /**\n   * Add a (style) class or css class to a state with the given id.\n   * If the state isn't already in the list of known states, add it.\n   * Might be called by parser when a style class or CSS class should be applied to a state\n   *\n   * @param {string | string[]} itemIds The id or a list of ids of the item(s) to apply the css class to\n   * @param {string} cssClassName CSS class name\n   */\n  setCssClass(itemIds, cssClassName) {\n    itemIds.split(\",\").forEach((id) => {\n      let foundState = this.getState(id);\n      if (foundState === void 0) {\n        const trimmedId = id.trim();\n        this.addState(trimmedId);\n        foundState = this.getState(trimmedId);\n      }\n      foundState.classes.push(cssClassName);\n    });\n  }\n  /**\n   * Add a style to a state with the given id.\n   * @example style stateId fill:#f9f,stroke:#333,stroke-width:4px\n   *   where 'style' is the keyword\n   *   stateId is the id of a state\n   *   the rest of the string is the styleText (all of the attributes to be applied to the state)\n   *\n   * @param itemId The id of item to apply the style to\n   * @param styleText - the text of the attributes for the style\n   */\n  setStyle(itemId, styleText) {\n    const item = this.getState(itemId);\n    if (item !== void 0) {\n      item.styles.push(styleText);\n    }\n  }\n  /**\n   * Add a text style to a state with the given id\n   *\n   * @param itemId The id of item to apply the css class to\n   * @param cssClassName CSS class name\n   */\n  setTextStyle(itemId, cssClassName) {\n    const item = this.getState(itemId);\n    if (item !== void 0) {\n      item.textStyles.push(cssClassName);\n    }\n  }\n  /**\n   * Finds the direction statement in the root document.\n   * @private\n   * @returns {{ value: string } | undefined} - the direction statement if present\n   */\n  getDirectionStatement() {\n    return this.rootDoc.find((doc) => doc.stmt === STMT_DIRECTION);\n  }\n  getDirection() {\n    return this.getDirectionStatement()?.value ?? DEFAULT_DIAGRAM_DIRECTION;\n  }\n  setDirection(dir) {\n    const doc = this.getDirectionStatement();\n    if (doc) {\n      doc.value = dir;\n    } else {\n      this.rootDoc.unshift({ stmt: STMT_DIRECTION, value: dir });\n    }\n  }\n  trimColon(str) {\n    return str && str[0] === \":\" ? str.substr(1).trim() : str.trim();\n  }\n  getData() {\n    const config = getConfig();\n    return {\n      nodes: this.nodes,\n      edges: this.edges,\n      other: {},\n      config,\n      direction: getDir(this.getRootDocV2())\n    };\n  }\n  getConfig() {\n    return getConfig().state;\n  }\n  getAccTitle = getAccTitle;\n  setAccTitle = setAccTitle;\n  getAccDescription = getAccDescription;\n  setAccDescription = setAccDescription;\n  setDiagramTitle = setDiagramTitle;\n  getDiagramTitle = getDiagramTitle;\n};\n\n// src/diagrams/state/styles.js\nvar getStyles = /* @__PURE__ */ __name((options) => `\ndefs #statediagram-barbEnd {\n    fill: ${options.transitionColor};\n    stroke: ${options.transitionColor};\n  }\ng.stateGroup text {\n  fill: ${options.nodeBorder};\n  stroke: none;\n  font-size: 10px;\n}\ng.stateGroup text {\n  fill: ${options.textColor};\n  stroke: none;\n  font-size: 10px;\n\n}\ng.stateGroup .state-title {\n  font-weight: bolder;\n  fill: ${options.stateLabelColor};\n}\n\ng.stateGroup rect {\n  fill: ${options.mainBkg};\n  stroke: ${options.nodeBorder};\n}\n\ng.stateGroup line {\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n}\n\n.transition {\n  stroke: ${options.transitionColor};\n  stroke-width: 1;\n  fill: none;\n}\n\n.stateGroup .composit {\n  fill: ${options.background};\n  border-bottom: 1px\n}\n\n.stateGroup .alt-composit {\n  fill: #e0e0e0;\n  border-bottom: 1px\n}\n\n.state-note {\n  stroke: ${options.noteBorderColor};\n  fill: ${options.noteBkgColor};\n\n  text {\n    fill: ${options.noteTextColor};\n    stroke: none;\n    font-size: 10px;\n  }\n}\n\n.stateLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ${options.mainBkg};\n  opacity: 0.5;\n}\n\n.edgeLabel .label rect {\n  fill: ${options.labelBackgroundColor};\n  opacity: 0.5;\n}\n.edgeLabel {\n  background-color: ${options.edgeLabelBackground};\n  p {\n    background-color: ${options.edgeLabelBackground};\n  }\n  rect {\n    opacity: 0.5;\n    background-color: ${options.edgeLabelBackground};\n    fill: ${options.edgeLabelBackground};\n  }\n  text-align: center;\n}\n.edgeLabel .label text {\n  fill: ${options.transitionLabelColor || options.tertiaryTextColor};\n}\n.label div .edgeLabel {\n  color: ${options.transitionLabelColor || options.tertiaryTextColor};\n}\n\n.stateLabel text {\n  fill: ${options.stateLabelColor};\n  font-size: 10px;\n  font-weight: bold;\n}\n\n.node circle.state-start {\n  fill: ${options.specialStateColor};\n  stroke: ${options.specialStateColor};\n}\n\n.node .fork-join {\n  fill: ${options.specialStateColor};\n  stroke: ${options.specialStateColor};\n}\n\n.node circle.state-end {\n  fill: ${options.innerEndBackground};\n  stroke: ${options.background};\n  stroke-width: 1.5\n}\n.end-state-inner {\n  fill: ${options.compositeBackground || options.background};\n  // stroke: ${options.background};\n  stroke-width: 1.5\n}\n\n.node rect {\n  fill: ${options.stateBkg || options.mainBkg};\n  stroke: ${options.stateBorder || options.nodeBorder};\n  stroke-width: 1px;\n}\n.node polygon {\n  fill: ${options.mainBkg};\n  stroke: ${options.stateBorder || options.nodeBorder};;\n  stroke-width: 1px;\n}\n#statediagram-barbEnd {\n  fill: ${options.lineColor};\n}\n\n.statediagram-cluster rect {\n  fill: ${options.compositeTitleBackground};\n  stroke: ${options.stateBorder || options.nodeBorder};\n  stroke-width: 1px;\n}\n\n.cluster-label, .nodeLabel {\n  color: ${options.stateLabelColor};\n  // line-height: 1;\n}\n\n.statediagram-cluster rect.outer {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state .divider {\n  stroke: ${options.stateBorder || options.nodeBorder};\n}\n\n.statediagram-state .title-state {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-cluster.statediagram-cluster .inner {\n  fill: ${options.compositeBackground || options.background};\n}\n.statediagram-cluster.statediagram-cluster-alt .inner {\n  fill: ${options.altBackground ? options.altBackground : \"#efefef\"};\n}\n\n.statediagram-cluster .inner {\n  rx:0;\n  ry:0;\n}\n\n.statediagram-state rect.basic {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state rect.divider {\n  stroke-dasharray: 10,10;\n  fill: ${options.altBackground ? options.altBackground : \"#efefef\"};\n}\n\n.note-edge {\n  stroke-dasharray: 5;\n}\n\n.statediagram-note rect {\n  fill: ${options.noteBkgColor};\n  stroke: ${options.noteBorderColor};\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n.statediagram-note rect {\n  fill: ${options.noteBkgColor};\n  stroke: ${options.noteBorderColor};\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n\n.statediagram-note text {\n  fill: ${options.noteTextColor};\n}\n\n.statediagram-note .nodeLabel {\n  color: ${options.noteTextColor};\n}\n.statediagram .edgeLabel {\n  color: red; // ${options.noteTextColor};\n}\n\n#dependencyStart, #dependencyEnd {\n  fill: ${options.lineColor};\n  stroke: ${options.lineColor};\n  stroke-width: 1;\n}\n\n.statediagramTitleText {\n  text-anchor: middle;\n  font-size: 18px;\n  fill: ${options.textColor};\n}\n`, \"getStyles\");\nvar styles_default = getStyles;\n\nexport {\n  stateDiagram_default,\n  stateRenderer_v3_unified_default,\n  StateDB,\n  styles_default\n};\n","/******************************************************************************\n * This file was generated by langium-cli 3.3.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\nimport { AbstractAstReflection } from '../../syntax-tree.js';\nexport const LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\nexport const AbstractRule = 'AbstractRule';\nexport function isAbstractRule(item) {\n    return reflection.isInstance(item, AbstractRule);\n}\nexport const AbstractType = 'AbstractType';\nexport function isAbstractType(item) {\n    return reflection.isInstance(item, AbstractType);\n}\nexport const Condition = 'Condition';\nexport function isCondition(item) {\n    return reflection.isInstance(item, Condition);\n}\nexport function isFeatureName(item) {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\nexport function isPrimitiveType(item) {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\nexport const TypeDefinition = 'TypeDefinition';\nexport function isTypeDefinition(item) {\n    return reflection.isInstance(item, TypeDefinition);\n}\nexport const ValueLiteral = 'ValueLiteral';\nexport function isValueLiteral(item) {\n    return reflection.isInstance(item, ValueLiteral);\n}\nexport const AbstractElement = 'AbstractElement';\nexport function isAbstractElement(item) {\n    return reflection.isInstance(item, AbstractElement);\n}\nexport const ArrayLiteral = 'ArrayLiteral';\nexport function isArrayLiteral(item) {\n    return reflection.isInstance(item, ArrayLiteral);\n}\nexport const ArrayType = 'ArrayType';\nexport function isArrayType(item) {\n    return reflection.isInstance(item, ArrayType);\n}\nexport const BooleanLiteral = 'BooleanLiteral';\nexport function isBooleanLiteral(item) {\n    return reflection.isInstance(item, BooleanLiteral);\n}\nexport const Conjunction = 'Conjunction';\nexport function isConjunction(item) {\n    return reflection.isInstance(item, Conjunction);\n}\nexport const Disjunction = 'Disjunction';\nexport function isDisjunction(item) {\n    return reflection.isInstance(item, Disjunction);\n}\nexport const Grammar = 'Grammar';\nexport function isGrammar(item) {\n    return reflection.isInstance(item, Grammar);\n}\nexport const GrammarImport = 'GrammarImport';\nexport function isGrammarImport(item) {\n    return reflection.isInstance(item, GrammarImport);\n}\nexport const InferredType = 'InferredType';\nexport function isInferredType(item) {\n    return reflection.isInstance(item, InferredType);\n}\nexport const Interface = 'Interface';\nexport function isInterface(item) {\n    return reflection.isInstance(item, Interface);\n}\nexport const NamedArgument = 'NamedArgument';\nexport function isNamedArgument(item) {\n    return reflection.isInstance(item, NamedArgument);\n}\nexport const Negation = 'Negation';\nexport function isNegation(item) {\n    return reflection.isInstance(item, Negation);\n}\nexport const NumberLiteral = 'NumberLiteral';\nexport function isNumberLiteral(item) {\n    return reflection.isInstance(item, NumberLiteral);\n}\nexport const Parameter = 'Parameter';\nexport function isParameter(item) {\n    return reflection.isInstance(item, Parameter);\n}\nexport const ParameterReference = 'ParameterReference';\nexport function isParameterReference(item) {\n    return reflection.isInstance(item, ParameterReference);\n}\nexport const ParserRule = 'ParserRule';\nexport function isParserRule(item) {\n    return reflection.isInstance(item, ParserRule);\n}\nexport const ReferenceType = 'ReferenceType';\nexport function isReferenceType(item) {\n    return reflection.isInstance(item, ReferenceType);\n}\nexport const ReturnType = 'ReturnType';\nexport function isReturnType(item) {\n    return reflection.isInstance(item, ReturnType);\n}\nexport const SimpleType = 'SimpleType';\nexport function isSimpleType(item) {\n    return reflection.isInstance(item, SimpleType);\n}\nexport const StringLiteral = 'StringLiteral';\nexport function isStringLiteral(item) {\n    return reflection.isInstance(item, StringLiteral);\n}\nexport const TerminalRule = 'TerminalRule';\nexport function isTerminalRule(item) {\n    return reflection.isInstance(item, TerminalRule);\n}\nexport const Type = 'Type';\nexport function isType(item) {\n    return reflection.isInstance(item, Type);\n}\nexport const TypeAttribute = 'TypeAttribute';\nexport function isTypeAttribute(item) {\n    return reflection.isInstance(item, TypeAttribute);\n}\nexport const UnionType = 'UnionType';\nexport function isUnionType(item) {\n    return reflection.isInstance(item, UnionType);\n}\nexport const Action = 'Action';\nexport function isAction(item) {\n    return reflection.isInstance(item, Action);\n}\nexport const Alternatives = 'Alternatives';\nexport function isAlternatives(item) {\n    return reflection.isInstance(item, Alternatives);\n}\nexport const Assignment = 'Assignment';\nexport function isAssignment(item) {\n    return reflection.isInstance(item, Assignment);\n}\nexport const CharacterRange = 'CharacterRange';\nexport function isCharacterRange(item) {\n    return reflection.isInstance(item, CharacterRange);\n}\nexport const CrossReference = 'CrossReference';\nexport function isCrossReference(item) {\n    return reflection.isInstance(item, CrossReference);\n}\nexport const EndOfFile = 'EndOfFile';\nexport function isEndOfFile(item) {\n    return reflection.isInstance(item, EndOfFile);\n}\nexport const Group = 'Group';\nexport function isGroup(item) {\n    return reflection.isInstance(item, Group);\n}\nexport const Keyword = 'Keyword';\nexport function isKeyword(item) {\n    return reflection.isInstance(item, Keyword);\n}\nexport const NegatedToken = 'NegatedToken';\nexport function isNegatedToken(item) {\n    return reflection.isInstance(item, NegatedToken);\n}\nexport const RegexToken = 'RegexToken';\nexport function isRegexToken(item) {\n    return reflection.isInstance(item, RegexToken);\n}\nexport const RuleCall = 'RuleCall';\nexport function isRuleCall(item) {\n    return reflection.isInstance(item, RuleCall);\n}\nexport const TerminalAlternatives = 'TerminalAlternatives';\nexport function isTerminalAlternatives(item) {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\nexport const TerminalGroup = 'TerminalGroup';\nexport function isTerminalGroup(item) {\n    return reflection.isInstance(item, TerminalGroup);\n}\nexport const TerminalRuleCall = 'TerminalRuleCall';\nexport function isTerminalRuleCall(item) {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\nexport const UnorderedGroup = 'UnorderedGroup';\nexport function isUnorderedGroup(item) {\n    return reflection.isInstance(item, UnorderedGroup);\n}\nexport const UntilToken = 'UntilToken';\nexport function isUntilToken(item) {\n    return reflection.isInstance(item, UntilToken);\n}\nexport const Wildcard = 'Wildcard';\nexport function isWildcard(item) {\n    return reflection.isInstance(item, Wildcard);\n}\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n    getAllTypes() {\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n    getTypeMetaData(type) {\n        switch (type) {\n            case AbstractElement: {\n                return {\n                    name: AbstractElement,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case ArrayLiteral: {\n                return {\n                    name: ArrayLiteral,\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case ArrayType: {\n                return {\n                    name: ArrayType,\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case BooleanLiteral: {\n                return {\n                    name: BooleanLiteral,\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case Conjunction: {\n                return {\n                    name: Conjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Disjunction: {\n                return {\n                    name: Disjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Grammar: {\n                return {\n                    name: Grammar,\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case GrammarImport: {\n                return {\n                    name: GrammarImport,\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case InferredType: {\n                return {\n                    name: InferredType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case Interface: {\n                return {\n                    name: Interface,\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case NamedArgument: {\n                return {\n                    name: NamedArgument,\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Negation: {\n                return {\n                    name: Negation,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NumberLiteral: {\n                return {\n                    name: NumberLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Parameter: {\n                return {\n                    name: Parameter,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case ParameterReference: {\n                return {\n                    name: ParameterReference,\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case ParserRule: {\n                return {\n                    name: ParserRule,\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case ReferenceType: {\n                return {\n                    name: ReferenceType,\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case ReturnType: {\n                return {\n                    name: ReturnType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case SimpleType: {\n                return {\n                    name: SimpleType,\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case StringLiteral: {\n                return {\n                    name: StringLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case TerminalRule: {\n                return {\n                    name: TerminalRule,\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Type: {\n                return {\n                    name: Type,\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case TypeAttribute: {\n                return {\n                    name: TypeAttribute,\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case UnionType: {\n                return {\n                    name: UnionType,\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case Action: {\n                return {\n                    name: Action,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Alternatives: {\n                return {\n                    name: Alternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Assignment: {\n                return {\n                    name: Assignment,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case CharacterRange: {\n                return {\n                    name: CharacterRange,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case CrossReference: {\n                return {\n                    name: CrossReference,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case EndOfFile: {\n                return {\n                    name: EndOfFile,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Group: {\n                return {\n                    name: Group,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Keyword: {\n                return {\n                    name: Keyword,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NegatedToken: {\n                return {\n                    name: NegatedToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case RegexToken: {\n                return {\n                    name: RegexToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case RuleCall: {\n                return {\n                    name: RuleCall,\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case TerminalAlternatives: {\n                return {\n                    name: TerminalAlternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalGroup: {\n                return {\n                    name: TerminalGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalRuleCall: {\n                return {\n                    name: TerminalRuleCall,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case UnorderedGroup: {\n                return {\n                    name: UnorderedGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case UntilToken: {\n                return {\n                    name: UntilToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case Wildcard: {\n                return {\n                    name: Wildcard,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\nexport const reflection = new LangiumGrammarAstReflection();\n//# sourceMappingURL=ast.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport function isAstNode(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';\n}\nexport function isReference(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';\n}\nexport function isAstNodeDescription(obj) {\n    return typeof obj === 'object' && obj !== null\n        && typeof obj.name === 'string'\n        && typeof obj.type === 'string'\n        && typeof obj.path === 'string';\n}\nexport function isLinkingError(obj) {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode(obj.container)\n        && isReference(obj.reference)\n        && typeof obj.message === 'string';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport class AbstractAstReflection {\n    constructor() {\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        }\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\nexport function isCompositeCstNode(node) {\n    return typeof node === 'object' && node !== null && Array.isArray(node.content);\n}\nexport function isLeafCstNode(node) {\n    return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';\n}\nexport function isRootCstNode(node) {\n    return isCompositeCstNode(node) && typeof node.fullText === 'string';\n}\n//# sourceMappingURL=syntax-tree.js.map","export function cc(char) {\n    return char.charCodeAt(0);\n}\nexport function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n            set.push(subItem);\n        });\n    }\n    else {\n        set.push(item);\n    }\n}\nexport function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n    }\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\nexport function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n        throw Error(\"Internal Error - Should never get here!\");\n    }\n    return true;\n}\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n}\nexport function isCharacter(obj) {\n    return obj[\"type\"] === \"Character\";\n}\n//# sourceMappingURL=utils.js.map","import { cc } from \"./utils.js\";\nexport const digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n}\nexport const wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes = [\n    cc(\" \"),\n    cc(\"\\f\"),\n    cc(\"\\n\"),\n    cc(\"\\r\"),\n    cc(\"\\t\"),\n    cc(\"\\v\"),\n    cc(\"\\t\"),\n    cc(\"\\u00a0\"),\n    cc(\"\\u1680\"),\n    cc(\"\\u2000\"),\n    cc(\"\\u2001\"),\n    cc(\"\\u2002\"),\n    cc(\"\\u2003\"),\n    cc(\"\\u2004\"),\n    cc(\"\\u2005\"),\n    cc(\"\\u2006\"),\n    cc(\"\\u2007\"),\n    cc(\"\\u2008\"),\n    cc(\"\\u2009\"),\n    cc(\"\\u200a\"),\n    cc(\"\\u2028\"),\n    cc(\"\\u2029\"),\n    cc(\"\\u202f\"),\n    cc(\"\\u205f\"),\n    cc(\"\\u3000\"),\n    cc(\"\\ufeff\"),\n];\n//# sourceMappingURL=character-classes.js.map","import { addFlag, ASSERT_EXISTS, ASSERT_NEVER_REACH_HERE, cc, insertToSet, isCharacter, } from \"./utils.js\";\nimport { digitsCharCodes, whitespaceCodes, wordCharCodes, } from \"./character-classes.js\";\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n    constructor() {\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx,\n        };\n    }\n    restoreState(newState) {\n        this.idx = newState.idx;\n        this.input = newState.input;\n        this.groupIdx = newState.groupIdx;\n    }\n    pattern(input) {\n        // parser state\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar(\"/\");\n        const value = this.disjunction();\n        this.consumeChar(\"/\");\n        const flags = {\n            type: \"Flags\",\n            loc: { begin: this.idx, end: input.length },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false,\n        };\n        while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n                case \"g\":\n                    addFlag(flags, \"global\");\n                    break;\n                case \"i\":\n                    addFlag(flags, \"ignoreCase\");\n                    break;\n                case \"m\":\n                    addFlag(flags, \"multiLine\");\n                    break;\n                case \"u\":\n                    addFlag(flags, \"unicode\");\n                    break;\n                case \"y\":\n                    addFlag(flags, \"sticky\");\n                    break;\n            }\n        }\n        if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n        }\n        return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0),\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n        }\n        return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while (this.isTerm()) {\n            terms.push(this.term());\n        }\n        return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n    }\n    term() {\n        if (this.isAssertion()) {\n            return this.assertion();\n        }\n        else {\n            return this.atom();\n        }\n    }\n    assertion() {\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"^\":\n                return {\n                    type: \"StartAnchor\",\n                    loc: this.loc(begin),\n                };\n            case \"$\":\n                return { type: \"EndAnchor\", loc: this.loc(begin) };\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.popChar()) {\n                    case \"b\":\n                        return {\n                            type: \"WordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                    case \"B\":\n                        return {\n                            type: \"NonWordBoundary\",\n                            loc: this.loc(begin),\n                        };\n                }\n                // istanbul ignore next\n                throw Error(\"Invalid Assertion Escape\");\n            // '(?=' or '(?!'\n            case \"(\":\n                this.consumeChar(\"?\");\n                let type;\n                switch (this.popChar()) {\n                    case \"=\":\n                        type = \"Lookahead\";\n                        break;\n                    case \"!\":\n                        type = \"NegativeLookahead\";\n                        break;\n                }\n                ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(\")\");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin),\n                };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = undefined;\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case \"*\":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity,\n                };\n                break;\n            case \"+\":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity,\n                };\n                break;\n            case \"?\":\n                range = {\n                    atLeast: 0,\n                    atMost: 1,\n                };\n                break;\n            case \"{\":\n                const atLeast = this.integerIncludingZero();\n                switch (this.popChar()) {\n                    case \"}\":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast,\n                        };\n                        break;\n                    case \",\":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost,\n                            };\n                        }\n                        else {\n                            range = {\n                                atLeast: atLeast,\n                                atMost: Infinity,\n                            };\n                        }\n                        this.consumeChar(\"}\");\n                        break;\n                }\n                // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                // causes severe performance degradations\n                if (isBacktracking === true && range === undefined) {\n                    return undefined;\n                }\n                ASSERT_EXISTS(range);\n                break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n            return undefined;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\");\n                range.greedy = false;\n            }\n            else {\n                range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom;\n        const begin = this.idx;\n        switch (this.peekChar()) {\n            case \".\":\n                atom = this.dotAll();\n                break;\n            case \"\\\\\":\n                atom = this.atomEscape();\n                break;\n            case \"[\":\n                atom = this.characterClass();\n                break;\n            case \"(\":\n                atom = this.group();\n                break;\n        }\n        if (atom === undefined && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier();\n            }\n            return atom;\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(\".\");\n        return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n        };\n    }\n    atomEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return { type: \"GroupBackReference\", value: value };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch (this.popChar()) {\n            case \"d\":\n                set = digitsCharCodes;\n                break;\n            case \"D\":\n                set = digitsCharCodes;\n                complement = true;\n                break;\n            case \"s\":\n                set = whitespaceCodes;\n                break;\n            case \"S\":\n                set = whitespaceCodes;\n                complement = true;\n                break;\n            case \"w\":\n                set = wordCharCodes;\n                break;\n            case \"W\":\n                set = wordCharCodes;\n                complement = true;\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(set)) {\n            return { type: \"Set\", value: set, complement: complement };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch (this.popChar()) {\n            case \"f\":\n                escapeCode = cc(\"\\f\");\n                break;\n            case \"n\":\n                escapeCode = cc(\"\\n\");\n                break;\n            case \"r\":\n                escapeCode = cc(\"\\r\");\n                break;\n            case \"t\":\n                escapeCode = cc(\"\\t\");\n                break;\n            case \"v\":\n                escapeCode = cc(\"\\v\");\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(escapeCode)) {\n            return { type: \"Character\", value: escapeCode };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar(\"c\");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n        }\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return { type: \"Character\", value: letterCode };\n    }\n    nulCharacterAtom() {\n        // TODO implement '[lookahead  DecimalDigit]'\n        // TODO: for the deprecated octal escape sequence\n        this.consumeChar(\"0\");\n        return { type: \"Character\", value: cc(\"\\0\") };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar(\"x\");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar(\"u\");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n        const escapedChar = this.popChar();\n        return { type: \"Character\", value: cc(escapedChar) };\n    }\n    classPatternCharacterAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \"]\":\n                throw Error(\"TBD\");\n            default:\n                const nextChar = this.popChar();\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar(\"[\");\n        if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n        }\n        while (this.isClassAtom()) {\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar(\"-\");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === \"Character\";\n                // a range can only be used when both sides are single characters\n                if (isCharacter(to)) {\n                    if (to.value < from.value) {\n                        throw Error(\"Range out of order in character class\");\n                    }\n                    set.push({ from: from.value, to: to.value });\n                }\n                else {\n                    // literal dash\n                    insertToSet(from.value, set);\n                    set.push(cc(\"-\"));\n                    insertToSet(to.value, set);\n                }\n            }\n            else {\n                insertToSet(from.value, set);\n            }\n        }\n        this.consumeChar(\"]\");\n        return { type: \"Set\", complement: complement, value: set };\n    }\n    classAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case \"]\":\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n                throw Error(\"TBD\");\n            case \"\\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar(\"\\\\\");\n        switch (this.peekChar()) {\n            // Matches a backspace.\n            // (Not to be confused with \\b word boundary outside characterClass)\n            case \"b\":\n                this.consumeChar(\"b\");\n                return { type: \"Character\", value: cc(\"\\u0008\") };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n                return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n                return this.controlEscapeAtom();\n            case \"c\":\n                return this.controlLetterEscapeAtom();\n            case \"0\":\n                return this.nulCharacterAtom();\n            case \"x\":\n                return this.hexEscapeSequenceAtom();\n            case \"u\":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar(\"(\");\n        switch (this.peekChar(0)) {\n            case \"?\":\n                this.consumeChar(\"?\");\n                this.consumeChar(\":\");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(\")\");\n        const groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value,\n        };\n        if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n        }\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        // istanbul ignore next - can't ever get here due to previous lookahead checks\n        // still implementing this error checking in case this ever changes.\n        if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch (nextChar) {\n            // istanbul ignore next\n            case \"\\n\":\n            // istanbul ignore next\n            case \"\\r\":\n            // istanbul ignore next\n            case \"\\u2028\":\n            // istanbul ignore next\n            case \"\\u2029\":\n            // istanbul ignore next\n            case \"^\":\n            // istanbul ignore next\n            case \"$\":\n            // istanbul ignore next\n            case \"\\\\\":\n            // istanbul ignore next\n            case \".\":\n            // istanbul ignore next\n            case \"*\":\n            // istanbul ignore next\n            case \"+\":\n            // istanbul ignore next\n            case \"?\":\n            // istanbul ignore next\n            case \"(\":\n            // istanbul ignore next\n            case \")\":\n            // istanbul ignore next\n            case \"[\":\n            // istanbul ignore next\n            case \"|\":\n                // istanbul ignore next\n                throw Error(\"TBD\");\n            default:\n                return { type: \"Character\", value: cc(nextChar) };\n        }\n    }\n    isRegExpFlag() {\n        switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === \"-\" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) {\n            return true;\n        }\n        switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\": // atomEscape\n            case \"[\": // characterClass\n            // TODO: isAtom must be called before isAssertion - disambiguate\n            case \"(\": // group\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n                return true;\n            // '\\b' or '\\B'\n            case \"\\\\\":\n                switch (this.peekChar(1)) {\n                    case \"b\":\n                    case \"B\":\n                        return true;\n                    default:\n                        return false;\n                }\n            // '(?=' or '(?!'\n            case \"(\":\n                return (this.peekChar(1) === \"?\" &&\n                    (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\"));\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== undefined;\n        }\n        catch (e) {\n            return false;\n        }\n        finally {\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = \"\";\n        for (let i = 0; i < howMany; i++) {\n            const hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n                throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return { type: \"Character\", value: charCode };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(undefined);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== undefined && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" +\n                char +\n                \"' but found: '\" +\n                this.input[this.idx] +\n                \"' at offset: \" +\n                this.idx);\n        }\n        if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n        }\n        this.idx++;\n    }\n    loc(begin) {\n        return { begin: begin, end: this.idx };\n    }\n}\n//# sourceMappingURL=regexp-parser.js.map","export class BaseRegExpVisitor {\n    visitChildren(node) {\n        for (const key in node) {\n            const child = node[key];\n            /* istanbul ignore else */\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== undefined) {\n                    this.visit(child);\n                }\n                else if (Array.isArray(child)) {\n                    child.forEach((subChild) => {\n                        this.visit(subChild);\n                    }, this);\n                }\n            }\n        }\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Disjunction\":\n                this.visitDisjunction(node);\n                break;\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"StartAnchor\":\n                this.visitStartAnchor(node);\n                break;\n            case \"EndAnchor\":\n                this.visitEndAnchor(node);\n                break;\n            case \"WordBoundary\":\n                this.visitWordBoundary(node);\n                break;\n            case \"NonWordBoundary\":\n                this.visitNonWordBoundary(node);\n                break;\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                break;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"Set\":\n                this.visitSet(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"GroupBackReference\":\n                this.visitGroupBackReference(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) { }\n    visitFlags(node) { }\n    visitDisjunction(node) { }\n    visitAlternative(node) { }\n    // Assertion\n    visitStartAnchor(node) { }\n    visitEndAnchor(node) { }\n    visitWordBoundary(node) { }\n    visitNonWordBoundary(node) { }\n    visitLookahead(node) { }\n    visitNegativeLookahead(node) { }\n    // atoms\n    visitCharacter(node) { }\n    visitSet(node) { }\n    visitGroup(node) { }\n    visitGroupBackReference(node) { }\n    visitQuantifier(node) { }\n}\n//# sourceMappingURL=base-regexp-visitor.js.map","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new RegExpParser();\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n    constructor() {\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join('');\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n    visitChildren(node) {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\nconst visitor = new TerminalRegExpVisitor();\nexport function getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    }\n    catch (_a) {\n        return [];\n    }\n}\nexport function isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * A set of all characters that are considered whitespace by the '\\s' RegExp character class.\n * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\n */\nexport const whitespaceCharacters = ('\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007' +\n    '\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').split('');\nexport function isWhitespace(value) {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return whitespaceCharacters.some((ws) => regexp.test(ws));\n}\nexport function escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nexport function getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, letter => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');\n}\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nexport function partialMatches(regex, input) {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nexport function partialRegExp(regex) {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process() {\n        let result = '', tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        function appendOptional(nbChars) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                }\n                                else {\n                                    appendOptional(6);\n                                }\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n                case '[':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n                case '|':\n                case '^':\n                case '$':\n                case '*':\n                case '+':\n                case '?':\n                    appendRaw(1);\n                    break;\n                case '{':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    }\n                    else {\n                        appendOptional(1);\n                    }\n                    break;\n                case '(':\n                    if (source[i + 1] === '?') {\n                        switch (source[i + 2]) {\n                            case ':':\n                                result += '(?:';\n                                i += 3;\n                                result += process() + '|$)';\n                                break;\n                            case '=':\n                                result += '(?=';\n                                i += 3;\n                                result += process() + ')';\n                                break;\n                            case '!':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case '<':\n                                switch (source[i + 3]) {\n                                    case '=':\n                                    case '!':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf('>', i) - i + 1);\n                                        result += process() + '|$)';\n                                        break;\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        appendRaw(1);\n                        result += process() + '|$)';\n                    }\n                    break;\n                case ')':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n        return result;\n    }\n    return new RegExp(process(), regex.flags);\n}\n//# sourceMappingURL=regexp-utils.js.map","import {\n  __name,\n  configureSvgSize,\n  log\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/rendering-util/insertElementsForSize.js\nimport { select } from \"d3\";\nvar getDiagramElement = /* @__PURE__ */ __name((id, securityLevel) => {\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const svg = root.select(`[id=\"${id}\"]`);\n  return svg;\n}, \"getDiagramElement\");\n\n// src/rendering-util/setupViewPortForSVG.ts\nvar setupViewPortForSVG = /* @__PURE__ */ __name((svg, padding, cssDiagram, useMaxWidth) => {\n  svg.attr(\"class\", cssDiagram);\n  const { width, height, x, y } = calculateDimensionsWithPadding(svg, padding);\n  configureSvgSize(svg, height, width, useMaxWidth);\n  const viewBox = createViewBox(x, y, width, height, padding);\n  svg.attr(\"viewBox\", viewBox);\n  log.debug(`viewBox configured: ${viewBox} with padding: ${padding}`);\n}, \"setupViewPortForSVG\");\nvar calculateDimensionsWithPadding = /* @__PURE__ */ __name((svg, padding) => {\n  const bounds = svg.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 };\n  return {\n    width: bounds.width + padding * 2,\n    height: bounds.height + padding * 2,\n    x: bounds.x,\n    y: bounds.y\n  };\n}, \"calculateDimensionsWithPadding\");\nvar createViewBox = /* @__PURE__ */ __name((x, y, width, height, padding) => {\n  return `${x - padding} ${y - padding} ${width} ${height}`;\n}, \"createViewBox\");\n\nexport {\n  getDiagramElement,\n  setupViewPortForSVG\n};\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class EmptyFileSystemProvider {\n    readFile() {\n        throw new Error('No file system is available.');\n    }\n    async readDirectory() {\n        return [];\n    }\n}\nexport const EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n//# sourceMappingURL=file-system-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';\nimport { inject } from '../dependency-injection.js';\nimport * as ast from '../languages/generated/ast.js';\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\nimport { URI } from './uri-utils.js';\nconst minimalGrammarModule = {\n    Grammar: () => undefined,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: ['.langium'],\n        languageId: 'langium'\n    })\n};\nconst minimalSharedGrammarModule = {\n    AstReflection: () => new ast.LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n    const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n    const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nexport function loadGrammarFromJson(json) {\n    var _a;\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));\n    return astNode;\n}\n//# sourceMappingURL=grammar-loader.js.map","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/language/generated/ast.ts\nimport { AbstractAstReflection } from \"langium\";\nvar Statement = \"Statement\";\nvar Architecture = \"Architecture\";\nfunction isArchitecture(item) {\n  return reflection.isInstance(item, Architecture);\n}\n__name(isArchitecture, \"isArchitecture\");\nvar Axis = \"Axis\";\nvar Branch = \"Branch\";\nfunction isBranch(item) {\n  return reflection.isInstance(item, Branch);\n}\n__name(isBranch, \"isBranch\");\nvar Checkout = \"Checkout\";\nvar CherryPicking = \"CherryPicking\";\nvar Commit = \"Commit\";\nfunction isCommit(item) {\n  return reflection.isInstance(item, Commit);\n}\n__name(isCommit, \"isCommit\");\nvar Common = \"Common\";\nfunction isCommon(item) {\n  return reflection.isInstance(item, Common);\n}\n__name(isCommon, \"isCommon\");\nvar Curve = \"Curve\";\nvar Edge = \"Edge\";\nvar Entry = \"Entry\";\nvar GitGraph = \"GitGraph\";\nfunction isGitGraph(item) {\n  return reflection.isInstance(item, GitGraph);\n}\n__name(isGitGraph, \"isGitGraph\");\nvar Group = \"Group\";\nvar Info = \"Info\";\nfunction isInfo(item) {\n  return reflection.isInstance(item, Info);\n}\n__name(isInfo, \"isInfo\");\nvar Junction = \"Junction\";\nvar Merge = \"Merge\";\nfunction isMerge(item) {\n  return reflection.isInstance(item, Merge);\n}\n__name(isMerge, \"isMerge\");\nvar Option = \"Option\";\nvar Packet = \"Packet\";\nfunction isPacket(item) {\n  return reflection.isInstance(item, Packet);\n}\n__name(isPacket, \"isPacket\");\nvar PacketBlock = \"PacketBlock\";\nfunction isPacketBlock(item) {\n  return reflection.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, \"isPacketBlock\");\nvar Pie = \"Pie\";\nfunction isPie(item) {\n  return reflection.isInstance(item, Pie);\n}\n__name(isPie, \"isPie\");\nvar PieSection = \"PieSection\";\nfunction isPieSection(item) {\n  return reflection.isInstance(item, PieSection);\n}\n__name(isPieSection, \"isPieSection\");\nvar Radar = \"Radar\";\nvar Service = \"Service\";\nvar Direction = \"Direction\";\nvar MermaidAstReflection = class extends AbstractAstReflection {\n  static {\n    __name(this, \"MermaidAstReflection\");\n  }\n  getAllTypes() {\n    return [Architecture, Axis, Branch, Checkout, CherryPicking, Commit, Common, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Junction, Merge, Option, Packet, PacketBlock, Pie, PieSection, Radar, Service, Statement];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Entry:axis\": {\n        return Axis;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case Architecture: {\n        return {\n          name: Architecture,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"edges\", defaultValue: [] },\n            { name: \"groups\", defaultValue: [] },\n            { name: \"junctions\", defaultValue: [] },\n            { name: \"services\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Axis: {\n        return {\n          name: Axis,\n          properties: [\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Branch: {\n        return {\n          name: Branch,\n          properties: [\n            { name: \"name\" },\n            { name: \"order\" }\n          ]\n        };\n      }\n      case Checkout: {\n        return {\n          name: Checkout,\n          properties: [\n            { name: \"branch\" }\n          ]\n        };\n      }\n      case CherryPicking: {\n        return {\n          name: CherryPicking,\n          properties: [\n            { name: \"id\" },\n            { name: \"parent\" },\n            { name: \"tags\", defaultValue: [] }\n          ]\n        };\n      }\n      case Commit: {\n        return {\n          name: Commit,\n          properties: [\n            { name: \"id\" },\n            { name: \"message\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Common: {\n        return {\n          name: Common,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Curve: {\n        return {\n          name: Curve,\n          properties: [\n            { name: \"entries\", defaultValue: [] },\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Edge: {\n        return {\n          name: Edge,\n          properties: [\n            { name: \"lhsDir\" },\n            { name: \"lhsGroup\", defaultValue: false },\n            { name: \"lhsId\" },\n            { name: \"lhsInto\", defaultValue: false },\n            { name: \"rhsDir\" },\n            { name: \"rhsGroup\", defaultValue: false },\n            { name: \"rhsId\" },\n            { name: \"rhsInto\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Entry: {\n        return {\n          name: Entry,\n          properties: [\n            { name: \"axis\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case GitGraph: {\n        return {\n          name: GitGraph,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Group: {\n        return {\n          name: Group,\n          properties: [\n            { name: \"icon\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Info: {\n        return {\n          name: Info,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Junction: {\n        return {\n          name: Junction,\n          properties: [\n            { name: \"id\" },\n            { name: \"in\" }\n          ]\n        };\n      }\n      case Merge: {\n        return {\n          name: Merge,\n          properties: [\n            { name: \"branch\" },\n            { name: \"id\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Option: {\n        return {\n          name: Option,\n          properties: [\n            { name: \"name\" },\n            { name: \"value\", defaultValue: false }\n          ]\n        };\n      }\n      case Packet: {\n        return {\n          name: Packet,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"blocks\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PacketBlock: {\n        return {\n          name: PacketBlock,\n          properties: [\n            { name: \"end\" },\n            { name: \"label\" },\n            { name: \"start\" }\n          ]\n        };\n      }\n      case Pie: {\n        return {\n          name: Pie,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"sections\", defaultValue: [] },\n            { name: \"showData\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PieSection: {\n        return {\n          name: PieSection,\n          properties: [\n            { name: \"label\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Radar: {\n        return {\n          name: Radar,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"axes\", defaultValue: [] },\n            { name: \"curves\", defaultValue: [] },\n            { name: \"options\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Service: {\n        return {\n          name: Service,\n          properties: [\n            { name: \"icon\" },\n            { name: \"iconText\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Direction: {\n        return {\n          name: Direction,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"dir\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection = new MermaidAstReflection();\n\n// src/language/generated/grammar.ts\nimport { loadGrammarFromJson } from \"langium\";\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Info\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"InfoGrammar\");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Packet\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Pie\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"PieGrammar\");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Architecture\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"LeftPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"RightPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Arrow\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TEXT_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\(\\\\\"[^\\\\\"]+\\\\\"\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"ArchitectureGrammar\");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"GitGraph\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+(?=\\\\\\\\s)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar loadedRadarGrammar;\nvar RadarGrammar = /* @__PURE__ */ __name(() => loadedRadarGrammar ?? (loadedRadarGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Radar\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]},{\"$type\":\"Interface\",\"name\":\"Entry\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"axis\",\"isOptional\":true,\"type\":{\"$type\":\"ReferenceType\",\"referenceType\":{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@12\"}}}},{\"$type\":\"TypeAttribute\",\"name\":\"value\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"number\"},\"isOptional\":false}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Radar\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\"radar-beta:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"axis\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"curve\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Label\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"]\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Axis\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Curve\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\"}\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Entries\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"DetailedEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"axis\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@12\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Keyword\",\"value\":\":\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NumberEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Option\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showLegend\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"ticks\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"max\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"min\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"graticule\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"GRATICULE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"circle\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"polygon\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[a-zA-Z_][a-zA-Z0-9\\\\\\\\-_]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"RadarGrammar\");\n\n// src/language/generated/module.ts\nvar InfoLanguageMetaData = {\n  languageId: \"info\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PacketLanguageMetaData = {\n  languageId: \"packet\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PieLanguageMetaData = {\n  languageId: \"pie\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: \"architecture\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar GitGraphLanguageMetaData = {\n  languageId: \"gitGraph\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar RadarLanguageMetaData = {\n  languageId: \"radar\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), \"AstReflection\")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar RadarGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => RadarGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => RadarLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\n\n// src/language/common/valueConverter.ts\nimport { DefaultValueConverter } from \"langium\";\n\n// src/language/common/matcher.ts\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\n\n// src/language/common/valueConverter.ts\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = class extends DefaultValueConverter {\n  static {\n    __name(this, \"AbstractMermaidValueConverter\");\n  }\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n    }\n    return void 0;\n  }\n};\nvar CommonValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"CommonValueConverter\");\n  }\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n};\n\n// src/language/common/tokenBuilder.ts\nimport { DefaultTokenBuilder } from \"langium\";\nvar AbstractMermaidTokenBuilder = class extends DefaultTokenBuilder {\n  static {\n    __name(this, \"AbstractMermaidTokenBuilder\");\n  }\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n      }\n    });\n    return tokenTypes;\n  }\n};\nvar CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"CommonTokenBuilder\");\n  }\n};\n\nexport {\n  __name,\n  Statement,\n  Architecture,\n  isArchitecture,\n  Branch,\n  isBranch,\n  Commit,\n  isCommit,\n  isCommon,\n  GitGraph,\n  isGitGraph,\n  Info,\n  isInfo,\n  Merge,\n  isMerge,\n  Packet,\n  isPacket,\n  PacketBlock,\n  isPacketBlock,\n  Pie,\n  isPie,\n  PieSection,\n  isPieSection,\n  Radar,\n  MermaidGeneratedSharedModule,\n  InfoGeneratedModule,\n  PacketGeneratedModule,\n  PieGeneratedModule,\n  ArchitectureGeneratedModule,\n  GitGraphGeneratedModule,\n  RadarGeneratedModule,\n  AbstractMermaidValueConverter,\n  CommonValueConverter,\n  AbstractMermaidTokenBuilder,\n  CommonTokenBuilder\n};\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCrossReference, isRuleCall } from '../languages/generated/ast.js';\nimport { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';\nexport class DefaultValueConverter {\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if (isCrossReference(feature)) {\n            feature = getCrossReferenceTerminal(feature);\n        }\n        if (isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error('This cst node was not parsed by a rule.');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch (rule.name.toUpperCase()) {\n            case 'INT': return ValueConverter.convertInt(input);\n            case 'STRING': return ValueConverter.convertString(input);\n            case 'ID': return ValueConverter.convertID(input);\n        }\n        switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case 'number': return ValueConverter.convertNumber(input);\n            case 'boolean': return ValueConverter.convertBoolean(input);\n            case 'bigint': return ValueConverter.convertBigint(input);\n            case 'date': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\nexport var ValueConverter;\n(function (ValueConverter) {\n    function convertString(input) {\n        let result = '';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === '\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            }\n            else {\n                result += c;\n            }\n        }\n        return result;\n    }\n    ValueConverter.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch (char) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            case '0': return '\\0';\n            default: return char;\n        }\n    }\n    function convertID(input) {\n        if (input.charAt(0) === '^') {\n            return input.substring(1);\n        }\n        else {\n            return input;\n        }\n    }\n    ValueConverter.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    ValueConverter.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    ValueConverter.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    ValueConverter.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    ValueConverter.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === 'true';\n    }\n    ValueConverter.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n//# sourceMappingURL=value-converter.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node) {\n    return new TreeStreamImpl(node, element => {\n        if (isCompositeCstNode(element)) {\n            return element.content;\n        }\n        else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node) {\n    return streamCst(node).filter(isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child, parent) {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tokenToRange(token) {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn, // endColumn uses the correct index\n            line: token.endLine - 1\n        }\n    };\n}\nexport function toDocumentSegment(node) {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\nexport var RangeComparison;\n(function (RangeComparison) {\n    RangeComparison[RangeComparison[\"Before\"] = 0] = \"Before\";\n    RangeComparison[RangeComparison[\"After\"] = 1] = \"After\";\n    RangeComparison[RangeComparison[\"OverlapFront\"] = 2] = \"OverlapFront\";\n    RangeComparison[RangeComparison[\"OverlapBack\"] = 3] = \"OverlapBack\";\n    RangeComparison[RangeComparison[\"Inside\"] = 4] = \"Inside\";\n    RangeComparison[RangeComparison[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nexport function compareRange(range, to) {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\n        return RangeComparison.Before;\n    }\n    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    }\n    else if (startInside) {\n        return RangeComparison.OverlapBack;\n    }\n    else if (endInside) {\n        return RangeComparison.OverlapFront;\n    }\n    else {\n        return RangeComparison.Outside;\n    }\n}\nexport function inRange(range, to) {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\nexport function findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nexport function isCommentNode(cstNode, commentNames) {\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = undefined;\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        }\n        else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n    return closestNode;\n}\nexport function getPreviousNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getNextNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nexport function getStartlineNode(node) {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        }\n        else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\nexport function getInteriorNodes(start, end) {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        }\n        else {\n            break;\n        }\n    }\n    return current;\n}\nfunction getParentChain(node) {\n    const chain = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n//# sourceMappingURL=cst-utils.js.map","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  GitGraphGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/gitGraph/module.ts\nimport {\n  inject,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  EmptyFileSystem\n} from \"langium\";\n\n// src/language/gitGraph/tokenBuilder.ts\nvar GitGraphTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"GitGraphTokenBuilder\");\n  }\n  constructor() {\n    super([\"gitGraph\"]);\n  }\n};\n\n// src/language/gitGraph/module.ts\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new GitGraphTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createGitGraphServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const GitGraph = inject(\n    createDefaultCoreModule({ shared }),\n    GitGraphGeneratedModule,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph);\n  return { shared, GitGraph };\n}\n__name(createGitGraphServices, \"createGitGraphServices\");\n\nexport {\n  GitGraphModule,\n  createGitGraphServices\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  MermaidGeneratedSharedModule,\n  PieGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/pie/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/pie/tokenBuilder.ts\nvar PieTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PieTokenBuilder\");\n  }\n  constructor() {\n    super([\"pie\", \"showData\"]);\n  }\n};\n\n// src/language/pie/valueConverter.ts\nvar PieValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"PieValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== \"PIE_SECTION_LABEL\") {\n      return void 0;\n    }\n    return input.replace(/\"/g, \"\").trim();\n  }\n};\n\n// src/language/pie/module.ts\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PieTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new PieValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPieServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Pie = inject(\n    createDefaultCoreModule({ shared }),\n    PieGeneratedModule,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie);\n  return { shared, Pie };\n}\n__name(createPieServices, \"createPieServices\");\n\nexport {\n  PieModule,\n  createPieServices\n};\n","import {\n  __name\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/diagrams/common/populateCommonDb.ts\nfunction populateCommonDb(ast, db) {\n  if (ast.accDescr) {\n    db.setAccDescription?.(ast.accDescr);\n  }\n  if (ast.accTitle) {\n    db.setAccTitle?.(ast.accTitle);\n  }\n  if (ast.title) {\n    db.setDiagramTitle?.(ast.title);\n  }\n}\n__name(populateCommonDb, \"populateCommonDb\");\n\nexport {\n  populateCommonDb\n};\n","var LIB;(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf(\"/\");if(a!==n.length-1){-1===a?(n=\"\",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf(\"/\"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=h,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+=\"..\":g+=\"/..\");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),\"object\"==typeof process)t=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let e=navigator.userAgent;t=e.indexOf(\"Windows\")>=0}const e=/^\\w[\\w\\d+.-]*$/,i=/^\\//,o=/^\\/\\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!e.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",a=\"/\",c=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l(\"file\",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&\"file\"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,\"\\\\\")),n}function y(t,e){const r=e?p:d;let n=\"\",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=a,n+=a),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+=\"?\",n+=r(h,!1,!1)),c&&(n+=\"#\",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x=\"/\";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();export const{URI,Utils}=LIB;\n//# sourceMappingURL=index.mjs.map","import baseFlatten from './_baseFlatten.js';\nimport map from './map.js';\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  InfoGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/info/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/info/tokenBuilder.ts\nvar InfoTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"InfoTokenBuilder\");\n  }\n  constructor() {\n    super([\"info\", \"showInfo\"]);\n  }\n};\n\n// src/language/info/module.ts\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new InfoTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createInfoServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Info = inject(\n    createDefaultCoreModule({ shared }),\n    InfoGeneratedModule,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info);\n  return { shared, Info };\n}\n__name(createInfoServices, \"createInfoServices\");\n\nexport {\n  InfoModule,\n  createInfoServices\n};\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n","import {\n  GitGraphModule,\n  createGitGraphServices\n} from \"./chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs\";\nimport {\n  InfoModule,\n  createInfoServices\n} from \"./chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs\";\nimport {\n  PacketModule,\n  createPacketServices\n} from \"./chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs\";\nimport {\n  PieModule,\n  createPieServices\n} from \"./chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs\";\nimport {\n  ArchitectureModule,\n  createArchitectureServices\n} from \"./chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs\";\nimport {\n  RadarModule,\n  createRadarServices\n} from \"./chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs\";\nimport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  Info,\n  InfoGeneratedModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  Pie,\n  PieGeneratedModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  Statement,\n  __name,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isCommon,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection\n} from \"./chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs\";\n\n// src/parse.ts\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ __name(async () => {\n    const { createInfoServices: createInfoServices2 } = await import(\"./chunks/mermaid-parser.core/info-4N47QTOZ.mjs\");\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, \"info\"),\n  packet: /* @__PURE__ */ __name(async () => {\n    const { createPacketServices: createPacketServices2 } = await import(\"./chunks/mermaid-parser.core/packet-KVYON367.mjs\");\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, \"packet\"),\n  pie: /* @__PURE__ */ __name(async () => {\n    const { createPieServices: createPieServices2 } = await import(\"./chunks/mermaid-parser.core/pie-R6RNRRYF.mjs\");\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, \"pie\"),\n  architecture: /* @__PURE__ */ __name(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await import(\"./chunks/mermaid-parser.core/architecture-4AB2E3PP.mjs\");\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, \"architecture\"),\n  gitGraph: /* @__PURE__ */ __name(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await import(\"./chunks/mermaid-parser.core/gitGraph-O2Q2CXLX.mjs\");\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, \"gitGraph\"),\n  radar: /* @__PURE__ */ __name(async () => {\n    const { createRadarServices: createRadarServices2 } = await import(\"./chunks/mermaid-parser.core/radar-MK3ICKWK.mjs\");\n    const parser = createRadarServices2().Radar.parser.LangiumParser;\n    parsers.radar = parser;\n  }, \"radar\")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n__name(parse, \"parse\");\nvar MermaidParseError = class extends Error {\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join(\"\\n\");\n    const parserErrors = result.parserErrors.map((err) => err.message).join(\"\\n\");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n  static {\n    __name(this, \"MermaidParseError\");\n  }\n};\nexport {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  Architecture,\n  ArchitectureGeneratedModule,\n  ArchitectureModule,\n  Branch,\n  Commit,\n  CommonTokenBuilder,\n  CommonValueConverter,\n  GitGraph,\n  GitGraphGeneratedModule,\n  GitGraphModule,\n  Info,\n  InfoGeneratedModule,\n  InfoModule,\n  Merge,\n  MermaidGeneratedSharedModule,\n  MermaidParseError,\n  Packet,\n  PacketBlock,\n  PacketGeneratedModule,\n  PacketModule,\n  Pie,\n  PieGeneratedModule,\n  PieModule,\n  PieSection,\n  Radar,\n  RadarGeneratedModule,\n  RadarModule,\n  Statement,\n  createArchitectureServices,\n  createGitGraphServices,\n  createInfoServices,\n  createPacketServices,\n  createPieServices,\n  createRadarServices,\n  isArchitecture,\n  isBranch,\n  isCommit,\n  isCommon,\n  isGitGraph,\n  isInfo,\n  isMerge,\n  isPacket,\n  isPacketBlock,\n  isPie,\n  isPieSection,\n  parse\n};\n","import {\n  AbstractMermaidTokenBuilder,\n  AbstractMermaidValueConverter,\n  ArchitectureGeneratedModule,\n  MermaidGeneratedSharedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/architecture/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/architecture/tokenBuilder.ts\nvar ArchitectureTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"ArchitectureTokenBuilder\");\n  }\n  constructor() {\n    super([\"architecture\"]);\n  }\n};\n\n// src/language/architecture/valueConverter.ts\nvar ArchitectureValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, \"ArchitectureValueConverter\");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"ARCH_ICON\") {\n      return input.replace(/[()]/g, \"\").trim();\n    } else if (rule.name === \"ARCH_TEXT_ICON\") {\n      return input.replace(/[\"()]/g, \"\");\n    } else if (rule.name === \"ARCH_TITLE\") {\n      return input.replace(/[[\\]]/g, \"\").trim();\n    }\n    return void 0;\n  }\n};\n\n// src/language/architecture/module.ts\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new ArchitectureTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new ArchitectureValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createArchitectureServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Architecture = inject(\n    createDefaultCoreModule({ shared }),\n    ArchitectureGeneratedModule,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture);\n  return { shared, Architecture };\n}\n__name(createArchitectureServices, \"createArchitectureServices\");\n\nexport {\n  ArchitectureModule,\n  createArchitectureServices\n};\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nimport filter from \"lodash-es/filter.js\";\nimport { Alternation, NonTerminal, Option, RepetitionMandatory, Repetition, Terminal, RepetitionWithSeparator, RepetitionMandatoryWithSeparator } from \"chevrotain\";\nexport function buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\nexport const ATN_INVALID_TYPE = 0;\nexport const ATN_BASIC = 1;\nexport const ATN_RULE_START = 2;\nexport const ATN_PLUS_BLOCK_START = 4;\nexport const ATN_STAR_BLOCK_START = 5;\n// Currently unused as the ATN is not used for lexing\nexport const ATN_TOKEN_START = 6;\nexport const ATN_RULE_STOP = 7;\nexport const ATN_BLOCK_END = 8;\nexport const ATN_STAR_LOOP_BACK = 9;\nexport const ATN_STAR_LOOP_ENTRY = 10;\nexport const ATN_PLUS_LOOP_BACK = 11;\nexport const ATN_LOOP_END = 12;\nexport class AbstractTransition {\n    constructor(target) {\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n}\nexport class AtomTransition extends AbstractTransition {\n    constructor(target, tokenType) {\n        super(target);\n        this.tokenType = tokenType;\n    }\n}\nexport class EpsilonTransition extends AbstractTransition {\n    constructor(target) {\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport class RuleTransition extends AbstractTransition {\n    constructor(ruleStart, rule, followState) {\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nexport function createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: new Map(),\n        ruleToStopState: new Map(),\n        states: []\n    };\n    createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const ruleBlock = block(atn, rule, rule);\n        if (ruleBlock === undefined) {\n            continue;\n        }\n        buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const start = newState(atn, rule, undefined, {\n            type: ATN_RULE_START\n        });\n        const stop = newState(atn, rule, undefined, {\n            type: ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\nfunction atom(atn, rule, production) {\n    if (production instanceof Terminal) {\n        return tokenRef(atn, rule, production.terminalType, production);\n    }\n    else if (production instanceof NonTerminal) {\n        return ruleRef(atn, rule, production);\n    }\n    else if (production instanceof Alternation) {\n        return alternation(atn, rule, production);\n    }\n    else if (production instanceof Option) {\n        return option(atn, rule, production);\n    }\n    else if (production instanceof Repetition) {\n        return repetition(atn, rule, production);\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return repetitionSep(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return repetitionMandatory(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return repetitionMandatorySep(atn, rule, production);\n    }\n    else {\n        return block(atn, rule, production);\n    }\n}\nfunction repetition(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    return star(atn, rule, repetition, handle);\n}\nfunction repetitionSep(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return star(atn, rule, repetition, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    return plus(atn, rule, repetition, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return plus(atn, rule, repetition, handle, sep);\n}\nfunction alternation(atn, rule, alternation) {\n    const start = newState(atn, rule, alternation, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const alts = map(alternation.definition, (e) => atom(atn, rule, e));\n    const handle = makeAlts(atn, rule, start, alternation, ...alts);\n    return handle;\n}\nfunction option(atn, rule, option) {\n    const start = newState(atn, rule, option, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));\n    return optional(atn, rule, option, handle);\n}\nfunction block(atn, rule, block) {\n    const handles = filter(map(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);\n    if (handles.length === 1) {\n        return handles[0];\n    }\n    else if (handles.length === 0) {\n        return undefined;\n    }\n    else {\n        return makeBlock(atn, handles);\n    }\n}\nfunction plus(atn, rule, plus, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = newState(atn, rule, plus, {\n        type: ATN_PLUS_LOOP_BACK\n    });\n    defineDecisionState(atn, loop);\n    const end = newState(atn, rule, plus, {\n        type: ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;\n    epsilon(blkEnd, loop); // block can see loop back\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\n    // This influences the chosen option in the lookahead DFA\n    if (sep === undefined) {\n        epsilon(loop, blkStart); // loop back to start\n        epsilon(loop, end); // exit\n    }\n    else {\n        epsilon(loop, end); // exit\n        // loop back to start with separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\nfunction star(atn, rule, star, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_ENTRY\n    });\n    defineDecisionState(atn, entry);\n    const loopEnd = newState(atn, rule, star, {\n        type: ATN_LOOP_END\n    });\n    const loop = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    epsilon(entry, start); // loop enter edge (alt 2)\n    epsilon(entry, loopEnd); // bypass loop edge (alt 1)\n    epsilon(end, loop); // block end hits loop back\n    if (sep !== undefined) {\n        epsilon(loop, loopEnd); // end loop\n        // loop back to start of handle using separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, start);\n    }\n    else {\n        epsilon(loop, entry); // loop back to entry/exit decision\n    }\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\nfunction optional(atn, rule, optional, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    epsilon(start, end);\n    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;\n    return handle;\n}\nfunction defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n    const end = newState(atn, rule, production, {\n        type: ATN_BLOCK_END,\n        start\n    });\n    start.end = end;\n    for (const alt of alts) {\n        if (alt !== undefined) {\n            // hook alts up to decision block\n            epsilon(start, alt.left);\n            epsilon(alt.right, end);\n        }\n        else {\n            epsilon(start, end);\n        }\n    }\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;\n    return handle;\n}\nfunction getProdType(production) {\n    if (production instanceof Alternation) {\n        return 'Alternation';\n    }\n    else if (production instanceof Option) {\n        return 'Option';\n    }\n    else if (production instanceof Repetition) {\n        return 'Repetition';\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return 'RepetitionWithSeparator';\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return 'RepetitionMandatory';\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return 'RepetitionMandatoryWithSeparator';\n    }\n    else {\n        throw new Error('Invalid production type encountered');\n    }\n}\nfunction makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for (let i = 0; i < altsLength - 1; i++) {\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) {\n            transition = handle.left.transitions[0];\n        }\n        const isRuleTransition = transition instanceof RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === ATN_BASIC &&\n            handle.right.type === ATN_BASIC &&\n            transition !== undefined &&\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\n                transition.target === handle.right)) {\n            // we can avoid epsilon edge to next element\n            if (isRuleTransition) {\n                ruleTransition.followState = next;\n            }\n            else {\n                transition.target = next;\n            }\n            removeState(atn, handle.right); // we skipped over this state\n        }\n        else {\n            // need epsilon if previous block's right end node is complex\n            epsilon(handle.right, next);\n        }\n    }\n    const first = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first.left,\n        right: last.right\n    };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n    const left = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    addTransition(left, new AtomTransition(right, tokenType));\n    return {\n        left,\n        right\n    };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const call = new RuleTransition(start, rule, right);\n    addTransition(left, call);\n    return {\n        left,\n        right\n    };\n}\nfunction buildRuleHandle(atn, rule, block) {\n    const start = atn.ruleToStartState.get(rule);\n    epsilon(start, block.left);\n    const stop = atn.ruleToStopState.get(rule);\n    epsilon(block.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\nfunction epsilon(a, b) {\n    const transition = new EpsilonTransition(b);\n    addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n    const t = Object.assign({ atn,\n        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);\n    atn.states.push(t);\n    return t;\n}\nfunction addTransition(state, transition) {\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\n    // Because they are never mixed, only setting the property for the first transition is fine\n    if (state.transitions.length === 0) {\n        state.epsilonOnlyTransitions = transition.isEpsilon();\n    }\n    state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n//# sourceMappingURL=atn.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport map from \"lodash-es/map.js\";\nexport const DFA_ERROR = {};\nexport class ATNConfigSet {\n    constructor() {\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        // Empties the map to free up memory\n        this.map = {};\n    }\n    add(config) {\n        const key = getATNConfigKey(config);\n        // Only add configs which don't exist in our map already\n        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return map(this.configs, (e) => e.alt);\n    }\n    get key() {\n        let value = \"\";\n        for (const k in this.map) {\n            value += k + \":\";\n        }\n        return value;\n    }\n}\nexport function getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\n//# sourceMappingURL=dfa.js.map","import baseIteratee from './_baseIteratee.js';\nimport baseUniq from './_baseUniq.js';\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nexport default uniqBy;\n","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { tokenMatcher, tokenLabel, NonTerminal, Alternation, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Repetition, Terminal, LLkLookaheadStrategy, getLookaheadPaths } from \"chevrotain\";\nimport { ATN_RULE_STOP, AtomTransition, buildATNKey, createATN, EpsilonTransition, RuleTransition } from \"./atn.js\";\nimport { ATNConfigSet, DFA_ERROR, getATNConfigKey } from \"./dfa.js\";\nimport min from \"lodash-es/min.js\";\nimport flatMap from \"lodash-es/flatMap.js\";\nimport uniqBy from \"lodash-es/uniqBy.js\";\nimport map from \"lodash-es/map.js\";\nimport flatten from \"lodash-es/flatten.js\";\nimport forEach from \"lodash-es/forEach.js\";\nimport isEmpty from \"lodash-es/isEmpty.js\";\nimport reduce from \"lodash-es/reduce.js\";\nfunction createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet) => {\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            existing = {\n                atnStartState: startState,\n                decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\nclass PredicateSet {\n    constructor() {\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = \"\";\n        const size = this.predicates.length;\n        for (let i = 0; i < size; i++) {\n            value += this.predicates[i] === true ? \"1\" : \"0\";\n        }\n        return value;\n    }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nexport class LLStarLookaheadStrategy extends LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));\n    }\n    initialize(options) {\n        this.atn = createATN(options.rules);\n        this.dfas = initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, 'Alternation', prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: \"Alternation\",\n            rule: rule\n        }), (currAlt) => map(currAlt, (path) => path[0]));\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = reduce(partialAlts, (result, currAlt, idx) => {\n                forEach(currAlt, (currTokType) => {\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) {\n                return function (orAlts) {\n                    var _a;\n                    const nextToken = this.LA(1);\n                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                    if (orAlts !== undefined && prediction !== undefined) {\n                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                        if (gate !== undefined && gate.call(this) === false) {\n                            return undefined;\n                        }\n                    }\n                    return prediction;\n                };\n            }\n            else {\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx];\n                };\n            }\n        }\n        else if (hasPredicates) {\n            return function (orAlts) {\n                const predicates = new PredicateSet();\n                const length = orAlts === undefined ? 0 : orAlts.length;\n                for (let i = 0; i < length; i++) {\n                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                    predicates.set(i, gate === undefined || gate.call(this));\n                }\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n        else {\n            return function () {\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = map(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType,\n            rule\n        }), (e) => {\n            return map(e, (g) => g[0]);\n        });\n        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = flatten(alt);\n            if (singleTokensTypes.length === 1 &&\n                isEmpty(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function () {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            }\n            else {\n                const choiceToAlt = reduce(singleTokensTypes, (result, currTokType) => {\n                    if (currTokType !== undefined) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        forEach(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function () {\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n            return typeof result === \"object\" ? false : result === 0;\n        };\n    }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = new Set();\n    for (const alt of sequences) {\n        const altSet = new Set();\n        for (const tokType of alt) {\n            if (tokType === undefined) {\n                if (allowEmpty) {\n                    // Epsilon production encountered\n                    break;\n                }\n                else {\n                    return false;\n                }\n            }\n            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n            for (const index of indices) {\n                if (fullSet.has(index)) {\n                    if (!altSet.has(index)) {\n                        return false;\n                    }\n                }\n                else {\n                    fullSet.add(index);\n                    altSet.add(index);\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for (let i = 0; i < decisionLength; i++) {\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n    }\n    return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === undefined) {\n        const closure = computeStartState(dfa.atnStartState);\n        start = addDFAState(dfa, newDFAState(closure));\n        dfa.start = start;\n    }\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n    return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while (true) {\n        let d = getExistingTargetState(previousD, t);\n        if (d === undefined) {\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n        }\n        if (d === DFA_ERROR) {\n            return buildAdaptivePredictError(path, previousD, t);\n        }\n        if (d.isAcceptState === true) {\n            return d.prediction;\n        }\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        addDFAEdge(dfa, previousD, token, DFA_ERROR);\n        return DFA_ERROR;\n    }\n    let newState = newDFAState(reach);\n    const predictedAlt = getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== undefined) {\n        newState.isAcceptState = true;\n        newState.prediction = predictedAlt;\n        newState.configs.uniqueAlt = predictedAlt;\n    }\n    else if (hasConflictTerminatingPrediction(reach)) {\n        const prediction = min(reach.alts);\n        newState.isAcceptState = true;\n        newState.prediction = prediction;\n        newState.configs.uniqueAlt = prediction;\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n    }\n    newState = addDFAEdge(dfa, previousD, token, newState);\n    return newState;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for (let i = 1; i <= lookahead; i++) {\n        prefixPath.push(this.LA(i).tokenType);\n    }\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = buildAmbiguityError({\n        topLevelRule,\n        ambiguityIndices,\n        production,\n        prefixPath\n    });\n    logging(message);\n}\nfunction buildAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n    const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName(options.production)}${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage =\n        currMessage +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n            `For Further details.`;\n    return currMessage;\n}\nfunction getProductionDslName(prod) {\n    if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = flatMap(previous.configs.elements, (e) => e.state.transitions);\n    const nextTokenTypes = uniqBy(nextTransitions\n        .filter((e) => e instanceof AtomTransition)\n        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\nfunction getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n    const intermediate = new ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === false) {\n            continue;\n        }\n        if (c.state.type === ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for (let i = 0; i < transitionLength; i++) {\n            const transition = c.state.transitions[i];\n            const target = getReachableTarget(transition, token);\n            if (target !== undefined) {\n                intermediate.add({\n                    state: target,\n                    alt: c.alt,\n                    stack: c.stack\n                });\n            }\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\n        reach = intermediate;\n    }\n    if (reach === undefined) {\n        reach = new ATNConfigSet();\n        for (const c of intermediate.elements) {\n            closure(c, reach);\n        }\n    }\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n        for (const c of skippedStopStates) {\n            reach.add(c);\n        }\n    }\n    return reach;\n}\nfunction getReachableTarget(transition, token) {\n    if (transition instanceof AtomTransition &&\n        tokenMatcher(token, transition.tokenType)) {\n        return transition.target;\n    }\n    return undefined;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === true) {\n            if (alt === undefined) {\n                alt = c.alt;\n            }\n            else if (alt !== c.alt) {\n                return undefined;\n            }\n        }\n    }\n    return alt;\n}\nfunction newDFAState(closure) {\n    return {\n        configs: closure,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n    to = addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\nfunction addDFAState(dfa, state) {\n    if (state === DFA_ERROR) {\n        return state;\n    }\n    // Repetitions have the same config set\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== undefined) {\n        return existing;\n    }\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\nfunction computeStartState(atnState) {\n    const configs = new ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for (let i = 0; i < numberOfTransitions; i++) {\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        closure(config, configs);\n    }\n    return configs;\n}\nfunction closure(config, configs) {\n    const p = config.state;\n    if (p.type === ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [...config.stack];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            closure(followConfig, configs);\n        }\n        else {\n            // Dipping into outer context, simply add the config\n            // This will stop computation once every config is at the rule stop state\n            configs.add(config);\n        }\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) {\n        configs.add(config);\n    }\n    const transitionLength = p.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n        const transition = p.transitions[i];\n        const c = getEpsilonTarget(config, transition);\n        if (c !== undefined) {\n            closure(c, configs);\n        }\n    }\n}\nfunction getEpsilonTarget(config, transition) {\n    if (transition instanceof EpsilonTransition) {\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: config.stack\n        };\n    }\n    else if (transition instanceof RuleTransition) {\n        const stack = [...config.stack, transition.followState];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack\n        };\n    }\n    return undefined;\n}\nfunction hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type === ATN_RULE_STOP) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type !== ATN_RULE_STOP) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n    if (allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    const altSets = getConflictingAltSets(configs.elements);\n    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n    const configToAlts = new Map();\n    for (const c of configs) {\n        const key = getATNConfigKey(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === undefined) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length > 1) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length === 1) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=all-star-lookahead.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line, character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri, range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range,\n            color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = { range, message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command, ...args) {\n        let result = { title, command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range, newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = { label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument, edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'create',\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: 'rename',\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'delete',\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */\nclass ChangeAnnotations {\n    constructor(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nexport class WorkspaceChange {\n    constructor(workspaceEdit) {\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change) => {\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key) => {\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */\n    get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            }\n            else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            const textDocument = { uri: key.uri, version: key.version };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri, languageId, version, text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText, insert, replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label, documentation } : { label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = { label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        let result = { range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: { uri, range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name, kind, location: { uri, range } }\n            : { name, kind, location: { uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        let result = { diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = { title };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        let result = { range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize, insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range, target, data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range, parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range, text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range, variableName, caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range, expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId, stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        const result = { position, label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var StringValue;\n(function (StringValue) {\n    function createSnippet(value) {\n        return { kind: 'snippet', value };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nexport var InlineCompletionItem;\n(function (InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return { insertText, filterText, range, command };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nexport var InlineCompletionList;\n(function (InlineCompletionList) {\n    function create(items) {\n        return { items };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */\n    InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */\n    InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SelectedCompletionInfo;\n(function (SelectedCompletionInfo) {\n    function create(range, text) {\n        return { range, text };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nexport var InlineCompletionContext;\n(function (InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return { triggerKind, selectedCompletionInfo };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport const EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = (data.length / 2) | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for (let i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function (Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position } from 'vscode-languageserver-types';\nimport { tokenToRange } from '../utils/cst-utils.js';\nexport class CstNodeBuilder {\n    constructor() {\n        this.nodeStack = [];\n    }\n    get current() {\n        var _a;\n        return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;\n    }\n    buildRootNode(input) {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n    addHiddenNodes(tokens) {\n        const nodes = [];\n        for (const token of tokens) {\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n            leafNode.root = this.rootNode;\n            nodes.push(leafNode);\n        }\n        let current = this.current;\n        let added = false;\n        // If we are within a composite node, we add the hidden nodes to the content\n        if (current.content.length > 0) {\n            current.content.push(...nodes);\n            return;\n        }\n        // Otherwise we are at a newly created node\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\n        while (current.container) {\n            const index = current.container.content.indexOf(current);\n            if (index > 0) {\n                // Add the hidden nodes before the current node\n                current.container.content.splice(index, 0, ...nodes);\n                added = true;\n                break;\n            }\n            current = current.container;\n        }\n        // If we arrive at the root node, we add the hidden nodes at the beginning\n        // This is the case if the hidden nodes are the first nodes in the tree\n        if (!added) {\n            this.rootNode.content.unshift(...nodes);\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === 'string') {\n            this.current.astNode = item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n            this.removeNode(node);\n        }\n    }\n}\nexport class AbstractCstNode {\n    /** @deprecated use `container` instead. */\n    get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */\n    get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) {\n            throw new Error('This node has no associated AST element');\n        }\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */\n    get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\nexport class LeafCstNodeImpl extends AbstractCstNode {\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\nexport class CompositeCstNodeImpl extends AbstractCstNode {\n    constructor() {\n        super(...arguments);\n        this.content = new CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */\n    get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        }\n        else {\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\n        }\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\nclass CstNodeContainer extends Array {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items) {\n            item.container = this.parent;\n        }\n    }\n}\nexport class RootCstNodeImpl extends CompositeCstNodeImpl {\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input) {\n        super();\n        this._text = '';\n        this._text = input !== null && input !== void 0 ? input : '';\n    }\n}\n//# sourceMappingURL=cst-node-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\nimport { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';\nimport { getExplicitRuleType, isDataTypeRule } from '../utils/grammar-utils.js';\nimport { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';\nimport { CstNodeBuilder } from './cst-node-builder.js';\nexport const DatatypeSymbol = Symbol('Datatype');\nfunction isDataTypeNode(node) {\n    return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = '\\u200B';\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nexport class AbstractLangiumParser {\n    constructor(services) {\n        this._unorderedGroups = new Map();\n        this.allRules = new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    getRule(name) {\n        return this.allRules.get(name);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\nexport class LangiumParser extends AbstractLangiumParser {\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services) {\n        super(services);\n        this.nodeBuilder = new CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = this.computeRuleType(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    computeRuleType(rule) {\n        if (rule.fragment) {\n            return undefined;\n        }\n        else if (isDataTypeRule(rule)) {\n            return DatatypeSymbol;\n        }\n        else {\n            const explicit = getExplicitRuleType(rule);\n            return explicit !== null && explicit !== void 0 ? explicit : rule.name;\n        }\n    }\n    parse(input, options = {}) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\n        if (!ruleMethod) {\n            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');\n        }\n        const result = ruleMethod.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        this.lexerResult = undefined;\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            lexerReport: lexerResult.report,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args) => {\n            // Only create a new AST node in case the calling rule is not a fragment rule\n            const createNode = !this.isRecording() && $type !== undefined;\n            if (createNode) {\n                const node = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = '';\n                }\n            }\n            let result;\n            try {\n                result = implementation(args);\n            }\n            catch (err) {\n                result = undefined;\n            }\n            if (result === undefined && createNode) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n    extractHiddenTokens(token) {\n        const hiddenTokens = this.lexerResult.hidden;\n        if (!hiddenTokens.length) {\n            return [];\n        }\n        const offset = token.startOffset;\n        for (let i = 0; i < hiddenTokens.length; i++) {\n            const token = hiddenTokens[i];\n            if (token.startOffset > offset) {\n                return hiddenTokens.splice(0, i);\n            }\n        }\n        return hiddenTokens.splice(0, hiddenTokens.length);\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const hiddenTokens = this.extractHiddenTokens(token);\n            this.nodeBuilder.addHiddenNodes(hiddenTokens);\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            }\n            else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!isKeyword(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        let cstNode;\n        if (!this.isRecording() && !fragment) {\n            // We only want to create a new CST node if the subrule actually creates a new AST node.\n            // In other cases like calls of fragment rules the current CST/AST is populated further.\n            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.\n            // This is intended, as fragment rules only enrich the current AST node\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        }\n        else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            }\n            else if (typeof result === 'object' && result) {\n                const object = this.assignWithoutOverride(result, current);\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            if (action.feature && action.operator) {\n                last = this.construct();\n                this.nodeBuilder.removeNode(last.$cstNode);\n                const node = this.nodeBuilder.buildCompositeNode(action);\n                node.content.push(last.$cstNode);\n                const newItem = { $type };\n                this.stack.push(newItem);\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n            else {\n                last.$type = $type;\n            }\n        }\n    }\n    construct() {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        this.stack.pop();\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        }\n        else {\n            assignMandatoryProperties(this.astReflection, obj);\n        }\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = getContainerOfType(feature, isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === 'string') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        }\n        else {\n            item = value;\n        }\n        switch (operator) {\n            case '=': {\n                obj[feature] = item;\n                break;\n            }\n            case '?=': {\n                obj[feature] = true;\n                break;\n            }\n            case '+=': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            }\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        // The target was parsed from a unassigned subrule\n        // After the subrule construction, it received a cst node\n        // This CST node will later be overriden by the cst node builder\n        // To prevent references to stale AST nodes in the CST,\n        // we need to remove the reference here\n        const targetCstNode = target.$cstNode;\n        if (targetCstNode) {\n            targetCstNode.astNode = undefined;\n            target.$cstNode = undefined;\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n}\nexport class AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage(options) {\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage({ expected, actual }) {\n        const expectedMsg = expected.LABEL\n            ? '`' + expected.LABEL + '`'\n            : expected.name.endsWith(':KW')\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\n                : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\nexport class LangiumCompletionParser extends AbstractLangiumParser {\n    constructor() {\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {\n        // NOOP\n    }\n    construct() {\n        // NOOP\n        return undefined;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input, { mode: 'partial' });\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            }\n            finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n}\nconst defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: 'full',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n    constructor(tokens, config) {\n        const useDefaultLookahead = config && 'maxLookahead' in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new LLStarLookaheadStrategy({\n                    // If validations are skipped, don't log the lookahead warnings\n                    logging: config.skipValidations ? () => { } : undefined\n                }) }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n}\n//# sourceMappingURL=langium-parser.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\nexport function createParser(grammar, parser, tokens) {\n    const parserContext = {\n        parser,\n        tokens,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\nfunction buildRules(parserContext, grammar) {\n    const reachable = getAllReachableRules(grammar, false);\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n    }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if (isKeyword(element)) {\n        method = buildKeyword(ctx, element);\n    }\n    else if (isAction(element)) {\n        method = buildAction(ctx, element);\n    }\n    else if (isAssignment(element)) {\n        method = buildElement(ctx, element.terminal);\n    }\n    else if (isCrossReference(element)) {\n        method = buildCrossReference(ctx, element);\n    }\n    else if (isRuleCall(element)) {\n        method = buildRuleCall(ctx, element);\n    }\n    else if (isAlternatives(element)) {\n        method = buildAlternatives(ctx, element);\n    }\n    else if (isUnorderedGroup(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    }\n    else if (isGroup(element)) {\n        method = buildGroup(ctx, element);\n    }\n    else if (isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, EOF, element);\n    }\n    else {\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n    const actionType = getTypeName(action);\n    return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if (isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const fragment = rule.fragment;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n    }\n    else if (isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    }\n    else if (!rule) {\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n    }\n    else {\n        assertUnreachable(rule);\n    }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\nfunction buildPredicate(condition) {\n    if (isDisjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    }\n    else if (isConjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    }\n    else if (isNegation(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    }\n    else if (isParameterReference(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args) => args !== undefined && args[name] === true;\n    }\n    else if (isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    }\n    else {\n        const methods = [];\n        for (const element of alternatives.elements) {\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\nfunction buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods = [];\n    for (const element of group.elements) {\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = (groupIdx, lParser) => {\n        const stackId = lParser.getRuleStack().join('-');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key);\n                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        }\n        else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\nfunction buildGroup(ctx, group) {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n    if (isGroup(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n        }\n        const assignment = findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) {\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    }\n    else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n        // The terminal is a data type rule here. Everything else will result in a validation error.\n        const rule = terminal.rule.ref;\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n    }\n    else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    }\n    else if (isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error('Could not build cross reference parser');\n    }\n}\nfunction buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error('Could not find token for keyword: ' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n    const gate = guard && buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return method;\n        }\n    }\n    if (cardinality === '*') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else if (cardinality === '+') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    }\n    else if (cardinality === '?') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else {\n        assertUnreachable(cardinality);\n    }\n}\nfunction getRule(ctx, element) {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.parser.getRule(name);\n    if (!rule)\n        throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\nfunction getRuleName(ctx, element) {\n    if (isParserRule(element)) {\n        return element.name;\n    }\n    else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element);\n    }\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while (!isParserRule(parent)) {\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + ':' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + ':' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\nfunction getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token)\n        throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n//# sourceMappingURL=parser-builder-base.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nexport function createLangiumParser(services) {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nexport function prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumParser(services);\n    return createParser(grammar, parser, lexer.definition);\n}\n//# sourceMappingURL=langium-parser-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\n */\nexport function delayNextTick() {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === 'undefined') {\n            setTimeout(resolve, 0);\n        }\n        else {\n            setImmediate(resolve);\n        }\n    });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nexport function startCancelableOperation() {\n    lastTick = performance.now();\n    return new CancellationTokenSource();\n}\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nexport function setInterruptionPeriod(period) {\n    globalInterruptionPeriod = period;\n}\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nexport const OperationCancelled = Symbol('OperationCancelled');\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nexport function isOperationCancelled(err) {\n    return err === OperationCancelled;\n}\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nexport async function interruptAndCheck(token) {\n    if (token === CancellationToken.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = performance.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n        // prevent calling delayNextTick every iteration of loop\n        // where delayNextTick takes up the majority or all of the\n        // globalInterruptionPeriod itself\n        lastTick = performance.now();\n    }\n    if (token.isCancellationRequested) {\n        throw OperationCancelled;\n    }\n}\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nexport class Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (arg) => {\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err) => {\n                reject(err);\n                return this;\n            };\n        });\n    }\n}\n//# sourceMappingURL=promise-utils.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) {\n            return lineOffset;\n        }\n        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n            offset--;\n        }\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charCodeAt(i);\n        if (isEOL(ch)) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction isEOL(char) {\n    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\nexport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { TextDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { URI } from '../utils/uri-utils.js';\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nexport var DocumentState;\n(function (DocumentState) {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    DocumentState[DocumentState[\"Changed\"] = 0] = \"Changed\";\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    DocumentState[DocumentState[\"Parsed\"] = 1] = \"Parsed\";\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    DocumentState[DocumentState[\"IndexedContent\"] = 2] = \"IndexedContent\";\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    DocumentState[DocumentState[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    DocumentState[DocumentState[\"Linked\"] = 4] = \"Linked\";\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    DocumentState[DocumentState[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    DocumentState[DocumentState[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nexport class DefaultLangiumDocumentFactory {\n    constructor(services) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = CancellationToken.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, token) {\n        uri = uri !== null && uri !== void 0 ? uri : URI.parse(textDocument.uri);\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, textDocument, token);\n        }\n        else {\n            return this.create(uri, textDocument, token);\n        }\n    }\n    fromString(text, uri, token) {\n        if (CancellationToken.is(token)) {\n            return this.createAsync(uri, text, token);\n        }\n        else {\n            return this.create(uri, text, token);\n        }\n    }\n    fromModel(model, uri) {\n        return this.create(uri, { $model: model });\n    }\n    create(uri, content, options) {\n        if (typeof content === 'string') {\n            const parseResult = this.parse(uri, content, options);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else if ('$model' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument(parseResult, uri);\n        }\n        else {\n            const parseResult = this.parse(uri, content.getText(), options);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === 'string') {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) {\n            Object.defineProperty(document, 'textDocument', {\n                value: textDocument\n            });\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, 'textDocument', {\n                get: textDocumentGetter\n            });\n        }\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text, options) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text, options);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = undefined;\n        return () => {\n            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : ''));\n        };\n    }\n}\nexport class DefaultLangiumDocuments {\n    constructor(services) {\n        this.documentMap = new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get all() {\n        return stream(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        }\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\n            linker.unlink(langiumDoc);\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n//# sourceMappingURL=documents.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { DocumentState } from '../workspace/documents.js';\nconst ref_resolving = Symbol('ref_resolving');\nexport class DefaultLinker {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = CancellationToken.None) {\n        for (const node of streamAst(document.parseResult.value)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        var _a;\n        const ref = refInfo.reference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            ref._ref = ref_resolving;\n            try {\n                const description = this.getCandidate(refInfo);\n                if (isLinkingError(description)) {\n                    ref._ref = description;\n                }\n                else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                    }\n                    else {\n                        // Try to load the target AST node later using the already provided description\n                        ref._ref = undefined;\n                    }\n                }\n            }\n            catch (err) {\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\n                const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });\n            }\n            // Add the reference to the document's array of references\n            // Only add if the reference has been not been resolved earlier\n            // Otherwise we end up with duplicates\n            // See also implementation of `buildReference`\n            document.references.push(ref);\n        }\n    }\n    unlink(document) {\n        for (const ref of document.references) {\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref() {\n                var _a;\n                if (isAstNode(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                }\n                else if (isAstNodeDescription(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                }\n                else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    this._ref = ref_resolving;\n                    const document = findRootNode(node).$document;\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && document && document.state < DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\n                        return this._ref = undefined;\n                    }\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                    document === null || document === void 0 ? void 0 : document.references.push(this);\n                }\n                else if (this._ref === ref_resolving) {\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\n                }\n                return isAstNode(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return isLinkingError(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        var _a;\n        try {\n            const description = this.getCandidate(refInfo);\n            if (isLinkingError(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error: this.createLinkingError(refInfo, description)\n                };\n            }\n        }\n        catch (err) {\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\n            const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n            return {\n                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = findRootNode(refInfo.container).$document;\n        if (document && document.state < DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n    }\n}\n//# sourceMappingURL=linker.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findNodeForProperty } from '../utils/grammar-utils.js';\nexport function isNamed(node) {\n    return typeof node.name === 'string';\n}\nexport class DefaultNameProvider {\n    getName(node) {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n    getNameNode(node) {\n        return findNodeForProperty(node.$cstNode, 'name');\n    }\n}\n//# sourceMappingURL=name-provider.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI, Utils } from 'vscode-uri';\nexport { URI };\nexport var UriUtils;\n(function (UriUtils) {\n    UriUtils.basename = Utils.basename;\n    UriUtils.dirname = Utils.dirname;\n    UriUtils.extname = Utils.extname;\n    UriUtils.joinPath = Utils.joinPath;\n    UriUtils.resolvePath = Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    UriUtils.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === 'string' ? from : from.path;\n        const toPath = typeof to === 'string' ? to : to.path;\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\n        const toParts = toPath.split('/').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = '../'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join('/');\n        return backPart + toPart;\n    }\n    UriUtils.relative = relative;\n    function normalize(uri) {\n        return URI.parse(uri.toString()).toString();\n    }\n    UriUtils.normalize = normalize;\n})(UriUtils || (UriUtils = {}));\n//# sourceMappingURL=uri-utils.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { findAssignment } from '../utils/grammar-utils.js';\nimport { isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultReferences {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if (isReference(reference)) {\n                    return reference.ref;\n                }\n                else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if (isReference(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return undefined;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return stream(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=references.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Reduction, stream } from './stream.js';\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nexport class MultiMap {\n    constructor(elements) {\n        this.map = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n    /**\n     * The total number of values in the multimap.\n     */\n    get size() {\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\n    }\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear() {\n        this.map.clear();\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key, value) {\n        if (value === undefined) {\n            return this.map.delete(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    }\n                    else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key, value) {\n        if (value === undefined) {\n            return this.map.has(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key, value) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(value);\n        }\n        else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key, values) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(...values);\n        }\n        else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn) {\n        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));\n    }\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries() {\n        return stream(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value]));\n    }\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys() {\n        return stream(this.map.keys());\n    }\n    /**\n     * Returns a stream of values in the map.\n     */\n    values() {\n        return stream(this.map.values()).flat();\n    }\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey() {\n        return stream(this.map.entries());\n    }\n}\nexport class BiMap {\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements) {\n        this.map = new Map();\n        this.inverse = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=collections.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { streamAllContents, streamContents } from '../utils/ast-utils.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nexport class DefaultScopeComputation {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = CancellationToken.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCancelled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = CancellationToken.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n    async computeLocalScopes(document, cancelToken = CancellationToken.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new MultiMap();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of streamAllContents(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n}\n//# sourceMappingURL=scope-computation.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nexport class StreamScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        }\n        else {\n            return this.elements;\n        }\n    }\n    getElement(name) {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\nexport class MapScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n    getAllElements() {\n        let elementStream = stream(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n}\nexport const EMPTY_SCOPE = {\n    getElement() {\n        return undefined;\n    },\n    getAllElements() {\n        return EMPTY_STREAM;\n    }\n};\n//# sourceMappingURL=scope.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DisposableCache {\n    constructor() {\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error('This cache has already been disposed');\n        }\n    }\n}\nexport class SimpleCache extends DisposableCache {\n    constructor() {\n        super(...arguments);\n        this.cache = new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\nexport class ContextCache extends DisposableCache {\n    constructor(converter) {\n        super();\n        this.cache = new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        }\n        else {\n            this.cache.clear();\n        }\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nexport class DocumentCache extends ContextCache {\n    /**\n     * Creates a new document cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     *\n     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,\n     * which triggers on all documents that have been affected by this change, assuming that the\n     * state is `DocumentState.Linked` or a later state.\n     */\n    constructor(sharedServices, state) {\n        super(uri => uri.toString());\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {\n                this.clear(document.uri.toString());\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                for (const uri of deleted) { // react only on deleted documents\n                    this.clear(uri);\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n                const allUris = changed.concat(deleted); // react on both changed and deleted documents\n                for (const uri of allUris) {\n                    this.clear(uri);\n                }\n            }));\n        }\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace is added, changed or deleted, the whole cache is evicted.\n */\nexport class WorkspaceCache extends SimpleCache {\n    /**\n     * Creates a new workspace cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     */\n    constructor(sharedServices, state) {\n        super();\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\n                this.clear();\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                if (deleted.length > 0) { // react only on deleted documents\n                    this.clear();\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n                this.clear();\n            }));\n        }\n    }\n}\n//# sourceMappingURL=caching.js.map","/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\nexport class DefaultScopeProvider {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push(stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    createScope(elements, outerScope, options) {\n        return new StreamScope(stream(elements), outerScope, options);\n    }\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    createScopeForNodes(elements, outerScope, options) {\n        const s = stream(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new StreamScope(s, outerScope, options);\n    }\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n    }\n}\n//# sourceMappingURL=scope-provider.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { URI } from 'vscode-uri';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { findNodesForProperty } from '../utils/grammar-utils.js';\nexport function isAstNodeWithComment(node) {\n    return typeof node.$comment === 'string';\n}\nfunction isIntermediateReference(obj) {\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\n}\nexport class DefaultJsonSerializer {\n    constructor(services) {\n        /** The set of AstNode properties to be ignored by the serializer. */\n        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options) {\n        const serializeOptions = options !== null && options !== void 0 ? options : {};\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);\n        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = getDocument(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        }\n        finally {\n            this.currentDocument = undefined;\n        }\n    }\n    deserialize(content, options) {\n        const deserializeOptions = options !== null && options !== void 0 ? options : {};\n        const root = JSON.parse(content);\n        this.linkNode(root, root, deserializeOptions);\n        return root;\n    }\n    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        }\n        else if (isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = getDocument(refValue);\n                let targetUri = '';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    }\n                    else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                };\n            }\n            else {\n                return {\n                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference',\n                    $refText\n                };\n            }\n        }\n        else if (isAstNode(value)) {\n            let astNode = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    astNode.$comment = comment.replace(/\\r/g, '');\n                }\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        }\n        else {\n            return value;\n        }\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = cstNode => ({\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        });\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n            return node;\n        }\n        return undefined;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    }\n                    else if (isAstNode(element)) {\n                        this.linkNode(element, root, options, node, propertyName, index);\n                    }\n                }\n            }\n            else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            }\n            else if (isAstNode(item)) {\n                this.linkNode(item, root, options, node, propertyName);\n            }\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if (isAstNode(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : '',\n                    ref\n                };\n            }\n            else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : ''\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        }\n        else {\n            return undefined;\n        }\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf('#');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return 'Could not resolve path: ' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return 'Could not find document for URI: ' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return 'Could not find document for URI: ' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return 'Could not resolve URI: ' + uri;\n            }\n            return node;\n        }\n        catch (err) {\n            return String(err);\n        }\n    }\n}\n//# sourceMappingURL=json-serializer.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { UriUtils } from './utils/uri-utils.js';\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nexport class DefaultServiceRegistry {\n    /**\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n     */\n    get map() {\n        return this.fileExtensionMap;\n    }\n    constructor(services) {\n        this.languageIdMap = new Map();\n        this.fileExtensionMap = new Map();\n        this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n    }\n    register(language) {\n        const data = language.LanguageMetaData;\n        for (const ext of data.fileExtensions) {\n            if (this.fileExtensionMap.has(ext)) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\n            }\n            this.fileExtensionMap.set(ext, language);\n        }\n        this.languageIdMap.set(data.languageId, language);\n        if (this.languageIdMap.size === 1) {\n            this.singleton = language;\n        }\n        else {\n            this.singleton = undefined;\n        }\n    }\n    getServices(uri) {\n        var _a, _b;\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.languageIdMap.size === 0) {\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n        }\n        const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;\n        if (languageId !== undefined) {\n            const services = this.languageIdMap.get(languageId);\n            if (services) {\n                return services;\n            }\n        }\n        const ext = UriUtils.extname(uri);\n        const services = this.fileExtensionMap.get(ext);\n        if (!services) {\n            if (languageId) {\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n            }\n            else {\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n            }\n        }\n        return services;\n    }\n    hasServices(uri) {\n        try {\n            this.getServices(uri);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    get all() {\n        return Array.from(this.languageIdMap.values());\n    }\n}\n//# sourceMappingURL=service-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../index.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nexport function diagnosticData(code) {\n    return { code };\n}\nexport var ValidationCategory;\n(function (ValidationCategory) {\n    ValidationCategory.all = ['fast', 'slow', 'built-in'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nexport class ValidationRegistry {\n    constructor(services) {\n        this.entries = new MultiMap();\n        this.entriesBefore = [];\n        this.entriesAfter = [];\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register(checksRecord, thisObj = this, category = 'fast') {\n        if (category === 'built-in') {\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            }\n            else if (typeof callbacks === 'function') {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n            else {\n                assertUnreachable(callbacks);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\n        };\n    }\n    async handleException(functionality, messageContext, accept, node) {\n        try {\n            await functionality();\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error(`${messageContext}:`, err);\n            if (err instanceof Error && err.stack) {\n                console.error(err.stack);\n            }\n            const messageDetails = err instanceof Error ? err.message : String(err);\n            accept('error', `${messageContext}: ${messageDetails}`, { node });\n        }\n    }\n    addEntry(type, entry) {\n        if (type === 'AstNode') {\n            this.entries.add('AstNode', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n    getChecks(type, categories) {\n        let checks = stream(this.entries.get(type))\n            .concat(this.entries.get('AstNode'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n    /**\n     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map for mapping names to nodes could be established.\n     * During the usual checks on the nodes, they are put into this map with their name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerBeforeDocument(checkBefore, thisObj = this) {\n        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\n    }\n    /**\n     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n     * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map with all the collected nodes and their names is checked\n     * and validation hints are created for all nodes with the same name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerAfterDocument(checkAfter, thisObj = this) {\n        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\n    }\n    wrapPreparationException(check, messageContext, thisObj) {\n        return async (rootNode, accept, categories, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n        };\n    }\n    get checksBefore() {\n        return this.entriesBefore;\n    }\n    get checksAfter() {\n        return this.entriesAfter;\n    }\n}\n//# sourceMappingURL=validation-registry.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { tokenToRange } from '../utils/cst-utils.js';\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { diagnosticData } from './validation-registry.js';\nexport class DefaultDocumentValidator {\n    constructor(services) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = CancellationToken.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await interruptAndCheck(cancelToken);\n        if (!options.categories || options.categories.includes('built-in')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {\n                return diagnostics;\n            }\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {\n                return diagnostics;\n            }\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {\n                return diagnostics;\n            }\n        }\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error('An error occurred during validation:', err);\n        }\n        await interruptAndCheck(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        var _a, _b, _c;\n        const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null && _b !== void 0 ? _b : []];\n        for (const lexerDiagnostic of lexerDiagnostics) {\n            const severity = (_c = lexerDiagnostic.severity) !== null && _c !== void 0 ? _c : 'error';\n            const diagnostic = {\n                severity: toDiagnosticSeverity(severity),\n                range: {\n                    start: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column - 1\n                    },\n                    end: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column + lexerDiagnostic.length - 1\n                    }\n                },\n                message: lexerDiagnostic.message,\n                data: toDiagnosticData(severity),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors) {\n            let range = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if ('previousToken' in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = { line: token.endLine - 1, character: token.endColumn };\n                        range = { start: position, end: position };\n                    }\n                    else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position = { line: 0, character: 0 };\n                        range = { start: position, end: position };\n                    }\n                }\n            }\n            else {\n                range = tokenToRange(parserError.token);\n            }\n            if (range) {\n                const diagnostic = {\n                    severity: toDiagnosticSeverity('error'),\n                    range,\n                    message: parserError.message,\n                    data: diagnosticData(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = CancellationToken.None) {\n        const validationItems = [];\n        const acceptor = (severity, message, info) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\n        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\n        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\n        return validationItems;\n    }\n    async validateAstBefore(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksBefore = this.validationRegistry.checksBefore;\n        for (const checkBefore of checksBefore) {\n            await interruptAndCheck(cancelToken);\n            await checkBefore(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    async validateAstNodes(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        await Promise.all(streamAst(rootNode).map(async (node) => {\n            await interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n    }\n    async validateAstAfter(rootNode, options, acceptor, cancelToken = CancellationToken.None) {\n        var _a;\n        const checksAfter = this.validationRegistry.checksAfter;\n        for (const checkAfter of checksAfter) {\n            await interruptAndCheck(cancelToken);\n            await checkAfter(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n}\nexport function getDiagnosticRange(info) {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode;\n    if (typeof info.property === 'string') {\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    }\n    else if (typeof info.keyword === 'string') {\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\n/**\n * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.\n *\n * @param severity The lexing diagnostic severity\n * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`\n */\nexport function toDiagnosticSeverity(severity) {\n    switch (severity) {\n        case 'error':\n            return 1;\n        case 'warning':\n            return 2;\n        case 'info':\n            return 3;\n        case 'hint':\n            return 4;\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport function toDiagnosticData(severity) {\n    switch (severity) {\n        case 'error':\n            return diagnosticData(DocumentValidator.LexingError);\n        case 'warning':\n            return diagnosticData(DocumentValidator.LexingWarning);\n        case 'info':\n            return diagnosticData(DocumentValidator.LexingInfo);\n        case 'hint':\n            return diagnosticData(DocumentValidator.LexingHint);\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nexport var DocumentValidator;\n(function (DocumentValidator) {\n    DocumentValidator.LexingError = 'lexing-error';\n    DocumentValidator.LexingWarning = 'lexing-warning';\n    DocumentValidator.LexingInfo = 'lexing-info';\n    DocumentValidator.LexingHint = 'lexing-hint';\n    DocumentValidator.ParsingError = 'parsing-error';\n    DocumentValidator.LinkingError = 'linking-error';\n})(DocumentValidator || (DocumentValidator = {}));\n//# sourceMappingURL=document-validator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isLinkingError } from '../syntax-tree.js';\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { toDocumentSegment } from '../utils/cst-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultAstNodeDescriptionProvider {\n    constructor(services) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document) {\n        const doc = document !== null && document !== void 0 ? document : getDocument(node);\n        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment;\n        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: doc.uri,\n            path\n        };\n    }\n}\nexport class DefaultReferenceDescriptionProvider {\n    constructor(services) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = CancellationToken.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of streamAst(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: toDocumentSegment(refCstNode),\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n}\n//# sourceMappingURL=ast-descriptions.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport class DefaultAstNodeLocator {\n    constructor() {\n        this.segmentSeparator = '/';\n        this.indexSeparator = '@';\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return '';\n    }\n    getPathSegment({ $containerProperty, $containerIndex }) {\n        if (!$containerProperty) {\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n}\n//# sourceMappingURL=ast-node-locator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Disposable;\n(function (Disposable) {\n    function create(callback) {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (Disposable = {}));\n//# sourceMappingURL=disposable.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Emitter } from '../utils/event.js';\nimport { Deferred } from '../utils/promise-utils.js';\n/**\n * Base configuration provider for building up other configuration providers\n */\nexport class DefaultConfigurationProvider {\n    constructor(services) {\n        this._ready = new Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.onConfigurationSectionUpdateEmitter = new Emitter();\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => ({\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                }));\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change) {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            const configuration = change.settings[section];\n            this.updateSectionConfiguration(section, configuration);\n            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n    get onConfigurationSectionUpdate() {\n        return this.onConfigurationSectionUpdateEmitter.event;\n    }\n}\n//# sourceMappingURL=configuration.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Disposable } from '../utils/disposable.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { OperationCancelled, interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { ValidationCategory } from '../validation/validation-registry.js';\nimport { DocumentState } from './documents.js';\nexport class DefaultDocumentBuilder {\n    constructor(services) {\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: ['built-in', 'fast']\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new MultiMap();\n        this.documentPhaseListeners = new MultiMap();\n        this.buildState = new Map();\n        this.documentBuildWaiters = new Map();\n        this.currentState = DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = CancellationToken.None) {\n        var _a, _b;\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === DocumentState.Validated) {\n                if (typeof options.validation === 'boolean' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                }\n                else if (typeof options.validation === 'object') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), { categories })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            }\n            else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = CancellationToken.None) {\n        this.currentState = DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\n                newDocument.state = DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n            doc.diagnostics = undefined;\n        });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await interruptAndCheck(cancelToken);\n        // Collect and sort all documents that we should rebuild\n        const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all\n            .filter(doc => {\n            var _a;\n            // This includes those that were reported as changed and those that we selected for relinking\n            return doc.state < DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        })\n            .toArray());\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n    /**\n     * Sort the given documents by priority. By default, documents with an open text document are prioritized.\n     * This is useful to ensure that visible documents show their diagnostics before all other documents.\n     *\n     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\n     * in files that are currently not opened in the editor.\n     */\n    sortDocuments(documents) {\n        let left = 0;\n        let right = documents.length - 1;\n        while (left < right) {\n            while (left < documents.length && this.hasTextDocument(documents[left])) {\n                left++;\n            }\n            while (right >= 0 && !this.hasTextDocument(documents[right])) {\n                right--;\n            }\n            if (left < right) {\n                [documents[left], documents[right]] = [documents[right], documents[left]];\n            }\n        }\n        return documents;\n    }\n    hasTextDocument(doc) {\n        var _a;\n        return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));\n    }\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    shouldRelink(document, changedUris) {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n    /**\n     * Build the given documents by stepping through all build phases. If a document's state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     *\n     * @param documents The documents to build.\n     * @param options the {@link BuildOptions} to use.\n     * @param cancelToken A cancellation token that can be used to cancel the build.\n     * @returns A promise that resolves when the build is done.\n     */\n    async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));\n        // 1. Index content\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));\n        // 2. Compute scopes\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n    /**\n     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\n     *\n     * @param documents collection of documents to be built\n     * @param options the {@link BuildOptions} to use\n     */\n    prepareBuild(documents, options) {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state === null || state === void 0 ? void 0 : state.result\n                });\n            }\n        }\n    }\n    /**\n     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\n     *\n     * @param documents The array of documents to process.\n     * @param targetState The target {@link DocumentState} to bring the documents to.\n     * @param cancelToken A token that can be used to cancel the operation.\n     * @param callback A function to be called for each document.\n     * @returns A promise that resolves when all documents have been processed or the operation is canceled.\n     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\n     */\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter(doc => doc.state < targetState);\n        for (const document of filtered) {\n            await interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n            await this.notifyDocumentPhase(document, targetState, cancelToken);\n        }\n        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state\n        // For example, this happens in case the cancellation triggers between the processing of two documents\n        // Or files that were picked up during the workspace initialization\n        const targetStateDocs = documents.filter(doc => doc.state === targetState);\n        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    onDocumentPhase(targetState, callback) {\n        this.documentPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.documentPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = undefined;\n        if (uriOrToken && 'path' in uriOrToken) {\n            uri = uriOrToken;\n        }\n        else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = CancellationToken.None);\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        }\n        else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(OperationCancelled);\n            });\n        });\n    }\n    async notifyDocumentPhase(document, state, cancelToken) {\n        const listeners = this.documentPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            try {\n                await listener(document, cancelToken);\n            }\n            catch (err) {\n                // Ignore cancellation errors\n                // We want to finish the listeners before throwing\n                if (!isOperationCancelled(err)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) {\n            // Don't notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            await interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it's set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        }\n        else {\n            document.diagnostics = diagnostics;\n        }\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            }\n            else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n}\n//# sourceMappingURL=document-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { ContextCache } from '../utils/caching.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultIndexManager {\n    constructor(services) {\n        /**\n         * The symbol index stores all `AstNodeDescription` items exported by a document.\n         * The key used in this map is the string representation of the specific document URI.\n         */\n        this.symbolIndex = new Map();\n        /**\n         * This is a cache for the `allElements()` method.\n         * It caches the descriptions from `symbolIndex` grouped by types.\n         */\n        this.symbolByTypeIndex = new ContextCache();\n        /**\n         * This index keeps track of all `ReferenceDescription` items exported by a document.\n         * This is used to compute which elements are affected by a document change\n         * and for finding references to an AST node.\n         */\n        this.referenceIndex = new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = getDocument(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return stream(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = stream(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) {\n            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            var _a;\n            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n}\n//# sourceMappingURL=index-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Deferred, interruptAndCheck } from '../utils/promise-utils.js';\nimport { URI, UriUtils } from '../utils/uri-utils.js';\nexport class DefaultWorkspaceManager {\n    constructor(services) {\n        this.initialBuildOptions = {};\n        this._ready = new Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    get workspaceFolders() {\n        return this.folders;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;\n    }\n    initialized(_params) {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });\n    }\n    async initializeWorkspace(folders, cancelToken = CancellationToken.None) {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = (document) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don't await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])\n            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    getRootFolder(workspaceFolder) {\n        return URI.parse(workspaceFolder.uri);\n    }\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry) => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                }\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = UriUtils.basename(entry.uri);\n        if (name.startsWith('.')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== 'node_modules' && name !== 'out';\n        }\n        else if (entry.isFile) {\n            const extname = UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=workspace-manager.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Lexer as ChevrotainLexer, defaultLexerErrorProvider } from 'chevrotain';\nexport class DefaultLexerErrorMessageProvider {\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\n    }\n    buildUnableToPopLexerModeMessage(token) {\n        return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\n    }\n}\nexport const DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };\nexport class DefaultLexer {\n    constructor(services) {\n        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\n        this.tokenBuilder = services.parser.TokenBuilder;\n        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\n            positionTracking: 'full',\n            skipValidations: production,\n            errorMessageProvider: this.errorMessageProvider\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {\n        var _a, _b, _c;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : [],\n            report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if (isTokenTypeDictionary(buildTokens))\n            return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nexport function isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\n}\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nexport function isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nexport function isTokenTypeDictionary(tokenVocabulary) {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n//# sourceMappingURL=lexer.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position, Range } from 'vscode-languageserver-types';\nimport { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';\nimport { URI } from '../utils/uri-utils.js';\nexport function parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === 'string') {\n        position = start;\n        opts = options;\n    }\n    else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) {\n        position = Position.create(0, 0);\n    }\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\nexport function isJSDoc(node, options) {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\nfunction getLines(node) {\n    let content = '';\n    if (typeof node === 'string') {\n        content = node;\n    }\n    else {\n        content = node.text;\n    }\n    const lines = content.split(NEWLINE_REGEXP);\n    return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: 'break',\n                    content: '',\n                    range: Range.create(position, position)\n                });\n            }\n        }\n        else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = Position.create(currentLine, currentCharacter + index);\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: 'tag',\n                    content: value,\n                    range: Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\n        return tokens.slice(0, -1);\n    }\n    return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = Position.create(lineIndex, characterIndex);\n        const end = Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: 'text',\n            content: line,\n            range: Range.create(start, end)\n        });\n    }\n    else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: 'text',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: 'inline-tag',\n                content: tagName,\n                range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: 'text',\n                    content: value,\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            }\n            else {\n                tokens.push({\n                    type: 'text',\n                    content: '',\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: 'text',\n                content: endContent,\n                range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n            });\n        }\n    }\n    return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index;\n    }\n    else {\n        return line.length;\n    }\n}\nfunction lastCharacter(line) {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === 'number') {\n        return match.index;\n    }\n    return undefined;\n}\n// Parsing\nfunction parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n    }\n    const elements = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new JSDocCommentImpl(elements, Range.create(start, end));\n}\nfunction parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === 'tag') {\n        return parseJSDocTag(context, false);\n    }\n    else if (next.type === 'text' || next.type === 'inline-tag') {\n        return parseJSDocText(context);\n    }\n    else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\nfunction appendEmptyLine(token, element) {\n    if (element) {\n        const line = new JSDocLineImpl('', token.range);\n        if ('inlines' in element) {\n            element.inlines.push(line);\n        }\n        else {\n            element.content.inlines.push(line);\n        }\n    }\n}\nfunction parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while (token && token.type !== 'break' && token.type !== 'tag') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === 'inline-tag') {\n        return parseJSDocTag(context, true);\n    }\n    else {\n        return parseJSDocLine(context);\n    }\n}\nfunction parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n        }\n        else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    }\n    else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\nfunction parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n    if (!options) {\n        return normalizeOptions({\n            start: '/**',\n            end: '*/',\n            line: '*'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\nfunction normalizeOption(option, start) {\n    if (typeof option === 'string' || typeof option === 'object') {\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        }\n        else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    }\n    else {\n        return option;\n    }\n}\nclass JSDocCommentImpl {\n    constructor(elements, range) {\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find(e => e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e) => 'name' in e);\n    }\n    toString() {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            }\n            else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            }\n            else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\nclass JSDocTagImpl {\n    constructor(name, content, inline, range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === 'string') {\n                return rendered;\n            }\n        }\n        let marker = '';\n        if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {\n            marker = '*';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {\n            marker = '**';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {\n            marker = '***';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text}  ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n}\nfunction renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\n        const index = content.indexOf(' ');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\nfunction renderLinkDefault(content, display) {\n    try {\n        URI.parse(content, true);\n        return `[${display}](${content})`;\n    }\n    catch (_a) {\n        return content;\n    }\n}\nclass JSDocTextImpl {\n    constructor(lines, range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n}\nclass JSDocLineImpl {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n}\nfunction fillNewlines(text) {\n    if (text.endsWith('\\n')) {\n        return '\\n';\n    }\n    else {\n        return '\\n\\n';\n    }\n}\n//# sourceMappingURL=jsdoc.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\nexport class JSDocDocumentationProvider {\n    constructor(services) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && isJSDoc(comment)) {\n            const parsedJSDoc = parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        }\n        else {\n            return undefined;\n        }\n    }\n    documentationTagRenderer(_node, _tag) {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n        return undefined;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n//# sourceMappingURL=documentation-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\nimport { findCommentNode } from '../utils/cst-utils.js';\nexport class DefaultCommentProvider {\n    constructor(services) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if (isAstNodeWithComment(node)) {\n            return node.$comment;\n        }\n        return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n}\n//# sourceMappingURL=comment-provider.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Deferred, OperationCancelled } from '../utils/promise-utils.js';\nimport { Emitter } from '../utils/event.js';\n/**\n * Default implementation of the async parser which simply wraps the sync parser in a promise.\n *\n * @remarks\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nexport class DefaultAsyncParser {\n    constructor(services) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text, _cancelToken) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n}\nexport class AbstractThreadedAsyncParser {\n    constructor(services) {\n        /**\n         * The thread count determines how many threads are used to parse files in parallel.\n         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n         */\n        this.threadCount = 8;\n        /**\n         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n         * The default value is 200(ms).\n         */\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new Deferred();\n        let timeout;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new Deferred();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n}\nexport class ParserWorker {\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate) {\n        this.onReadyEmitter = new Emitter();\n        this.deferred = new Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject(OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) {\n            throw new Error('Parser worker is busy');\n        }\n        this._parsing = true;\n        this.deferred = new Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n//# sourceMappingURL=async-parser.js.map","/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\nimport { Deferred, isOperationCancelled, startCancelableOperation } from '../utils/promise-utils.js';\nexport class DefaultWorkspaceLock {\n    constructor() {\n        this.previousTokenSource = new CancellationTokenSource();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = startCancelableOperation();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken = CancellationToken.None) {\n        const deferred = new Deferred();\n        const entry = {\n            action,\n            deferred,\n            cancellationToken\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) {\n            return;\n        }\n        const entries = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift());\n        }\n        else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        }\n        else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            }\n            catch (err) {\n                if (isOperationCancelled(err)) {\n                    // If the operation was cancelled, we don't want to reject the promise\n                    deferred.resolve(undefined);\n                }\n                else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n}\n//# sourceMappingURL=workspace-lock.js.map","/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';\nimport { isAbstractElement } from '../languages/generated/ast.js';\nimport { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { BiMap } from '../utils/collections.js';\nimport { streamCst } from '../utils/cst-utils.js';\nexport class DefaultHydrator {\n    constructor(services) {\n        this.grammarElementIdMap = new BiMap();\n        this.tokenTypeIdMap = new BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            parserErrors: result.parserErrors.map(e => (Object.assign(Object.assign({}, e), { message: e.message }))),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    dehydrateLexerReport(lexerReport) {\n        // By default, lexer reports are serializable\n        return lexerReport;\n    }\n    createDehyrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            }\n            else if (isReference(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            }\n            else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if (isRootCstNode(node)) {\n            cstNode.fullText = node.fullText;\n        }\n        else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if (isCompositeCstNode(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        }\n        else if (isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if ('$cstNode' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        let root;\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                let cst;\n                if ('fullText' in cstNode) {\n                    cst = new RootCstNodeImpl(cstNode.fullText);\n                    root = cst;\n                }\n                else if ('content' in cstNode) {\n                    cst = new CompositeCstNodeImpl();\n                }\n                else if ('tokenType' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    }\n                    else if (isReference(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (isAstNode(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            }\n            else if (isReference(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            }\n            else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === 'number') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if (isCompositeCstNode(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (!node) {\n            return undefined;\n        }\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        return element;\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of streamAst(this.grammar)) {\n            if (isAbstractElement(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n}\n//# sourceMappingURL=hydrator.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\nimport { createGrammarConfig } from './languages/grammar-config.js';\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\nimport { DefaultValueConverter } from './parser/value-converter.js';\nimport { DefaultLinker } from './references/linker.js';\nimport { DefaultNameProvider } from './references/name-provider.js';\nimport { DefaultReferences } from './references/references.js';\nimport { DefaultScopeComputation } from './references/scope-computation.js';\nimport { DefaultScopeProvider } from './references/scope-provider.js';\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\nimport { DefaultServiceRegistry } from './service-registry.js';\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\nimport { ValidationRegistry } from './validation/validation-registry.js';\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\nimport { DefaultIndexManager } from './workspace/index-manager.js';\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\nimport { DefaultLexer, DefaultLexerErrorMessageProvider } from './parser/lexer.js';\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\nimport { DefaultAsyncParser } from './parser/async-parser.js';\nimport { DefaultWorkspaceLock } from './workspace/workspace-lock.js';\nimport { DefaultHydrator } from './serializer/hydrator.js';\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nexport function createDefaultCoreModule(context) {\n    return {\n        documentation: {\n            CommentProvider: (services) => new DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new DefaultAsyncParser(services),\n            GrammarConfig: (services) => createGrammarConfig(services),\n            LangiumParser: (services) => createLangiumParser(services),\n            CompletionParser: (services) => createCompletionParser(services),\n            ValueConverter: () => new DefaultValueConverter(),\n            TokenBuilder: () => new DefaultTokenBuilder(),\n            Lexer: (services) => new DefaultLexer(services),\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider(),\n            LexerErrorMessageProvider: () => new DefaultLexerErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new DefaultLinker(services),\n            NameProvider: () => new DefaultNameProvider(),\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\n            References: (services) => new DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new DefaultHydrator(services),\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nexport function createDefaultSharedCoreModule(context) {\n    return {\n        ServiceRegistry: (services) => new DefaultServiceRegistry(services),\n        workspace: {\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n            IndexManager: (services) => new DefaultIndexManager(services),\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n        }\n    };\n}\n//# sourceMappingURL=default-module.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { DefaultNameRegexp } from '../utils/cst-utils.js';\nimport { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';\nimport { isMultilineComment } from '../utils/regexp-utils.js';\nimport { isTerminalRule } from './generated/ast.js';\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nexport function createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: DefaultNameRegexp\n    };\n}\n//# sourceMappingURL=grammar-config.js.map","/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { LangiumCompletionParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\nexport function createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumCompletionParser(services);\n    createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n//# sourceMappingURL=completion-parser-builder.js.map","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport var Module;\n(function (Module) {\n    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nexport function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n    return _inject(module);\n}\nconst isProxy = Symbol('isProxy');\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nexport function eagerLoad(item) {\n    if (item && item[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: () => false,\n        set: () => {\n            throw new Error('Cannot set property on injected service container');\n        },\n        get: (obj, prop) => {\n            if (prop === isProxy) {\n                return true;\n            }\n            else {\n                return _resolve(obj, prop, module, injector || proxy);\n            }\n        },\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\n        has: (_, prop) => prop in module, // used by ..in..\n        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in\n    });\n    return proxy;\n}\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\n        }\n        return obj[prop];\n    }\n    else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\n        }\n        catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\n                    target[key] = _merge(value1, value2);\n                }\n                else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=dependency-injection.js.map","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n","/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (isAstNode(item)) {\n                        item.$container = node;\n                        item.$containerProperty = name;\n                        item.$containerIndex = index;\n                    }\n                });\n            }\n            else if (isAstNode(value)) {\n                value.$container = node;\n                value.$containerProperty = name;\n            }\n        }\n    }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType(node, typePredicate) {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node, predicate) {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument(node) {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node) {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node, options) {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) {\n        return true;\n    }\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node) {\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if (isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection, node) {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\nfunction copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    }\n    else {\n        return propertyType;\n    }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode(node, buildReference) {\n    const copy = { $type: node.$type };\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            }\n            else if (isReference(value)) {\n                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n            }\n            else if (Array.isArray(value)) {\n                const copiedArray = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    }\n                    else if (isReference(element)) {\n                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                    }\n                    else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            }\n            else {\n                copy[name] = value;\n            }\n        }\n    }\n    linkContentToContainer(copy);\n    return copy;\n}\n//# sourceMappingURL=ast-utils.js.map","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n","import {\n  AbstractMermaidTokenBuilder,\n  CommonValueConverter,\n  MermaidGeneratedSharedModule,\n  PacketGeneratedModule,\n  __name\n} from \"./chunk-7PKI6E2E.mjs\";\n\n// src/language/packet/module.ts\nimport {\n  EmptyFileSystem,\n  createDefaultCoreModule,\n  createDefaultSharedCoreModule,\n  inject\n} from \"langium\";\n\n// src/language/packet/tokenBuilder.ts\nvar PacketTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, \"PacketTokenBuilder\");\n  }\n  constructor() {\n    super([\"packet-beta\"]);\n  }\n};\n\n// src/language/packet/module.ts\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PacketTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPacketServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Packet = inject(\n    createDefaultCoreModule({ shared }),\n    PacketGeneratedModule,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet);\n  return { shared, Packet };\n}\n__name(createPacketServices, \"createPacketServices\");\n\nexport {\n  PacketModule,\n  createPacketServices\n};\n"],"names":["getAllReachableRules","grammar","allTerminals","ruleNames","Set","entryRule","rules","find","e","entry","getEntryRule","topMostRules","concat","filter","hidden","getHiddenRules","rule","ruleDfs","has","name","add","visitedSet","forEach","node","refRule","ref","getCrossReferenceTerminal","crossRef","terminal","type","nameAssigment","findNameAssignment","isCommentTerminal","terminalRule","terminalRegex","findNodesForProperty","property","findNodesForPropertyInternal","astNode","findNodeForProperty","index","nodes","length","undefined","Math","max","min","element","first","nodeFeature","grammarSource","feature","content","flatMap","findNodeForKeyword","keyword","findNodesForKeywordInternal","value","treeIterator","iterator","result","keywordNodes","next","done","childNode","push","prune","findAssignment","cstNode","_a","container","assignment","startNode","$container","findNameAssignmentInternal","Map","cache","go","refType","childAssignment","set","get","toLowerCase","typeRef","isDataTypeRule","isDataTypeRuleInternal","visited","Boolean","definition","getExplicitRuleType","inferredType","dataType","returnType","getTypeName","actionType","action","getActionType","Error","getRuleType","_b","_c","flags","s","i","u","source","abstractElementToRegex","flagText","Object","entries","map","join","RegExp","WILDCARD","withCardinality","alternatives","elements","cardinality","lookahead","group","range","right","keywordToRegex","left","wrap","characterRangeToRegex","negate","until","lastSlash","regex","lastIndexOf","substring","regexFlags","includes","$type","options","parser","o","k","v","o2","l","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","$Va","$Vb","$Vc","$Vd","$Ve","$Vf","$Vg","$Vh","$Vi","$Vj","$Vk","$Vl","$Vm","$Vn","$Vo","$Vp","$Vq","$Vr","$Vs","$Vt","$Vu","$Vv","$Vw","$Vx","$Vy","$Vz","$VA","$VB","$VC","$VD","$VE","$VF","$VG","$VH","$VI","$VJ","$VK","$VL","$VM","$VN","$VO","$VP","$VQ","$VR","$VS","$VT","$VU","parser2","trace","yy","symbols_","terminals_","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","$","addRelation","title","cleanupLabel","trim","setAccTitle","setAccDescription","addClassesToNamespace","addNamespace","unshift","setCssClass","addMembers","addClass","setClassLabel","addAnnotation","addMember","relation","relationTitle1","relationTitle2","id1","id2","addNote","defineClass","setDirection","type1","type2","lineType","relationType","AGGREGATION","EXTENSION","COMPOSITION","DEPENDENCY","LOLLIPOP","LINE","DOTTED_LINE","setClickEvent","setTooltip","setLink","setCssStyle","table","defaultActions","parseError","str","hash","recoverable","error","parse","input","self","stack","tstack","vstack","lstack","recovering","args","slice","call","arguments","lexer2","create","lexer","sharedState","prototype","hasOwnProperty","setInput","yylloc","yyloc","ranges","lex","token","pop","Array","getPrototypeOf","n","symbol","preErrorSymbol","state","r","p","len","newState","expected","yyval","errStr","showPosition","text","match","line","loc","first_line","last_line","first_column","last_column","apply","EOF","_input","_more","_backtrack","matched","conditionStack","offset","ch","unput","lines","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","replace","upcomingInput","pre","c","test_match","indexed_rule","backup","matches","tempMatch","_currentRules","flex","begin","condition","popState","conditions","topState","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","Parser","classDiagram_default","visibilityValues","ClassMember","constructor","memberType","visibility","classifier","sanitizedInput","parseMember","getDisplayDetails","displayText","id","parameters","cssStyle","parseClassifier","potentialClassifier","exec","detectedVisibility","lastChar","firstChar","startsWith","combinedText","replaceAll","MERMAID_DOM_ID_PREFIX","classCounter","sanitizeText2","txt","sanitizeText","ClassDB","relations","classes","styleClasses","notes","interfaces","namespaces","namespaceCounter","functions","setupToolTips","tooltipElem","_groups","append","attr","style","select","selectAll","on","event","el","currentTarget","rect","getBoundingClientRect","transition","duration","window","scrollX","scrollY","top","document","body","scrollTop","html","classed","direction","getAccTitle","getAccDescription","setDiagramTitle","getDiagramTitle","getConfig","class","bind","clear","bindFunctions","splitClassNameAndType","_id","genericType","className","indexOf","label","shape","cssClasses","methods","members","annotations","styles","domId","addInterface","classId","classInterface","lookUpDomId","getClass","getClasses","getRelations","getNotes","classRelation","debug","JSON","stringify","invalidTypes","annotation","validatedClassName","member","theClass","memberString","endsWith","isArray","reverse","note","ids","classNode","styleClass","textStyles","newStyle","tooltip","getTooltip","namespace","linkStr","target","config","link","formatUrl","securityLevel","linkTarget","functionName","functionArgs","setClickFunc","haveCallback","_domId","elemId","argList","item","elem","querySelector","addEventListener","runFunc","fun","getDirection","dir","children","getNamespace","getNamespaces","classNames","parent","thisClass","getArrowMarker","marker","getData","edges","namespaceKey","keys","isGroup","padding","cssStyles","look","classKey","parentId","cnt","noteNode","themeVariables","noteBkgColor","noteBorderColor","noteClassId","edge","start","end","thickness","arrowTypeStart","arrowTypeEnd","arrowheadStyle","labelStyle","pattern","_interface","interfaceNode","prefix","counter","labelpos","startLabelRight","endLabelLeft","other","styles_default","nodeBorder","classText","fontFamily","mainBkg","lineColor","textColor","getDir","parsedItem","defaultDir","doc","parsedItemDoc","stmt","classRenderer_v3_unified_default","diagramObj","db","draw","async","_version","diag","info","conf","layout","data4Layout","svg","layoutAlgorithm","nodeSpacing","rankSpacing","markers","diagramId","insertTitle","titleTopMargin","useMaxWidth","idCounter","nativeCeil","ceil","nativeMax","step","fromRight","toFinite","List","sentinel","_next","_prev","_sentinel","dequeue","unlink","enqueue","toString","strs","curr","filterOutLinks","DEFAULT_WEIGHT_FN","greedyFAS","g","weightFn","nodeCount","fasGraph","maxIn","maxOut","setNode","in","out","prevWeight","w","weight","edgeWeight","setEdge","buckets","zeroIdx","assignBucket","graph","buildState","results","sources","sinks","removeNode","doGreedyFAS","outEdges","collectPredecessors","inEdges","uEntry","wEntry","run","fas","acyclicer","dfs","dfsFAS","removeEdge","forwardName","reversed","object","paths","path","hasIn","func","flatten","array","identity","iteratee","key","Date","now","addDummyNode","attrs","hasNode","dummy","asNonCompoundGraph","simplified","multigraph","isMultigraph","setGraph","intersectRect","point","sx","sy","x","y","dx","dy","width","h","height","buildLayerMatrix","layering","rank","order","addBorderNode","fn","console","log","notime","prop","sg","sgNode","borderType","prev","setParent","rankDir","rankdir","reverseYOne","points","reverseY","swapXYOne","swapXY","swapWidthHeight","swapWidthHeightOne","dummyChains","vRank","wRank","edgeLabel","labelRank","edgeObj","normalizeEdge","longestPath","minlen","Number","POSITIVE_INFINITY","slack","feasibleTree","delta","t","directed","size","tightTree","findMinSlackEdge","shiftRanks","nodeEdges","edgeV","rsAstral","rsCombo","rsFitz","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsOptVar","rsSeq","rsSymbol","vs","navigation","isDirected","successors","neighbors","acc","doDfs","postorder","networkSimplex","simpleLabel","simplify","initLowLimValues","initCutValues","leaveEdge","exchangeEdges","enterEdge","child","childLab","cutvalue","calcCutValue","assignCutValue","childIsTail","graphEdge","cutValue","isOutEdge","pointsToHead","otherWeight","hasEdge","otherCutValue","tree","root","dfsAssignLowLim","nextLim","low","lim","vLabel","wLabel","tailLabel","flip","candidates","isDescendant","f","flipped","updateRanks","rootLabel","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker","depths","depth","treeDepths","nodeSep","nestingRoot","sumWeights","nodeRankFactor","bottom","borderTop","borderBottom","childTop","childBottom","thisWeight","nestingEdge","CLONE_DEEP_FLAG","buildLayerGraph","relationship","createRootNode","compound","setDefaultNodeLabel","minRank","maxRank","borderLeft","borderRight","props","values","assignFunc","valsLength","comparer","sort","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","isSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","orders","objCriteria","criteria","othCriteria","ordersLength","collection","iteratees","crossCount","cc","twoLayerCrossCount","northLayer","southLayer","southPos","southEntries","pos","firstIndex","treeSize","weightSum","resolveConflicts","cg","mappedEntries","tmp","indegree","barycenter","entryV","entryW","sourceSet","handleIn","vEntry","merged","sum","mergeEntries","handleOut","doResolveConflicts","biasRight","bias","parts","lhs","rhs","sortable","unsortable","vsIndex","consumeUnsortable","last","sortSubgraph","movable","bl","br","subgraphs","barycenters","inV","nodeU","subgraphResult","expandSubgraphs","predecessors","blPred","brPred","downLayerGraphs","buildLayerGraphs","upLayerGraphs","simpleNodes","layers","orderedVs","initOrder","assignOrder","best","bestCC","lastBest","sweepLayerGraphs","ranks","layerGraphs","lg","sorted","rootPrev","prevChild","addSubgraphConstraints","layer","parentDummyChains","postorderNums","pathData","lca","vPath","wPath","findPath","pathIdx","pathV","ascending","keysIn","findType1Conflicts","conflicts","prevLayer","k0","scanPos","prevLayerLength","lastNode","findOtherInnerSegmentNode","k1","scanNode","uLabel","uPos","addConflict","conflictsV","hasConflict","horizontalCompaction","align","reverseSep","xs","blockG","blockGraph","graphLabel","sepFn","edgeSep","sep","nodesep","edgesep","vRoot","uRoot","prevMax","buildBlockGraph","iterate","setXsFunc","nextNodesFunc","reduce","positionX","adjustedLayering","scan","south","southEnd","prevNorthBorder","nextNorthBorder","uNode","north","nextNorthPos","prevNorthPos","southLookahead","findType2Conflicts","xss","vert","horiz","inner","neighborFn","prevIdx","ws","mp","floor","il","verticalAlignment","smallestWidth","NEGATIVE_INFINITY","halfWidth","findSmallestWidthAlignment","alignTo","alignToVals","alignToMin","alignToMax","alignment","xsVals","alignCoordinates","ul","ignore","balance","position","rankSep","ranksep","prevY","maxHeight","positionY","opts","time","debugTiming","layoutGraph","inputGraph","canonicalize","graphDefaults","selectNumberAttrs","graphNumAttrs","graphAttrs","nodeNumAttrs","nodeDefaults","edgeDefaults","edgeNumAttrs","edgeAttrs","buildLayoutGraph","labeloffset","makeSpaceForEdgeLabels","selfEdges","removeSelfEdges","injectEdgeLabelProxies","assignRankMinMax","removeEdgeLabelProxies","addBorderSegments","orderShift","selfEdge","insertSelfEdges","selfNode","positionSelfEdges","b","removeBorderNodes","origLabel","fixupEdgeLabelCoords","minX","maxX","minY","maxY","marginX","marginx","marginY","marginy","getExtremes","translateGraph","p1","p2","nodeV","nodeW","assignNodeIntersects","reversePointsForReversedEdges","runLayout","inputLabel","layoutLabel","updateInputGraph","obj","newAttrs","RadarTokenBuilder","super","RadarModule","TokenBuilder","ValueConverter","createRadarServices","context","shared","Radar","ServiceRegistry","register","toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","bar","guard","toInteger","isArrayLike","predicate","isObjectLike","nodeIsRegExp","isRegExp","tokenLabel","tokType","isString","LABEL","AbstractProduction","_definition","accept","visitor","visit","prod","idx","referencedRule","Rule","orgText","Alternative","ignoreAmbiguities","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","hasPredicates","Terminal","serializeProduction","convertDefinition","serializedNonTerminal","nonTerminalName","separator","terminalType","serializedTerminal","terminalLabel","PATTERN","nodeAny","visitNonTerminal","visitAlternative","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","fromIndex","isOptionalProd","alreadyVisited","subProd","getProductionDslName","RestWalker","walk","prevRest","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","isSequenceProd","firstSet","seq","currSubProd","nextSubProdIdx","hasInnerProdsRemaining","isLastInnerProdOptional","firstForSequence","isBranchingProd","allAlternativesFirsts","innerProd","firstForBranching","ResyncFollowsWalker","topProd","follows","startWalking","followName","occurenceInParent","fullRest","t_in_topProd_follows","TypeError","comparator","isCommon","valuesLength","outer","computed","valuesIndex","isArrayLikeObject","resIndex","PRINT_ERROR","msg","PRINT_WARNING","warn","regExpAstCache","regExpParser","getRegExpAst","regExp","regExpStr","regExpAst","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","ensureOptimizations","ast","firstCharOptimizedIndices","ignoreCase","message","msgSuffix","terms","term","atom","addOptimizedIdxToResult","complement","code","rangeCode","from","to","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","atLeast","isWholeOptional","optimizedCharIdx","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","handleIgnoreCase","findCode","targetCharCodes","codeOrRange","targetCode","CharCodeFinder","found","visitChildren","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","canMatchCharCode","charCodes","charCodeFinder","DEFAULT_MODE","MODES","SUPPORT_STICKY","sticky","analyzeTokenTypes","tokenTypes","tracer","defaults","useSticky","safeMode","positionTracking","lineTerminatorCharacters","onlyRelevantTypes","isEmpty","charCodeToOptimizedIdxMap","initCharCodeToOptimizedIndexMap","currType","Lexer","NA","allTransformedPatterns","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","patternIdxToCanLineTerminator","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","hasCustom","currPattern","regExpSource","addStickyFlag","addStartOfInput","isFunction","escapedRegExpString","wrappedRegExp","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","isUndefined","longerAltType","LONGER_ALT","PUSH_MODE","lineTerminatorCharCodes","getCharCodes","LINE_BREAKS","checkLineBreaksIssues","isCustomPattern","isShortPattern","longerAlt","canLineTerminator","isCustom","short","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","currTokType","optimizedIdx","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx","charOrInt","currOptimizedIdx","unicode","optimizedCodes","validatePatterns","validModesNames","errors","missingResult","tokenTypesWithMissingPattern","LexerDefinitionErrorType","MISSING_PATTERN","valid","findMissingPatterns","invalidResult","tokenTypesWithInvalidPattern","INVALID_PATTERN","findInvalidPatterns","validTokenTypes","withRegExpPatterns","EndAnchorFinder","visitEndAnchor","invalidRegex","regexpAst","endAnchorVisitor","end_of_input","test","EOI_ANCHOR_FOUND","findEndOfInputAnchor","StartAnchorFinder","visitStartAnchor","startAnchorVisitor","start_of_input","SOI_ANCHOR_FOUND","findStartOfInputAnchor","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","findUnsupportedFlags","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","DUPLICATE_PATTERNS_FOUND","findDuplicatePatterns","matchesEmptyString","EMPTY_MATCH_PATTERN","findEmptyMatchRegExps","validateRegExpPattern","INVALID_GROUP_TYPE_FOUND","findInvalidGroupType","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","findModesThatDoNotExist","canBeTested","metaChars","noMetaChar","testIdx","regExpArray","testTokenType","UNREACHABLE_PATTERN","findUnreachablePatterns","performWarningRuntimeChecks","lexerDefinition","trackLines","warnings","hasAnyLineBreak","allTokenTypes","modes","concreteTokenTypes","terminatorCharCodes","currIssue","details","issue","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","buildLineBreakIssueMessage","warningDescriptor","NO_LINE_BREAKS_FLAGS","LineTerminatorOptimizedTester","lastIndex","charsOrCodes","numOrString","charCode","timer","getTime","val","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypesAndParents","clone","categories","searching","CATEGORIES","newCategories","expandCategories","hasShortKeyProperty","hasCategoriesProperty","categoryMatches","hasExtendingTokensTypesMapProperty","assignTokenDefaultProps","singleAssignCategoriesToksMap","assignCategoriesMapProp","assignCategoriesTokensProp","nextNode","pathNode","nextCategory","newPath","isTokenType","defaultLexerErrorProvider","buildUnableToPopLexerModeMessage","image","buildUnexpectedCharactersMessage","fullText","startOffset","column","charAt","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","lineTerminatorsPattern","errorMessageProvider","traceInitPerf","skipValidations","recoveryEnabled","freeze","lexerDefinitionErrors","lexerDefinitionWarning","trackStartLines","trackEndLines","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","indent","traceInitMaxIdent","traceMethod","traceInitVal","Infinity","actualDefinition","hasOnlySingleMode","defaultMode","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","performRuntimeChecks","allModeNames","currModDef","currModName","currAnalyzeResult","allErrMessagesString","chopInput","matchWithTest","updateLastIndex","noop","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","tokenize","initialMode","tokenizeInternal","j","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","orgLength","matchedTokensIndex","guessedNumberOfTokens","matchedTokens","groups","clonedResult","groupKeys","currKey","currGroupValue","cloneEmptyGroups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","startLine","startColumn","newMode","modeCanBeOptimized","push_mode","currConfig","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","foundTerminator","lastLTEndOffset","numOfLTsInMatch","errorStartOffset","errorLine","errorColumn","foundResyncPoint","tokens","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","endOffset","tokenVector","tokenToAdd","PARENT","POP_MODE","createToken","createTokenInternal","tokenMatcher","defaultParserErrorProvider","buildMismatchTokenMessage","actual","previous","ruleName","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","itemMsg","buildEarlyExitMessage","expectedIterationPaths","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","topLevelName","duplicateProd","dslName","extraArgument","buildNamespaceConflictError","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","leftRecursionPath","currRule","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","GastRefResolverVisitor","nameToTopRule","errMsgProvider","resolveRefs","currTopLevel","ParserDefinitionErrorType","UNRESOLVED_SUBRULE_REF","unresolvedRefName","setter","accumulator","initializer","PROD_TYPE","AbstractNextPossibleTokensWalker","possibleTokTypes","nextProductionName","nextProductionOccurrence","isAtEndOfPath","ruleStack","occurrenceStack","updateExpectedNext","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","restProd","AbstractNextTerminalAfterProductionWalker","topRule","isEndOfRule","NextTerminalAfterManyWalker","firstAfterMany","NextTerminalAfterManySepWalker","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","getAlternativesForProd","newDef","currAlt","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currRuleStack","currOccurrenceStack","nextPath","nextIdx","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","getLookaheadPaths","prodType","maxLookahead","getLookaheadPathsForOr","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","dynamicTokensEnabled","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","currNumOfPaths","currPredicate","currPathLength","nextToken","LA","singleTokenAlts","choiceToAlt","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenUniqueKey","RestDefinitionFinderWalker","targetOccurrence","targetProdType","restDef","checkIsTarget","expectedProdType","InsideDefinitionFinderVisitor","targetRef","expectedProdName","initializeArrayOfArrays","pathToHashKeys","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","currAltResult","containsPath","newPartialPathsAndSuffixes","ruleGrammar","insideDefVisitor","insideDef","afterDef","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","areTokenCategoriesNotUsed","lookAheadPaths","singleAltPaths","singlePath","validateGrammar","topLevels","duplicateErrors","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","DUPLICATE_PRODUCTIONS","param","getExtraProductionArgument","parameter","validateDuplicateProductions","termsNamespaceConflictErrors","tokenNames","currToken","currRuleName","CONFLICT_TOKENS_RULES_NAMESPACE","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","orCollector","OrCollector","ors","alternations","currOr","TOO_MANY_ALTS","validateTooManyAlts","duplicateRulesError","allRules","occurrences","DUPLICATE_RULE_NAME","validateRuleDoesNotAlreadyExist","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","currSubDef","isFirstOptional","hasMore","rest","validateAmbiguousAlternationAlternatives","globalMaxLookahead","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currErrors","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","pathsAndIndices","currPathsAndIdx","currPathAndIdx","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","otherTokType","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","checkPrefixAlternativesAmbiguities","RepetitionCollector","actualOptions","topRulesTable","refResolver","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","RecognitionException","resyncedTokens","setPrototypeOf","captureStackTrace","MismatchedTokenException","previousToken","NoViableAltException","NotAllInputParsedException","EarlyExitException","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","attemptInRepetitionRecovery","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","notStuck","getKeyForAutomaticLookahead","firstAfterRepInfo","firstAfterRepMap","getCurrRuleFullName","getGAstProductions","expectTokAfterLastMatch","nextTokIdx","RULE_STACK","shouldInRepetitionRecoveryBeTried","tryInRepetitionRecovery","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","ruleIdx","LLkLookaheadStrategy","DEFAULT_PARSER_CONFIG","validate","leftRecursionErrors","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","currTopRule","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","validateEmptyOrAlternative","topLevelRules","currProd","pathsInsideProduction","NO_NON_EMPTY_LOOKAHEAD","buildLookaheadForAlternation","laFuncBuilder","buildLookaheadFuncForOr","buildLookaheadForOptional","lookaheadBuilder","buildLookaheadFuncForOptionalProd","dslMethods","repetitionWithSeparator","repetitionMandatory","repetitionMandatoryWithSeparator","reset","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","setNodeLocationFull","defineNameProp","nameValue","defineProperty","enumerable","configurable","writable","defaultVisit","ctx","childrenNames","childrenNamesLength","currChildArray","currChildArrayLength","currChild","createBaseSemanticVisitorConstructor","derivedConstructor","semanticProto","validateVisitor","semanticDefinitionErrors","visitorInstance","missingErrors","missingRuleNames","CstVisitorDefinitionError","MISSING_METHOD","methodName","validateMissingCstMethods","errorMessages","currDefError","_RULE_NAMES","RECORDING_NULL_OBJECT","description","HANDLE_SEPARATOR","MAX_METHOD_IDX","pow","RFT","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","recordProd","prodConstructor","mainProdArg","handleSep","assertMethodIdxIsValid","prevProd","recordingProdStack","grammarAction","DEF","newProd","SEP","MAX_LOOKAHEAD","recordOrProd","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","ALT","getIdxSuffix","KNOWN_RECORDER_ERROR","END_OF_FILE","NaN","outputCst","nodeLocationTracking","DEFAULT_RULE_CONFIG","recoveryValueFunc","resyncEnabled","derivedCtor","EMPTY_ALT","performSelfAnalysis","parserInstance","defErrorsMsgs","selfAnalysisDone","enableRecording","definedRulesNames","originalGrammarAction","recordedRuleGast","topLevelRuleRecord","gastProductionsCache","disableRecording","resolverErrors","definitionErrors","validationErrors","tokensMap","lookaheadValidationErrors","lookaheadValidationErrorMessages","lookaheadStrategy","errorMessage","assign","CUSTOM_LOOKAHEAD_VALIDATION","validateLookahead","allFollows","topProductions","reSyncFollows","currRefsFollow","computeAllProdsFollows","resyncFollows","initialize","preComputeLookaheadFunctions","DEFER_DEFINITION_ERRORS_HANDLING","tokenVocabulary","that","initErrorHandler","initLexerAdapter","initLooksAhead","initRecognizerEngine","initRecoverable","initTreeBuilder","initContentAssist","initGastRecorder","initPerformanceTracer","getTokenToInsert","tokToInsert","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","SAVE_ERROR","SKIP_TOKEN","addToResyncTokens","importLexerState","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","mismatchedTok","possibleFollowsTokType","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","followStack","resyncTokens","reSyncTo","getHumanReadableRuleStack","currShortName","lookAheadFuncsCache","collectMethods","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","getLaFuncFromCache","CST_STACK","setNodeLocationFromToken","setNodeLocationFromNode","cstPostRule","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","location","fullRuleName","ruleCstNode","prevToken","consumedToken","rootCst","tokenTypeName","ruleCstResult","preCstNode","ruleResult","addNoneTerminalToCst","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","baseConstructor","withDefaultsProto","createBaseVisitorConstructorWithDefaults","tokVector","tokVectorLength","newInput","howMuch","soughtIdx","resetLexerState","moveToTerminatedState","getLexerPosition","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","isBackTrackingStack","uniqueTokens","isObject","noTokenCategoriesUsed","tokenConstructor","defineRule","impl","shortName","invokeRuleWithTry","ruleInvocationStateUpdate","cst","invokeRuleCatch","ruleFinallyStateUpdate","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternal","actionORMethodDef","optionInternalLogic","orgLookaheadFunction","atLeastOneInternal","laKey","atLeastOneInternalLogic","raiseEarlyExitException","ERR_MSG","doSingleRepetition","atLeastOneSepFirstInternal","atLeastOneSepFirstInternalLogic","separatorLookAheadFunc","CONSUME","repetitionSepSecondInternal","manyInternal","manyInternalLogic","lookaheadFunction","manySepFirstInternal","manySepFirstInternalLogic","nextTerminalAfterWalker","beforeIteration","orInternal","altsOrOpts","altIdxToTake","raiseNoAltException","isAtEndOfInput","firstRedundantTok","subruleInternal","ruleToCall","ARGS","subruleInternalError","consumeInternal","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","saveRecogState","savedErrors","savedRuleStack","lexerState","reloadRecogState","fullName","ACTION","consume","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","ruleImplementation","OVERRIDE_RULE","ruleErrors","INVALID_RULE_OVERRIDE","validateRuleIsOverridden","BACKTRACK","orgState","getSerializedGastProductions","topRules","_errors","ruleOccurrenceStack","newErrors","userDefinedErrMsg","insideProdPaths","actualTokens","errMsgTypes","lookAheadPathsPerAlternative","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","topProduction","RECORDING_PHASE","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","newTopLevelRule","originalError","mutabilityError","newNoneTerminal","userTraceInitPerf","traceIsNumber","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","EmbeddedActionsParser","configClone","arrays","GRAPH_NODE","Graph","_isDirected","_isMultigraph","_isCompound","_label","_defaultNodeLabelFn","_defaultEdgeLabelFn","_nodes","_parent","_children","_in","_preds","_out","_sucs","_edgeObjs","_edgeLabels","isCompound","newDefault","_nodeCount","setNodes","_removeFromParentsChildList","ancestor","predsV","sucsV","preds","isLeaf","filterNodes","copy","parents","findParent","setDefaultEdgeLabel","edgeCount","_edgeCount","setPath","valueSpecified","arg0","edgeArgsToId","v_","w_","edgeArgsToObj","incrementOrInitEntry","edgeObjToId","decrementOrRemoveEntry","outV","ErrorWithLocation","character","assertUnreachable","_","StreamImpl","startFn","nextFn","Symbol","count","toArray","toSet","toMap","keyFn","valueFn","entryStream","firstDone","DONE_RESULT","addSeparator","searchElement","every","some","callbackfn","nonNullable","initialValue","previousValue","reduceRight","recursiveReduce","findIndex","mapped","isIterable","flat","stream","head","tail","skipCount","limit","maxSize","distinct","by","internalState","exclude","otherKeySet","ownKey","EMPTY_STREAM","collections","collIndex","arrIndex","TreeStreamImpl","iterators","includeRoot","pruned","Reduction","a","product","DefaultTokenBuilder","diagnostics","buildTokens","reachableRules","terminalTokens","buildTerminalTokens","buildKeywordTokens","terminalToken","flushLexingReport","popDiagnostics","fragment","buildTerminalToken","requiresCustomPattern","regexPatternFunction","stickyRegex","buildKeywordToken","caseInsensitive","keywordPattern","buildKeywordPattern","findLongerAlt","longerAlts","setRootDoc","stateStmt","trimColon","state1","state2","relDescription","getDividerId","stateDiagram_default","STMT_STATE","STMT_RELATION","DEFAULT_STATE_TYPE","DIVIDER_TYPE","G_EDGE_STYLE","G_EDGE_ARROWHEADSTYLE","G_EDGE_LABELTYPE","G_EDGE_THICKNESS","SHAPE_STATE","SHAPE_STATE_WITH_DESC","SHAPE_DIVIDER","SHAPE_GROUP","CSS_DIAGRAM","CSS_DIAGRAM_STATE","CSS_EDGE","CSS_EDGE_NOTE_EDGE","CSS_DIAGRAM_NOTE","CSS_DIAGRAM_CLUSTER","CSS_DIAGRAM_CLUSTER_ALT","NOTE","DOMID_TYPE_SPACER","NOTE_ID","PARENT_ID","stateRenderer_v3_unified_default","extract","getRootDocV2","nodeDb","graphItemCount","stateDomId","itemId","typeSpacer","setupDoc","parentParsedItem","diagramStates","altFlag","dataFetcher","edgeData","arrowhead","labelType","getDir2","insertOrUpdateNode","nodeData","cssCompiledStyles","cssClass","classDef","existingNodeData","getClassesFromDbInfo","dbInfoItem","getStylesFromDbInfo","dbState","classStr","newNode","sanitizeTextOrArray","rx","ry","centerLabel","noteData","cssCompilesStyles","flowchart","parentNodeId","groupData","START_NODE","START_TYPE","END_NODE","COLOR_KEYWORD","FILL_KEYWORD","newClassesList","newDoc","states","documents","StateDB","version","rootDoc","currentDocument","startEndCount","dividerCnt","static","getRootDoc","docTranslator","currentDoc","docNode","_doc","addState","addStyleClass","foundState","getState","trimmedId","getStates","descr","descriptions","addDescription","des","doc2","setStyle","textStyle","setTextStyle","saveCommon","logDocuments","startIdIfNeeded","fixedId","startTypeIfNeeded","endIdIfNeeded","endTypeIfNeeded","addRelationObjs","item1","item2","relationTitle","theState","_descr","styleAttributes","foundClass","attrib","fixedAttrib","newStyle2","itemIds","cssClassName","styleText","getDirectionStatement","transitionColor","stateLabelColor","background","noteTextColor","labelBackgroundColor","edgeLabelBackground","transitionLabelColor","tertiaryTextColor","specialStateColor","innerEndBackground","compositeBackground","stateBkg","stateBorder","compositeTitleBackground","altBackground","AbstractRule","AbstractType","Condition","TypeDefinition","ValueLiteral","AbstractElement","isAbstractElement","reflection","isInstance","ArrayLiteral","ArrayType","BooleanLiteral","isBooleanLiteral","Conjunction","isConjunction","Disjunction","isDisjunction","Grammar","GrammarImport","InferredType","isInferredType","Interface","isInterface","NamedArgument","Negation","isNegation","NumberLiteral","Parameter","ParameterReference","isParameterReference","ParserRule","isParserRule","ReferenceType","ReturnType","isReturnType","SimpleType","isSimpleType","StringLiteral","TerminalRule","isTerminalRule","Type","isType","TypeAttribute","UnionType","Action","isAction","Alternatives","isAlternatives","Assignment","isAssignment","CharacterRange","isCharacterRange","CrossReference","isCrossReference","EndOfFile","isEndOfFile","Group","Keyword","isKeyword","NegatedToken","isNegatedToken","RegexToken","isRegexToken","RuleCall","isRuleCall","TerminalAlternatives","isTerminalAlternatives","TerminalGroup","isTerminalGroup","TerminalRuleCall","isTerminalRuleCall","UnorderedGroup","isUnorderedGroup","UntilToken","isUntilToken","Wildcard","isWildcard","LangiumGrammarAstReflection","getAllTypes","computeIsSubtype","subtype","supertype","isSubtype","getReferenceType","refInfo","referenceId","getTypeMetaData","properties","defaultValue","isAstNode","isReference","$refText","isAstNodeDescription","isLinkingError","reference","AbstractAstReflection","subtypes","allSubtypes","nested","existing","getAllSubTypes","allTypes","types","possibleSubType","isCompositeCstNode","isLeafCstNode","isRootCstNode","insertToSet","subItem","addFlag","flagObj","flagKey","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","wordCharCodes","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","RegExpParser","groupIdx","saveState","restoreState","consumeChar","disjunction","multiLine","isRegExpFlag","popChar","peekChar","isTerm","isAssertion","assertion","isBacktracking","atMost","integerIncludingZero","isDigit","greedy","dotAll","atomEscape","characterClass","isPatternCharacter","patternCharacter","isQuantifier","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","letter","parseHexDigits","classPatternCharacterAtom","isClassAtom","classAtom","isRangeDash","classEscape","capturing","groupAst","number","parseInt","nextChar","isAtom","prevState","howMany","hexString","hexChar","BaseRegExpVisitor","subChild","visitPattern","visitFlags","visitDisjunction","visitWordBoundary","visitNonWordBoundary","visitGroup","visitGroupBackReference","visitQuantifier","exports","Emitter","Event","ral_1","_disposable","dispose","None","CallbackList","callback","bucket","_callbacks","_contexts","remove","foundCallbackWithDifferentContext","splice","invoke","ret","callbacks","contexts","default","_options","_event","listener","thisArgs","disposables","onFirstListenerAdd","_noop","onLastListenerRemove","fire","NEWLINE_REGEXP","regexpParser","TerminalRegExpVisitor","isStarting","endRegexpStack","endRegex","startRegexp","escapedChar","escapeRegExp","isMultilineComment","regexp","whitespaceCharacters","isWhitespace","getCaseInsensitivePattern","partialMatches","partial","re","process","appendRaw","nbChars","appendOptional","partialRegExp","getDiagramElement","sandboxElement","contentDocument","setupViewPortForSVG","cssDiagram","calculateDimensionsWithPadding","viewBox","createViewBox","bounds","getBBox","EmptyFileSystemProvider","readFile","readDirectory","EmptyFileSystem","fileSystemProvider","minimalGrammarModule","LanguageMetaData","fileExtensions","languageId","minimalSharedGrammarModule","AstReflection","loadGrammarFromJson","json","services","createMinimalGrammarServices","serializer","JsonSerializer","deserialize","workspace","LangiumDocumentFactory","fromModel","__defProp","__name","Statement","Architecture","Axis","Branch","Checkout","CherryPicking","Commit","Common","Curve","Edge","Entry","GitGraph","Info","Junction","Merge","Packet","PacketBlock","Pie","PieSection","loadedInfoGrammar","loadedPacketGrammar","loadedPieGrammar","loadedArchitectureGrammar","loadedGitGraphGrammar","loadedRadarGrammar","Service","Direction","MermaidAstReflection","InfoGrammar","PacketGrammar","PieGrammar","ArchitectureGrammar","GitGraphGrammar","RadarGrammar","InfoLanguageMetaData","mode","PacketLanguageMetaData","PieLanguageMetaData","ArchitectureLanguageMetaData","GitGraphLanguageMetaData","RadarLanguageMetaData","MermaidGeneratedSharedModule","InfoGeneratedModule","PacketGeneratedModule","PieGeneratedModule","ArchitectureGeneratedModule","GitGraphGeneratedModule","RadarGeneratedModule","rulesRegexes","ACC_DESCR","ACC_TITLE","TITLE","AbstractMermaidValueConverter","runConverter","runCommonConverter","runCustomConverter","_cstNode","CommonValueConverter","_rule","AbstractMermaidTokenBuilder","keywords","DefaultValueConverter","convert","convertInt","convertString","convertID","convertNumber","convertBoolean","convertBigint","convertDate","convertEscapeCharacter","BigInt","RangeComparison","streamCst","isChildNode","tokenToRange","toDocumentSegment","inRange","comparison","Before","After","startInside","endInside","Inside","OverlapBack","OverlapFront","Outside","compareRange","DefaultNameRegexp","findCommentNode","commentNames","getPreviousNode","isCommentNode","GitGraphTokenBuilder","GitGraphModule","createGitGraphServices","PieTokenBuilder","PieValueConverter","PieModule","createPieServices","populateCommonDb","accDescr","accTitle","LIB","resolve","cwd","normalize","isAbsolute","relative","_makeLong","dirname","basename","extname","format","base","ext","delimiter","win32","posix","d","toStringTag","URI","Utils","P","platform","navigator","userAgent","scheme","authority","query","isUri","fsPath","with","m","C","file","toJSON","revive","_formatted","external","_fsPath","_sep","$mid","encodeURIComponent","decodeURIComponent","A","joinPath","resolvePath","InfoTokenBuilder","InfoModule","createInfoServices","string","stringArray","boolean","parsers","initializers","createInfoServices2","LangiumParser","packet","createPacketServices","createPacketServices2","pie","createPieServices2","architecture","createArchitectureServices","createArchitectureServices2","gitGraph","createGitGraphServices2","radar","createRadarServices2","diagramType","lexerErrors","parserErrors","MermaidParseError","err","ArchitectureTokenBuilder","ArchitectureValueConverter","ArchitectureModule","buildATNKey","AbstractTransition","isEpsilon","AtomTransition","EpsilonTransition","RuleTransition","ruleStart","followState","createATN","atn","decisionMap","decisionStates","ruleToStartState","ruleToStopState","ruleLength","stop","createRuleStartAndStopATNStates","ruleBlock","block","buildRuleHandle","production","tokenRef","currentRule","nonTerminal","addTransition","ruleRef","defineDecisionState","handle","makeAlts","optional","epsilon","starState","star","repetitionSep","plusState","plus","repetitionMandatorySep","handles","altsLength","transitions","isRuleTransition","ruleTransition","removeState","makeBlock","blkStart","blkEnd","loop","loopback","loopEnd","decision","epsilonOnlyTransitions","nextTokenWithinRule","stateNumber","DFA_ERROR","ATNConfigSet","configs","finalize","getATNConfigKey","createDFACache","startState","predicateSet","atnStartState","PredicateSet","is","EMPTY_PREDICATES","LLStarLookaheadStrategy","logging","dfas","decisionLength","decisionToDFA","initATNSimulator","decisionIndex","isLL1Sequence","prediction","gate","adaptivePredict","sequences","allowEmpty","fullSet","altSet","indices","dfaCaches","dfa","addDFAState","newDFAState","computeStartState","performLookahead","s0","previousD","computeLookaheadTarget","buildAdaptivePredictError","isAcceptState","reach","intermediate","skippedStopStates","transitionLength","getReachableTarget","closure","hasConfigInRuleStopState","computeReachSet","addDFAEdge","predictedAlt","getUniqueAlt","uniqueAlt","allConfigsInRuleStopStates","altSets","configToAlts","getConflictingAltSets","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasConflictTerminatingPrediction","reportLookaheadAmbiguity","atnState","buildAmbiguityError","current","nextTransitions","actualToken","possibleTokenTypes","tokenPath","mapKey","numberOfTransitions","atnStack","getEpsilonTarget","DocumentUri","integer","uinteger","Position","Range","Location","LocationLink","Color","ColorInformation","ColorPresentation","FoldingRangeKind","FoldingRange","DiagnosticRelatedInformation","DiagnosticSeverity","DiagnosticTag","CodeDescription","Diagnostic","Command","TextEdit","ChangeAnnotation","ChangeAnnotationIdentifier","AnnotatedTextEdit","TextDocumentEdit","CreateFile","RenameFile","DeleteFile","WorkspaceEdit","TextDocumentIdentifier","VersionedTextDocumentIdentifier","OptionalVersionedTextDocumentIdentifier","TextDocumentItem","MarkupKind","MarkupContent","CompletionItemKind","InsertTextFormat","CompletionItemTag","InsertReplaceEdit","InsertTextMode","CompletionItemLabelDetails","CompletionItem","CompletionList","MarkedString","Hover","ParameterInformation","SignatureInformation","DocumentHighlightKind","DocumentHighlight","SymbolKind","SymbolTag","SymbolInformation","WorkspaceSymbol","DocumentSymbol","CodeActionKind","CodeActionTriggerKind","CodeActionContext","CodeAction","CodeLens","FormattingOptions","DocumentLink","SelectionRange","SemanticTokenTypes","SemanticTokenModifiers","SemanticTokens","InlineValueText","InlineValueVariableLookup","InlineValueEvaluatableExpression","InlineValueContext","InlayHintKind","InlayHintLabelPart","InlayHint","StringValue","InlineCompletionItem","InlineCompletionList","InlineCompletionTriggerKind","SelectedCompletionInfo","InlineCompletionContext","WorkspaceFolder","MIN_VALUE","MAX_VALUE","candidate","Is","objectLiteral","one","two","three","four","uri","targetUri","targetRange","targetSelectionRange","originSelectionRange","red","green","blue","alpha","numberRange","color","textEdit","additionalTextEdits","typedArray","Comment","Imports","Region","startCharacter","endCharacter","kind","collapsedText","defined","Warning","Information","Hint","Unnecessary","Deprecated","href","severity","relatedInformation","codeDescription","command","newText","insert","del","needsConfirmation","annotationId","textDocument","edits","overwrite","ignoreIfExists","oldUri","newUri","recursive","ignoreIfNotExists","changes","documentChanges","change","PlainText","Markdown","Text","Method","Function","Constructor","Field","Variable","Class","Module","Property","Unit","Value","Enum","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Operator","TypeParameter","asIs","adjustIndentation","detail","items","isIncomplete","fromPlainText","plainText","language","contents","documentation","Read","Write","Namespace","Package","Key","Null","containerName","selectionRange","deprecated","tags","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","Invoked","Automatic","only","triggerKind","kindOrCommandOrEdit","checkKind","edit","isPreferred","data","tabSize","insertSpaces","resultId","variableName","caseSensitiveLookup","expression","frameId","stoppedLocation","textEdits","paddingLeft","paddingRight","createSnippet","insertText","filterText","selectedCompletionInfo","TextDocument","mergeSort","compare","leftIdx","rightIdx","FullTextDocument","lineCount","getText","positionAt","offsetAt","applyEdits","sortedEdits","diff","lastModifiedOffset","_uri","_languageId","_content","_lineOffsets","update","getLineOffsets","lineOffsets","isLineStart","high","mid","lineOffset","nextLineOffset","check","CstNodeBuilder","nodeStack","rootNode","buildRootNode","RootCstNodeImpl","buildCompositeNode","compositeNode","CompositeCstNodeImpl","buildLeafNode","leafNode","LeafCstNodeImpl","addHiddenNodes","added","construct","$cstNode","AbstractCstNode","_astNode","_offset","_length","_hidden","_tokenType","_range","CstNodeContainer","firstNonHiddenNode","lastNonHiddenNode","firstNode","_rangeCache","firstRange","lastRange","addParents","_text","DatatypeSymbol","isDataTypeNode","withRuleSuffix","AbstractLangiumParser","_unorderedGroups","wrapper","ChevrotainWrapper","ParserConfig","ParserErrorMessageProvider","choices","wrapOr","wrapOption","wrapMany","wrapAtLeastOne","getRule","isRecording","IS_RECORDING","unorderedGroups","getRuleStack","wrapSelfAnalysis","nodeBuilder","assignmentMap","linker","references","Linker","converter","astReflection","computeRuleType","ruleMethod","DEFINE_RULE","startImplementation","mainRule","explicit","lexerResult","lexerReport","report","createNode","extractHiddenTokens","hiddenTokens","wrapConsume","isValidToken","isCrossRef","getAssignment","convertedValue","operator","subruleResult","wrapSubrule","performSubruleAssignment","newItem","assignWithoutOverride","buildReference","existingValue","newValue","targetCstNode","AbstractParserErrorMessageProvider","LangiumParserErrorMessageProvider","LangiumCompletionParser","elementStack","lastElementStack","nextTokenIndex","stackSize","resetState","tokenIndex","keepStackSize","resetStackSize","removeUnexpectedElements","before","after","defaultConfig","useDefaultLookahead","createParser","parserContext","reachable","parserRules","buildElement","buildRules","ignoreGuard","method","buildKeyword","buildAction","buildCrossReference","ruleCall","namedArgs","buildPredicate","ruleArgs","ruleTarget","buildRuleCallPredicate","getToken","buildRuleCall","predicatedMethod","getGuardCondition","buildAlternatives","orIdx","idFunc","lParser","groupState","trackedAlternatives","wrapped","delete","buildUnorderedGroup","buildGroup","true","guardCondition","assignTerminal","getRuleName","createLangiumParser","prepareLangiumParser","lastTick","globalInterruptionPeriod","isOperationCancelled","interruptAndCheck","performance","Promise","setImmediate","setTimeout","isCancellationRequested","promise","arg","isIncremental","getWellformedRange","addedLineOffsets","computeLineOffsets","isFull","ensureBeforeEOL","isEOL","rangeLength","isAtLineStart","textOffset","getWellformedEdit","spans","DocumentState","DefaultLangiumDocumentFactory","serviceRegistry","textDocuments","TextDocuments","FileSystemProvider","fromUri","cancellationToken","createAsync","fromTextDocument","fromString","model","$model","parseResult","createLangiumDocument","cancelToken","parseAsync","Parsed","textDocumentGetter","createTextDocumentGetter","$document","oldText","getServices","AsyncParser","textDoc","DefaultLangiumDocuments","documentMap","langiumDocumentFactory","all","addDocument","uriString","getDocument","getOrCreateDocument","createDocument","then","hasDocument","invalidateDocument","langiumDoc","Changed","precomputedScopes","deleteDocument","ref_resolving","DefaultLinker","langiumDocuments","LangiumDocuments","scopeProvider","ScopeProvider","astNodeLocator","AstNodeLocator","doLink","_ref","getCandidate","_nodeDescription","documentUri","linkedNode","loadAstNode","createLinkingError","getScope","getElement","refNode","refText","$refNode","refData","getLinkedNode","ComputedScopes","getAstNodePath","$nodeDescription","nodeDescription","getAstNode","targetDescription","referenceType","DefaultNameProvider","getName","isNamed","getNameNode","UriUtils","equals","fromPath","toPath","fromParts","toParts","repeat","DefaultReferences","nameProvider","NameProvider","IndexManager","nodeLocator","findDeclaration","sourceCstNode","nodeElem","nameNode","findDeclarationNode","targetNode","findReferences","refs","includeDeclaration","getReferenceToSelf","indexReferences","findAllReferences","sourceUri","sourcePath","segment","local","MultiMap","addAll","entriesGroupedByKey","BiMap","inverse","getKey","DefaultScopeComputation","AstNodeDescriptionProvider","computeExports","computeExportsForNode","parentNode","exportNode","createDescription","computeLocalScopes","scopes","processNode","StreamScope","outerScope","getAllElements","MapScope","localName","elementStream","DisposableCache","toDispose","isDisposed","onDispose","disposable","throwIfDisposed","SimpleCache","provider","ContextCache","contextKey","cacheForContext","contextCache","documentCache","WorkspaceCache","sharedServices","DocumentBuilder","onBuildPhase","onUpdate","_changed","deleted","DefaultScopeProvider","indexManager","globalScopeCache","precomputed","currentNode","allDescriptions","desc","getGlobalScope","createScope","createScopeForNodes","_context","allElements","isIntermediateReference","DefaultJsonSerializer","ignoreProperties","commentProvider","CommentProvider","serialize","serializeOptions","specificReplacer","replacer","defaultReplacer","space","deserializeOptions","linkNode","sourceText","textRegions","comments","uriConverter","_d","refValue","targetDocument","$ref","$error","addAstNodeRegionWithAssignmentsTo","$textRegion","documentURI","$sourceText","comment","getComment","$comment","createDocumentSegment","assignments","propertyAssignments","containerProperty","containerIndex","propertyName","reviveReference","mutable","$containerProperty","$containerIndex","getRefNode","fragmentIndex","DefaultServiceRegistry","fileExtensionMap","languageIdMap","singleton","hasServices","diagnosticData","ValidationCategory","DocumentValidator","ValidationRegistry","entriesBefore","entriesAfter","checksRecord","thisObj","category","wrapValidationException","addEntry","handleException","functionality","messageContext","getChecks","checks","registerBeforeDocument","checkBefore","wrapPreparationException","registerAfterDocument","checkAfter","checksBefore","checksAfter","DefaultDocumentValidator","validationRegistry","validation","metadata","validateDocument","processLexingErrors","stopAfterLexingErrors","LexingError","processParsingErrors","stopAfterParsingErrors","ParsingError","processLinkingErrors","stopAfterLinkingErrors","LinkingError","validateAst","lexerDiagnostics","lexerDiagnostic","diagnostic","toDiagnosticSeverity","toDiagnosticData","getSource","parserError","linkingError","containerType","toDiagnostic","validationItems","acceptor","validateAstBefore","validateAstNodes","validateAstAfter","getDiagnosticRange","LexingWarning","LexingInfo","LexingHint","DefaultAstNodeDescriptionProvider","nameNodeSegment","nameSegmentGetter","nameSegment","selectionSegment","DefaultReferenceDescriptionProvider","createDescriptions","targetNodeDescr","refCstNode","docUri","DefaultAstNodeLocator","segmentSeparator","indexSeparator","containerPath","newSegment","getPathSegment","currentValue","propertyIndex","arrayIndex","Disposable","DefaultConfigurationProvider","_ready","settings","workspaceConfig","onConfigurationSectionUpdateEmitter","ready","params","capabilities","configuration","initialized","languages","section","lang","toSectionName","fetchConfiguration","configToUpdate","updateSectionConfiguration","updateConfiguration","getConfiguration","sectionName","onConfigurationSectionUpdate","DefaultDocumentBuilder","updateBuildOptions","updateListeners","buildPhaseListeners","documentPhaseListeners","documentBuildWaiters","currentState","build","Validated","IndexedReferences","previousCategories","validationChecks","completed","emitUpdate","buildDocuments","changed","deletedUri","changedUri","newDocument","allChangedUris","shouldRelink","rebuildDocuments","sortDocuments","Linked","hasTextDocument","changedUris","isAffected","prepareBuild","runCancelable","IndexedContent","updateContent","scopeComputation","ScopeComputation","updateReferences","toBeValidated","shouldValidate","targetState","filtered","notifyDocumentPhase","targetStateDocs","notifyBuildPhase","onDocumentPhase","waitUntil","uriOrToken","buildDisposable","cancelDisposable","onCancellationRequested","listenersCopy","getBuildOptions","validator","validationSetting","DefaultIndexManager","symbolIndex","symbolByTypeIndex","referenceIndex","astNodePath","targetDocUri","docRefs","refDescr","nodeType","uris","documentUris","getFileDescriptions","indexData","ReferenceDescriptionProvider","DefaultWorkspaceManager","initialBuildOptions","documentBuilder","mutex","WorkspaceLock","workspaceFolders","folders","_params","write","initializeWorkspace","performStartup","collector","loadAdditionalDocuments","wf","getRootFolder","traverseFolder","_folders","_collector","workspaceFolder","folderPath","includeEntry","isDirectory","isFile","_workspaceFolder","DefaultLexerErrorMessageProvider","DEFAULT_TOKENIZE_OPTIONS","DefaultLexer","LexerErrorMessageProvider","tokenBuilder","toTokenTypeDictionary","lexerTokens","isTokenTypeDictionary","chevrotainLexer","chevrotainResult","isIMultiModeLexerDefinition","res","isTokenTypeArray","parseJSDoc","currentLine","currentCharacter","lastCharacter","skipWhitespace","tagRegex","tagMatch","fullMatch","inlineTagMatches","matchAll","inlineTagRegex","buildInlineTokens","getLines","normalizeOptions","startPosition","JSDocCommentImpl","parseJSDocElement","parseJSDocComment","lineIndex","characterIndex","matchIndex","startContent","tagName","endContent","nonWhitespaceRegex","whitespaceEndRegex","parseJSDocTag","parseJSDocText","JSDocLineImpl","inlines","appendEmptyLine","firstToken","lastToken","parseJSDocInline","JSDocTextImpl","parseJSDocLine","inline","tagToken","docLine","JSDocTagImpl","normalizeOption","escaped","getTag","getAllTags","getTags","fillNewlines","toMarkdown","renderTag","toMarkdownDefault","rendered","tag","display","displayStart","renderedLink","renderLink","renderLinkDefault","renderInlineTag","JSDocDocumentationProvider","getDocumentation","normalizedOptions","firstRegex","lastRegex","isJSDoc","documentationLinkRenderer","documentationTagRenderer","findNameInPrecomputedScopes","findNameInGlobalScope","_node","_tag","DefaultCommentProvider","grammarConfig","GrammarConfig","isAstNodeWithComment","multilineCommentRules","DefaultAsyncParser","syncParser","_cancelToken","DefaultWorkspaceLock","previousTokenSource","writeQueue","readQueue","cancelWrite","tokenSource","read","queue","deferred","performNextOperation","shift","cancel","DefaultHydrator","grammarElementIdMap","tokenTypeIdMap","dehydrate","dehydrateLexerReport","dehydrateAstNode","createDehyrationContext","astNodes","cstNodes","dehydrateCstNode","arr","dehydrateReference","getGrammarElementId","hydrate","createHydrationContext","hydrateCstNode","hydrateAstNode","hydrateCstLeafNode","hydrateReference","num","cstNodeObj","getGrammarElement","hydrated","getTokenType","createGrammarElementIdMap","createDefaultCoreModule","DocumentationProvider","nameRegexp","createGrammarConfig","CompletionParser","createCompletionParser","References","Hydrator","createDefaultSharedCoreModule","WorkspaceManager","ConfigurationProvider","inject","module1","module2","module3","module4","module5","module6","module7","module8","module9","_inject","_merge","merge","m1","m2","isProxy","module","injector","proxy","Proxy","deleteProperty","_resolve","ownKeys","__requested__","cause","value2","value1","_ral","RAL","install","ral","linkContentToContainer","getContainerOfType","typePredicate","findRootNode","streamContents","keyIndex","isAstNodeInRange","streamAllContents","streamAst","nodeRange","streamReferences","assignMandatoryProperties","typeMetaData","genericNode","copyDefaultValue","propertyType","events_1","CancellationToken","Cancelled","shortcutEvent","MutableToken","_isCancelled","_emitter","_token","PacketTokenBuilder","PacketModule"],"sourceRoot":""}